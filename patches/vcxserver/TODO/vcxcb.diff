diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/.gitignore b/vcxsrv-code/libxcb/.gitignore
index d0ba8d2..a408472 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/.gitignore
+++ b/vcxsrv-code/libxcb/.gitignore
@@ -23,6 +23,3 @@ mkinstalldirs
 stamp-h1
 ChangeLog
 INSTALL
-check-pc-requires.log
-check-pc-requires.trs
-test-suite.log
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/Makefile.am b/vcxsrv-code/libxcb/Makefile.am
index fbf6e04..57c3a7b 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/Makefile.am
+++ b/vcxsrv-code/libxcb/Makefile.am
@@ -99,7 +99,6 @@ tools/README \
 tools/api_conv.pl \
 tools/constants \
 autogen.sh \
-README.md \
 $(TESTS)
 
 MAINTAINERCLEANFILES = ChangeLog INSTALL
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/NEWS b/vcxsrv-code/libxcb/NEWS
index 224544b..e1b4655 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/NEWS
+++ b/vcxsrv-code/libxcb/NEWS
@@ -1,23 +1,3 @@
-Release 1.14 (2020-02-22)
-=========================
-* Add xcb_total_read() and xcb_total_written() API
-* Support check >= 0.13 API (for make check)
-* Bug fix to handle EINTR from recvmsg
-* Only require pthread-stubs on non-Linux platforms
-
-Release 1.13.1 (2018-09-27)
-===========================
-* Don't flag extra reply in xcb_take_socket
-
-Release 1.13 (2018-02-28)
-=========================
-* Add support for variable-sized lists of FDs
-* Poll for events when blocking waiting for special events
-* xinput: Enable XInput extension by default
-* ge: Add explicit support for GenericEvent extension
-* Fix documentation warnings from clang
-* Cosmetic cleanups
-
 Release 1.12 (2016-05-18)
 =========================
 * configure: Various fixes for dri3 and FD passing support
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/configure.ac b/vcxsrv-code/libxcb/configure.ac
index 1fcda56..d3165c6 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/configure.ac
+++ b/vcxsrv-code/libxcb/configure.ac
@@ -2,8 +2,8 @@ dnl Process this file with autoconf to produce a configure script.
 
 # Initialize Autoconf
 AC_PREREQ([2.60])
-AC_INIT([libxcb],[1.14],
-        [https://gitlab.freedesktop.org/xorg/lib/libxcb/issues],
+AC_INIT([libxcb],[1.12],
+        [https://bugs.freedesktop.org/enter_bug.cgi?product=xcb],
         [libxcb])
 AC_CONFIG_AUX_DIR([build-aux])
 AC_CONFIG_MACRO_DIR([m4])
@@ -11,7 +11,7 @@ AC_CONFIG_SRCDIR([xcb.pc.in])
 AC_CONFIG_HEADERS([src/config.h])
 
 # Initialize Automake
-AM_INIT_AUTOMAKE([foreign dist-xz])
+AM_INIT_AUTOMAKE([foreign dist-bzip2])
 AM_PATH_PYTHON([2.6])
 
 # Set common system defines for POSIX extensions, such as _GNU_SOURCE
@@ -22,7 +22,6 @@ AC_USE_SYSTEM_EXTENSIONS
 # Initialize libtool
 LT_PREREQ([2.2])
 LT_INIT([win32-dll])
-AC_LIBTOOL_WIN32_DLL
 
 # Require xorg-macros minimum of 1.18 - Initial version
 m4_ifndef([XORG_MACROS_VERSION],
@@ -37,7 +36,7 @@ if test x"$HAVE_DOT" = xno; then
     AC_MSG_WARN([dot not found - doxygen targets will be skipped])
 fi
 
-PKG_CHECK_MODULES(CHECK, [check >= 0.9.6], [HAVE_CHECK=yes], [HAVE_CHECK=no])
+PKG_CHECK_MODULES(CHECK, [check >= 0.9.4], [HAVE_CHECK=yes], [HAVE_CHECK=no])
 AM_CONDITIONAL(HAVE_CHECK, test x$HAVE_CHECK = xyes)
 
 XSLTPROC=no
@@ -51,12 +50,8 @@ fi
 AC_SUBST(HTML_CHECK_RESULT)
 
 # Checks for pkg-config packages
-PKG_CHECK_MODULES(XCBPROTO, xcb-proto >= 1.14)
-NEEDED="xau >= 0.99.2"
-case $host_os in
-linux*) ;;
-     *) NEEDED="$NEEDED pthread-stubs" ;;
-esac
+PKG_CHECK_MODULES(XCBPROTO, xcb-proto >= 1.12)
+NEEDED="pthread-stubs xau >= 0.99.2"
 PKG_CHECK_MODULES(NEEDED, $NEEDED)
 
 have_xdmcp="no"
@@ -92,11 +87,11 @@ AC_MSG_RESULT($XCBPROTO_XCBPYTHONDIR)
 AC_SUBST(XCBPROTO_XCBPYTHONDIR)
 
 AC_HEADER_STDC
-AC_SEARCH_LIBS(getaddrinfo, [socket Ws2_32])
-AC_SEARCH_LIBS(connect, [socket Ws2_32])
+AC_SEARCH_LIBS(getaddrinfo, socket)
+AC_SEARCH_LIBS(connect, socket)
 
 # Find support for sending a message from a socket
-AC_SEARCH_LIBS(sendmsg, [socket Ws2_32], [have_sendmsg="yes"], [have_sendmsg="no"])
+AC_SEARCH_LIBS(sendmsg, socket, [have_sendmsg="yes"], [have_sendmsg="no"])
 
 # XPG4v2/UNIX95 added msg_control - check to see if we need to define
 # _XOPEN_SOURCE to get it (such as on Solaris)
@@ -145,10 +140,6 @@ mingw*)
         have_win32="yes"
         lt_enable_auto_import="-Wl,--enable-auto-import"
         ;;
-msys*)
-        have_win32="yes"
-        lt_enable_auto_import="-Wl,--enable-auto-import"
-        ;;
 linux*)
         AC_DEFINE([HAVE_ABSTRACT_SOCKETS], 1, [Define if your platform supports abstract sockets])
         ;;
@@ -217,7 +208,7 @@ esac
 
 dnl Link with winsock for socket functions on MinGW
 case $host_os in
-        *mingw*| *msys* )
+        *mingw*)
                 AC_CHECK_LIB([ws2_32],[main])
                 ;;
         *)
@@ -244,7 +235,7 @@ XCB_EXTENSION(Xevie, no)
 XCB_EXTENSION(XFixes, yes)
 XCB_EXTENSION(XFree86-DRI, yes)
 XCB_EXTENSION(Xinerama, yes)
-XCB_EXTENSION(XInput, yes)
+XCB_EXTENSION(XInput, no)
 XCB_EXTENSION(XKB, yes)
 XCB_EXTENSION(Xprint, no)
 XCB_EXTENSION(SELinux, no)
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/.gitignore b/vcxsrv-code/libxcb/src/.gitignore
index 7c69ebe..d6a2e9c 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/.gitignore
+++ b/vcxsrv-code/libxcb/src/.gitignore
@@ -1,32 +1,60 @@
-bigreq.*
-composite.*
-damage.*
-dpms.*
-dri2.*
-dri3.*
-ge.*
-glx.*
-present.*
-randr.*
-record.*
-render.*
-res.*
-screensaver.*
-shape.*
-shm.*
-sync.*
-xc_misc.*
-xevie.*
-xf86dri.*
-xfixes.*
-xinerama.*
-xinput.*
-xkb.*
-xprint.*
-xselinux.*
-xtest.*
-xv.*
-xvmc.*
-xproto.*
-xcb_des.c
-X11
+dri3.c
+dri3.h
+present.c
+present.h
+bigreq.c
+bigreq.h
+composite.c
+composite.h
+damage.c
+damage.h
+dpms.c
+dpms.h
+dri2.c
+dri2.h
+ge.c
+ge.h
+glx.c
+glx.h
+randr.c
+randr.h
+record.c
+record.h
+render.c
+render.h
+res.c
+res.h
+screensaver.c
+screensaver.h
+shape.c
+shape.h
+shm.c
+shm.h
+sync.c
+sync.h
+xc_misc.c
+xc_misc.h
+xevie.c
+xevie.h
+xf86dri.c
+xf86dri.h
+xf86vidmode.c
+xf86vidmode.h
+xfixes.c
+xfixes.h
+xinerama.c
+xinerama.h
+xinput.c
+xinput.h
+xprint.c
+xprint.h
+xproto.c
+xproto.h
+xselinux.c
+xselinux.h
+xtest.c
+xtest.h
+xv.c
+xv.h
+xvmc.c
+xvmc.h
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/Makefile.am b/vcxsrv-code/libxcb/src/Makefile.am
index 086e5ca..17b64a8 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/Makefile.am
+++ b/vcxsrv-code/libxcb/src/Makefile.am
@@ -59,7 +59,7 @@ endif
 EXTSOURCES += dri3.c
 if BUILD_DRI3
 lib_LTLIBRARIES += libxcb-dri3.la
-libxcb_dri3_la_LDFLAGS = -version-info 1:0:1 -no-undefined @lt_enable_auto_import@
+libxcb_dri3_la_LDFLAGS = -version-info 0:0:0 -no-undefined @lt_enable_auto_import@
 libxcb_dri3_la_LIBADD = $(XCB_LIBS)
 nodist_libxcb_dri3_la_SOURCES = dri3.c dri3.h
 endif
@@ -260,7 +260,7 @@ if XCB_SERVERSIDE_SUPPORT
 C_CLIENT_PY_EXTRA_ARGS += --server-side
 endif
 
-$(EXTSOURCES): c_client.py /$(@:.c=.xml)
+$(EXTSOURCES): c_client.py $(XCBPROTO_XCBINCLUDEDIR)/$(@:.c=.xml)
 	$(AM_V_GEN)$(PYTHON) $(srcdir)/c_client.py	-c "$(PACKAGE_STRING)" -l "$(XORG_MAN_PAGE)" \
 		-s "$(LIB_MAN_SUFFIX)" -p $(XCBPROTO_XCBPYTHONDIR) \
 		$(C_CLIENT_PY_EXTRA_ARGS) \
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/c_client.py b/vcxsrv-code/libxcb/src/c_client.py
index 39f162e..a14f2bd 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/c_client.py
+++ b/vcxsrv-code/libxcb/src/c_client.py
@@ -286,6 +286,7 @@ def c_open(self):
     _c('#include <stddef.h>  /* for offsetof() */')
     _c('#include "xcbext.h"')
     _c('#include "%s.h"', _ns.header)
+    _c('#include <X11/Xtrans/Xtrans.h>')
 
     _c('')
     _c('#define ALIGNOF(type) offsetof(struct { char dummy; type member; }, member)')
@@ -304,7 +305,7 @@ def c_open(self):
         _h('#define XCB_%s_MAJOR_VERSION %s', _ns.ext_name.upper(), _ns.major_version)
         _h('#define XCB_%s_MINOR_VERSION %s', _ns.ext_name.upper(), _ns.minor_version)
         _h('') #XXX
-        _h('extern xcb_extension_t %s;', _ns.c_ext_global_name)
+        _h('XCB_EXTERN xcb_extension_t %s;', _ns.c_ext_global_name)
 
         _c('')
         _c('xcb_extension_t %s = { "%s", 0 };', _ns.c_ext_global_name, _ns.ext_xname)
@@ -458,7 +459,7 @@ def _c_type_setup(self, name, postfix):
                 field.c_field_const_type = 'const ' + field.c_field_type
                 self.c_need_aux = True
 
-            if not field.type.fixed_size() and not field.type.is_case_or_bitcase and field.wire:
+            if not field.type.fixed_size() and not field.type.is_case_or_bitcase:
                 self.c_need_sizeof = True
 
             field.c_iterator_type = _t(field.field_type + ('iterator',))      # xcb_fieldtype_iterator_t
@@ -497,7 +498,7 @@ def _c_type_setup(self, name, postfix):
             _c_type_setup(field.type, field.field_type, ())
             if field.type.is_list:
                 _c_type_setup(field.type.member, field.field_type, ())
-                if (field.type.nmemb is None and field.wire):
+                if (field.type.nmemb is None):
                     self.c_need_sizeof = True
 
     if self.c_need_serialize:
@@ -1170,8 +1171,6 @@ def _c_serialize_helper_fields(context, self,
     _c_pre.push_indent(space + '    ')
 
     for field in self.fields:
-        if not field.wire:
-            continue
         if not field.visible:
             if not ((field.wire and not field.auto) or 'unserialize' == context):
                 continue
@@ -1196,9 +1195,7 @@ def _c_serialize_helper_fields(context, self,
 
         # fields with variable size
         else:
-            if not field.wire:
-                continue
-            elif field.type.is_pad:
+            if field.type.is_pad:
                 # Variable length pad is <pad align= />
                 code_lines.append('%s    xcb_align_to = %d;' % (space, field.type.align))
                 count += _c_serialize_helper_insert_padding(context, self, code_lines, space,
@@ -1933,7 +1930,7 @@ def _c_accessors_list(self, field):
                 else:
                     # use the accessor to get the start of the list, then
                     # compute the length of it by subtracting it from
-                    # the address of the first byte after the end of the
+                    # the adress of the first byte after the end of the
                     # request
                     after_end_of_request = '(((char*)R) + R->length * 4)'
                     start_of_list = '%s(R)' % (field.c_accessor_name)
@@ -2312,7 +2309,7 @@ def _c_request_helper(self, name, void, regular, aux=False, reply_fds=False):
     count = 2
     if not self.c_var_followed_by_fixed_fields:
         for field in param_fields:
-            if not field.type.fixed_size() and field.wire:
+            if not field.type.fixed_size():
                 count = count + 2
                 if field.type.c_need_serialize:
                     # _serialize() keeps track of padding automatically
@@ -2340,30 +2337,12 @@ def _c_request_helper(self, name, void, regular, aux=False, reply_fds=False):
         if aux:
             _c('    void *xcb_aux%d = 0;' % (idx))
     if list_with_var_size_elems:
+        _c('    unsigned int i;')
         _c('    unsigned int xcb_tmp_len;')
         _c('    char *xcb_tmp;')
-
-    num_fds_fixed = 0
-    num_fds_expr = []
-    for field in param_fields:
-        if field.isfd:
-            if not field.type.is_list:
-                num_fds_fixed += 1
-            else:
-                num_fds_expr.append(_c_accessor_get_expr(field.type.expr, None))
-
-    if list_with_var_size_elems or len(num_fds_expr) > 0:
-        _c('    unsigned int i;')
-
-    if num_fds_fixed > 0:
-        num_fds_expr.append('%d' % (num_fds_fixed))
-    if len(num_fds_expr) > 0:
-        num_fds = '+'.join(num_fds_expr)
-        _c('    int fds[%s];' % (num_fds))
-        _c('    int fd_index = 0;')
-    else:
-        num_fds = None
-
+    num_fds = len([field for field in param_fields if field.isfd])
+    if num_fds > 0:
+        _c('    int fds[%d];' % (num_fds))
     _c('')
 
     # fixed size fields
@@ -2401,7 +2380,7 @@ def _c_request_helper(self, name, void, regular, aux=False, reply_fds=False):
         count = 4
 
         for field in param_fields:
-            if field.wire and not field.type.fixed_size():
+            if not field.type.fixed_size():
                 _c('    /* %s %s */', field.type.c_type, field.c_field_name)
                 # default: simple cast to char *
                 if not field.type.c_need_serialize and not field.type.c_need_sizeof:
@@ -2469,18 +2448,16 @@ def _c_request_helper(self, name, void, regular, aux=False, reply_fds=False):
         # no padding necessary - _serialize() keeps track of padding automatically
 
     _c('')
+    fd_index = 0
     for field in param_fields:
         if field.isfd:
-            if not field.type.is_list:
-                _c('    fds[fd_index++] = %s;', field.c_field_name)
-            else:
-                _c('    for (i = 0; i < %s; i++)', _c_accessor_get_expr(field.type.expr, None))
-                _c('        fds[fd_index++] = %s[i];', field.c_field_name)
+            _c('    fds[%d] = %s;', fd_index, field.c_field_name)
+            fd_index = fd_index + 1
 
-    if not num_fds:
+    if num_fds == 0:
         _c('    xcb_ret.sequence = xcb_send_request(c, %s, xcb_parts + 2, &xcb_req);', func_flags)
     else:
-        _c('    xcb_ret.sequence = xcb_send_request_with_fds(c, %s, xcb_parts + 2, &xcb_req, %s, fds);', func_flags, num_fds)
+        _c('    xcb_ret.sequence = xcb_send_request_with_fds(c, %s, xcb_parts + 2, &xcb_req, %d, fds);', func_flags, num_fds)
 
     # free dyn. all. data, if any
     for f in free_calls:
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/man/.gitignore b/vcxsrv-code/libxcb/src/man/.gitignore
index f000a81..a73d430 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/man/.gitignore
+++ b/vcxsrv-code/libxcb/src/man/.gitignore
@@ -1,2 +1,3 @@
 *.[0-9]
 *.[0-9]x
+*.xcb
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb.h b/vcxsrv-code/libxcb/src/xcb.h
index 3f39bb4..7d8f52a 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb.h
+++ b/vcxsrv-code/libxcb/src/xcb.h
@@ -37,6 +37,7 @@
 
 #ifndef _WIN32
 #include <sys/uio.h>
+#define XCB_EXTERN extern
 #else
 #include "xcb_windefs.h"
 #endif
@@ -51,10 +52,10 @@ extern "C" {
  * @file xcb.h
  */
 
-#ifdef __GNUC__
-#define XCB_PACKED __attribute__((__packed__))
-#else
+#ifdef _MSC_VER
 #define XCB_PACKED
+#else
+#define XCB_PACKED __attribute__((__packed__))
 #endif
 
 /**
@@ -595,7 +596,7 @@ xcb_connection_t *xcb_connect_to_display_with_auth_info(const char *display, xcb
 /**
  * @brief Allocates an XID for a new object.
  * @param c The connection.
- * @return A newly allocated XID, or -1 on failure.
+ * @return A newly allocated XID.
  *
  * Allocates an XID for a new object. Typically used just prior to
  * various object creation functions, such as xcb_create_window.
@@ -603,35 +604,6 @@ xcb_connection_t *xcb_connect_to_display_with_auth_info(const char *display, xcb
 uint32_t xcb_generate_id(xcb_connection_t *c);
 
 
-/**
- * @brief Obtain number of bytes read from the connection.
- * @param c The connection
- * @return Number of bytes read from the server.
- *
- * Returns cumulative number of bytes received from the connection.
- *
- * This retrieves the total number of bytes read from this connection,
- * to be used for diagnostic/monitoring/informative purposes.
- */
-
-uint64_t
-xcb_total_read(xcb_connection_t *c);
-
-/**
- *
- * @brief Obtain number of bytes written to the connection.
- * @param c The connection
- * @return Number of bytes written to the server.
- *
- * Returns cumulative number of bytes sent to the connection.
- *
- * This retrieves the total number of bytes written to this connection,
- * to be used for diagnostic/monitoring/informative purposes.
- */
-
-uint64_t
-xcb_total_written(xcb_connection_t *c);
-
 /**
  * @}
  */
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_auth.c b/vcxsrv-code/libxcb/src/xcb_auth.c
index 9a1e459..de628a6 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_auth.c
+++ b/vcxsrv-code/libxcb/src/xcb_auth.c
@@ -31,8 +31,9 @@
 
 #include <assert.h>
 #include <X11/Xauth.h>
+#include <sys/param.h>
+#include <unistd.h>
 #include <stdlib.h>
-#include <time.h>
 
 #ifdef __INTERIX
 /* _don't_ ask. interix has INADDR_LOOPBACK in here. */
@@ -46,12 +47,7 @@
 #include <X11/Xwindows.h>
 #endif
 #include "xcb_windefs.h"
-#ifdef _MSC_VER
-#include <process.h>
-#endif
 #else
-#include <sys/param.h>
-#include <unistd.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -137,7 +133,6 @@ static Xauth *get_authptr(struct sockaddr *sockname, int display)
         }
         addr += 12;
         /* if v4-mapped, fall through. */
-        XCB_ALLOW_FALLTHRU
 #endif
     case AF_INET:
         if(!addr)
@@ -270,21 +265,15 @@ static int compute_auth(xcb_auth_info_t *info, Xauth *authptr, struct sockaddr *
 /* `sockaddr_un.sun_path' typical size usually ranges between 92 and 108 */
 #define INITIAL_SOCKNAME_SLACK 108
 
+#ifndef WIN32
+typedef int (*LPFN_GETPEERNAME)(int,struct sockaddr *,socklen_t *);
+#endif
 /* Return a dynamically allocated socket address structure according
    to the value returned by either getpeername() or getsockname()
    (according to POSIX, applications should not assume a particular
    length for `sockaddr_un.sun_path') */
-#ifdef _WIN32
-static struct sockaddr *get_peer_sock_name(int(_stdcall *socket_func)(SOCKET,
-    struct sockaddr *,
-    socklen_t *),
-    int fd)
-#else
-static struct sockaddr *get_peer_sock_name(int (*socket_func)(int,
-                                                              struct sockaddr *,
-                                                              socklen_t *),
+static struct sockaddr *get_peer_sock_name(LPFN_GETPEERNAME socket_func,
                                            int fd)
-#endif
 {
     socklen_t socknamelen = sizeof(struct sockaddr) + INITIAL_SOCKNAME_SLACK;
     socklen_t actual_socknamelen = socknamelen;
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_conn.c b/vcxsrv-code/libxcb/src/xcb_conn.c
index 1d2e62f..0ead776 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_conn.c
+++ b/vcxsrv-code/libxcb/src/xcb_conn.c
@@ -32,6 +32,7 @@
 #include <assert.h>
 #include <string.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <stdlib.h>
 #include <fcntl.h>
 #include <errno.h>
@@ -47,13 +48,17 @@
 
 #ifdef _WIN32
 #include "xcb_windefs.h"
-#include <io.h>
 #else
-#include <unistd.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #endif /* _WIN32 */
 
+#include <X11/Xtrans/Xtrans.h>
+
+#ifdef _MSC_VER
+#define _close(fd) closesocket(fd)
+#endif
+
 /* SHUT_RDWR is fairly recent and is not available on all platforms */
 #if !defined(SHUT_RDWR)
 #define SHUT_RDWR 2
@@ -105,7 +110,7 @@ static int set_fd_flags(const int fd)
 
 #ifdef _WIN32
    u_long iMode = 1; /* non-zero puts it in non-blocking mode, 0 in blocking mode */
-   int ret = 0;
+   int ret;
 
    ret = ioctlsocket(fd, FIONBIO, &iMode);
    if(ret != 0)
@@ -145,7 +150,7 @@ static int write_setup(xcb_connection_t *c, xcb_auth_info_t *auth_info)
     out.authorization_protocol_name_len = 0;
     out.authorization_protocol_data_len = 0;
     parts[count].iov_len = sizeof(xcb_setup_request_t);
-    parts[count++].iov_base = &out;
+    parts[count++].iov_base = (caddr_t) &out;
     parts[count].iov_len = XCB_PAD(sizeof(xcb_setup_request_t));
     parts[count++].iov_base = (char *) pad;
 
@@ -212,48 +217,49 @@ static int read_setup(xcb_connection_t *c)
 /* precondition: there must be something for us to write. */
 static int write_vec(xcb_connection_t *c, struct iovec **vector, int *count)
 {
-#ifndef _WIN32
     int n;
-#endif
 
+#ifdef _WIN32
+    int i = 0;
+    int cnt=*count;
+    struct iovec *vec;
+    n = 0;
     assert(!c->out.queue_len);
 
-#ifdef _WIN32
     /* Could use the WSASend win32 function for scatter/gather i/o but setting up the WSABUF struct from
        an iovec would require more work and I'm not sure of the benefit....works for now */
-    while (*count)
+    vec = *vector;
+    while(i < cnt)
     {
-        struct iovec *vec = *vector;
-        if (vec->iov_len)
-        {
-            int ret = send(c->fd, vec->iov_base, vec->iov_len, 0);
-            if (ret == SOCKET_ERROR)
-            {
-                int err = WSAGetLastError();
-                if (err == WSAEWOULDBLOCK)
-                {
-                    return 1;
-                }
-            }
-            if (ret <= 0)
-            {
-                _xcb_conn_shutdown(c, XCB_CONN_ERROR);
-                return 0;
-            }
-            c->out.total_written += ret;
-            vec->iov_len -= ret;
-            vec->iov_base = (char *)vec->iov_base + ret;
-        }
-        if (vec->iov_len == 0) {
-            (*vector)++;
-            (*count)--;
-        }
+      char *p= vec->iov_base;
+      size_t l= vec->iov_len;
+      while (l > 0)
+      {
+         int ret = send(c->fd, p, l, 0); 
+         if(ret == SOCKET_ERROR)
+         {
+             int err  = WSAGetLastError();
+             if(err == WSAEWOULDBLOCK)
+             {
+                 if (n)
+                 {
+                   /* already return the data */
+                   i=cnt;
+                   break;
+                 }
+                 else
+                   return 1;
+             }
+         }
+         p += ret;
+         l -= ret;
+         n += ret;
+      }
+      vec++;
+      i++;
     }
-
-    if (!*count)
-        *vector = 0;
-
 #else
+    assert(!c->out.queue_len);
     n = *count;
     if (n > IOV_MAX)
         n = IOV_MAX;
@@ -294,13 +300,14 @@ static int write_vec(xcb_connection_t *c, struct iovec **vector, int *count)
             return 1;
     }
 
+#endif /* _WIN32 */
+
     if(n <= 0)
     {
         _xcb_conn_shutdown(c, XCB_CONN_ERROR);
         return 0;
     }
 
-    c->out.total_written += n;
     for(; *count; --*count, ++*vector)
     {
         int cur = (*vector)->iov_len;
@@ -315,9 +322,6 @@ static int write_vec(xcb_connection_t *c, struct iovec **vector, int *count)
     if(!*count)
         *vector = 0;
     assert(n == 0);
-
-#endif /* _WIN32 */
-
     return 1;
 }
 
@@ -361,11 +365,7 @@ xcb_connection_t *xcb_connect_to_fd(int fd, xcb_auth_info_t *auth_info)
 
     c = calloc(1, sizeof(xcb_connection_t));
     if(!c) {
-#ifdef _WIN32
-        closesocket(fd);
-#else
         close(fd);
-#endif
         return _xcb_conn_ret_error(XCB_CONN_CLOSED_MEM_INSUFFICIENT) ;
     }
 
@@ -398,11 +398,7 @@ void xcb_disconnect(xcb_connection_t *c)
 
     /* disallow further sends and receives */
     shutdown(c->fd, SHUT_RDWR);
-#ifdef _WIN32
-    closesocket(c->fd);
-#else
     close(c->fd);
-#endif
 
     pthread_mutex_destroy(&c->iolock);
     _xcb_in_destroy(&c->in);
@@ -511,6 +507,13 @@ int _xcb_conn_wait(xcb_connection_t *c, pthread_cond_t *cond, struct iovec **vec
         }
 #else
         ret = select(c->fd + 1, &rfds, &wfds, 0, 0);
+	if (ret==SOCKET_ERROR)
+	{
+	   ret=-1;
+           errno = WSAGetLastError();
+	   if (errno == WSAEINTR)
+		   errno=EINTR;
+	}
 #endif
     } while (ret == -1 && errno == EINTR);
     if(ret < 0)
@@ -553,30 +556,3 @@ int _xcb_conn_wait(xcb_connection_t *c, pthread_cond_t *cond, struct iovec **vec
 
     return ret;
 }
-
-uint64_t xcb_total_read(xcb_connection_t *c)
-{
-    uint64_t n;
-
-    if (xcb_connection_has_error(c))
-        return 0;
-
-    pthread_mutex_lock(&c->iolock);
-    n = c->in.total_read;
-    pthread_mutex_unlock(&c->iolock);
-    return n;
-}
-
-uint64_t xcb_total_written(xcb_connection_t *c)
-{
-    uint64_t n;
-
-    if (xcb_connection_has_error(c))
-        return 0;
-
-    pthread_mutex_lock(&c->iolock);
-    n = c->out.total_written;
-    pthread_mutex_unlock(&c->iolock);
-
-    return n;
-}
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_ext.c b/vcxsrv-code/libxcb/src/xcb_ext.c
index 831f283..990c67a 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_ext.c
+++ b/vcxsrv-code/libxcb/src/xcb_ext.c
@@ -123,6 +123,8 @@ int _xcb_ext_init(xcb_connection_t *c)
 
 void _xcb_ext_destroy(xcb_connection_t *c)
 {
+    if (!c->ext.lock)
+      return; /* mutex is not initialised */
     pthread_mutex_destroy(&c->ext.lock);
     while(c->ext.extensions_size-- > 0)
         if(c->ext.extensions[c->ext.extensions_size].tag == LAZY_FORCED)
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_in.c b/vcxsrv-code/libxcb/src/xcb_in.c
index 7d02e9b..bab4bc7 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_in.c
+++ b/vcxsrv-code/libxcb/src/xcb_in.c
@@ -32,6 +32,7 @@
 #include <assert.h>
 #include <string.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 
@@ -39,7 +40,6 @@
 #include <poll.h>
 #endif
 #ifndef _WIN32
-#include <unistd.h>
 #include <sys/select.h>
 #include <sys/socket.h>
 #endif
@@ -365,7 +365,7 @@ static void free_reply_list(struct reply_list *head)
     }
 }
 
-static int read_block(const int fd, void *buf, const intptr_t len)
+static int read_block(const int fd, void *buf, const ssize_t len)
 {
     int done = 0;
     while(done < len)
@@ -661,8 +661,6 @@ int xcb_poll_for_reply(xcb_connection_t *c, unsigned int request, void **reply,
     assert(reply != 0);
     pthread_mutex_lock(&c->iolock);
     ret = poll_for_reply(c, widen(c, request), reply, error);
-    if(!ret && c->in.reading == 0 && _xcb_in_read(c)) /* _xcb_in_read shuts down the connection on error */
-        ret = poll_for_reply(c, widen(c, request), reply, error);
     pthread_mutex_unlock(&c->iolock);
     return ret;
 }
@@ -680,8 +678,6 @@ int xcb_poll_for_reply64(xcb_connection_t *c, uint64_t request, void **reply, xc
     assert(reply != 0);
     pthread_mutex_lock(&c->iolock);
     ret = poll_for_reply(c, request, reply, error);
-    if(!ret && c->in.reading == 0 && _xcb_in_read(c)) /* _xcb_in_read shuts down the connection on error */
-        ret = poll_for_reply(c, request, reply, error);
     pthread_mutex_unlock(&c->iolock);
     return ret;
 }
@@ -772,8 +768,6 @@ xcb_generic_event_t *xcb_poll_for_special_event(xcb_connection_t *c,
         return 0;
     pthread_mutex_lock(&c->iolock);
     event = get_special_event(c, se);
-    if(!event && c->in.reading == 0 && _xcb_in_read(c)) /* _xcb_in_read shuts down the connection on error */
-        event = get_special_event(c, se);
     pthread_mutex_unlock(&c->iolock);
     return event;
 }
@@ -958,20 +952,8 @@ void _xcb_in_replies_done(xcb_connection_t *c)
         pend = container_of(c->in.pending_replies_tail, struct pending_reply, next);
         if(pend->workaround == WORKAROUND_EXTERNAL_SOCKET_OWNER)
         {
-            if (XCB_SEQUENCE_COMPARE(pend->first_request, <=, c->out.request)) {
-                pend->last_request = c->out.request;
-                pend->workaround = WORKAROUND_NONE;
-            } else {
-                /* The socket was taken, but no requests were actually sent
-                 * so just discard the pending_reply that was created.
-                 */
-                struct pending_reply **prev_next = &c->in.pending_replies;
-                while (*prev_next != pend)
-                    prev_next = &(*prev_next)->next;
-                *prev_next = NULL;
-                c->in.pending_replies_tail = prev_next;
-                free(pend);
-            }
+            pend->last_request = c->out.request;
+            pend->workaround = WORKAROUND_NONE;
         }
     }
 }
@@ -1025,7 +1007,6 @@ int _xcb_in_read(xcb_connection_t *c)
             }
         }
 #endif
-        c->in.total_read += n;
         c->in.queue_len += n;
     }
     while(read_packet(c))
@@ -1052,7 +1033,7 @@ int _xcb_in_read(xcb_connection_t *c)
     }
 #endif
 #ifndef _WIN32
-    if((n > 0) || (n < 0 && (errno == EAGAIN || errno == EINTR)))
+    if((n > 0) || (n < 0 && errno == EAGAIN))
 #else
     if((n > 0) || (n < 0 && WSAGetLastError() == WSAEWOULDBLOCK))
 #endif /* !_WIN32 */
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_out.c b/vcxsrv-code/libxcb/src/xcb_out.c
index df94867..3d849ea 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_out.c
+++ b/vcxsrv-code/libxcb/src/xcb_out.c
@@ -31,19 +31,16 @@
 
 #include <assert.h>
 #include <stdlib.h>
-#ifdef _WIN32
-#include <io.h>
-#else
 #include <unistd.h>
-#endif
 #include <string.h>
+#include <X11/Xtrans/Xtrans.h>
 
 #include "xcb.h"
 #include "xcbext.h"
 #include "xcbint.h"
 #include "bigreq.h"
 
-static inline void send_request(xcb_connection_t *c, int isvoid, enum workarounds workaround, int flags, struct iovec *vector, int count)
+static __inline void send_request(xcb_connection_t *c, int isvoid, enum workarounds workaround, int flags, struct iovec *vector, int count)
 {
     if(c->has_error)
         return;
@@ -294,10 +291,10 @@ uint64_t xcb_send_request_with_fds64(xcb_connection_t *c, int flags, struct iove
         {
             prefix[0] = ((uint32_t *) vector[0].iov_base)[0];
             prefix[1] = ++longlen;
-            vector[0].iov_base = (uint32_t *) vector[0].iov_base + 1;
+            vector[0].iov_base = (caddr_t)((uint32_t *) vector[0].iov_base + 1);
             vector[0].iov_len -= sizeof(uint32_t);
             --vector, ++veclen;
-            vector[0].iov_base = prefix;
+            vector[0].iov_base = (caddr_t)prefix;
             vector[0].iov_len = sizeof(prefix);
         }
     }
@@ -391,14 +388,8 @@ int xcb_take_socket(xcb_connection_t *c, void (*return_socket)(void *closure), v
     {
         c->out.return_socket = return_socket;
         c->out.socket_closure = closure;
-        if(flags) {
-            /* c->out.request + 1 will be the first request sent by the external
-             * socket owner. If the socket is returned before this request is sent
-             * it will be detected in _xcb_in_replies_done and this pending_reply
-             * will be discarded.
-             */
-            _xcb_in_expect_reply(c, c->out.request + 1, WORKAROUND_EXTERNAL_SOCKET_OWNER, flags);
-        }
+        if(flags)
+            _xcb_in_expect_reply(c, c->out.request, WORKAROUND_EXTERNAL_SOCKET_OWNER, flags);
         assert(c->out.request == c->out.request_written);
         *sent = c->out.request;
     }
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_util.c b/vcxsrv-code/libxcb/src/xcb_util.c
index cce54aa..e2d9d3d 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_util.c
+++ b/vcxsrv-code/libxcb/src/xcb_util.c
@@ -36,12 +36,12 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
+#include <unistd.h>
 #include <string.h>
 
 #ifdef _WIN32
 #include "xcb_windefs.h"
 #else
-#include <unistd.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
 #include <sys/un.h>
@@ -64,6 +64,13 @@
 #include <sys/stat.h>
 #endif
 
+#ifdef _MSC_VER
+#ifdef close
+#undef close
+#endif
+#define close(fd) closesocket(fd)
+#endif
+
 int xcb_popcount(uint32_t mask)
 {
     uint32_t y;
@@ -265,8 +272,6 @@ static int _xcb_open(const char *host, char *protocol, const int display)
     struct stat sbuf;
     if (0 == stat(host, &sbuf)) {
         file = strdup(host);
-        if(file == NULL)
-            return -1;
         filelen = actual_filelen = strlen(file);
     } else
 #endif
@@ -329,7 +334,7 @@ static int _xcb_socket(int family, int type, int proto)
 
 
 static int _xcb_do_connect(int fd, const struct sockaddr* addr, int addrlen) {
-    int on = 1;
+    char on = 1;
 
     if(fd < 0)
         return -1;
@@ -340,6 +345,23 @@ static int _xcb_do_connect(int fd, const struct sockaddr* addr, int addrlen) {
     return connect(fd, addr, addrlen);
 }
 
+#ifdef WIN32
+int InitWSA(void)
+{
+  static WSADATA wsadata;
+
+  if (!wsadata.wVersion)
+  {
+    __ptw32_processInitialize();
+    if (WSAStartup(0x0202, &wsadata))
+      return -1;
+  }
+  return 0;
+}
+#else
+#define InitWSA()
+#endif
+
 static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short port)
 {
     int fd = -1;
@@ -379,6 +401,11 @@ static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short
     }
 #endif
 
+#ifdef WIN32
+    if (InitWSA()<0)
+      return -1;
+#endif
+
     snprintf(service, sizeof(service), "%hu", port);
     if(getaddrinfo(host, service, &hints, &results))
         /* FIXME: use gai_strerror, and fill in error connection */
@@ -389,11 +416,7 @@ static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short
         fd = _xcb_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
         if (_xcb_do_connect(fd, addr->ai_addr, addr->ai_addrlen) >= 0)
             break;
-#ifdef _WIN32
-        closesocket(fd);
-#else
         close(fd);
-#endif
         fd = -1;
     }
     freeaddrinfo(results);
@@ -419,11 +442,7 @@ static int _xcb_open_tcp(const char *host, char *protocol, const unsigned short
             if(_xcb_do_connect(fd, (struct sockaddr*)&_s, sizeof(_s)) >= 0)
                 break;
 
-#ifdef _WIN32
-            closesocket(fd);
-#else
             close(fd);
-#endif
             fd = -1;
             ++_c;
         }
@@ -458,11 +477,7 @@ static int _xcb_open_unix(char *protocol, const char *file)
         setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, sizeof(int));
     }
     if(connect(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
-#ifdef _WIN32
-        closesocket(fd);
-#else
         close(fd);
-#endif
         return -1;
     }
     return fd;
@@ -489,11 +504,7 @@ static int _xcb_open_abstract(char *protocol, const char *file, size_t filelen)
     if (fd == -1)
         return -1;
     if (connect(fd, (struct sockaddr *) &addr, namelen) == -1) {
-#ifdef _WIN32
-        closesocket(fd);
-#else
         close(fd);
-#endif
         return -1;
     }
     return fd;
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_windefs.h b/vcxsrv-code/libxcb/src/xcb_windefs.h
index d28bb13..6d6e31c 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_windefs.h
+++ b/vcxsrv-code/libxcb/src/xcb_windefs.h
@@ -31,20 +31,31 @@
 #define WINVER 0x0501 /* required for getaddrinfo/freeaddrinfo defined only for WinXP and above */
 #endif
 
-#include <stdio.h>
-#include <X11/Xwindows.h>
+#ifdef INCL_WINSOCK_API_TYPEDEFS
+#undef INCL_WINSOCK_API_TYPEDEFS
+#endif
+#define INCL_WINSOCK_API_TYPEDEFS 1 /* Needed for LPFN_GETPEERNAME */
+
+#define FD_SETSIZE 1024
+
 #include <X11/Xwinsock.h>
-typedef unsigned char BYTE;
+#include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windef.h>
 
-#define STDERR_FILENO _fileno( stderr )
-
-struct iovec  {
-    void *iov_base;    /* Pointer to data.  */
-    int iov_len;       /* Length of data.  */
-};
+typedef unsigned char BYTE;
 
 typedef unsigned int in_addr_t;
 
+#define HANDLE void *
+typedef int pid_t;
+
+#define STDERR_FILENO 2
+
+#ifdef LIBXCB_DLL
+#define XCB_EXTERN __declspec(dllexport) extern
+#else
+#define XCB_EXTERN __declspec(dllimport) extern
+#endif
+
 #endif /* xcb_windefs.h */
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_xid.c b/vcxsrv-code/libxcb/src/xcb_xid.c
index ebe41a1..7d9fc62 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcb_xid.c
+++ b/vcxsrv-code/libxcb/src/xcb_xid.c
@@ -55,7 +55,7 @@ uint32_t xcb_generate_id(xcb_connection_t *c)
             /* check for extension */
             const xcb_query_extension_reply_t *xc_misc_reply =
               xcb_get_extension_data(c, &xcb_xc_misc_id);
-            if (!xc_misc_reply || !xc_misc_reply->present) {
+            if (!xc_misc_reply) {
                 pthread_mutex_unlock(&c->xid.lock);
                 return -1;
             }
@@ -97,5 +97,7 @@ int _xcb_xid_init(xcb_connection_t *c)
 
 void _xcb_xid_destroy(xcb_connection_t *c)
 {
+    if (!c->xid.lock)
+      return; /* mutex was not initialised yet */
     pthread_mutex_destroy(&c->xid.lock);
 }
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcbint.h b/vcxsrv-code/libxcb/src/xcbint.h
index 524d6c7..acce646 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/src/xcbint.h
+++ b/vcxsrv-code/libxcb/src/xcbint.h
@@ -38,16 +38,6 @@
 #pragma GCC visibility push(hidden)
 #endif
 
-#ifndef __has_attribute
-# define __has_attribute(x) 0  /* Compatibility with older compilers. */
-#endif
-
-#if __has_attribute(fallthrough)
-# define XCB_ALLOW_FALLTHRU __attribute__ ((fallthrough));
-#else
-# define XCB_ALLOW_FALLTHRU /* FALLTHRU */
-#endif
-
 enum workarounds {
     WORKAROUND_NONE,
     WORKAROUND_GLX_GET_FB_CONFIGS_BUG,
@@ -113,7 +103,6 @@ typedef struct _xcb_out {
 
     uint64_t request;
     uint64_t request_written;
-    uint64_t total_written;
 
     pthread_mutex_t reqlenlock;
     enum lazy_reply_tag maximum_request_length_tag;
@@ -146,7 +135,6 @@ typedef struct _xcb_in {
     uint64_t request_expected;
     uint64_t request_read;
     uint64_t request_completed;
-    uint64_t total_read;
     struct reply_list *current_reply;
     struct reply_list **current_reply_tail;
 
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_all.c b/vcxsrv-code/libxcb/tests/check_all.c
index f4c909c..4393422 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_all.c
+++ b/vcxsrv-code/libxcb/tests/check_all.c
@@ -1,19 +1,10 @@
 #include <stdlib.h>
 #include "check_suites.h"
 
-#if CHECK_MAJOR_VERSION == 0 && CHECK_MINOR_VERSION < 13
 void suite_add_test(Suite *s, TFun tf, const char *name)
-#else
-void suite_add_test(Suite *s, const TTest *tt, const char *name)
-#endif
 {
 	TCase *tc = tcase_create(name);
-
-#if CHECK_MAJOR_VERSION == 0 && CHECK_MINOR_VERSION < 13
 	tcase_add_test(tc, tf);
-#else
-	tcase_add_test(tc, tt);
-#endif
 	suite_add_tcase(s, tc);
 }
 
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_public.c b/vcxsrv-code/libxcb/tests/check_public.c
index aed40c8..2094bfe 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_public.c
+++ b/vcxsrv-code/libxcb/tests/check_public.c
@@ -37,18 +37,18 @@ static void parse_display_pass(const char *name, const char *host, const int dis
 		got_display = got_screen = -42;
 		mark_point();
 		success = xcb_parse_display(argument, &got_host, &got_display, &got_screen);
-		ck_assert_msg(success, "unexpected parse failure %sfor '%s'", test_string[test_type], name);
-		ck_assert_msg(strcmp(host, got_host) == 0, "parse %sproduced unexpected hostname '%s' for '%s': expected '%s'", test_string[test_type], got_host, name, host);
-		ck_assert_msg(display == got_display, "parse %sproduced unexpected display '%d' for '%s': expected '%d'", test_string[test_type], got_display, name, display);
-		ck_assert_msg(screen == got_screen, "parse %sproduced unexpected screen '%d' for '%s': expected '%d'", test_string[test_type], got_screen, name, screen);
+		fail_unless(success, "unexpected parse failure %sfor '%s'", test_string[test_type], name);
+		fail_unless(strcmp(host, got_host) == 0, "parse %sproduced unexpected hostname '%s' for '%s': expected '%s'", test_string[test_type], got_host, name, host);
+		fail_unless(display == got_display, "parse %sproduced unexpected display '%d' for '%s': expected '%d'", test_string[test_type], got_display, name, display);
+		fail_unless(screen == got_screen, "parse %sproduced unexpected screen '%d' for '%s': expected '%d'", test_string[test_type], got_screen, name, screen);
 
 		got_host = (char *) -1;
 		got_display = got_screen = -42;
 		mark_point();
 		success = xcb_parse_display(argument, &got_host, &got_display, 0);
-		ck_assert_msg(success, "unexpected screenless parse failure %sfor '%s'", test_string[test_type], name);
-		ck_assert_msg(strcmp(host, got_host) == 0, "screenless parse %sproduced unexpected hostname '%s' for '%s': expected '%s'", test_string[test_type], got_host, name, host);
-		ck_assert_msg(display == got_display, "screenless parse %sproduced unexpected display '%d' for '%s': expected '%d'", test_string[test_type], got_display, name, display);
+		fail_unless(success, "unexpected screenless parse failure %sfor '%s'", test_string[test_type], name);
+		fail_unless(strcmp(host, got_host) == 0, "screenless parse %sproduced unexpected hostname '%s' for '%s': expected '%s'", test_string[test_type], got_host, name, host);
+		fail_unless(display == got_display, "screenless parse %sproduced unexpected display '%d' for '%s': expected '%d'", test_string[test_type], got_display, name, display);
 	}
 	putenv("DISPLAY=");
 }
@@ -79,18 +79,18 @@ static void parse_display_fail(const char *name)
 		got_display = got_screen = -42;
 		mark_point();
 		success = xcb_parse_display(argument, &got_host, &got_display, &got_screen);
-		ck_assert_msg(!success, "unexpected parse success %sfor '%s'", test_string[test_type], name);
-		ck_assert_msg(got_host == (char *) -1, "host changed on parse failure %sfor '%s': got %p", test_string[test_type], name, got_host);
-		ck_assert_msg(got_display == -42, "display changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_display);
-		ck_assert_msg(got_screen == -42, "screen changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_screen);
+		fail_unless(!success, "unexpected parse success %sfor '%s'", test_string[test_type], name);
+		fail_unless(got_host == (char *) -1, "host changed on parse failure %sfor '%s': got %p", test_string[test_type], name, got_host);
+		fail_unless(got_display == -42, "display changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_display);
+		fail_unless(got_screen == -42, "screen changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_screen);
 
 		got_host = (char *) -1;
 		got_display = got_screen = -42;
 		mark_point();
 		success = xcb_parse_display(argument, &got_host, &got_display, 0);
-		ck_assert_msg(!success, "unexpected screenless parse success %sfor '%s'", test_string[test_type], name);
-		ck_assert_msg(got_host == (char *) -1, "host changed on parse failure %sfor '%s': got %p", test_string[test_type], name, got_host);
-		ck_assert_msg(got_display == -42, "display changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_display);
+		fail_unless(!success, "unexpected screenless parse success %sfor '%s'", test_string[test_type], name);
+		fail_unless(got_host == (char *) -1, "host changed on parse failure %sfor '%s': got %p", test_string[test_type], name, got_host);
+		fail_unless(got_display == -42, "display changed on parse failure %sfor '%s': got %d", test_string[test_type], name, got_display);
 	}
 	putenv("DISPLAY=");
 }
@@ -183,7 +183,7 @@ END_TEST
 
 static void popcount_eq(uint32_t bits, int count)
 {
-	ck_assert_msg(xcb_popcount(bits) == count, "unexpected popcount(%08x) != %d", bits, count);
+	fail_unless(xcb_popcount(bits) == count, "unexpected popcount(%08x) != %d", bits, count);
 }
 
 START_TEST(popcount)
diff --git a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_suites.h b/vcxsrv-code/libxcb/tests/check_suites.h
index e662084..499f1af 100644
--- a/xserver-vcpkg/vcpkg/buildtrees/xcb/src/d6e45c44f9-29da05f51f.clean/tests/check_suites.h
+++ b/vcxsrv-code/libxcb/tests/check_suites.h
@@ -1,8 +1,4 @@
 #include <check.h>
 
-#if CHECK_MAJOR_VERSION == 0 && CHECK_MINOR_VERSION < 13
 void suite_add_test(Suite *s, TFun tf, const char *name);
-#else
-void suite_add_test(Suite *s, const TTest *tt, const char *name);
-#endif
 Suite *public_suite(void);
