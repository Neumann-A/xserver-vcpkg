diff --git a/xserver/xkb/ddxPrivate.c b/vcxsrv-code/xorg-server/xkb/ddxPrivate.c
index fcde3a1..c4d21cb 100644
--- a/xserver/xkb/ddxPrivate.c
+++ b/vcxsrv-code/xorg-server/xkb/ddxPrivate.c
@@ -3,12 +3,44 @@
 #include <dix-config.h>
 #endif
 
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdio.h>
 #include <X11/X.h>
 #include "windowstr.h"
+#define XKBSRV_NEED_FILE_FUNCS
 #include <xkbsrv.h>
 
+#include "dixgrabs.h"
+#include "os.h"
+#include "xf86.h"
+
 int
 XkbDDXPrivate(DeviceIntPtr dev, KeyCode key, XkbAction *act)
 {
+    XkbAnyAction *xf86act = &(act->any);
+    char msgbuf[XkbAnyActionDataSize+1];
+
+    if (xf86act->type == XkbSA_XFree86Private) {
+        memcpy(msgbuf, xf86act->data, XkbAnyActionDataSize);
+        msgbuf[XkbAnyActionDataSize]= '\0';
+        if (strcasecmp(msgbuf, "prgrbs")==0) {
+            DeviceIntPtr tmp;
+            ErrorF("Printing all currently active device grabs:\n");
+            for (tmp = inputInfo.devices; tmp; tmp = tmp->next)
+                if (tmp->deviceGrab.grab)
+                    PrintDeviceGrabInfo(tmp);
+            ErrorF("End list of active device grabs\n");
+        }
+        else if (strcasecmp(msgbuf, "ungrab")==0)
+            UngrabAllDevices(FALSE);
+        else if (strcasecmp(msgbuf, "clsgrb")==0)
+            UngrabAllDevices(TRUE);
+        else if (strcasecmp(msgbuf, "prwins")==0)
+            PrintWindowTree();
+    }
+
     return 0;
 }
diff --git a/xserver/randr/rrlease.c b/vcxsrv-code/xorg-server/randr/rrlease.c
index cb366e7..ad98622 100644
--- a/xserver/randr/rrlease.c
+++ b/vcxsrv-code/xorg-server/randr/rrlease.c
@@ -321,11 +321,13 @@ leaseReturned:
         return BadAlloc;
     }
 
+#ifdef XTRANS_SEND_FDS
     if (WriteFdToClient(client, fd, TRUE) < 0) {
         RRTerminateLease(lease);
         close(fd);
         return BadAlloc;
     }
+#endif
 
     RRLeaseChangeState(lease, RRLeaseCreating, RRLeaseRunning);
 

diff --git a/xserver/os/xstrans.c b/vcxsrv-code/xorg-server/os/xstrans.c
index 2bc79e7..30de32b 100644
--- a/xserver/os/xstrans.c
+++ b/vcxsrv-code/xorg-server/os/xstrans.c
@@ -5,13 +5,21 @@
 #include <X11/Xfuncproto.h>
 
 /* ErrorF is used by xtrans */
-#ifndef HAVE_DIX_CONFIG_H
+/*#ifndef HAVE_DIX_CONFIG_H
 extern _X_EXPORT void
 ErrorF(const char *f, ...)
 _X_ATTRIBUTE_PRINTF(1, 2);
-#endif
+#endif*/
 
 #define TRANS_REOPEN
 #define TRANS_SERVER
 #define XSERV_t
+#ifndef TCPCONN
+#define TCPCONN
+#endif
+#ifdef WIN32
+#undef SO_REUSEADDR
+#define SO_BINDRETRYCOUNT 0  // do not try to bind again when it fails, this will speed up searching for a free listening port
+#endif
+
 #include <X11/Xtrans/transport.c>