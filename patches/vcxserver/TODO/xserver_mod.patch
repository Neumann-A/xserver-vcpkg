diff --git a/xserver/.gitignore b/vcxsrv-code/xorg-server/.gitignore
index dc56b46..0f3a8fb 100644
--- a/xserver/.gitignore
+++ b/vcxsrv-code/xorg-server/.gitignore
@@ -1,82 +1,11 @@
-#
-#		X.Org module default exclusion patterns
-#		The next section if for module specific patterns
-#
-#	Do not edit the following section
-# 	GNU Build System (Autotools)
-aclocal.m4
-autom4te.cache/
-autoscan.log
-ChangeLog
-compile
-config.guess
-config.h
-config.h.in
-config.log
-config-ml.in
-config.py
-config.status
-config.status.lineno
-config.sub
-configure
-configure.scan
-depcomp
-.deps/
-INSTALL
-install-sh
-.libs/
-libtool
-libtool.m4
-ltmain.sh
-lt~obsolete.m4
-ltoptions.m4
-ltsugar.m4
-ltversion.m4
-Makefile
-Makefile.in
-mdate-sh
-missing
-mkinstalldirs
-*.pc
-py-compile
-stamp-h?
-symlink-tree
-test-driver
-texinfo.tex
-ylwrap
-
-#	Do not edit the following section
-# 	Edit Compile Debug Document Distribute
-*~
-*.[0-9]
-*.[0-9]x
-*.bak
-*.bin
-core
-*.dll
-*.exe
-*-ISO*.bdf
-*-JIS*.bdf
-*-KOI8*.bdf
-*.kld
-*.ko
-*.ko.cmd
-*.lai
-*.l[oa]
-*.[oa]
-*.obj
-*.patch
-*.so
-*.pcf.gz
-*.pdb
-*.tar.bz2
-*.tar.gz
-#
-#		Add & Override patterns for xserver 
-#
-#		Edit the following section as needed
-# For example, !report.pc overrides *.pc. See 'man gitignore'
-# 
-doltcompile
-doltlibtool
-xserver.ent
+fonts
+locale
+protocol.txt
+xcalc
+xcalc-color
+xclock
+xclock-color
+xerrordb
+xkbdata
+xwin.rc
+test-driver
\ No newline at end of file
diff --git a/xserver/Xext/dpms.c b/vcxsrv-code/xorg-server/Xext/dpms.c
index e43a379..2a06af5 100644
--- a/xserver/Xext/dpms.c
+++ b/vcxsrv-code/xorg-server/Xext/dpms.c
@@ -28,6 +28,8 @@ Equipment Corporation.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define DPMSExtension
 #endif
 
 #include <X11/X.h>
diff --git a/xserver/Xext/hashtable.c b/vcxsrv-code/xorg-server/Xext/hashtable.c
index 3434c99..ba63704 100644
--- a/xserver/Xext/hashtable.c
+++ b/vcxsrv-code/xorg-server/Xext/hashtable.c
@@ -72,7 +72,7 @@ void
 ht_destroy(HashTable ht)
 {
     int c;
-    BucketPtr it, tmp;
+    BucketPtr it=NULL, tmp;
     int numBuckets = 1 << ht->bucketBits;
     for (c = 0; c < numBuckets; ++c) {
         xorg_list_for_each_entry_safe(it, tmp, &ht->buckets[c], l) {
@@ -102,7 +102,7 @@ double_size(HashTable ht)
         }
 
         for (c = 0; c < numBuckets; ++c) {
-            BucketPtr it, tmp;
+            BucketPtr it=NULL, tmp;
             xorg_list_for_each_entry_safe(it, tmp, &ht->buckets[c], l) {
                 struct xorg_list *newBucket =
                     &newBuckets[ht->hash(ht->cdata, it->key, newBucketBits)];
@@ -171,7 +171,7 @@ ht_remove(HashTable ht, const void *key)
 {
     unsigned index = ht->hash(ht->cdata, key, ht->bucketBits);
     struct xorg_list *bucket = &ht->buckets[index];
-    BucketPtr it;
+    BucketPtr it=NULL;
 
     xorg_list_for_each_entry(it, bucket, l) {
         if (ht->compare(ht->cdata, key, it->key) == 0) {
@@ -190,7 +190,7 @@ ht_find(HashTable ht, const void *key)
 {
     unsigned index = ht->hash(ht->cdata, key, ht->bucketBits);
     struct xorg_list *bucket = &ht->buckets[index];
-    BucketPtr it;
+    BucketPtr it=NULL;
 
     xorg_list_for_each_entry(it, bucket, l) {
         if (ht->compare(ht->cdata, key, it->key) == 0) {
@@ -207,7 +207,7 @@ ht_dump_distribution(HashTable ht)
     int c;
     int numBuckets = 1 << ht->bucketBits;
     for (c = 0; c < numBuckets; ++c) {
-        BucketPtr it;
+        BucketPtr it=NULL;
         int n = 0;
 
         xorg_list_for_each_entry(it, &ht->buckets[c], l) {
@@ -280,7 +280,7 @@ ht_dump_contents(HashTable ht,
     int c;
     int numBuckets = 1 << ht->bucketBits;
     for (c = 0; c < numBuckets; ++c) {
-        BucketPtr it;
+        BucketPtr it=NULL;
         int n = 0;
 
         printf("%d: ", c);
diff --git a/xserver/Xext/saver.c b/vcxsrv-code/xorg-server/Xext/saver.c
index f813ba0..a89ac5e 100644
--- a/xserver/Xext/saver.c
+++ b/vcxsrv-code/xorg-server/Xext/saver.c
@@ -28,6 +28,12 @@ in this Software without prior written authorization from the X Consortium.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define SCREENSAVER
+#endif
+
+#ifdef CreateWindow
+#undef CreateWindow
 #endif
 
 #include <X11/X.h>
diff --git a/xserver/Xext/security.c b/vcxsrv-code/xorg-server/Xext/security.c
index 162d07a..0a29e0b 100644
--- a/xserver/Xext/security.c
+++ b/vcxsrv-code/xorg-server/Xext/security.c
@@ -26,6 +26,8 @@ in this Software without prior written authorization from The Open Group.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define XACE
 #endif
 
 #include "scrnintstr.h"
diff --git a/xserver/Xext/shape.c b/vcxsrv-code/xorg-server/Xext/shape.c
index e7c7a45..2b36612 100644
--- a/xserver/Xext/shape.c
+++ b/vcxsrv-code/xorg-server/Xext/shape.c
@@ -26,6 +26,8 @@ in this Software without prior written authorization from The Open Group.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define SHAPE
 #endif
 
 #include <stdlib.h>
diff --git a/xserver/Xext/shm.c b/vcxsrv-code/xorg-server/Xext/shm.c
index 071bd1a..4a2ce13 100644
--- a/xserver/Xext/shm.c
+++ b/vcxsrv-code/xorg-server/Xext/shm.c
@@ -33,8 +33,10 @@ in this Software without prior written authorization from The Open Group.
 #endif
 
 #include <sys/types.h>
+#if !defined(_MSC_VER)
 #include <sys/ipc.h>
 #include <sys/shm.h>
+#endif
 #ifdef HAVE_MEMFD_CREATE
 #include <sys/mman.h>
 #endif
@@ -339,6 +341,9 @@ shm_access(ClientPtr client, SHMPERM_TYPE * perm, int readonly)
             if (uid == 0) {
                 return 0;
             }
+            #ifdef _MSC_VER
+            __asm int 3;
+            #else
             /* Check the owner */
             if (SHMPERM_UID(perm) == uid || SHMPERM_CUID(perm) == uid) {
                 mask = S_IRUSR;
@@ -347,10 +352,14 @@ shm_access(ClientPtr client, SHMPERM_TYPE * perm, int readonly)
                 }
                 return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
             }
+            #endif
         }
 
         if (gidset) {
             /* Check the group */
+            #ifdef _MSC_VER
+            __asm int 3;
+            #else
             if (SHMPERM_GID(perm) == gid || SHMPERM_CGID(perm) == gid) {
                 mask = S_IRGRP;
                 if (!readonly) {
@@ -358,14 +367,20 @@ shm_access(ClientPtr client, SHMPERM_TYPE * perm, int readonly)
                 }
                 return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
             }
+            #endif
         }
     }
+            #ifdef _MSC_VER
+            __asm int 3;
+            return -1;
+            #else
     /* Otherwise, check everyone else */
     mask = S_IROTH;
     if (!readonly) {
         mask |= S_IWOTH;
     }
     return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
+    #endif
 }
 
 static int
@@ -436,6 +451,7 @@ ShmDetachSegment(void *value, /* must conform to DeleteType */
 
     if (--shmdesc->refcnt)
         return TRUE;
+#ifndef _MSC_VER
 #if SHM_FD_PASSING
     if (shmdesc->is_fd) {
         if (shmdesc->busfault)
@@ -444,6 +460,7 @@ ShmDetachSegment(void *value, /* must conform to DeleteType */
     } else
 #endif
         shmdt(shmdesc->addr);
+#endif
     for (prev = &Shmsegs; *prev != shmdesc; prev = &(*prev)->next);
     *prev = shmdesc->next;
     free(shmdesc);
diff --git a/xserver/Xext/sync.c b/vcxsrv-code/xorg-server/Xext/sync.c
index fd2ceb0..206f6a4 100644
--- a/xserver/Xext/sync.c
+++ b/vcxsrv-code/xorg-server/Xext/sync.c
@@ -1194,6 +1194,10 @@ FreeAwait(void *addr, XID id)
     return Success;
 }
 
+#ifdef _MSC_VER
+#pragma warning(disable:4715) /* Not all control paths return a value */
+#endif
+
 /* loosely based on dix/events.c/OtherClientGone */
 static int
 FreeAlarmClient(void *value, XID id)
diff --git a/xserver/Xext/xace.c b/vcxsrv-code/xorg-server/Xext/xace.c
index f8f8d13..340b3a0 100644
--- a/xserver/Xext/xace.c
+++ b/vcxsrv-code/xorg-server/Xext/xace.c
@@ -19,6 +19,8 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define XACE
 #endif
 
 #include <stdarg.h>
diff --git a/xserver/Xext/xf86bigfont.c b/vcxsrv-code/xorg-server/Xext/xf86bigfont.c
index 529595b..bc5eaa3 100644
--- a/xserver/Xext/xf86bigfont.c
+++ b/vcxsrv-code/xorg-server/Xext/xf86bigfont.c
@@ -275,8 +275,13 @@ ProcXF86BigfontQueryVersion(ClientPtr client)
         .length = 0,
         .majorVersion = SERVER_XF86BIGFONT_MAJOR_VERSION,
         .minorVersion = SERVER_XF86BIGFONT_MINOR_VERSION,
+#ifdef WIN32
+        .uid = 0,
+        .gid = 0,
+#else,
         .uid = geteuid(),
         .gid = getegid(),
+#endif
 #ifdef HAS_SHM
         .signature = signature,
         .capabilities = (client->local && !client->swapped)
diff --git a/xserver/Xext/xres.c b/vcxsrv-code/xorg-server/Xext/xres.c
index 3543298..d6e557d 100644
--- a/xserver/Xext/xres.c
+++ b/vcxsrv-code/xorg-server/Xext/xres.c
@@ -120,7 +120,7 @@ AddFragment(struct xorg_list *frags, int bytes)
 static void
 WriteFragmentsToClient(ClientPtr client, struct xorg_list *frags)
 {
-    FragmentList *it;
+    FragmentList *it=NULL;
     xorg_list_for_each_entry(it, frags, l) {
         WriteToClient(client, it->bytes, (char*) it + sizeof(*it));
     }
@@ -133,7 +133,7 @@ WriteFragmentsToClient(ClientPtr client, struct xorg_list *frags)
 static void
 DestroyFragments(struct xorg_list *frags)
 {
-    FragmentList *it, *tmp;
+    FragmentList *it=NULL, *tmp;
     xorg_list_for_each_entry_safe(it, tmp, frags, l) {
         xorg_list_del(&it->l);
         free(it);
@@ -271,7 +271,7 @@ ResFindAllRes(void *value, XID id, RESTYPE type, void *cdata)
 {
     int *counts = (int *) cdata;
 
-    counts[(type & TypeMask) - 1]++;
+    if ((type & TypeMask) != RT_NONE) counts[(type & TypeMask) - 1]++;
 }
 
 static CARD32
diff --git a/xserver/Xext/xvmain.c b/vcxsrv-code/xorg-server/Xext/xvmain.c
index f627471..9834627 100644
--- a/xserver/Xext/xvmain.c
+++ b/vcxsrv-code/xorg-server/Xext/xvmain.c
@@ -271,7 +271,7 @@ XvScreenInit(ScreenPtr pScreen)
 
     /* ALLOCATE SCREEN PRIVATE RECORD */
 
-    pxvs = malloc(sizeof(XvScreenRec));
+    pxvs = calloc(1,sizeof(XvScreenRec));
     if (!pxvs) {
         ErrorF("XvScreenInit: Unable to allocate screen private structure\n");
         return BadAlloc;
diff --git a/xserver/Xi/chgdctl.c b/vcxsrv-code/xorg-server/Xi/chgdctl.c
index a778fa3..8fdd38f 100644
--- a/xserver/Xi/chgdctl.c
+++ b/vcxsrv-code/xorg-server/Xi/chgdctl.c
@@ -128,13 +128,12 @@ ProcXChangeDeviceControl(ClientPtr client)
         goto out;
     }
 
-    rep = (xChangeDeviceControlReply) {
-        .repType = X_Reply,
-        .RepType = X_ChangeDeviceControl,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .status = Success,
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_ChangeDeviceControl;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.status = Success;
 
     switch (stuff->control) {
     case DEVICE_RESOLUTION:
@@ -224,13 +223,12 @@ ProcXChangeDeviceControl(ClientPtr client)
 
  out:
     if (ret == Success) {
-        devicePresenceNotify dpn = {
-            .type = DevicePresenceNotify,
-            .time = currentTime.milliseconds,
-            .devchange = DeviceControlChanged,
-            .deviceid = dev->id,
-            .control = stuff->control
-        };
+        devicePresenceNotify dpn;
+        dpn.type = DevicePresenceNotify;
+        dpn.time = currentTime.milliseconds;
+        dpn.devchange = DeviceControlChanged;
+        dpn.deviceid = dev->id;
+        dpn.control = stuff->control;
         SendEventToAllWindows(dev, DevicePresenceNotifyMask,
                               (xEvent *) &dpn, 1);
 
diff --git a/xserver/Xi/exevents.c b/vcxsrv-code/xorg-server/Xi/exevents.c
index 94b9983..dca3894 100644
--- a/xserver/Xi/exevents.c
+++ b/vcxsrv-code/xorg-server/Xi/exevents.c
@@ -80,6 +80,8 @@ SOFTWARE.
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define XINPUT
 #endif
 
 #include "inputstr.h"
@@ -1085,7 +1087,7 @@ DeliverOneTouchEvent(ClientPtr client, DeviceIntPtr dev, TouchPointInfoPtr ti,
     err = EventToXI2(ev, &xi2);
     if (err != Success)
         FatalError("[Xi] %s: XI2 conversion failed in %s"
-                   " (%d)\n", dev->name, __func__, err);
+                   " (%d)\n", dev->name, __FUNCTION__, err);
 
     FixUpEventFromWindow(&ti->sprite, xi2, win, child, FALSE);
     filter = GetEventFilter(dev, xi2);
@@ -1721,7 +1723,7 @@ ProcessBarrierEvent(InternalEvent *e, DeviceIntPtr dev)
 
     rc = EventToXI2(e, &ev);
     if (rc != Success) {
-        ErrorF("[Xi] event conversion from %s failed with code %d\n", __func__, rc);
+        ErrorF("[Xi] event conversion from %s failed with code %d\n", __FUNCTION__, rc);
         return;
     }
 
@@ -1827,7 +1829,7 @@ ProcessDeviceEvent(InternalEvent *ev, DeviceIntPtr device)
     if (IsPointerDevice(device)) {
         kbd = GetMaster(device, KEYBOARD_OR_FLOAT);
         mouse = device;
-        if (!kbd->key)          /* can happen with floating SDs */
+        if (kbd && !kbd->key)          /* can happen with floating SDs */
             kbd = NULL;
     }
     else {
@@ -1857,6 +1859,8 @@ ProcessDeviceEvent(InternalEvent *ev, DeviceIntPtr device)
     case ET_KeyRelease:
     case ET_ProximityIn:
     case ET_ProximityOut:
+        if (!device->spriteInfo->sprite)
+          return;
         GetSpritePosition(device, &rootX, &rootY);
         event->root_x = rootX;
         event->root_y = rootY;
@@ -2820,6 +2824,10 @@ RecalculateDeviceDeliverableEvents(WindowPtr pWin)
     }
 }
 
+#ifdef _MSC_VER
+#pragma warning(disable:4715) /* Not all control paths return a value */
+#endif
+
 int
 InputClientGone(WindowPtr pWin, XID id)
 {
diff --git a/xserver/Xi/getbmap.c b/vcxsrv-code/xorg-server/Xi/getbmap.c
index ce3e9e6..b7d5f17 100644
--- a/xserver/Xi/getbmap.c
+++ b/vcxsrv-code/xorg-server/Xi/getbmap.c
@@ -92,13 +92,12 @@ ProcXGetDeviceButtonMapping(ClientPtr client)
     REQUEST(xGetDeviceButtonMappingReq);
     REQUEST_SIZE_MATCH(xGetDeviceButtonMappingReq);
 
-    rep = (xGetDeviceButtonMappingReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceButtonMapping,
-        .sequenceNumber = client->sequence,
-        .nElts = 0,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceButtonMapping;
+    rep.sequenceNumber = client->sequence;
+    rep.nElts = 0;
+    rep.length = 0;
 
     rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGetAttrAccess);
     if (rc != Success)
diff --git a/xserver/Xi/getdctl.c b/vcxsrv-code/xorg-server/Xi/getdctl.c
index 149f5e1..f3fa38c 100644
--- a/xserver/Xi/getdctl.c
+++ b/vcxsrv-code/xorg-server/Xi/getdctl.c
@@ -182,12 +182,11 @@ ProcXGetDeviceControl(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGetDeviceControlReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceControl,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceControl;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     switch (stuff->control) {
     case DEVICE_RESOLUTION:
diff --git a/xserver/Xi/getfctl.c b/vcxsrv-code/xorg-server/Xi/getfctl.c
index eea0113..437e064 100644
--- a/xserver/Xi/getfctl.c
+++ b/vcxsrv-code/xorg-server/Xi/getfctl.c
@@ -295,13 +295,12 @@ ProcXGetFeedbackControl(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGetFeedbackControlReply) {
-        .repType = X_Reply,
-        .RepType = X_GetFeedbackControl,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .num_feedbacks = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetFeedbackControl;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.num_feedbacks = 0;
 
     for (k = dev->kbdfeed; k; k = k->next) {
         rep.num_feedbacks++;
diff --git a/xserver/Xi/getfocus.c b/vcxsrv-code/xorg-server/Xi/getfocus.c
index cf8e024..5a116d9 100644
--- a/xserver/Xi/getfocus.c
+++ b/vcxsrv-code/xorg-server/Xi/getfocus.c
@@ -99,12 +99,11 @@ ProcXGetDeviceFocus(ClientPtr client)
     if (!dev->focus)
         return BadDevice;
 
-    rep = (xGetDeviceFocusReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceFocus,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceFocus;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     focus = dev->focus;
 
diff --git a/xserver/Xi/getkmap.c b/vcxsrv-code/xorg-server/Xi/getkmap.c
index c6db2ce..d02115a 100644
--- a/xserver/Xi/getkmap.c
+++ b/vcxsrv-code/xorg-server/Xi/getkmap.c
@@ -119,13 +119,13 @@ ProcXGetDeviceKeyMapping(ClientPtr client)
     if (!syms)
         return BadAlloc;
 
-    rep = (xGetDeviceKeyMappingReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceKeyMapping,
-        .sequenceNumber = client->sequence,
-        .keySymsPerKeyCode = syms->mapWidth,
-        .length = (syms->mapWidth * stuff->count) /* KeySyms are 4 bytes */
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceKeyMapping;
+    rep.sequenceNumber = client->sequence;
+    rep.keySymsPerKeyCode = syms->mapWidth;
+    rep.length = (syms->mapWidth * stuff->count); /* KeySyms are 4 bytes */
+
     WriteReplyToClient(client, sizeof(xGetDeviceKeyMappingReply), &rep);
 
     client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
diff --git a/xserver/Xi/getmmap.c b/vcxsrv-code/xorg-server/Xi/getmmap.c
index 19d8eb2..3d34cbd 100644
--- a/xserver/Xi/getmmap.c
+++ b/vcxsrv-code/xorg-server/Xi/getmmap.c
@@ -101,14 +101,13 @@ ProcXGetDeviceModifierMapping(ClientPtr client)
     if (ret != Success)
         return ret;
 
-    rep = (xGetDeviceModifierMappingReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceModifierMapping,
-        .sequenceNumber = client->sequence,
-        .numKeyPerModifier = max_keys_per_mod,
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceModifierMapping;
+    rep.sequenceNumber = client->sequence;
+    rep.numKeyPerModifier = max_keys_per_mod;
     /* length counts 4 byte quantities - there are 8 modifiers 1 byte big */
-        .length = max_keys_per_mod << 1
-    };
+    rep.length = max_keys_per_mod << 1;
 
     WriteReplyToClient(client, sizeof(xGetDeviceModifierMappingReply), &rep);
     WriteToClient(client, max_keys_per_mod * 8, modkeymap);
diff --git a/xserver/Xi/getprop.c b/vcxsrv-code/xorg-server/Xi/getprop.c
index b744f35..46316e0 100644
--- a/xserver/Xi/getprop.c
+++ b/vcxsrv-code/xorg-server/Xi/getprop.c
@@ -101,13 +101,12 @@ ProcXGetDeviceDontPropagateList(ClientPtr client)
     REQUEST(xGetDeviceDontPropagateListReq);
     REQUEST_SIZE_MATCH(xGetDeviceDontPropagateListReq);
 
-    rep = (xGetDeviceDontPropagateListReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceDontPropagateList,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .count = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceDontPropagateList;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.count = 0;
 
     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
     if (rc != Success)
diff --git a/xserver/Xi/getselev.c b/vcxsrv-code/xorg-server/Xi/getselev.c
index 0623c7a..c9065f9 100644
--- a/xserver/Xi/getselev.c
+++ b/vcxsrv-code/xorg-server/Xi/getselev.c
@@ -102,14 +102,13 @@ ProcXGetSelectedExtensionEvents(ClientPtr client)
     REQUEST(xGetSelectedExtensionEventsReq);
     REQUEST_SIZE_MATCH(xGetSelectedExtensionEventsReq);
 
-    rep = (xGetSelectedExtensionEventsReply) {
-        .repType = X_Reply,
-        .RepType = X_GetSelectedExtensionEvents,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .this_client_count = 0,
-        .all_clients_count = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetSelectedExtensionEvents;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.this_client_count = 0;
+    rep.all_clients_count = 0;
 
     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
     if (rc != Success)
diff --git a/xserver/Xi/getvers.c b/vcxsrv-code/xorg-server/Xi/getvers.c
index a56ff16..2de2167 100644
--- a/xserver/Xi/getvers.c
+++ b/vcxsrv-code/xorg-server/Xi/getvers.c
@@ -98,15 +98,14 @@ ProcXGetExtensionVersion(ClientPtr client)
                                         stuff->nbytes))
         return BadLength;
 
-    rep = (xGetExtensionVersionReply) {
-        .repType = X_Reply,
-        .RepType = X_GetExtensionVersion,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .major_version = XIVersion.major_version,
-        .minor_version = XIVersion.minor_version,
-        .present = TRUE
-    };
+    memset(&rep, 0, sizeof(xGetExtensionVersionReply));
+    rep.repType = X_Reply;
+    rep.RepType = X_GetExtensionVersion;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.major_version = XIVersion.major_version;
+    rep.minor_version = XIVersion.minor_version;
+    rep.present = TRUE;
 
     WriteReplyToClient(client, sizeof(xGetExtensionVersionReply), &rep);
 
diff --git a/xserver/Xi/grabdev.c b/vcxsrv-code/xorg-server/Xi/grabdev.c
index cb68cfa..900cf2b 100644
--- a/xserver/Xi/grabdev.c
+++ b/vcxsrv-code/xorg-server/Xi/grabdev.c
@@ -113,12 +113,11 @@ ProcXGrabDevice(ClientPtr client)
         bytes_to_int32(sizeof(xGrabDeviceReq)) + stuff->event_count)
         return BadLength;
 
-    rep = (xGrabDeviceReply) {
-        .repType = X_Reply,
-        .RepType = X_GrabDevice,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GrabDevice;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     rc = dixLookupDevice(&dev, stuff->deviceid, client, DixGrabAccess);
     if (rc != Success)
diff --git a/xserver/Xi/grabdevb.c b/vcxsrv-code/xorg-server/Xi/grabdevb.c
index a2f7eb3..0a64fc2 100644
--- a/xserver/Xi/grabdevb.c
+++ b/vcxsrv-code/xorg-server/Xi/grabdevb.c
@@ -137,14 +137,13 @@ ProcXGrabDeviceButton(ClientPtr client)
                                   X_GrabDeviceButton)) != Success)
         return ret;
 
-    param = (GrabParameters) {
-        .grabtype = XI,
-        .ownerEvents = stuff->ownerEvents,
-        .this_device_mode = stuff->this_device_mode,
-        .other_devices_mode = stuff->other_devices_mode,
-        .grabWindow = stuff->grabWindow,
-        .modifiers = stuff->modifiers
-    };
+    memset(&param, 0, sizeof(param));
+    param.grabtype = XI;
+    param.ownerEvents = stuff->ownerEvents;
+    param.this_device_mode = stuff->this_device_mode;
+    param.other_devices_mode = stuff->other_devices_mode;
+    param.grabWindow = stuff->grabWindow;
+    param.modifiers = stuff->modifiers;
     mask.xi = tmp[stuff->grabbed_device].mask;
 
     ret = GrabButton(client, dev, mdev, stuff->button, &param, XI, &mask);
diff --git a/xserver/Xi/grabdevk.c b/vcxsrv-code/xorg-server/Xi/grabdevk.c
index e856fa8..306e6fb 100644
--- a/xserver/Xi/grabdevk.c
+++ b/vcxsrv-code/xorg-server/Xi/grabdevk.c
@@ -135,14 +135,13 @@ ProcXGrabDeviceKey(ClientPtr client)
                                   X_GrabDeviceKey)) != Success)
         return ret;
 
-    param = (GrabParameters) {
-        .grabtype = XI,
-        .ownerEvents = stuff->ownerEvents,
-        .this_device_mode = stuff->this_device_mode,
-        .other_devices_mode = stuff->other_devices_mode,
-        .grabWindow = stuff->grabWindow,
-        .modifiers = stuff->modifiers
-    };
+    memset(&param, 0, sizeof(param));
+    param.grabtype = XI;
+    param.ownerEvents = stuff->ownerEvents;
+    param.this_device_mode = stuff->this_device_mode;
+    param.other_devices_mode = stuff->other_devices_mode;
+    param.grabWindow = stuff->grabWindow;
+    param.modifiers = stuff->modifiers;
     mask.xi = tmp[stuff->grabbed_device].mask;
 
     ret = GrabKey(client, dev, mdev, stuff->key, &param, XI, &mask);
diff --git a/xserver/Xi/gtmotion.c b/vcxsrv-code/xorg-server/Xi/gtmotion.c
index 7c66849..b1ce07d 100644
--- a/xserver/Xi/gtmotion.c
+++ b/vcxsrv-code/xorg-server/Xi/gtmotion.c
@@ -110,15 +110,15 @@ ProcXGetDeviceMotionEvents(ClientPtr client)
     if (dev->valuator->motionHintWindow)
         MaybeStopDeviceHint(dev, client);
     axes = v->numAxes;
-    rep = (xGetDeviceMotionEventsReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceMotionEvents,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .nEvents = 0,
-        .axes = axes,
-        .mode = Absolute        /* XXX we don't do relative at the moment */
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_GetDeviceMotionEvents;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.nEvents = 0;
+    rep.axes = axes;
+    rep.mode = Absolute;        /* XXX we don't do relative at the moment */
+    
     start = ClientTimeToServerTime(stuff->start);
     stop = ClientTimeToServerTime(stuff->stop);
     if (CompareTimeStamps(start, stop) == LATER ||
diff --git a/xserver/Xi/listdev.c b/vcxsrv-code/xorg-server/Xi/listdev.c
index c15e61b..ce62d0e 100644
--- a/xserver/Xi/listdev.c
+++ b/vcxsrv-code/xorg-server/Xi/listdev.c
@@ -342,12 +342,11 @@ ProcXListInputDevices(ClientPtr client)
 
     REQUEST_SIZE_MATCH(xListInputDevicesReq);
 
-    rep = (xListInputDevicesReply) {
-        .repType = X_Reply,
-        .RepType = X_ListInputDevices,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    memset(&rep, 0, sizeof(xListInputDevicesReply));
+    rep.repType = X_Reply;
+    rep.RepType = X_ListInputDevices;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     /* allocate space for saving skip value */
     skip = calloc(sizeof(Bool), inputInfo.numDevices);
diff --git a/xserver/Xi/opendev.c b/vcxsrv-code/xorg-server/Xi/opendev.c
index 3472c97..a32396d 100644
--- a/xserver/Xi/opendev.c
+++ b/vcxsrv-code/xorg-server/Xi/opendev.c
@@ -114,9 +114,6 @@ ProcXOpenDevice(ClientPtr client)
     if (IsMaster(dev))
         return BadDevice;
 
-    if (status != Success)
-        return status;
-
     if (dev->key != NULL) {
         evbase[j].class = KeyClass;
         evbase[j++].event_type_base = event_base[KeyClass];
@@ -144,13 +141,12 @@ ProcXOpenDevice(ClientPtr client)
     }
     evbase[j].class = OtherClass;
     evbase[j++].event_type_base = event_base[OtherClass];
-    rep = (xOpenDeviceReply) {
-        .repType = X_Reply,
-        .RepType = X_OpenDevice,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(j * sizeof(xInputClassInfo)),
-        .num_classes = j
-    };
+    memset(&rep, 0, sizeof(xOpenDeviceReply));
+    rep.repType = X_Reply;
+    rep.RepType = X_OpenDevice;
+    rep.sequenceNumber = client->sequence;
+    rep.length = bytes_to_int32(j * sizeof(xInputClassInfo));
+    rep.num_classes = j;
     WriteReplyToClient(client, sizeof(xOpenDeviceReply), &rep);
     WriteToClient(client, j * sizeof(xInputClassInfo), evbase);
     return Success;
diff --git a/xserver/Xi/queryst.c b/vcxsrv-code/xorg-server/Xi/queryst.c
index 6c9d666..49215d1 100644
--- a/xserver/Xi/queryst.c
+++ b/vcxsrv-code/xorg-server/Xi/queryst.c
@@ -158,13 +158,13 @@ ProcXQueryDeviceState(ClientPtr client)
         }
     }
 
-    rep = (xQueryDeviceStateReply) {
-        .repType = X_Reply,
-        .RepType = X_QueryDeviceState,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(total_length),
-        .num_classes = num_classes
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_QueryDeviceState;
+    rep.sequenceNumber = client->sequence;
+    rep.length = bytes_to_int32(total_length);
+    rep.num_classes = num_classes;
+
     WriteReplyToClient(client, sizeof(xQueryDeviceStateReply), &rep);
     if (total_length > 0)
         WriteToClient(client, total_length, savbuf);
diff --git a/xserver/Xi/setbmap.c b/vcxsrv-code/xorg-server/Xi/setbmap.c
index f94db86..82c6ef2 100644
--- a/xserver/Xi/setbmap.c
+++ b/vcxsrv-code/xorg-server/Xi/setbmap.c
@@ -100,13 +100,12 @@ ProcXSetDeviceButtonMapping(ClientPtr client)
     if (ret != Success)
         return ret;
 
-    rep = (xSetDeviceButtonMappingReply) {
-        .repType = X_Reply,
-        .RepType = X_SetDeviceButtonMapping,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .status = MappingSuccess
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_SetDeviceButtonMapping;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.status = MappingSuccess;
 
     ret =
         ApplyPointerMapping(dev, (CARD8 *) &stuff[1], stuff->map_length,
diff --git a/xserver/Xi/setdval.c b/vcxsrv-code/xorg-server/Xi/setdval.c
index e57cb25..1f039a9 100644
--- a/xserver/Xi/setdval.c
+++ b/vcxsrv-code/xorg-server/Xi/setdval.c
@@ -92,13 +92,12 @@ ProcXSetDeviceValuators(ClientPtr client)
     REQUEST(xSetDeviceValuatorsReq);
     REQUEST_AT_LEAST_SIZE(xSetDeviceValuatorsReq);
 
-    rep = (xSetDeviceValuatorsReply) {
-        .repType = X_Reply,
-        .RepType = X_SetDeviceValuators,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .status = Success
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_SetDeviceValuators;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.status = Success;
 
     if (stuff->length != bytes_to_int32(sizeof(xSetDeviceValuatorsReq)) +
         stuff->num_valuators)
diff --git a/xserver/Xi/setmmap.c b/vcxsrv-code/xorg-server/Xi/setmmap.c
index d60096a..a8d0ea1 100644
--- a/xserver/Xi/setmmap.c
+++ b/vcxsrv-code/xorg-server/Xi/setmmap.c
@@ -98,12 +98,11 @@ ProcXSetDeviceModifierMapping(ClientPtr client)
         (stuff->numKeyPerModifier << 1))
         return BadLength;
 
-    rep = (xSetDeviceModifierMappingReply) {
-        .repType = X_Reply,
-        .RepType = X_SetDeviceModifierMapping,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_SetDeviceModifierMapping;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     ret = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);
     if (ret != Success)
diff --git a/xserver/Xi/setmode.c b/vcxsrv-code/xorg-server/Xi/setmode.c
index e7e12d4..a736df1 100644
--- a/xserver/Xi/setmode.c
+++ b/vcxsrv-code/xorg-server/Xi/setmode.c
@@ -92,12 +92,11 @@ ProcXSetDeviceMode(ClientPtr client)
     REQUEST(xSetDeviceModeReq);
     REQUEST_SIZE_MATCH(xSetDeviceModeReq);
 
-    rep = (xSetDeviceModeReply) {
-        .repType = X_Reply,
-        .RepType = X_SetDeviceMode,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_SetDeviceMode;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     rc = dixLookupDevice(&dev, stuff->deviceid, client, DixSetAttrAccess);
     if (rc != Success)
diff --git a/xserver/Xi/xibarriers.c b/vcxsrv-code/xorg-server/Xi/xibarriers.c
index 1926762..81c09c8 100644
--- a/xserver/Xi/xibarriers.c
+++ b/vcxsrv-code/xorg-server/Xi/xibarriers.c
@@ -398,19 +398,18 @@ input_constrain_cursor(DeviceIntPtr dev, ScreenPtr screen,
     struct PointerBarrier *nearest = NULL;
     PointerBarrierClientPtr c;
     Time ms = GetTimeInMillis();
-    BarrierEvent ev = {
-        .header = ET_Internal,
-        .type = 0,
-        .length = sizeof (BarrierEvent),
-        .time = ms,
-        .deviceid = dev->id,
-        .sourceid = dev->id,
-        .dx = dest_x - current_x,
-        .dy = dest_y - current_y,
-        .root = screen->root->drawable.id,
-    };
     InternalEvent *barrier_events = events;
     DeviceIntPtr master;
+    BarrierEvent ev;
+    ev.header = ET_Internal;
+    ev.type = 0;
+    ev.length = sizeof (BarrierEvent);
+    ev.time = ms;
+    ev.deviceid = dev->id;
+    ev.sourceid = dev->id;
+    ev.dx = dest_x - current_x;
+    ev.dy = dest_y - current_y;
+    ev.root = screen->root->drawable.id;
 
     if (nevents)
         *nevents = 0;
@@ -655,24 +654,24 @@ BarrierFreeBarrier(void *data, XID id)
     for (dev = inputInfo.devices; dev; dev = dev->next) {
         struct PointerBarrierDevice *pbd;
         int root_x, root_y;
-        BarrierEvent ev = {
-            .header = ET_Internal,
-            .type = ET_BarrierLeave,
-            .length = sizeof (BarrierEvent),
-            .time = ms,
-            /* .deviceid */
-            .sourceid = 0,
-            .barrierid = c->id,
-            .window = c->window,
-            .root = screen->root->drawable.id,
-            .dx = 0,
-            .dy = 0,
-            /* .root_x */
-            /* .root_y */
-            /* .dt */
-            /* .event_id */
-            .flags = XIBarrierPointerReleased,
-        };
+        BarrierEvent ev;
+        ev.header = ET_Internal;
+        ev.type = ET_BarrierLeave;
+        ev.length = sizeof (BarrierEvent);
+        ev.time = ms;
+        /* .deviceid */
+        ev.sourceid = 0;
+        ev.barrierid = c->id;
+        ev.window = c->window;
+        ev.root = screen->root->drawable.id;
+        ev.dx = 0;
+        ev.dy = 0;
+        /* .root_x */
+        /* .root_y */
+        /* .dt */
+        /* .event_id */
+        ev.flags = XIBarrierPointerReleased;
+
 
 
         if (dev->type != MASTER_POINTER)
@@ -740,22 +739,22 @@ static void remove_master_func(void *res, XID id, void *devid)
     pbd = GetBarrierDevice(barrier, *deviceid);
 
     if (pbd->hit) {
-        BarrierEvent ev = {
-            .header = ET_Internal,
-            .type =ET_BarrierLeave,
-            .length = sizeof (BarrierEvent),
-            .time = ms,
-            .deviceid = *deviceid,
-            .sourceid = 0,
-            .dx = 0,
-            .dy = 0,
-            .root = barrier->screen->root->drawable.id,
-            .window = barrier->window,
-            .dt = ms - pbd->last_timestamp,
-            .flags = XIBarrierPointerReleased,
-            .event_id = pbd->barrier_event_id,
-            .barrierid = barrier->id,
-        };
+        BarrierEvent ev;
+        ev.header = ET_Internal;
+        ev.type =ET_BarrierLeave;
+        ev.length = sizeof (BarrierEvent);
+        ev.time = ms;
+        ev.deviceid = *deviceid;
+        ev.sourceid = 0;
+        ev.dx = 0;
+        ev.dy = 0;
+        ev.root = barrier->screen->root->drawable.id;
+        ev.window = barrier->window;
+        ev.dt = ms - pbd->last_timestamp;
+        ev.flags = XIBarrierPointerReleased;
+        ev.event_id = pbd->barrier_event_id;
+        ev.barrierid = barrier->id;
+
 
         mieqEnqueue(dev, (InternalEvent *) &ev);
     }
diff --git a/xserver/Xi/xigetclientpointer.c b/vcxsrv-code/xorg-server/Xi/xigetclientpointer.c
index c3d494d..0aa68c8 100644
--- a/xserver/Xi/xigetclientpointer.c
+++ b/vcxsrv-code/xorg-server/Xi/xigetclientpointer.c
@@ -76,14 +76,13 @@ ProcXIGetClientPointer(ClientPtr client)
     else
         winclient = client;
 
-    rep = (xXIGetClientPointerReply) {
-        .repType = X_Reply,
-        .RepType = X_XIGetClientPointer,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .set = (winclient->clientPtr != NULL),
-        .deviceid = (winclient->clientPtr) ? winclient->clientPtr->id : 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_XIGetClientPointer;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.set = (winclient->clientPtr != NULL);
+    rep.deviceid = (winclient->clientPtr) ? winclient->clientPtr->id : 0;
 
     WriteReplyToClient(client, sizeof(xXIGetClientPointerReply), &rep);
     return Success;
diff --git a/xserver/Xi/xigrabdev.c b/vcxsrv-code/xorg-server/Xi/xigrabdev.c
index cf3ee7b..91b4ff5 100644
--- a/xserver/Xi/xigrabdev.c
+++ b/vcxsrv-code/xorg-server/Xi/xigrabdev.c
@@ -120,13 +120,12 @@ ProcXIGrabDevice(ClientPtr client)
     if (ret != Success)
         return ret;
 
-    rep = (xXIGrabDeviceReply) {
-        .repType = X_Reply,
-        .RepType = X_XIGrabDevice,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .status = status
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_XIGrabDevice;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.status = status;
 
     WriteReplyToClient(client, sizeof(rep), &rep);
     return ret;
diff --git a/xserver/Xi/xipassivegrab.c b/vcxsrv-code/xorg-server/Xi/xipassivegrab.c
index 2769fb7..0eed2d7 100644
--- a/xserver/Xi/xipassivegrab.c
+++ b/vcxsrv-code/xorg-server/Xi/xipassivegrab.c
@@ -79,13 +79,7 @@ int
 ProcXIPassiveGrabDevice(ClientPtr client)
 {
     DeviceIntPtr dev, mod_dev;
-    xXIPassiveGrabDeviceReply rep = {
-        .repType = X_Reply,
-        .RepType = X_XIPassiveGrabDevice,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .num_modifiers = 0
-    };
+    xXIPassiveGrabDeviceReply rep;
     int i, ret = Success;
     uint32_t *modifiers;
     xXIGrabModifierInfo *modifiers_failed = NULL;
@@ -98,6 +92,12 @@ ProcXIPassiveGrabDevice(ClientPtr client)
     REQUEST_FIXED_SIZE(xXIPassiveGrabDeviceReq,
         ((uint32_t) stuff->mask_len + stuff->num_modifiers) * 4);
 
+    rep.repType = X_Reply;
+    rep.RepType = X_XIPassiveGrabDevice;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.num_modifiers = 0;
+
     if (stuff->deviceid == XIAllDevices)
         dev = inputInfo.all_devices;
     else if (stuff->deviceid == XIAllMasterDevices)
diff --git a/xserver/Xi/xiproperty.c b/vcxsrv-code/xorg-server/Xi/xiproperty.c
index a36f7d6..9de4429 100644
--- a/xserver/Xi/xiproperty.c
+++ b/vcxsrv-code/xorg-server/Xi/xiproperty.c
@@ -185,23 +185,23 @@ static void
 send_property_event(DeviceIntPtr dev, Atom property, int what)
 {
     int state = (what == XIPropertyDeleted) ? PropertyDelete : PropertyNewValue;
-    devicePropertyNotify event = {
-        .type = DevicePropertyNotify,
-        .deviceid = dev->id,
-        .state = state,
-        .atom = property,
-        .time = currentTime.milliseconds
-    };
-    xXIPropertyEvent xi2 = {
-        .type = GenericEvent,
-        .extension = IReqCode,
-        .length = 0,
-        .evtype = XI_PropertyEvent,
-        .deviceid = dev->id,
-        .time = currentTime.milliseconds,
-        .property = property,
-        .what = what
-    };
+    xXIPropertyEvent xi2; devicePropertyNotify event;
+    event.type = DevicePropertyNotify;
+    event.deviceid = dev->id;
+    event.state = state;
+    event.atom = property;
+    event.time = currentTime.milliseconds;
+
+
+    xi2.type = GenericEvent;
+    xi2.extension = IReqCode;
+    xi2.length = 0;
+    xi2.evtype = XI_PropertyEvent;
+    xi2.deviceid = dev->id;
+    xi2.time = currentTime.milliseconds;
+    xi2.property = property;
+    xi2.what = what;
+    
 
     SendEventToAllWindows(dev, DevicePropertyNotifyMask, (xEvent *) &event, 1);
 
@@ -867,13 +867,12 @@ ProcXListDeviceProperties(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xListDevicePropertiesReply) {
-        .repType = X_Reply,
-        .RepType = X_ListDeviceProperties,
-        .sequenceNumber = client->sequence,
-        .length = natoms,
-        .nAtoms = natoms
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_ListDeviceProperties;
+    rep.sequenceNumber = client->sequence;
+    rep.length = natoms;
+    rep.nAtoms = natoms;
 
     WriteReplyToClient(client, sizeof(xListDevicePropertiesReply), &rep);
     if (natoms) {
@@ -963,17 +962,16 @@ ProcXGetDeviceProperty(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    reply = (xGetDevicePropertyReply) {
-        .repType = X_Reply,
-        .RepType = X_GetDeviceProperty,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(length),
-        .propertyType = type,
-        .bytesAfter = bytes_after,
-        .nItems = nitems,
-        .format = format,
-        .deviceid = dev->id
-    };
+
+    reply.repType = X_Reply;
+    reply.RepType = X_GetDeviceProperty;
+    reply.sequenceNumber = client->sequence;
+    reply.length = bytes_to_int32(length);
+    reply.propertyType = type;
+    reply.bytesAfter = bytes_after;
+    reply.nItems = nitems;
+    reply.format = format;
+    reply.deviceid = dev->id;
 
     if (stuff->delete && (reply.bytesAfter == 0))
         send_property_event(dev, stuff->property, XIPropertyDeleted);
@@ -1106,13 +1104,12 @@ ProcXIListProperties(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xXIListPropertiesReply) {
-        .repType = X_Reply,
-        .RepType = X_XIListProperties,
-        .sequenceNumber = client->sequence,
-        .length = natoms,
-        .num_properties = natoms
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_XIListProperties;
+    rep.sequenceNumber = client->sequence;
+    rep.length = natoms;
+    rep.num_properties = natoms;
 
     WriteReplyToClient(client, sizeof(xXIListPropertiesReply), &rep);
     if (natoms) {
@@ -1202,16 +1199,15 @@ ProcXIGetProperty(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    reply = (xXIGetPropertyReply) {
-        .repType = X_Reply,
-        .RepType = X_XIGetProperty,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(length),
-        .type = type,
-        .bytes_after = bytes_after,
-        .num_items = nitems,
-        .format = format
-    };
+
+    reply.repType = X_Reply;
+    reply.RepType = X_XIGetProperty;
+    reply.sequenceNumber = client->sequence;
+    reply.length = bytes_to_int32(length);
+    reply.type = type;
+    reply.bytes_after = bytes_after;
+    reply.num_items = nitems;
+    reply.format = format;
 
     if (length && stuff->delete && (reply.bytes_after == 0))
         send_property_event(dev, stuff->property, XIPropertyDeleted);
diff --git a/xserver/Xi/xiquerydevice.c b/vcxsrv-code/xorg-server/Xi/xiquerydevice.c
index e4731a1..6fd189b 100644
--- a/xserver/Xi/xiquerydevice.c
+++ b/vcxsrv-code/xorg-server/Xi/xiquerydevice.c
@@ -111,13 +111,12 @@ ProcXIQueryDevice(ClientPtr client)
         return BadAlloc;
     }
 
-    rep = (xXIQueryDeviceReply) {
-        .repType = X_Reply,
-        .RepType = X_XIQueryDevice,
-        .sequenceNumber = client->sequence,
-        .length = len / 4,
-        .num_devices = 0
-    };
+    memset(&rep, 0, sizeof(xXIQueryDeviceReply));
+    rep.repType = X_Reply;
+    rep.RepType = X_XIQueryDevice;
+    rep.sequenceNumber = client->sequence;
+    rep.length = len / 4;
+    rep.num_devices = 0;
 
     ptr = info;
     if (dev) {
diff --git a/xserver/Xi/xiquerypointer.c b/vcxsrv-code/xorg-server/Xi/xiquerypointer.c
index 5b77b1a..22732e3 100644
--- a/xserver/Xi/xiquerypointer.c
+++ b/vcxsrv-code/xorg-server/Xi/xiquerypointer.c
@@ -124,16 +124,15 @@ ProcXIQueryPointer(ClientPtr client)
 
     pSprite = pDev->spriteInfo->sprite;
 
-    rep = (xXIQueryPointerReply) {
-        .repType = X_Reply,
-        .RepType = X_XIQueryPointer,
-        .sequenceNumber = client->sequence,
-        .length = 6,
-        .root = (GetCurrentRootWindow(pDev))->drawable.id,
-        .root_x = double_to_fp1616(pSprite->hot.x),
-        .root_y = double_to_fp1616(pSprite->hot.y),
-        .child = None
-    };
+    memset(&rep, 0, sizeof(rep));
+    rep.repType = X_Reply;
+    rep.RepType = X_XIQueryPointer;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 6;
+    rep.root = (GetCurrentRootWindow(pDev))->drawable.id;
+    rep.root_x = double_to_fp1616(pSprite->hot.x);
+    rep.root_y = double_to_fp1616(pSprite->hot.y);
+    rep.child = None;
 
     if (kbd) {
         state = &kbd->key->xkbInfo->state;
diff --git a/xserver/Xi/xiqueryversion.c b/vcxsrv-code/xorg-server/Xi/xiqueryversion.c
index 111f1d6..1f04dcf 100644
--- a/xserver/Xi/xiqueryversion.c
+++ b/vcxsrv-code/xorg-server/Xi/xiqueryversion.c
@@ -114,14 +114,13 @@ ProcXIQueryVersion(ClientPtr client)
         pXIClient->minor_version = minor;
     }
 
-    rep = (xXIQueryVersionReply) {
-        .repType = X_Reply,
-        .RepType = X_XIQueryVersion,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .major_version = major,
-        .minor_version = minor
-    };
+    memset(&rep, 0, sizeof(xXIQueryVersionReply));
+    rep.repType = X_Reply;
+    rep.RepType = X_XIQueryVersion;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.major_version = major;
+    rep.minor_version = minor;
 
     WriteReplyToClient(client, sizeof(xXIQueryVersionReply), &rep);
 
diff --git a/xserver/Xi/xiselectev.c b/vcxsrv-code/xorg-server/Xi/xiselectev.c
index edcb8a0..d7875f8 100644
--- a/xserver/Xi/xiselectev.c
+++ b/vcxsrv-code/xorg-server/Xi/xiselectev.c
@@ -357,13 +357,12 @@ ProcXIGetSelectedEvents(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    reply = (xXIGetSelectedEventsReply) {
-        .repType = X_Reply,
-        .RepType = X_XIGetSelectedEvents,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .num_masks = 0
-    };
+
+    reply.repType = X_Reply;
+    reply.RepType = X_XIGetSelectedEvents;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    reply.num_masks = 0;
 
     masks = wOtherInputMasks(win);
     if (masks) {
diff --git a/xserver/Xi/xisetdevfocus.c b/vcxsrv-code/xorg-server/Xi/xisetdevfocus.c
index 2ed445c..ebe8f74 100644
--- a/xserver/Xi/xisetdevfocus.c
+++ b/vcxsrv-code/xorg-server/Xi/xisetdevfocus.c
@@ -101,12 +101,11 @@ ProcXIGetFocus(ClientPtr client)
     if (!dev->focus)
         return BadDevice;
 
-    rep = (xXIGetFocusReply) {
-        .repType = X_Reply,
-        .RepType = X_XIGetFocus,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.repType = X_Reply;
+    rep.RepType = X_XIGetFocus;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     if (dev->focus->win == NoneWin)
         rep.focus = None;
diff --git a/xserver/composite/compalloc.c b/vcxsrv-code/xorg-server/composite/compalloc.c
index eaabf0d..1e25c71 100644
--- a/xserver/composite/compalloc.c
+++ b/vcxsrv-code/xorg-server/composite/compalloc.c
@@ -170,7 +170,7 @@ compRedirectWindow(ClientPtr pClient, WindowPtr pWin, int update)
      * Now make sure there's a per-window structure to hang this from
      */
     if (!cw) {
-        cw = malloc(sizeof(CompWindowRec));
+        cw = calloc(1,sizeof(CompWindowRec));
         if (!cw) {
             free(ccw);
             return BadAlloc;
diff --git a/xserver/composite/compext.c b/vcxsrv-code/xorg-server/composite/compext.c
index 34a2a53..ba04425 100644
--- a/xserver/composite/compext.c
+++ b/vcxsrv-code/xorg-server/composite/compext.c
@@ -97,15 +97,14 @@ static int
 ProcCompositeQueryVersion(ClientPtr client)
 {
     CompositeClientPtr pCompositeClient = GetCompositeClient(client);
-    xCompositeQueryVersionReply rep = {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    xCompositeQueryVersionReply rep;
 
     REQUEST(xCompositeQueryVersionReq);
 
     REQUEST_SIZE_MATCH(xCompositeQueryVersionReq);
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
     if (stuff->majorVersion < SERVER_COMPOSITE_MAJOR_VERSION) {
         rep.majorVersion = stuff->majorVersion;
         rep.minorVersion = stuff->minorVersion;
@@ -313,12 +312,10 @@ ProcCompositeGetOverlayWindow(ClientPtr client)
         return rc;
     }
 
-    rep = (xCompositeGetOverlayWindowReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .overlayWin = cs->pOverlayWin->drawable.id
-    };
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.overlayWin = cs->pOverlayWin->drawable.id;
 
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
@@ -847,12 +844,10 @@ PanoramiXCompositeGetOverlayWindow(ClientPtr client)
 
     cs = GetCompScreen(screenInfo.screens[0]);
 
-    rep = (xCompositeGetOverlayWindowReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .overlayWin = cs->pOverlayWin->drawable.id
-    };
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.overlayWin = cs->pOverlayWin->drawable.id;
 
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
diff --git a/xserver/composite/compoverlay.c b/vcxsrv-code/xorg-server/composite/compoverlay.c
index 20c860d..2fce26d 100644
--- a/xserver/composite/compoverlay.c
+++ b/vcxsrv-code/xorg-server/composite/compoverlay.c
@@ -45,6 +45,10 @@
 #include <dix-config.h>
 #endif
 
+#ifdef CreateWindow
+#undef CreateWindow
+#endif
+
 #include "compint.h"
 #include "xace.h"
 
diff --git a/xserver/damageext/damageext.c b/vcxsrv-code/xorg-server/damageext/damageext.c
index c8194da..239ef6a 100644
--- a/xserver/damageext/damageext.c
+++ b/vcxsrv-code/xorg-server/damageext/damageext.c
@@ -98,17 +98,17 @@ DamageExtNotify(DamageExtPtr pDamageExt, BoxPtr pBoxes, int nBoxes)
     damageGetGeometry(pDrawable, &x, &y, &w, &h);
 
     UpdateCurrentTimeIf();
-    ev = (xDamageNotifyEvent) {
-        .type = DamageEventBase + XDamageNotify,
-        .level = pDamageExt->level,
-        .drawable = pDamageExt->drawable,
-        .damage = pDamageExt->id,
-        .timestamp = currentTime.milliseconds,
-        .geometry.x = x,
-        .geometry.y = y,
-        .geometry.width = w,
-        .geometry.height = h
-    };
+
+    ev.type = DamageEventBase + XDamageNotify;
+    ev.level = pDamageExt->level;
+    ev.drawable = pDamageExt->drawable;
+    ev.damage = pDamageExt->id;
+    ev.timestamp = currentTime.milliseconds;
+    ev.geometry.x = x;
+    ev.geometry.y = y;
+    ev.geometry.width = w;
+    ev.geometry.height = h;
+
     if (pBoxes) {
         for (i = 0; i < nBoxes; i++) {
             ev.level = pDamageExt->level;
@@ -177,16 +177,14 @@ static int
 ProcDamageQueryVersion(ClientPtr client)
 {
     DamageClientPtr pDamageClient = GetDamageClient(client);
-    xDamageQueryVersionReply rep = {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    xDamageQueryVersionReply rep;
 
     REQUEST(xDamageQueryVersionReq);
 
     REQUEST_SIZE_MATCH(xDamageQueryVersionReq);
-
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
     if (stuff->majorVersion < SERVER_DAMAGE_MAJOR_VERSION) {
         rep.majorVersion = stuff->majorVersion;
         rep.minorVersion = stuff->minorVersion;
diff --git a/xserver/dix/colormap.c b/vcxsrv-code/xorg-server/dix/colormap.c
index 7a00d14..2f0fb79 100644
--- a/xserver/dix/colormap.c
+++ b/vcxsrv-code/xorg-server/dix/colormap.c
@@ -64,9 +64,14 @@ SOFTWARE.
 #include "privates.h"
 #include "xace.h"
 
+#ifdef _MSC_VER
+#define UpdateColors thisUpdateColors
+#endif
+
 typedef int (*ColorCompareProcPtr) (EntryPtr /*pent */ ,
                                     xrgb * /*prgb */ );
 
+
 static Pixel FindBestPixel(EntryPtr /*pentFirst */ ,
                            int /*size */ ,
                            xrgb * /*prgb */ ,
@@ -455,12 +460,12 @@ TellNoMap(WindowPtr pwin, Colormap * pmid)
 {
     if (wColormap(pwin) == *pmid) {
         /* This should be call to DeliverEvent */
-        xEvent xE = {
-            .u.colormap.window = pwin->drawable.id,
-            .u.colormap.colormap = None,
-            .u.colormap.new = TRUE,
-            .u.colormap.state = ColormapUninstalled
-        };
+        xEvent xE;
+        xE.u.colormap.window = pwin->drawable.id;
+        xE.u.colormap.colormap = None;
+        xE.u.colormap.new = TRUE;
+        xE.u.colormap.state = ColormapUninstalled;
+
         xE.u.u.type = ColormapNotify;
 #ifdef PANORAMIX
         if (noPanoramiXExtension || !pwin->drawable.pScreen->myNum)
@@ -487,12 +492,12 @@ TellLostMap(WindowPtr pwin, void *value)
 #endif
     if (wColormap(pwin) == *pmid) {
         /* This should be call to DeliverEvent */
-        xEvent xE = {
-            .u.colormap.window = pwin->drawable.id,
-            .u.colormap.colormap = *pmid,
-            .u.colormap.new = FALSE,
-            .u.colormap.state = ColormapUninstalled
-        };
+        xEvent xE;
+        xE.u.colormap.window = pwin->drawable.id;
+        xE.u.colormap.colormap = *pmid;
+        xE.u.colormap.new = FALSE;
+        xE.u.colormap.state = ColormapUninstalled;
+
         xE.u.u.type = ColormapNotify;
         DeliverEvents(pwin, &xE, 1, (WindowPtr) NULL);
     }
@@ -512,12 +517,12 @@ TellGainedMap(WindowPtr pwin, void *value)
 #endif
     if (wColormap(pwin) == *pmid) {
         /* This should be call to DeliverEvent */
-        xEvent xE = {
-            .u.colormap.window = pwin->drawable.id,
-            .u.colormap.colormap = *pmid,
-            .u.colormap.new = FALSE,
-            .u.colormap.state = ColormapInstalled
-        };
+        xEvent xE;
+        xE.u.colormap.window = pwin->drawable.id;
+        xE.u.colormap.colormap = *pmid;
+        xE.u.colormap.new = FALSE;
+        xE.u.colormap.state = ColormapInstalled;
+
         xE.u.u.type = ColormapNotify;
         DeliverEvents(pwin, &xE, 1, (WindowPtr) NULL);
     }
diff --git a/xserver/dix/devices.c b/vcxsrv-code/xorg-server/dix/devices.c
index 5bf956e..19c1f47 100644
--- a/xserver/dix/devices.c
+++ b/vcxsrv-code/xorg-server/dix/devices.c
@@ -332,7 +332,7 @@ AddInputDevice(ClientPtr client, DeviceProc deviceProc, Bool autoStart)
 void
 SendDevicePresenceEvent(int deviceid, int type)
 {
-    DeviceIntRec dummyDev = { .id =  XIAllDevices };
+    DeviceIntRec dummyDev;
     devicePresenceNotify ev;
 
     UpdateCurrentTimeIf();
@@ -341,6 +341,8 @@ SendDevicePresenceEvent(int deviceid, int type)
     ev.devchange = type;
     ev.deviceid = deviceid;
 
+    memset(&dummyDev, 0, sizeof(DeviceIntRec));
+    dummyDev.id = XIAllDevices;
     SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                           (xEvent *) &ev, 1);
 }
@@ -1004,7 +1006,7 @@ CloseDevice(DeviceIntPtr dev)
     if (dev->deviceGrab.grab)
         FreeGrab(dev->deviceGrab.grab);
     free(dev->deviceGrab.sync.event);
-    free(dev->config_info);     /* Allocated in xf86ActivateDevice. */
+    if (dev->config_info) free(dev->config_info);     /* Allocated in xf86ActivateDevice. */
     free(dev->last.scroll);
     for (j = 0; j < dev->last.num_touches; j++)
         free(dev->last.touches[j].valuators);
@@ -1062,6 +1064,10 @@ CloseDownDevices(void)
     for (dev = inputInfo.devices; dev; dev = dev->next) {
         if (!IsMaster(dev) && !IsFloating(dev))
             dev->master = NULL;
+        /* Initialise the sprite and paired members of all devices
+           to avoid crashes in CloseDevice later */
+        dev->spriteInfo->sprite=NULL;
+        dev->spriteInfo->paired=NULL;
     }
 
     CloseDeviceList(&inputInfo.devices);
@@ -1731,11 +1737,10 @@ ProcSetModifierMapping(ClientPtr client)
                             bytes_to_int32(sizeof(xSetModifierMappingReq))))
         return BadLength;
 
-    rep = (xSetModifierMappingReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     rc = change_modmap(client, PickKeyboard(client), (KeyCode *) &stuff[1],
                        stuff->numKeyPerModifier);
@@ -1762,13 +1767,12 @@ ProcGetModifierMapping(ClientPtr client)
     generate_modkeymap(client, PickKeyboard(client), &modkeymap,
                        &max_keys_per_mod);
 
-    rep = (xGetModifierMappingReply) {
-        .type = X_Reply,
-        .numKeyPerModifier = max_keys_per_mod,
-        .sequenceNumber = client->sequence,
+    memset(&rep, 0, sizeof(xGetModifierMappingReply));
+    rep.type = X_Reply;
+    rep.numKeyPerModifier = max_keys_per_mod;
+    rep.sequenceNumber = client->sequence;
     /* length counts 4 byte quantities - there are 8 modifiers 1 byte big */
-        .length = max_keys_per_mod << 1
-    };
+    rep.length = max_keys_per_mod << 1;
 
     WriteReplyToClient(client, sizeof(xGetModifierMappingReply), &rep);
     WriteToClient(client, max_keys_per_mod * 8, modkeymap);
@@ -1853,12 +1857,12 @@ ProcSetPointerMapping(ClientPtr client)
         bytes_to_int32(sizeof(xSetPointerMappingReq) + stuff->nElts))
         return BadLength;
 
-    rep = (xSetPointerMappingReply) {
-        .type = X_Reply,
-        .success = MappingSuccess,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.type = X_Reply;
+    rep.success = MappingSuccess;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    
     map = (BYTE *) &stuff[1];
 
     /* So we're bounded here by the number of core buttons.  This check
@@ -1927,13 +1931,13 @@ ProcGetKeyboardMapping(ClientPtr client)
     if (!syms)
         return BadAlloc;
 
-    rep = (xGetKeyboardMappingReply) {
-        .type = X_Reply,
-        .keySymsPerKeyCode = syms->mapWidth,
-        .sequenceNumber = client->sequence,
-        /* length is a count of 4 byte quantities and KeySyms are 4 bytes */
-        .length = syms->mapWidth * stuff->count
-    };
+    memset(&rep, 0, sizeof(xGetKeyboardMappingReply));
+    rep.type = X_Reply;
+    rep.keySymsPerKeyCode = syms->mapWidth;
+    rep.sequenceNumber = client->sequence;
+    /* length is a count of 4 byte quantities and KeySyms are 4 bytes */
+    rep.length = syms->mapWidth * stuff->count;
+
     WriteReplyToClient(client, sizeof(xGetKeyboardMappingReply), &rep);
     client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
     WriteSwappedDataToClient(client,
@@ -1965,12 +1969,12 @@ ProcGetPointerMapping(ClientPtr client)
         return rc;
 
     nElts = (butc) ? butc->numButtons : 0;
-    rep = (xGetPointerMappingReply) {
-        .type = X_Reply,
-        .nElts = nElts,
-        .sequenceNumber = client->sequence,
-        .length = ((unsigned) nElts + (4 - 1)) / 4
-    };
+
+    rep.type = X_Reply;
+    rep.nElts = nElts;
+    rep.sequenceNumber = client->sequence;
+    rep.length = ((unsigned) nElts + (4 - 1)) / 4;
+
     WriteReplyToClient(client, sizeof(xGetPointerMappingReply), &rep);
     if (butc)
         WriteToClient(client, nElts, &butc->map[1]);
@@ -2017,7 +2021,7 @@ DoChangeKeyboardControl(ClientPtr client, DeviceIntPtr keybd, XID *vlist,
         vmask &= ~index2;
         switch (index2) {
         case KBKeyClickPercent:
-            t = (INT8) *vlist;
+            t = *vlist;
             vlist++;
             if (t == -1) {
                 t = defaultKeyboardControl.click;
@@ -2219,17 +2223,17 @@ ProcGetKeyboardControl(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGetKeyboardControlReply) {
-        .type = X_Reply,
-        .globalAutoRepeat = ctrl->autoRepeat,
-        .sequenceNumber = client->sequence,
-        .length = 5,
-        .ledMask = ctrl->leds,
-        .keyClickPercent = ctrl->click,
-        .bellPercent = ctrl->bell,
-        .bellPitch = ctrl->bell_pitch,
-        .bellDuration = ctrl->bell_duration
-    };
+
+    rep.type = X_Reply;
+    rep.globalAutoRepeat = ctrl->autoRepeat;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 5;
+    rep.ledMask = ctrl->leds;
+    rep.keyClickPercent = ctrl->click;
+    rep.bellPercent = ctrl->bell;
+    rep.bellPitch = ctrl->bell_pitch;
+    rep.bellDuration = ctrl->bell_duration;
+    
     for (i = 0; i < 32; i++)
         rep.map[i] = ctrl->autoRepeats[i];
     WriteReplyToClient(client, sizeof(xGetKeyboardControlReply), &rep);
@@ -2372,14 +2376,14 @@ ProcGetPointerControl(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGetPointerControlReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .accelNumerator = ctrl->num,
-        .accelDenominator = ctrl->den,
-        .threshold = ctrl->threshold
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.accelNumerator = ctrl->num;
+    rep.accelDenominator = ctrl->den;
+    rep.threshold = ctrl->threshold;
+    
     WriteReplyToClient(client, sizeof(xGenericReply), &rep);
     return Success;
 }
@@ -2424,10 +2428,10 @@ ProcGetMotionEvents(ClientPtr client)
     UpdateCurrentTimeIf();
     if (mouse->valuator->motionHintWindow)
         MaybeStopHint(mouse, client);
-    rep = (xGetMotionEventsReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    
     nEvents = 0;
     start = ClientTimeToServerTime(stuff->start);
     stop = ClientTimeToServerTime(stuff->stop);
@@ -2475,11 +2479,10 @@ ProcQueryKeymap(ClientPtr client)
     CARD8 *down = keybd->key->down;
 
     REQUEST_SIZE_MATCH(xReq);
-    rep = (xQueryKeymapReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 2
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 2;
 
     rc = XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess);
     /* If rc is Success, we're allowed to copy out the keymap.
@@ -2525,14 +2528,13 @@ RecalculateMasterButtons(DeviceIntPtr slave)
 
     if (master->button && master->button->numButtons != maxbuttons) {
         int i;
-        DeviceChangedEvent event = {
-            .header = ET_Internal,
-            .type = ET_DeviceChanged,
-            .time = GetTimeInMillis(),
-            .deviceid = master->id,
-            .flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE,
-            .buttons.num_buttons = maxbuttons
-        };
+        DeviceChangedEvent event; memset(&event, 0, sizeof(event));
+        event.header = ET_Internal;
+        event.type = ET_DeviceChanged;
+        event.time = GetTimeInMillis();
+        event.deviceid = master->id;
+        event.flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE;
+        event.buttons.num_buttons = maxbuttons;
 
         master->button->numButtons = maxbuttons;
 
diff --git a/xserver/dix/dispatch.c b/vcxsrv-code/xorg-server/dix/dispatch.c
index 4602961..df536c5 100644
--- a/xserver/dix/dispatch.c
+++ b/vcxsrv-code/xorg-server/dix/dispatch.c
@@ -101,6 +101,10 @@ Equipment Corporation.
 #include <version-config.h>
 #endif
 
+#ifdef CreateWindow
+#undef CreateWindow
+#endif
+
 #ifdef PANORAMIX_DEBUG
 #include <stdio.h>
 int ProcInitialConnection();
@@ -470,40 +474,69 @@ DisableLimitedSchedulingLatency(void)
         SmartScheduleLatencyLimited = 0;
 }
 
-void
-Dispatch(void)
-{
-    int result;
-    ClientPtr client;
-    long start_tick;
+Bool isThereSomething(Bool are_ready);
 
-    nextFreeClientID = 1;
-    nClients = 0;
-
-    SmartScheduleSlice = SmartScheduleInterval;
-    init_client_ready();
-
-    while (!dispatchException) {
-        if (InputCheckPending()) {
+void DispatchQueuedEvents(Bool wait)
+{
+    static int reentrantcheck;
+    static int maxDoCount;
+    if (!wait)
+    {
+        if (reentrantcheck)
+        {
+            maxDoCount = -1;
+            return;
+        }
+        reentrantcheck=1;
+        maxDoCount = 10;
+    }
+    while (1)
+    {
+        if (InputCheckPending())
+        {
             ProcessInputEvents();
             FlushIfCriticalOutputPending();
         }
 
-        if (!WaitForSomething(clients_are_ready()))
-            continue;
+        if (wait)
+        {
+            if (!WaitForSomething(clients_are_ready()))
+                return;
+        }
+        else
+        {
+            if (!isThereSomething(clients_are_ready()))
+            {
+                reentrantcheck=0;
+                return;
+            }
+            else if (maxDoCount-- < 0)
+            {
+                reentrantcheck=0;
+                return;
+            }
+        }
 
        /*****************
 	*  Handle events in round robin fashion, doing input between
 	*  each round
 	*****************/
 
-        if (!dispatchException && clients_are_ready()) {
+        if (!dispatchException && clients_are_ready())
+        {
+            long start_tick;
+            ClientPtr client;
             client = SmartScheduleClient();
 
             isItTimeToYield = FALSE;
 
             start_tick = SmartScheduleTime;
-            while (!isItTimeToYield) {
+            while (!isItTimeToYield)
+            {
+                int result;
+#ifdef XSERVER_DTRACE
+                CARD8 StartMajorOp;
+#endif
                 if (InputCheckPending())
                     ProcessInputEvents();
 
@@ -518,7 +551,8 @@ Dispatch(void)
 
                 /* now, finally, deal with client requests */
                 result = ReadRequestFromClient(client);
-                if (result <= 0) {
+                if (result <= 0)
+                {
                     if (result < 0)
                         CloseDownClient(client);
                     break;
@@ -527,7 +561,8 @@ Dispatch(void)
                 client->sequence++;
                 client->majorOp = ((xReq *) client->requestBuffer)->reqType;
                 client->minorOp = 0;
-                if (client->majorOp >= EXTENSION_BASE) {
+                if (client->majorOp >= EXTENSION_BASE)
+                {
                     ExtensionEntry *ext = GetExtensionEntry(client->majorOp);
 
                     if (ext)
@@ -535,15 +570,19 @@ Dispatch(void)
                 }
 #ifdef XSERVER_DTRACE
                 if (XSERVER_REQUEST_START_ENABLED())
+                {
+                    StartMajorOp=client->majorOp;
                     XSERVER_REQUEST_START(LookupMajorName(client->majorOp),
                                           client->majorOp,
                                           ((xReq *) client->requestBuffer)->length,
                                           client->index,
                                           client->requestBuffer);
+                }
 #endif
                 if (result > (maxBigRequestSize << 2))
                     result = BadLength;
-                else {
+                else
+                {
                     result = XaceHookDispatch(client, client->majorOp);
                     if (result == Success) {
                         currentClient = client;
@@ -557,19 +596,37 @@ Dispatch(void)
 
 #ifdef XSERVER_DTRACE
                 if (XSERVER_REQUEST_DONE_ENABLED())
-                    XSERVER_REQUEST_DONE(LookupMajorName(client->majorOp),
-                                         client->majorOp, client->sequence,
-                                         client->index, result);
+                {
+                    if (result!=Success)
+                    {
+                        char Message[255];
+                        sprintf(Message,"ERROR: %s (0x%x)",LookupMajorName(client->majorOp),client->errorValue);
+                        XSERVER_REQUEST_DONE(Message, client->majorOp, client->sequence, client->index, result);
+                    }
+                    else
+                    {
+                        if (StartMajorOp!=client->majorOp)
+                        {
+                            char Message[255];
+                            sprintf(Message,"Changed request: %s -> %s",LookupMajorName(StartMajorOp),LookupMajorName(client->majorOp));
+                            XSERVER_REQUEST_DONE(Message, client->majorOp, client->sequence, client->index, result);
+                        }
+                        else
+                        {
+                            XSERVER_REQUEST_DONE(LookupMajorName(client->majorOp), client->majorOp, client->sequence, client->index, result);
+                        }
+                    }
+                }
 #endif
 
-                if (client->noClientException != Success) {
+                if (client->noClientException != Success)
+                {
                     CloseDownClient(client);
                     break;
                 }
-                else if (result != Success) {
-                    SendErrorToClient(client, client->majorOp,
-                                      client->minorOp,
-                                      client->errorValue, result);
+                else if (result != Success)
+                {
+                    SendErrorToClient(client, client->majorOp, client->minorOp, client->errorValue, result);
                     break;
                 }
             }
@@ -579,6 +636,23 @@ Dispatch(void)
         }
         dispatchException &= ~DE_PRIORITYCHANGE;
     }
+    if (!wait)
+        reentrantcheck=0;
+}
+
+void
+Dispatch(void)
+{
+    nextFreeClientID = 1;
+    nClients = 0;
+
+    SmartScheduleSlice = SmartScheduleInterval;
+    init_client_ready();
+
+    while (!dispatchException) {
+        DispatchQueuedEvents(1);
+
+    }
 #if defined(DDXBEFORERESET)
     ddxBeforeReset();
 #endif
@@ -1043,9 +1117,11 @@ GetGeometry(ClientPtr client, xGetGeometryReply * rep)
 int
 ProcGetGeometry(ClientPtr client)
 {
-    xGetGeometryReply rep = { .type = X_Reply };
+    xGetGeometryReply rep;
     int status;
 
+    memset(&rep, 0, sizeof(xGetGeometryReply));
+    rep.type = X_Reply ;
     if ((status = GetGeometry(client, &rep)) != Success)
         return status;
 
@@ -1053,6 +1129,13 @@ ProcGetGeometry(ClientPtr client)
     return Success;
 }
 
+#ifdef WIN32
+/* Do not return the clipboard window in ProcQueryTree, cause this may cause
+   the clipboard client being closed when connecting through xdmcp.
+*/
+extern Window g_iClipboardWindow;
+
+#endif
 int
 ProcQueryTree(ClientPtr client)
 {
@@ -1067,16 +1150,18 @@ ProcQueryTree(ClientPtr client)
     rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);
     if (rc != Success)
         return rc;
+    memset(&reply, 0, sizeof(xQueryTreeReply));
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.root = pWin->drawable.pScreen->root->drawable.id;
+    reply.parent =  (pWin->parent) ? pWin->parent->drawable.id : (Window) None;
 
-    reply = (xQueryTreeReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .root = pWin->drawable.pScreen->root->drawable.id,
-        .parent = (pWin->parent) ? pWin->parent->drawable.id : (Window) None
-    };
     pHead = RealChildHead(pWin);
     for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)
-        numChildren++;
+#ifdef WIN32
+        if (pChild->drawable.id!=g_iClipboardWindow)
+#endif
+            numChildren++;
     if (numChildren) {
         int curChild = 0;
 
@@ -1085,6 +1170,9 @@ ProcQueryTree(ClientPtr client)
             return BadAlloc;
         for (pChild = pWin->lastChild; pChild != pHead;
              pChild = pChild->prevSib)
+#ifdef WIN32
+	         if (pChild->drawable.id!=g_iClipboardWindow)
+#endif
             childIDs[curChild++] = pChild->drawable.id;
     }
 
@@ -1118,12 +1206,12 @@ ProcInternAtom(ClientPtr client)
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, !stuff->onlyIfExists);
     if (atom != BAD_RESOURCE) {
-        xInternAtomReply reply = {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .length = 0,
-            .atom = atom
-        };
+        xInternAtomReply reply; memset(&reply, 0, sizeof(xInternAtomReply));
+        reply.type = X_Reply;
+        reply.sequenceNumber = client->sequence;
+        reply.length = 0;
+        reply.atom = atom;
+
         WriteReplyToClient(client, sizeof(xInternAtomReply), &reply);
         return Success;
     }
@@ -1140,14 +1228,13 @@ ProcGetAtomName(ClientPtr client)
 
     REQUEST_SIZE_MATCH(xResourceReq);
     if ((str = NameForAtom(stuff->id))) {
+        xGetAtomNameReply reply;
         int len = strlen(str);
-        xGetAtomNameReply reply = {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .length = bytes_to_int32(len),
-            .nameLength = len
-        };
-
+        memset(&reply, 0, sizeof(xGetAtomNameReply));
+        reply.type = X_Reply;
+        reply.sequenceNumber = client->sequence;
+        reply.length = bytes_to_int32(len);
+        reply.nameLength = len;
         WriteReplyToClient(client, sizeof(xGetAtomNameReply), &reply);
         WriteToClient(client, len, str);
         return Success;
@@ -1239,12 +1326,11 @@ ProcTranslateCoords(ClientPtr client)
     rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixGetAttrAccess);
     if (rc != Success)
         return rc;
+    memset(&rep, 0, sizeof(xTranslateCoordsReply));
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
-    rep = (xTranslateCoordsReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
     if (!SAME_SCREENS(pWin->drawable, pDst->drawable)) {
         rep.sameScreen = xFalse;
         rep.child = None;
@@ -1406,19 +1492,19 @@ ProcQueryTextExtents(ClientPtr client)
     }
     if (!xfont2_query_text_extents(pFont, length, (unsigned char *) &stuff[1], &info))
         return BadAlloc;
-    reply = (xQueryTextExtentsReply) {
-        .type = X_Reply,
-        .drawDirection = info.drawDirection,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .fontAscent = info.fontAscent,
-        .fontDescent = info.fontDescent,
-        .overallAscent = info.overallAscent,
-        .overallDescent = info.overallDescent,
-        .overallWidth = info.overallWidth,
-        .overallLeft = info.overallLeft,
-        .overallRight = info.overallRight
-    };
+
+    reply.type = X_Reply;
+    reply.drawDirection = info.drawDirection;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    reply.fontAscent = info.fontAscent;
+    reply.fontDescent = info.fontDescent;
+    reply.overallAscent = info.overallAscent;
+    reply.overallDescent = info.overallDescent;
+    reply.overallWidth = info.overallWidth;
+    reply.overallLeft = info.overallLeft;
+    reply.overallRight = info.overallRight;
+
     WriteReplyToClient(client, sizeof(xQueryTextExtentsReply), &reply);
     return Success;
 }
@@ -2611,15 +2697,14 @@ ProcAllocColor(ClientPtr client)
     rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,
                                  client, DixAddAccess);
     if (rc == Success) {
-        xAllocColorReply acr = {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .length = 0,
-            .red = stuff->red,
-            .green = stuff->green,
-            .blue = stuff->blue,
-            .pixel = 0
-        };
+        xAllocColorReply acr;
+        acr.type = X_Reply;
+        acr.sequenceNumber = client->sequence;
+        acr.length = 0;
+        acr.red = stuff->red;
+        acr.green = stuff->green;
+        acr.blue = stuff->blue;
+        acr.pixel = 0;
         if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,
                              &acr.pixel, client->index)))
             return rc;
@@ -2648,11 +2733,11 @@ ProcAllocNamedColor(ClientPtr client)
     rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                  client, DixAddAccess);
     if (rc == Success) {
-        xAllocNamedColorReply ancr = {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .length = 0
-        };
+        xAllocNamedColorReply ancr;
+        ancr.type = X_Reply;
+        ancr.sequenceNumber = client->sequence;
+        ancr.length = 0;
+
         if (OsLookupColor
             (pcmp->pScreen->myNum, (char *) &stuff[1], stuff->nbytes,
              &ancr.exactRed, &ancr.exactGreen, &ancr.exactBlue)) {
@@ -2722,13 +2807,12 @@ ProcAllocColorCells(ClientPtr client)
         if (noPanoramiXExtension || !pcmp->pScreen->myNum)
 #endif
         {
-            xAllocColorCellsReply accr = {
-                .type = X_Reply,
-                .sequenceNumber = client->sequence,
-                .length = bytes_to_int32(length),
-                .nPixels = npixels,
-                .nMasks = nmasks
-            };
+            xAllocColorCellsReply accr;
+            accr.type = X_Reply;
+            accr.sequenceNumber = client->sequence;
+            accr.length = bytes_to_int32(length);
+            accr.nPixels = npixels;
+            accr.nMasks = nmasks;
             WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);
             client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
             WriteSwappedDataToClient(client, length, ppixels);
@@ -2768,11 +2852,11 @@ ProcAllocColorPlanes(ClientPtr client)
             client->errorValue = stuff->contiguous;
             return BadValue;
         }
-        acpr = (xAllocColorPlanesReply) {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .nPixels = npixels
-        };
+
+        acpr.type = X_Reply;
+        acpr.sequenceNumber = client->sequence;
+        acpr.nPixels = npixels;
+        
         length = (long) npixels *sizeof(Pixel);
 
         ppixels = malloc(length);
@@ -2910,12 +2994,12 @@ ProcQueryColors(ClientPtr client)
             free(prgbs);
             return rc;
         }
-        qcr = (xQueryColorsReply) {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .length = bytes_to_int32(count * sizeof(xrgb)),
-            .nColors = count
-        };
+        memset(&qcr, 0, sizeof(xQueryColorsReply));
+        qcr.type = X_Reply;
+        qcr.sequenceNumber = client->sequence;
+        qcr.length = bytes_to_int32(count * sizeof(xrgb));
+        qcr.nColors = count;
+        
         WriteReplyToClient(client, sizeof(xQueryColorsReply), &qcr);
         if (count) {
             client->pSwapReplyFunc = (ReplySwapPtr) SQColorsExtend;
@@ -2948,17 +3032,17 @@ ProcLookupColor(ClientPtr client)
         if (OsLookupColor
             (pcmp->pScreen->myNum, (char *) &stuff[1], stuff->nbytes,
              &exactRed, &exactGreen, &exactBlue)) {
-            xLookupColorReply lcr = {
-                .type = X_Reply,
-                .sequenceNumber = client->sequence,
-                .length = 0,
-                .exactRed = exactRed,
-                .exactGreen = exactGreen,
-                .exactBlue = exactBlue,
-                .screenRed = exactRed,
-                .screenGreen = exactGreen,
-                .screenBlue = exactBlue
-            };
+            xLookupColorReply lcr;
+            lcr.type = X_Reply;
+            lcr.sequenceNumber = client->sequence;
+            lcr.length = 0;
+            lcr.exactRed = exactRed;
+            lcr.exactGreen = exactGreen;
+            lcr.exactBlue = exactBlue;
+            lcr.screenRed = exactRed;
+            lcr.screenGreen = exactGreen;
+            lcr.screenBlue = exactBlue;
+            
             (*pcmp->pScreen->ResolveColor) (&lcr.screenRed,
                                             &lcr.screenGreen,
                                             &lcr.screenBlue, pcmp->pVisual);
@@ -3145,13 +3229,13 @@ ProcQueryBestSize(ClientPtr client)
         return rc;
     (*pScreen->QueryBestSize) (stuff->class, &stuff->width,
                                &stuff->height, pScreen);
-    reply = (xQueryBestSizeReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .width = stuff->width,
-        .height = stuff->height
-    };
+    memset(&reply, 0, sizeof(xQueryBestSizeReply));
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    reply.width = stuff->width;
+    reply.height = stuff->height;
+    
     WriteReplyToClient(client, sizeof(xQueryBestSizeReply), &reply);
     return Success;
 }
@@ -3231,15 +3315,15 @@ ProcGetScreenSaver(ClientPtr client)
             return rc;
     }
 
-    rep = (xGetScreenSaverReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .timeout = ScreenSaverTime / MILLI_PER_SECOND,
-        .interval = ScreenSaverInterval / MILLI_PER_SECOND,
-        .preferBlanking = ScreenSaverBlanking,
-        .allowExposures = ScreenSaverAllowExposures
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.timeout = ScreenSaverTime / MILLI_PER_SECOND;
+    rep.interval = ScreenSaverInterval / MILLI_PER_SECOND;
+    rep.preferBlanking = ScreenSaverBlanking;
+    rep.allowExposures = ScreenSaverAllowExposures;
+    
     WriteReplyToClient(client, sizeof(xGetScreenSaverReply), &rep);
     return Success;
 }
@@ -3282,13 +3366,13 @@ ProcListHosts(ClientPtr client)
     if (result != Success)
         return result;
 
-    reply = (xListHostsReply) {
-        .type = X_Reply,
-        .enabled = enabled,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(len),
-        .nHosts = nHosts
-    };
+    
+    reply.type = X_Reply;
+    reply.enabled = enabled;
+    reply.sequenceNumber = client->sequence;
+    reply.length = bytes_to_int32(len);
+    reply.nHosts = nHosts;
+    
     WriteReplyToClient(client, sizeof(xListHostsReply), &reply);
     if (nHosts) {
         client->pSwapReplyFunc = (ReplySwapPtr) SLHostsExtend;
@@ -3347,17 +3431,14 @@ ProcKillClient(ClientPtr client)
 
     rc = dixLookupClient(&killclient, stuff->id, client, DixDestroyAccess);
     if (rc == Success) {
-        CloseDownClient(killclient);
         if (client == killclient) {
-            /* force yield and return Success, so that Dispatch()
-             * doesn't try to touch client
-             */
+            MarkClientException(client);
             isItTimeToYield = TRUE;
         }
-        return Success;
+        else
+            CloseDownClient(killclient);
     }
-    else
-        return rc;
+    return rc;
 }
 
 int
@@ -3401,12 +3482,11 @@ ProcGetFontPath(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    reply = (xGetFontPathReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(stringLens + numpaths),
-        .nPaths = numpaths
-    };
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.length = bytes_to_int32(stringLens + numpaths);
+    reply.nPaths = numpaths;
 
     WriteReplyToClient(client, sizeof(xGetFontPathReply), &reply);
     if (stringLens || numpaths)
@@ -3801,13 +3881,12 @@ void
 SendErrorToClient(ClientPtr client, unsigned majorCode, unsigned minorCode,
                   XID resId, int errorCode)
 {
-    xError rep = {
-        .type = X_Error,
-        .errorCode = errorCode,
-        .resourceID = resId,
-        .minorCode = minorCode,
-        .majorCode = majorCode
-    };
+    xError rep; memset(&rep, 0, sizeof(xError));
+    rep.type = X_Error;
+    rep.errorCode = errorCode;
+    rep.resourceID = resId;
+    rep.minorCode = minorCode;
+    rep.majorCode = majorCode;
 
     WriteEventsToClient(client, 1, (xEvent *) &rep);
 }
diff --git a/xserver/dix/dixfonts.c b/vcxsrv-code/xorg-server/dix/dixfonts.c
index 58a385f..17d2953 100644
--- a/xserver/dix/dixfonts.c
+++ b/vcxsrv-code/xorg-server/dix/dixfonts.c
@@ -134,6 +134,7 @@ SetDefaultFont(const char *defaultfontname)
     int err;
     FontPtr pf;
     XID fid;
+    static FontPtr last_pf;
 
     fid = FakeClientID(0);
     err = OpenFont(serverClient, fid, FontLoadAll | FontOpenSync,
@@ -142,9 +143,10 @@ SetDefaultFont(const char *defaultfontname)
         return FALSE;
     err = dixLookupResourceByType((void **) &pf, fid, RT_FONT, serverClient,
                                   DixReadAccess);
-    if (err != Success)
+    if (err == Success) last_pf = pf;
+    if (last_pf == (FontPtr) NULL)
         return FALSE;
-    defaultFont = pf;
+    defaultFont = last_pf;
     return TRUE;
 }
 
@@ -240,7 +242,8 @@ doOpenFont(ClientPtr client, OFclosurePtr c)
     char *alias, *newname;
     int newlen;
     int aliascount = 20;
-
+    Bool fromDispatch = c->from_dispatch;
+    Bool finished = FALSE;
     /*
      * Decide at runtime what FontFormat to use.
      */
@@ -264,6 +267,8 @@ doOpenFont(ClientPtr client, OFclosurePtr c)
 #endif
         BitmapFormatScanlineUnit8;
 
+    c->from_dispatch = FALSE;
+
     if (client->clientGone) {
         if (c->current_fpe < c->num_fpes) {
             fpe = c->fpe_list[c->current_fpe];
@@ -361,12 +366,15 @@ doOpenFont(ClientPtr client, OFclosurePtr c)
                           c->fontid, FontToXError(err));
     }
     ClientWakeup(c->client);
-    for (i = 0; i < c->num_fpes; i++) {
-        FreeFPE(c->fpe_list[i]);
+    finished = TRUE;
+    if (finished || fromDispatch) {
+        for (i = 0; i < c->num_fpes; i++) {
+            FreeFPE(c->fpe_list[i]);
+        }
+        free(c->fpe_list);
+        free((void *) c->fontname);
+        free(c);
     }
-    free(c->fpe_list);
-    free((void *) c->fontname);
-    free(c);
     return TRUE;
 }
 
@@ -438,6 +446,7 @@ OpenFont(ClientPtr client, XID fid, Mask flags, unsigned lenfname,
     c->num_fpes = num_fpes;
     c->fnamelen = lenfname;
     c->flags = flags;
+    c->from_dispatch = TRUE;
     c->non_cachable_font = cached;
 
     (void) doOpenFont(client, c);
@@ -564,6 +573,10 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
     char *bufptr;
     char *bufferStart;
     int aliascount = 0;
+    Bool fromDispatch = c->from_dispatch;
+    Bool finished = FALSE;
+
+    c->from_dispatch = FALSE;
 
     if (client->clientGone) {
         if (c->current.current_fpe < c->num_fpes) {
@@ -744,12 +757,11 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
     for (i = 0; i < nnames; i++)
         stringLens += (names->length[i] <= 255) ? names->length[i] : 0;
 
-    reply = (xListFontsReply) {
-        .type = X_Reply,
-        .length = bytes_to_int32(stringLens + nnames),
-        .nFonts = nnames,
-        .sequenceNumber = client->sequence
-    };
+    memset(&reply, 0, sizeof(xListFontsReply));
+    reply.type = X_Reply;
+    reply.length = bytes_to_int32(stringLens + nnames);
+    reply.nFonts = nnames;
+    reply.sequenceNumber = client->sequence;
 
     bufptr = bufferStart = malloc(reply.length << 2);
 
@@ -779,12 +791,15 @@ doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
 
  bail:
     ClientWakeup(client);
-    for (i = 0; i < c->num_fpes; i++)
-        FreeFPE(c->fpe_list[i]);
-    free(c->fpe_list);
-    free(c->savedName);
-    xfont2_free_font_names(names);
-    free(c);
+    finished = TRUE;
+    if (finished || fromDispatch) {
+        for (i = 0; i < c->num_fpes; i++)
+            FreeFPE(c->fpe_list[i]);
+        free(c->fpe_list);
+        free(c->savedName);
+        xfont2_free_font_names(names);
+        free(c);
+    }
     free(resolved);
     return TRUE;
 }
@@ -835,6 +850,7 @@ ListFonts(ClientPtr client, unsigned char *pattern, unsigned length,
     c->current.list_started = FALSE;
     c->current.private = 0;
     c->haveSaved = FALSE;
+    c->from_dispatch = TRUE;
     c->savedName = 0;
     doListFontsAndAliases(client, c);
     return Success;
@@ -846,6 +862,8 @@ doListFontsWithInfo(ClientPtr client, LFWIclosurePtr c)
     FontPathElementPtr fpe;
     int err = Successful;
     char *name;
+    Bool fromDispatch = c->from_dispatch;
+    Bool finished = FALSE;
     int namelen;
     int numFonts;
     FontInfoRec fontInfo, *pFontInfo;
@@ -856,6 +874,8 @@ doListFontsWithInfo(ClientPtr client, LFWIclosurePtr c)
     int aliascount = 0;
     xListFontsWithInfoReply finalReply;
 
+    c->from_dispatch = FALSE;
+
     if (client->clientGone) {
         if (c->current.current_fpe < c->num_fpes) {
             fpe = c->fpe_list[c->current.current_fpe];
@@ -1017,21 +1037,23 @@ doListFontsWithInfo(ClientPtr client, LFWIclosurePtr c)
     }
  finish:
     length = sizeof(xListFontsWithInfoReply);
-    finalReply = (xListFontsWithInfoReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(sizeof(xListFontsWithInfoReply)
-                                 - sizeof(xGenericReply))
-    };
+    memset((char *) &finalReply, 0, sizeof(xListFontsWithInfoReply));
+    finalReply.type = X_Reply;
+    finalReply.sequenceNumber = client->sequence;
+    finalReply.length = bytes_to_int32(sizeof(xListFontsWithInfoReply)
+                                       - sizeof(xGenericReply));
     WriteSwappedDataToClient(client, length, &finalReply);
  bail:
     ClientWakeup(client);
-    for (i = 0; i < c->num_fpes; i++)
-        FreeFPE(c->fpe_list[i]);
-    free(c->reply);
-    free(c->fpe_list);
-    free(c->savedName);
-    free(c);
+    finished = TRUE;
+    if (finished || fromDispatch) {
+        for (i = 0; i < c->num_fpes; i++)
+            FreeFPE(c->fpe_list[i]);
+        free(c->reply);
+        free(c->fpe_list);
+        free(c->savedName);
+        free(c);
+    }
     return TRUE;
 }
 
@@ -1078,6 +1100,7 @@ StartListFontsWithInfo(ClientPtr client, int length, unsigned char *pattern,
     c->current.private = 0;
     c->savedNumFonts = 0;
     c->haveSaved = FALSE;
+    c->from_dispatch = TRUE;
     c->savedName = 0;
     doListFontsWithInfo(client, c);
     return Success;
@@ -1087,7 +1110,7 @@ StartListFontsWithInfo(ClientPtr client, int length, unsigned char *pattern,
 
 #define TextEltHeader 2
 #define FontShiftSize 5
-static ChangeGCVal clearGC[] = { {.ptr = NullPixmap} };
+static ChangeGCVal clearGC[] = { NullPixmap };
 
 #define clearGCmask (GCClipMask)
 
@@ -1100,6 +1123,10 @@ doPolyText(ClientPtr client, PTclosurePtr c)
     FontPathElementPtr fpe;
     GC *origGC = NULL;
     int itemSize = c->reqType == X_PolyText8 ? 1 : 2;
+    Bool fromDispatch = c->from_dispatch;
+    Bool finished = FALSE;
+
+    c->from_dispatch = FALSE;
 
     if (client->clientGone) {
         fpe = c->pGC->font->fpe;
@@ -1335,15 +1362,18 @@ doPolyText(ClientPtr client, PTclosurePtr c)
     }
     if (ClientIsAsleep(client)) {
         ClientWakeup(c->client);
-        ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);
+        finished = TRUE;
+        if (finished || fromDispatch) {
+            ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);
 
-        /* Unreference the font from the scratch GC */
-        CloseFont(c->pGC->font, (Font) 0);
-        c->pGC->font = NullFont;
+            /* Unreference the font from the scratch GC */
+            CloseFont(c->pGC->font, (Font) 0);
+            c->pGC->font = NullFont;
 
-        FreeScratchGC(c->pGC);
-        free(c->data);
-        free(c);
+            FreeScratchGC(c->pGC);
+            free(c->data);
+            free(c);
+        }
     }
     return TRUE;
 }
@@ -1378,6 +1408,10 @@ doImageText(ClientPtr client, ITclosurePtr c)
     int err = Success, lgerr;   /* err is in X error, not font error, space */
     FontPathElementPtr fpe;
     int itemSize = c->reqType == X_ImageText8 ? 1 : 2;
+    Bool fromDispatch = c->from_dispatch;
+    Bool finished = FALSE;
+
+    c->from_dispatch = FALSE;
 
     if (client->clientGone) {
         fpe = c->pGC->font->fpe;
@@ -1481,15 +1515,18 @@ doImageText(ClientPtr client, ITclosurePtr c)
     }
     if (ClientIsAsleep(client)) {
         ClientWakeup(c->client);
-        ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);
+        finished = TRUE;
+        if (finished || fromDispatch) {
+            ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);
 
-        /* Unreference the font from the scratch GC */
-        CloseFont(c->pGC->font, (Font) 0);
-        c->pGC->font = NullFont;
+            /* Unreference the font from the scratch GC */
+            CloseFont(c->pGC->font, (Font) 0);
+            c->pGC->font = NullFont;
 
-        FreeScratchGC(c->pGC);
-        free(c->data);
-        free(c);
+            FreeScratchGC(c->pGC);
+            free(c->data);
+            free(c);
+        }
     }
     return TRUE;
 }
diff --git a/xserver/dix/enterleave.c b/vcxsrv-code/xorg-server/dix/enterleave.c
index 033ddc2..4d63ff3 100644
--- a/xserver/dix/enterleave.c
+++ b/vcxsrv-code/xorg-server/dix/enterleave.c
@@ -828,14 +828,13 @@ DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
     free(xi2event);
 
     /* XI 1.x event */
-    event = (deviceFocus) {
-        .deviceid = dev->id,
-        .mode = mode,
-        .type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut,
-        .detail = detail,
-        .window = pWin->drawable.id,
-        .time = currentTime.milliseconds
-    };
+
+    event.deviceid = dev->id;
+    event.mode = mode;
+    event.type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut;
+    event.detail = detail;
+    event.window = pWin->drawable.id;
+    event.time = currentTime.milliseconds;
 
     DeliverEventsToWindow(dev, pWin, (xEvent *) &event, 1,
                           DeviceFocusChangeMask, NullGrab);
diff --git a/xserver/dix/eventconvert.c b/vcxsrv-code/xorg-server/dix/eventconvert.c
index 53b8c79..ed5015e 100644
--- a/xserver/dix/eventconvert.c
+++ b/vcxsrv-code/xorg-server/dix/eventconvert.c
@@ -143,7 +143,7 @@ EventToCore(InternalEvent *event, xEvent **core_out, int *count_out)
         core->u.keyButtonPointer.time = e->time;
         core->u.keyButtonPointer.rootX = e->root_x;
         core->u.keyButtonPointer.rootY = e->root_y;
-        core->u.keyButtonPointer.state = e->corestate;
+        core->u.keyButtonPointer.state = e->corestate&0xffff;
         core->u.keyButtonPointer.root = e->root;
         EventSetKeyRepeatFlag(core, (e->type == ET_KeyPress && e->key_repeat));
         ret = Success;
diff --git a/xserver/dix/events.c b/vcxsrv-code/xorg-server/dix/events.c
index 341c746..afcdaa6 100644
--- a/xserver/dix/events.c
+++ b/vcxsrv-code/xorg-server/dix/events.c
@@ -683,15 +683,15 @@ ConfineToShape(DeviceIntPtr pDev, RegionPtr shape, int *px, int *py)
         x += incx;
         if (x >= box.x2) {
             incx = -1;
-            x = *px - 1;
+            x = min(box.x2,*px) - 1;
         }
         else if (x < box.x1) {
             incx = 1;
-            x = *px;
+            x = max(box.x1,*px);
             y += incy;
             if (y >= box.y2) {
                 incy = -1;
-                y = *py - 1;
+                y = min(box.y2,*py) - 1;
             }
             else if (y < box.y1)
                 return;         /* should never get here! */
@@ -748,7 +748,10 @@ CheckPhysLimits(DeviceIntPtr pDev, CursorPtr cursor, Bool generateEvents,
         (new.x != pSprite->hotPhys.x) || (new.y != pSprite->hotPhys.y)) {
 #ifdef PANORAMIX
         if (!noPanoramiXExtension)
-            XineramaSetCursorPosition(pDev, new.x, new.y, generateEvents);
+        {
+            if (pScreen && ((new.x != pSprite->hotPhys.x) || (new.y != pSprite->hotPhys.y)))
+                XineramaSetCursorPosition(pDev, new.x, new.y, generateEvents);
+        }
         else
 #endif
         {
@@ -1218,7 +1221,7 @@ void
 PlayReleasedEvents(void)
 {
     QdEventPtr tmp;
-    QdEventPtr qe;
+    QdEventPtr qe=NULL;
     DeviceIntPtr dev;
     DeviceIntPtr pDev;
 
@@ -1624,7 +1627,7 @@ void
 DeactivatePointerGrab(DeviceIntPtr mouse)
 {
     GrabPtr grab = mouse->deviceGrab.grab;
-    DeviceIntPtr dev;
+    DeviceIntPtr dev=mouse;
     Bool wasPassive = mouse->deviceGrab.fromPassiveGrab;
     Bool wasImplicit = (mouse->deviceGrab.fromPassiveGrab &&
                         mouse->deviceGrab.implicitGrab);
@@ -2441,7 +2444,7 @@ DeliverRawEvent(RawDeviceEvent *ev, DeviceIntPtr device)
     rc = EventToXI2((InternalEvent *) ev, (xEvent **) &xi);
     if (rc != Success) {
         ErrorF("[Xi] %s: XI2 conversion failed in %s (%d)\n",
-               __func__, device->name, rc);
+               __FUNCTION__, device->name, rc);
         return;
     }
 
@@ -3115,6 +3118,9 @@ CheckMotion(DeviceEvent *ev, DeviceIntPtr pDev)
 
     verify_internal_event((InternalEvent *) ev);
 
+    if (!pSprite)
+      return FALSE;
+
     prevSpriteWin = pSprite->win;
 
     if (ev && !syncEvents.playingEvents) {
@@ -4557,6 +4563,7 @@ OtherClientGone(void *value, XID id)
         prev = other;
     }
     FatalError("client not on event list");
+    return BadValue; // to avoid warning
 }
 
 int
@@ -4688,10 +4695,7 @@ CoreEnterLeaveEvent(DeviceIntPtr mouse,
                     int type,
                     int mode, int detail, WindowPtr pWin, Window child)
 {
-    xEvent event = {
-        .u.u.type = type,
-        .u.u.detail = detail
-    };
+    xEvent event;
     WindowPtr focus;
     DeviceIntPtr keybd;
     GrabPtr grab = mouse->deviceGrab.grab;
@@ -4711,6 +4715,9 @@ CoreEnterLeaveEvent(DeviceIntPtr mouse,
         mask = pWin->eventMask | wOtherEventMasks(pWin);
     }
 
+    memset(&event, 0, sizeof(xEvent));
+    event.u.u.type = type;
+    event.u.u.detail = detail;
     event.u.enterLeave.time = currentTime.milliseconds;
     event.u.enterLeave.rootX = mouse->spriteInfo->sprite->hot.x;
     event.u.enterLeave.rootY = mouse->spriteInfo->sprite->hot.y;
@@ -4741,16 +4748,17 @@ CoreEnterLeaveEvent(DeviceIntPtr mouse,
     }
 
     if ((type == EnterNotify) && (mask & KeymapStateMask)) {
-        xKeymapEvent ke = {
-            .type = KeymapNotify
-        };
+        xKeymapEvent ke;
         ClientPtr client = grab ? rClient(grab) : wClient(pWin);
         int rc;
 
         rc = XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess);
         if (rc == Success)
             memcpy((char *) &ke.map[0], (char *) &keybd->key->down[1], 31);
+        else
+            memset((char *) &ke.map[0], 0, 31);        
 
+        ke.type = KeymapNotify;
         if (grab)
             TryClientEvents(rClient(grab), keybd, (xEvent *) &ke, 1,
                             mask, KeymapStateMask, grab);
@@ -4841,10 +4849,10 @@ DeviceEnterLeaveEvent(DeviceIntPtr mouse,
 void
 CoreFocusEvent(DeviceIntPtr dev, int type, int mode, int detail, WindowPtr pWin)
 {
-    xEvent event = {
-        .u.u.type = type,
-        .u.u.detail = detail
-    };
+    xEvent event; memset(&event, 0, sizeof(xEvent));
+    event.u.u.type = type;
+    event.u.u.detail = detail;
+
     event.u.focus.mode = mode;
     event.u.focus.window = pWin->drawable.id;
 
@@ -4852,16 +4860,17 @@ CoreFocusEvent(DeviceIntPtr dev, int type, int mode, int detail, WindowPtr pWin)
                           GetEventFilter(dev, &event), NullGrab);
     if ((type == FocusIn) &&
         ((pWin->eventMask | wOtherEventMasks(pWin)) & KeymapStateMask)) {
-        xKeymapEvent ke = {
-            .type = KeymapNotify
-        };
+        xKeymapEvent ke;
         ClientPtr client = wClient(pWin);
         int rc;
 
         rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixReadAccess);
         if (rc == Success)
             memcpy((char *) &ke.map[0], (char *) &dev->key->down[1], 31);
+        else
+            memset((char *) &ke.map[0], 0, 31);
 
+        ke.type = KeymapNotify;
         DeliverEventsToWindow(dev, pWin, (xEvent *) &ke, 1,
                               KeymapStateMask, NullGrab);
     }
@@ -4908,7 +4917,7 @@ SetInputFocus(ClientPtr client,
     keybd = GetMaster(dev, KEYBOARD_OR_FLOAT);
 
     if ((focusID == None) || (focusID == PointerRoot))
-        focusWin = (WindowPtr) (long) focusID;
+        focusWin = (WindowPtr) (uintptr_t) focusID;
     else if ((focusID == FollowKeyboard) && followOK) {
         focusWin = keybd->focus->win;
     }
@@ -5003,12 +5012,11 @@ ProcGetInputFocus(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGetInputFocusReply) {
-        .type = X_Reply,
-        .length = 0,
-        .sequenceNumber = client->sequence,
-        .revertTo = focus->revert
-    };
+    memset(&rep, 0, sizeof(xGetInputFocusReply));
+    rep.type = X_Reply;
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+    rep.revertTo = focus->revert;
 
     if (focus->win == NoneWin)
         rep.focus = None;
@@ -5070,12 +5078,11 @@ ProcGrabPointer(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    rep = (xGrabPointerReply) {
-        .type = X_Reply,
-        .status = status,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    memset(&rep, 0, sizeof(xGrabPointerReply));
+    rep.type = X_Reply;
+    rep.status = status;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
     WriteReplyToClient(client, sizeof(xGrabPointerReply), &rep);
     return Success;
 }
@@ -5313,12 +5320,11 @@ ProcGrabKeyboard(ClientPtr client)
     if (result != Success)
         return result;
 
-    rep = (xGrabKeyboardReply) {
-        .type = X_Reply,
-        .status = status,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    memset(&rep, 0, sizeof(xGrabKeyboardReply));
+    rep.type = X_Reply;
+    rep.status = status,
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
     WriteReplyToClient(client, sizeof(xGrabKeyboardReply), &rep);
     return Success;
 }
@@ -5381,16 +5387,16 @@ ProcQueryPointer(ClientPtr client)
     pSprite = mouse->spriteInfo->sprite;
     if (mouse->valuator->motionHintWindow)
         MaybeStopHint(mouse, client);
-    rep = (xQueryPointerReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .mask = event_get_corestate(mouse, keyboard),
-        .root = (GetCurrentRootWindow(mouse))->drawable.id,
-        .rootX = pSprite->hot.x,
-        .rootY = pSprite->hot.y,
-        .child = None
-    };
+    memset(&rep, 0, sizeof(xQueryPointerReply));
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.mask = event_get_corestate(mouse, keyboard);
+    rep.root = (GetCurrentRootWindow(mouse))->drawable.id;
+    rep.rootX = pSprite->hot.x;
+    rep.rootY = pSprite->hot.y;
+    rep.child = None;
+    
     if (pSprite->hot.pScreen == pWin->drawable.pScreen) {
         rep.sameScreen = xTrue;
         rep.winX = pSprite->hot.x - pWin->drawable.x;
@@ -5440,7 +5446,8 @@ void
 InitEvents(void)
 {
     int i;
-    QdEventPtr qe, tmp;
+    QdEventPtr qe=NULL;
+    QdEventPtr tmp;
 
     inputInfo.numDevices = 0;
     inputInfo.devices = (DeviceIntPtr) NULL;
@@ -5668,13 +5675,12 @@ ProcGrabKey(ClientPtr client)
 
     REQUEST_SIZE_MATCH(xGrabKeyReq);
 
-    param = (GrabParameters) {
-        .grabtype = CORE,
-        .ownerEvents = stuff->ownerEvents,
-        .this_device_mode = stuff->keyboardMode,
-        .other_devices_mode = stuff->pointerMode,
-        .modifiers = stuff->modifiers
-    };
+    memset(&param, 0, sizeof(param));
+    param.grabtype = CORE;
+    param.ownerEvents = stuff->ownerEvents;
+    param.this_device_mode = stuff->keyboardMode;
+    param.other_devices_mode = stuff->pointerMode;
+    param.modifiers = stuff->modifiers;
 
     rc = CheckGrabValues(client, &param);
     if (rc != Success)
@@ -5776,13 +5782,12 @@ ProcGrabButton(ClientPtr client)
     if (rc != Success)
         return rc;
 
-    param = (GrabParameters) {
-        .grabtype = CORE,
-        .ownerEvents = stuff->ownerEvents,
-        .this_device_mode = stuff->keyboardMode,
-        .other_devices_mode = stuff->pointerMode,
-        .modifiers = stuff->modifiers
-    };
+    memset(&param, 0, sizeof(param));
+    param.grabtype = CORE;
+    param.ownerEvents = stuff->ownerEvents;
+    param.this_device_mode = stuff->keyboardMode;
+    param.other_devices_mode = stuff->pointerMode;
+    param.modifiers = stuff->modifiers;
 
     mask.core = stuff->eventMask;
 
diff --git a/xserver/dix/extension.c b/vcxsrv-code/xorg-server/dix/extension.c
index 9c158ba..3546646 100644
--- a/xserver/dix/extension.c
+++ b/vcxsrv-code/xorg-server/dix/extension.c
@@ -230,12 +230,11 @@ ProcQueryExtension(ClientPtr client)
 
     REQUEST_FIXED_SIZE(xQueryExtensionReq, stuff->nbytes);
 
-    reply = (xQueryExtensionReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .major_opcode = 0
-    };
+    memset(&reply, 0, sizeof(xQueryExtensionReply));
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    reply.major_opcode = 0;
 
     if (!NumExtensions)
         reply.present = xFalse;
@@ -263,12 +262,12 @@ ProcListExtensions(ClientPtr client)
 
     REQUEST_SIZE_MATCH(xReq);
 
-    reply = (xListExtensionsReply) {
-        .type = X_Reply,
-        .nExtensions = 0,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    memset(&reply, 0, sizeof(xListExtensionsReply));
+    reply.type = X_Reply;
+    reply.nExtensions = 0;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    
     buffer = NULL;
 
     if (NumExtensions) {
diff --git a/xserver/dix/gc.c b/vcxsrv-code/xorg-server/dix/gc.c
index 4ccbd3b..8e0b6c8 100644
--- a/xserver/dix/gc.c
+++ b/vcxsrv-code/xorg-server/dix/gc.c
@@ -127,7 +127,7 @@ ChangeGC(ClientPtr client, GC * pGC, BITS32 mask, ChangeGCValPtr pUnion)
     PixmapPtr pPixmap;
     BITS32 maskQ;
 
-    assert(pUnion);
+    assert(pUnion!=NULL);
     pGC->serialNumber |= GC_CHANGE_SERIAL_BIT;
 
     maskQ = mask;               /* save these for when we walk the GCque */
@@ -322,12 +322,30 @@ ChangeGC(ClientPtr client, GC * pGC, BITS32 mask, ChangeGCValPtr pUnion)
             break;
         }
         case GCClipXOrigin:
+            #ifndef _DEBUG
             NEXTVAL(INT16, pGC->clipOrg.x);
-
+            #else
+            {
+                long Val;
+                NEXTVAL(long, Val);
+                if (abs(Val)>65535)
+                    ErrorF("Value received for GCClipXOrigin is too large %x\n",Val);
+                pGC->clipOrg.x=(INT16)(Val&0xffff);
+            }
+            #endif
             break;
         case GCClipYOrigin:
+            #ifndef _DEBUG
             NEXTVAL(INT16, pGC->clipOrg.y);
-
+            #else
+            {
+                long Val;
+                NEXTVAL(long, Val);
+                if (abs(Val)>65535)
+                    ErrorF("Value received for GCClipYOrigin is too large %x\n",Val);
+                pGC->clipOrg.y=(INT16)(Val&0xffff);
+            }
+            #endif
             break;
         case GCClipMask:
             NEXT_PTR(PixmapPtr, pPixmap);
diff --git a/xserver/dix/getevents.c b/vcxsrv-code/xorg-server/dix/getevents.c
index 32bafe2..438d87b 100644
--- a/xserver/dix/getevents.c
+++ b/vcxsrv-code/xorg-server/dix/getevents.c
@@ -70,6 +70,17 @@
 #include "listdev.h"            /* for sizing up DeviceClassesChangedEvent */
 #include "probes.h"
 
+#ifdef _MSC_VER
+#include <math.h>
+
+double roundd(double f)
+{
+  return ((f<0.0) ? ceil(f-.5)  : floor (f+.5));
+}
+#define lroundf(val)   ((int)roundf(val))
+#define lround(val)   ((int)roundd(val))
+#endif
+
 /* Number of motion history events to store. */
 #define MOTION_HISTORY_SIZE 256
 
@@ -1087,7 +1098,7 @@ GetKeyboardEvents(InternalEvent *events, DeviceIntPtr pDev, int type,
     }
 
     /* refuse events from disabled devices */
-    if (!pDev->enabled)
+    if (!pDev || !pDev->enabled)
         return 0;
 
     if (!events || !pDev->key || !pDev->focus || !pDev->kbdfeed ||
@@ -1169,7 +1180,12 @@ FreeEventList(InternalEvent *list, int num_events)
 static void
 transform(struct pixman_f_transform *m, double *x, double *y)
 {
-    struct pixman_f_vector p = {.v = {*x, *y, 1} };
+    struct pixman_f_vector p;
+    
+    p.v[0] = *x;
+    p.v[1] = *y;
+    p.v[2] = 1;
+
     pixman_f_transform_point(m, &p);
 
     *x = p.v[0];
diff --git a/xserver/dix/globals.c b/vcxsrv-code/xorg-server/dix/globals.c
index 4b8b52e..65395c9 100644
--- a/xserver/dix/globals.c
+++ b/vcxsrv-code/xorg-server/dix/globals.c
@@ -115,6 +115,6 @@ int defaultColorVisualClass = -1;
 int monitorResolution = 0;
 
 const char *display;
-int displayfd = -1;
+intptr_t displayfd = -1;
 Bool explicit_display = FALSE;
 char *ConnectionInfo;
diff --git a/xserver/dix/inpututils.c b/vcxsrv-code/xorg-server/dix/inpututils.c
index 9026f65..710b9d6 100644
--- a/xserver/dix/inpututils.c
+++ b/vcxsrv-code/xorg-server/dix/inpututils.c
@@ -72,13 +72,14 @@ static void
 do_butmap_change(DeviceIntPtr dev, CARD8 *map, int len, ClientPtr client)
 {
     int i;
-    xEvent core_mn = { .u.u.type = MappingNotify };
+    xEvent core_mn;
     deviceMappingNotify xi_mn;
 
     /* The map in ButtonClassRec refers to button numbers, whereas the
      * protocol is zero-indexed.  Sigh. */
     memcpy(&(dev->button->map[1]), map, len);
 
+    core_mn.u.u.type = MappingNotify;
     core_mn.u.mappingNotify.request = MappingPointer;
 
     /* 0 is the server client. */
@@ -93,12 +94,11 @@ do_butmap_change(DeviceIntPtr dev, CARD8 *map, int len, ClientPtr client)
         WriteEventsToClient(clients[i], 1, &core_mn);
     }
 
-    xi_mn = (deviceMappingNotify) {
-        .type = DeviceMappingNotify,
-        .request = MappingPointer,
-        .deviceid = dev->id,
-        .time = GetTimeInMillis()
-    };
+
+    xi_mn.type = DeviceMappingNotify;
+    xi_mn.request = MappingPointer;
+    xi_mn.deviceid = dev->id;
+    xi_mn.time = GetTimeInMillis();
 
     SendEventToAllWindows(dev, DeviceMappingNotifyMask, (xEvent *) &xi_mn, 1);
 }
diff --git a/xserver/dix/main.c b/vcxsrv-code/xorg-server/dix/main.c
index bfc8add..e1ad512 100644
--- a/xserver/dix/main.c
+++ b/vcxsrv-code/xorg-server/dix/main.c
@@ -117,6 +117,10 @@ Equipment Corporation.
 #include "dpmsproc.h"
 #endif
 
+#ifdef _DEBUG
+#include <crtdbg.h>
+#endif
+
 extern void Dispatch(void);
 
 CallbackListPtr RootWindowFinalizeCallback = NULL;
@@ -126,9 +130,49 @@ dix_main(int argc, char *argv[], char *envp[])
 {
     int i;
     HWEventQueueType alwaysCheckForInput[2];
-
+    #ifdef _DEBUG
+    //int TmpFlag=_CrtSetDbgFlag( _CRTDBG_REPORT_FLAG);
+    
+    //TmpFlag|=_CRTDBG_ALLOC_MEM_DF;
+    //TmpFlag|=_CRTDBG_DELAY_FREE_MEM_DF;
+    //TmpFlag|=_CRTDBG_CHECK_ALWAYS_DF;
+    //TmpFlag|=_CRTDBG_CHECK_CRT_DF;
+    //TmpFlag|=_CRTDBG_LEAK_CHECK_DF;
+    
+    //_CrtSetDbgFlag(TmpFlag);
+    #endif
+
+    __ptw32_processInitialize();
     display = "0";
 
+    #ifdef WIN32
+
+    if (InitWSA()<0)
+    {
+      printf("Error initialising WSA\n");
+      return -1;
+    }
+    /* In Win32 we have different threads call Xlib functions (depending
+       on the commandline options given).
+       XInitThreads has to be called before
+       any xlib function is called (aoccording to the man page) */
+    XInitThreads();
+    /* change the current directory to the directory where the vcxsrv.exe executable is installed.
+       This is needed because the font directories are relative to the current directory.
+     */
+     {
+       char ModuleFilename[MAX_PATH];
+       char *pSlash;
+       GetModuleFileName(NULL,ModuleFilename,sizeof(ModuleFilename));
+       pSlash=strrchr(ModuleFilename,'\\');
+       if (pSlash)
+       {
+         *pSlash='\0';
+         chdir(ModuleFilename);
+       }
+     }
+    #endif
+
     InitRegions();
 
     CheckUserParameters(argc, argv, envp);
@@ -137,6 +181,10 @@ dix_main(int argc, char *argv[], char *envp[])
 
     ProcessCommandLine(argc, argv);
 
+    #ifdef WIN32
+    OsVendorPreInit(argc, argv);
+    #endif
+
     alwaysCheckForInput[0] = 0;
     alwaysCheckForInput[1] = 1;
     while (1) {
@@ -267,6 +315,11 @@ dix_main(int argc, char *argv[], char *envp[])
 
         NotifyParentProcess();
 
+        #ifdef _MSC_VER
+        // initialise here because doing it in InitInput failes because keyboard device is not started yet then
+        winInitializeModeKeyStates ();
+        #endif
+
         InputThreadInit();
 
         Dispatch();
diff --git a/xserver/dix/pixmap.c b/vcxsrv-code/xorg-server/dix/pixmap.c
index 5a0146b..70772de 100644
--- a/xserver/dix/pixmap.c
+++ b/vcxsrv-code/xorg-server/dix/pixmap.c
@@ -134,9 +134,9 @@ FreePixmap(PixmapPtr pPixmap)
 
 void PixmapUnshareSecondaryPixmap(PixmapPtr secondary_pixmap)
 {
-     int ihandle = -1;
+     intptr_t ihandle = -1;
      ScreenPtr pScreen = secondary_pixmap->drawable.pScreen;
-     pScreen->SetSharedPixmapBacking(secondary_pixmap, ((void *)(long)ihandle));
+     pScreen->SetSharedPixmapBacking(secondary_pixmap, (void *)ihandle);
 }
 
 PixmapPtr PixmapShareToSecondary(PixmapPtr pixmap, ScreenPtr secondary)
diff --git a/xserver/dix/privates.c b/vcxsrv-code/xorg-server/dix/privates.c
index 71a72fb..2222447 100644
--- a/xserver/dix/privates.c
+++ b/vcxsrv-code/xorg-server/dix/privates.c
@@ -67,64 +67,72 @@ from The Open Group.
 static DevPrivateSetRec global_keys[PRIVATE_LAST];
 
 static const Bool xselinux_private[PRIVATE_LAST] = {
-    [PRIVATE_SCREEN] = TRUE,
-    [PRIVATE_CLIENT] = TRUE,
-    [PRIVATE_WINDOW] = TRUE,
-    [PRIVATE_PIXMAP] = TRUE,
-    [PRIVATE_GC] = TRUE,
-    [PRIVATE_CURSOR] = TRUE,
-    [PRIVATE_COLORMAP] = TRUE,
-    [PRIVATE_DEVICE] = TRUE,
-    [PRIVATE_EXTENSION] = TRUE,
-    [PRIVATE_SELECTION] = TRUE,
-    [PRIVATE_PROPERTY] = TRUE,
-    [PRIVATE_PICTURE] = TRUE,
-    [PRIVATE_GLYPHSET] = TRUE,
+    /* PRIVATE_XSELINUX,*/    FALSE,
+    /* PRIVATE_SCREEN,*/      TRUE,
+    /* [PRIVATE_EXTENSION] =*/TRUE,
+    /* [PRIVATE_COLORMAP] =*/ TRUE,
+    /* [PRIVATE_DEVICE] =*/   TRUE,
+    /* [PRIVATE_CLIENT] = */  TRUE,
+    /* [PRIVATE_PROPERTY] =*/ TRUE,
+    /* [PRIVATE_SELECTION] =*/TRUE,
+    /* [PRIVATE_WINDOW] =*/   TRUE,
+    /* [PRIVATE_PIXMAP] =*/   TRUE,
+    /* [PRIVATE_GC] =*/       TRUE,
+    /* [PRIVATE_CURSOR] =*/   TRUE,
+    /* PRIVATE_CURSOR_BITS,*/ FALSE,
+    /* PRIVATE_DAMAGE,*/      FALSE,
+    /* PRIVATE_GLYPH,*/       FALSE,
+    /* [PRIVATE_GLYPHSET] =*/ TRUE,
+    /* [PRIVATE_PICTURE] =*/  TRUE
 };
 
 static const char *key_names[PRIVATE_LAST] = {
     /* XSELinux uses the same private keys for numerous objects */
-    [PRIVATE_XSELINUX] = "XSELINUX",
+    /*[PRIVATE_XSELINUX] =*/ "XSELINUX",
 
     /* Otherwise, you get a private in just the requested structure
      */
     /* These can have objects created before all of the keys are registered */
-    [PRIVATE_SCREEN] = "SCREEN",
-    [PRIVATE_EXTENSION] = "EXTENSION",
-    [PRIVATE_COLORMAP] = "COLORMAP",
-    [PRIVATE_DEVICE] = "DEVICE",
+    /*[PRIVATE_SCREEN] =*/ "SCREEN",
+    /*[PRIVATE_EXTENSION] =*/ "EXTENSION",
+    /*[PRIVATE_COLORMAP] =*/ "COLORMAP",
+    /*[PRIVATE_DEVICE] =*/ "DEVICE",
 
     /* These cannot have any objects before all relevant keys are registered */
-    [PRIVATE_CLIENT] = "CLIENT",
-    [PRIVATE_PROPERTY] = "PROPERTY",
-    [PRIVATE_SELECTION] = "SELECTION",
-    [PRIVATE_WINDOW] = "WINDOW",
-    [PRIVATE_PIXMAP] = "PIXMAP",
-    [PRIVATE_GC] = "GC",
-    [PRIVATE_CURSOR] = "CURSOR",
-    [PRIVATE_CURSOR_BITS] = "CURSOR_BITS",
+    /*[PRIVATE_CLIENT] =*/ "CLIENT",
+    /*[PRIVATE_PROPERTY] =*/ "PROPERTY",
+    /*[PRIVATE_SELECTION] =*/ "SELECTION",
+    /*[PRIVATE_WINDOW] =*/ "WINDOW",
+    /*[PRIVATE_PIXMAP] =*/ "PIXMAP",
+    /*[PRIVATE_GC] =*/ "GC",
+    /*[PRIVATE_CURSOR] =*/ "CURSOR",
+    /*[PRIVATE_CURSOR_BITS] =*/ "CURSOR_BITS",
 
     /* extension privates */
-    [PRIVATE_GLYPH] = "GLYPH",
-    [PRIVATE_GLYPHSET] = "GLYPHSET",
-    [PRIVATE_PICTURE] = "PICTURE",
-    [PRIVATE_SYNC_FENCE] = "SYNC_FENCE",
+    /*[PRIVATE_GLYPH] =*/ "GLYPH",
+    /*[PRIVATE_GLYPHSET] =*/ "GLYPHSET",
+    /*[PRIVATE_PICTURE] =*/ "PICTURE",
+    /*[PRIVATE_SYNC_FENCE] =*/ "SYNC_FENCE",
 };
 
 static const Bool screen_specific_private[PRIVATE_LAST] = {
-    [PRIVATE_SCREEN] = FALSE,
-    [PRIVATE_CLIENT] = FALSE,
-    [PRIVATE_WINDOW] = TRUE,
-    [PRIVATE_PIXMAP] = TRUE,
-    [PRIVATE_GC] = TRUE,
-    [PRIVATE_CURSOR] = FALSE,
-    [PRIVATE_COLORMAP] = FALSE,
-    [PRIVATE_DEVICE] = FALSE,
-    [PRIVATE_EXTENSION] = FALSE,
-    [PRIVATE_SELECTION] = FALSE,
-    [PRIVATE_PROPERTY] = FALSE,
-    [PRIVATE_PICTURE] = TRUE,
-    [PRIVATE_GLYPHSET] = FALSE,
+    /*[PRIVATE_XSELINUX] =*/ FALSE,
+    /*[PRIVATE_SCREEN] =*/ FALSE,
+    /*[PRIVATE_EXTENSION] =*/ FALSE,
+    /*[PRIVATE_COLORMAP] =*/ FALSE,
+    /*[PRIVATE_DEVICE] =*/ FALSE,
+    /*[PRIVATE_CLIENT] =*/ FALSE,
+    /*[PRIVATE_PROPERTY] =*/ FALSE,
+    /*[PRIVATE_SELECTION] =*/ FALSE,
+    /*[PRIVATE_WINDOW] =*/ TRUE,
+    /*[PRIVATE_PIXMAP] =*/ TRUE,
+    /*[PRIVATE_GC] =*/ TRUE,
+    /*[PRIVATE_CURSOR] =*/ FALSE,
+    /*[PRIVATE_CURSOR_BITS] =*/ FALSE,
+    /*[PRIVATE_GLYPH] =*/ FALSE,
+    /*[PRIVATE_GLYPHSET] =*/ FALSE,
+    /*[PRIVATE_PICTURE] =*/ TRUE,
+    /*[PRIVATE_SYNC_FENCE] =*/ FALSE
 };
 
 typedef Bool (*FixupFunc) (PrivatePtr *privates, int offset, unsigned bytes);
@@ -285,11 +293,23 @@ fixupDevices(FixupFunc fixup, unsigned bytes)
 }
 
 static Bool (*const allocated_early[PRIVATE_LAST]) (FixupFunc, unsigned) = {
-    [PRIVATE_SCREEN] = fixupScreens,
-    [PRIVATE_CLIENT] = fixupServerClient,
-    [PRIVATE_EXTENSION] = fixupExtensions,
-    [PRIVATE_COLORMAP] = fixupDefaultColormaps,
-    [PRIVATE_DEVICE] = fixupDevices,
+    /*PRIVATE_XSELINUX,*/     NULL,
+    /*PRIVATE_SCREEN =*/      fixupScreens,
+    /*PRIVATE_EXTENSION =*/   fixupExtensions,
+    /*PRIVATE_COLORMAP =*/    fixupDefaultColormaps,
+    /*PRIVATE_DEVICE,*/       fixupDevices,
+    /*PRIVATE_CLIENT =*/      fixupServerClient,
+    /*PRIVATE_PROPERTY,*/     NULL,
+    /*PRIVATE_SELECTION,*/    NULL,
+    /*PRIVATE_WINDOW,*/       NULL,
+    /*PRIVATE_PIXMAP,*/       NULL,
+    /*PRIVATE_GC,*/           NULL,
+    /*PRIVATE_CURSOR,*/       NULL,
+    /*PRIVATE_CURSOR_BITS,*/  NULL,
+    /*PRIVATE_GLYPH,*/        NULL,
+    /*PRIVATE_GLYPHSET,*/     NULL,
+    /*PRIVATE_PICTURE,*/      NULL,
+    /*PRIVATE_SYNC_FENCE,*/   NULL
 };
 
 static void
diff --git a/xserver/dix/property.c b/vcxsrv-code/xorg-server/dix/property.c
index 94ef5a0..48a0a67 100644
--- a/xserver/dix/property.c
+++ b/vcxsrv-code/xorg-server/dix/property.c
@@ -417,15 +417,14 @@ DeleteAllWindowProperties(WindowPtr pWin)
 static int
 NullPropertyReply(ClientPtr client, ATOM propertyType, int format)
 {
-    xGetPropertyReply reply = {
-        .type = X_Reply,
-        .format = format,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .propertyType = propertyType,
-        .bytesAfter = 0,
-        .nItems = 0
-    };
+    xGetPropertyReply reply;
+    reply.type = X_Reply;
+    reply.format = format;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
+    reply.propertyType = propertyType;
+    reply.bytesAfter = 0;
+    reply.nItems = 0;
     WriteReplyToClient(client, sizeof(xGenericReply), &reply);
     return Success;
 }
@@ -486,15 +485,14 @@ ProcGetProperty(ClientPtr client)
 
     if (((stuff->type != pProp->type) && (stuff->type != AnyPropertyType))
         ) {
-        reply = (xGetPropertyReply) {
-            .type = X_Reply,
-            .sequenceNumber = client->sequence,
-            .bytesAfter = pProp->size,
-            .format = pProp->format,
-            .length = 0,
-            .nItems = 0,
-            .propertyType = pProp->type
-        };
+        memset(&reply, 0, sizeof(xGetPropertyReply));
+        reply.type = X_Reply;
+        reply.sequenceNumber = client->sequence;
+        reply.bytesAfter = pProp->size;
+        reply.format = pProp->format;
+        reply.length = 0;
+        reply.nItems = 0;
+        reply.propertyType = pProp->type;
         WriteReplyToClient(client, sizeof(xGenericReply), &reply);
         return Success;
     }
@@ -515,15 +513,14 @@ ProcGetProperty(ClientPtr client)
 
     len = min(n - ind, 4 * stuff->longLength);
 
-    reply = (xGetPropertyReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .bytesAfter = n - (ind + len),
-        .format = pProp->format,
-        .length = bytes_to_int32(len),
-        .nItems = len / (pProp->format / 8),
-        .propertyType = pProp->type
-    };
+    memset(&reply, 0, sizeof(xGetPropertyReply));
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence,
+    reply.bytesAfter = n - (ind + len);
+    reply.format = pProp->format;
+    reply.length = bytes_to_int32(len);
+    reply.nItems = len / (pProp->format / 8);
+    reply.propertyType = pProp->type;
 
     if (stuff->delete && (reply.bytesAfter == 0))
         deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp);
@@ -598,12 +595,12 @@ ProcListProperties(ClientPtr client)
         }
     }
 
-    xlpr = (xListPropertiesReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(numProps * sizeof(Atom)),
-        .nProperties = numProps
-    };
+
+    xlpr.type = X_Reply;
+    xlpr.sequenceNumber = client->sequence;
+    xlpr.length = bytes_to_int32(numProps * sizeof(Atom));
+    xlpr.nProperties = numProps;
+    
     WriteReplyToClient(client, sizeof(xGenericReply), &xlpr);
     if (numProps) {
         client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
diff --git a/xserver/dix/ptrveloc.c b/vcxsrv-code/xorg-server/dix/ptrveloc.c
index 632971e..7efba49 100644
--- a/xserver/dix/ptrveloc.c
+++ b/vcxsrv-code/xorg-server/dix/ptrveloc.c
@@ -26,6 +26,10 @@
 #include <dix-config.h>
 #endif
 
+#ifdef _MSC_VER
+#define _USE_MATH_DEFINES
+#endif
+
 #include <math.h>
 #include <ptrveloc.h>
 #include <exevents.h>
@@ -60,6 +64,11 @@
  *
  ****************************************************************************/
 
+#ifdef _MSC_VER
+#define inline __inline
+#define lrintf(val) ((int)val)
+#endif
+
 /* fwds */
 static double
 SimpleSmoothProfile(DeviceIntPtr dev, DeviceVelocityPtr vel, double velocity,
diff --git a/xserver/dix/registry.c b/vcxsrv-code/xorg-server/dix/registry.c
index 84d48b4..aaccfbd 100644
--- a/xserver/dix/registry.c
+++ b/vcxsrv-code/xorg-server/dix/registry.c
@@ -23,6 +23,7 @@ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <X11/X.h>
 #include <X11/Xproto.h>
 #include "resource.h"
@@ -271,7 +272,7 @@ RegisterResourceName(RESTYPE resource, const char *name)
     resource &= TypeMask;
 
     while (resource >= nresource) {
-        if (!double_size(&resources, nresource, sizeof(char *)))
+        if (!double_size((void*)&resources, nresource, sizeof(char *)))
             return;
         nresource = nresource ? nresource * 2 : BASE_SIZE;
     }
@@ -318,7 +319,7 @@ dixFreeRegistry(void)
 #endif
 
 #ifdef X_REGISTRY_RESOURCE
-    free(resources);
+    free((void*)resources);
 
     resources = NULL;
     nresource = 0;
@@ -343,7 +344,7 @@ void
 dixResetRegistry(void)
 {
 #ifdef X_REGISTRY_REQUEST
-    ExtensionEntry extEntry = { .name = CORE };
+    ExtensionEntry extEntry;
 #endif
 
     dixFreeRegistry();
@@ -356,6 +357,8 @@ dixResetRegistry(void)
                    "Failed to open protocol names file " FILENAME "\n");
 
     /* Add the core protocol */
+    memset(&extEntry, 0, sizeof(extEntry));
+    extEntry.name = CORE;
     RegisterExtensionNames(&extEntry);
 #endif
 
diff --git a/xserver/dix/resource.c b/vcxsrv-code/xorg-server/dix/resource.c
index 6c0be2e..e58b048 100644
--- a/xserver/dix/resource.c
+++ b/vcxsrv-code/xorg-server/dix/resource.c
@@ -429,66 +429,66 @@ FindGCSubRes(void *value, FindAllRes func, void *cdata)
 static struct ResourceType *resourceTypes;
 
 static const struct ResourceType predefTypes[] = {
-    [RT_NONE & (RC_LASTPREDEF - 1)] = {
-                                       .deleteFunc = (DeleteType) NoopDDA,
-                                       .sizeFunc = GetDefaultBytes,
-                                       .findSubResFunc = DefaultFindSubRes,
-                                       .errorValue = BadValue,
-                                       },
-    [RT_WINDOW & (RC_LASTPREDEF - 1)] = {
-                                         .deleteFunc = DeleteWindow,
-                                         .sizeFunc = GetWindowBytes,
-                                         .findSubResFunc = FindWindowSubRes,
-                                         .errorValue = BadWindow,
-                                         },
-    [RT_PIXMAP & (RC_LASTPREDEF - 1)] = {
-                                         .deleteFunc = dixDestroyPixmap,
-                                         .sizeFunc = GetPixmapBytes,
-                                         .findSubResFunc = DefaultFindSubRes,
-                                         .errorValue = BadPixmap,
-                                         },
-    [RT_GC & (RC_LASTPREDEF - 1)] = {
-                                     .deleteFunc = FreeGC,
-                                     .sizeFunc = GetGcBytes,
-                                     .findSubResFunc = FindGCSubRes,
-                                     .errorValue = BadGC,
-                                     },
-    [RT_FONT & (RC_LASTPREDEF - 1)] = {
-                                       .deleteFunc = CloseFont,
-                                       .sizeFunc = GetDefaultBytes,
-                                       .findSubResFunc = DefaultFindSubRes,
-                                       .errorValue = BadFont,
-                                       },
-    [RT_CURSOR & (RC_LASTPREDEF - 1)] = {
-                                         .deleteFunc = FreeCursor,
-                                         .sizeFunc = GetDefaultBytes,
-                                         .findSubResFunc = DefaultFindSubRes,
-                                         .errorValue = BadCursor,
-                                         },
-    [RT_COLORMAP & (RC_LASTPREDEF - 1)] = {
-                                           .deleteFunc = FreeColormap,
-                                           .sizeFunc = GetDefaultBytes,
-                                           .findSubResFunc = DefaultFindSubRes,
-                                           .errorValue = BadColor,
-                                           },
-    [RT_CMAPENTRY & (RC_LASTPREDEF - 1)] = {
-                                            .deleteFunc = FreeClientPixels,
-                                            .sizeFunc = GetDefaultBytes,
-                                            .findSubResFunc = DefaultFindSubRes,
-                                            .errorValue = BadColor,
-                                            },
-    [RT_OTHERCLIENT & (RC_LASTPREDEF - 1)] = {
-                                              .deleteFunc = OtherClientGone,
-                                              .sizeFunc = GetDefaultBytes,
-                                              .findSubResFunc = DefaultFindSubRes,
-                                              .errorValue = BadValue,
-                                              },
-    [RT_PASSIVEGRAB & (RC_LASTPREDEF - 1)] = {
-                                              .deleteFunc = DeletePassiveGrab,
-                                              .sizeFunc = GetDefaultBytes,
-                                              .findSubResFunc = DefaultFindSubRes,
-                                              .errorValue = BadValue,
-                                              },
+  /* [RT_NONE & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */(DeleteType)NoopDDA,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadValue,
+    },
+  /* [RT_WINDOW & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */DeleteWindow,
+  /*.sizeFunc = */GetWindowBytes,
+  /*.findSubResFunc = */FindWindowSubRes,
+  /*.errorValue = */BadWindow,
+    },
+  /* [RT_PIXMAP & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */dixDestroyPixmap,
+  /*.sizeFunc = */GetPixmapBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadPixmap,
+    },
+  /* [RT_GC & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */FreeGC,
+  /*.sizeFunc = */GetGcBytes,
+  /*.findSubResFunc = */FindGCSubRes,
+  /*.errorValue = */BadGC,
+    },
+  /* [RT_FONT & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */CloseFont,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadFont,
+    },
+  /* [RT_CURSOR & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */FreeCursor,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadCursor,
+    },
+  /* [RT_COLORMAP & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */FreeColormap,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadColor,
+    },
+  /* [RT_CMAPENTRY & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */FreeClientPixels,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadColor,
+    },
+  /* [RT_OTHERCLIENT & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */OtherClientGone,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadValue,
+    },
+  /* [RT_PASSIVEGRAB & (RC_LASTPREDEF - 1)] = */ {
+  /*.deleteFunc = */DeletePassiveGrab,
+  /*.sizeFunc = */GetDefaultBytes,
+  /*.findSubResFunc = */DefaultFindSubRes,
+  /*.errorValue = */BadValue,
+    },
 };
 
 CallbackListPtr ResourceStateCallback;
@@ -812,7 +812,7 @@ AddResource(XID id, RESTYPE type, void *value)
     rrec = &clientTable[client];
     if (!rrec->buckets) {
         ErrorF("[dix] AddResource(%lx, %x, %lx), client=%d \n",
-               (unsigned long) id, type, (unsigned long) value, client);
+               (unsigned long) id, type, (unsigned long)(uintptr_t) value, client);
         FatalError("client not in use\n");
     }
     if ((rrec->elements >= 4 * rrec->buckets) && (rrec->hashsize < MAXHASHSIZE))
diff --git a/xserver/dix/selection.c b/vcxsrv-code/xorg-server/dix/selection.c
index d46103f..06cc47d 100644
--- a/xserver/dix/selection.c
+++ b/vcxsrv-code/xorg-server/dix/selection.c
@@ -181,11 +181,11 @@ ProcSetSelectionOwner(ClientPtr client)
         if (CompareTimeStamps(time, pSel->lastTimeChanged) == EARLIER)
             return Success;
         if (pSel->client && (!pWin || (pSel->client != client))) {
-            xEvent event = {
-                .u.selectionClear.time = time.milliseconds,
-                .u.selectionClear.window = pSel->window,
-                .u.selectionClear.atom = pSel->selection
-            };
+            xEvent event;
+            event.u.selectionClear.time = time.milliseconds;
+            event.u.selectionClear.window = pSel->window;
+            event.u.selectionClear.atom = pSel->selection;
+            
             event.u.u.type = SelectionClear;
             WriteEventsToClient(pSel->client, 1, &event);
         }
@@ -238,11 +238,10 @@ ProcGetSelectionOwner(ClientPtr client)
         return BadAtom;
     }
 
-    reply = (xGetSelectionOwnerReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-    };
+    memset(&reply, 0, sizeof(xGetSelectionOwnerReply));
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.length = 0;
 
     rc = dixLookupSelection(&pSel, stuff->id, client, DixGetAttrAccess);
     if (rc == Success)
diff --git a/xserver/dix/swapreq.c b/vcxsrv-code/xorg-server/dix/swapreq.c
index 6785059..6d4365b 100644
--- a/xserver/dix/swapreq.c
+++ b/vcxsrv-code/xorg-server/dix/swapreq.c
@@ -283,7 +283,7 @@ SProcConvertSelection(ClientPtr client)
 int _X_COLD
 SProcSendEvent(ClientPtr client)
 {
-    xEvent eventT = { .u.u.type = 0 };
+    xEvent eventT;
     EventSwapPtr proc;
 
     REQUEST(xSendEventReq);
@@ -303,6 +303,7 @@ SProcSendEvent(ClientPtr client)
     proc = EventSwapVector[stuff->event.u.u.type & 0177];
     if (!proc || proc == NotImplemented)        /* no swapping proc; invalid event type? */
         return BadValue;
+    eventT.u.u.type = 0;
     (*proc) (&stuff->event, &eventT);
     stuff->event = eventT;
 
diff --git a/xserver/dix/window.c b/vcxsrv-code/xorg-server/dix/window.c
index cd917f0..eed1e74 100644
--- a/xserver/dix/window.c
+++ b/vcxsrv-code/xorg-server/dix/window.c
@@ -939,16 +939,16 @@ CreateWindow(Window wid, WindowPtr pParent, int x, int y, unsigned w,
     }
 
     if (SubSend(pParent)) {
-        xEvent event = {
-            .u.createNotify.window = wid,
-            .u.createNotify.parent = pParent->drawable.id,
-            .u.createNotify.x = x,
-            .u.createNotify.y = y,
-            .u.createNotify.width = w,
-            .u.createNotify.height = h,
-            .u.createNotify.borderWidth = bw,
-            .u.createNotify.override = pWin->overrideRedirect
-        };
+        xEvent event; memset(&event, 0, sizeof(xEvent));
+        event.u.createNotify.window = wid;
+        event.u.createNotify.parent = pParent->drawable.id;
+        event.u.createNotify.x = x;
+        event.u.createNotify.y = y;
+        event.u.createNotify.width = w;
+        event.u.createNotify.height = h;
+        event.u.createNotify.borderWidth = bw;
+        event.u.createNotify.override = pWin->overrideRedirect;
+        
         event.u.u.type = CreateNotify;
         DeliverEvents(pParent, &event, 1, NullWindow);
     }
@@ -1036,7 +1036,9 @@ CrushTree(WindowPtr pWin)
         while (1) {
             pParent = pChild->parent;
             if (SubStrSend(pChild, pParent)) {
-                xEvent event = { .u.u.type = DestroyNotify };
+                xEvent event;
+                memset(&event, 0, sizeof(xEvent));
+                event.u.u.type = DestroyNotify;
                 event.u.destroyNotify.window = pChild->drawable.id;
                 DeliverEvents(pChild, &event, 1, NullWindow);
             }
@@ -1078,7 +1080,9 @@ DeleteWindow(void *value, XID wid)
 
     pParent = pWin->parent;
     if (wid && pParent && SubStrSend(pWin, pParent)) {
-        xEvent event = { .u.u.type = DestroyNotify };
+        xEvent event;
+        memset(&event, 0, sizeof(xEvent));
+        event.u.u.type = DestroyNotify;
         event.u.destroyNotify.window = pWin->drawable.id;
         DeliverEvents(pWin, &event, 1, NullWindow);
     }
@@ -1468,12 +1472,12 @@ ChangeWindowAttributes(WindowPtr pWin, Mask vmask, XID *vlist, ClientPtr client)
                         CheckWindowOptionalNeed(pChild);
                 }
 
-                xE = (xEvent) {
-                    .u.colormap.window = pWin->drawable.id,
-                    .u.colormap.colormap = cmap,
-                    .u.colormap.new = xTrue,
-                    .u.colormap.state = IsMapInstalled(cmap, pWin)
-                };
+
+                xE.u.colormap.window = pWin->drawable.id;
+                xE.u.colormap.colormap = cmap;
+                xE.u.colormap.new = xTrue;
+                xE.u.colormap.state = IsMapInstalled(cmap, pWin);
+                
                 xE.u.u.type = ColormapNotify;
                 DeliverEvents(pWin, &xE, 1, NullWindow);
             }
@@ -1859,11 +1863,11 @@ ResizeChildrenWinSize(WindowPtr pWin, int dx, int dy, int dw, int dh)
             GravityTranslate(cwsx, cwsy, cwsx - dx, cwsy - dy, dw, dh,
                              pSib->winGravity, &cwsx, &cwsy);
             if (cwsx != pSib->origin.x || cwsy != pSib->origin.y) {
-                xEvent event = {
-                    .u.gravity.window = pSib->drawable.id,
-                    .u.gravity.x = cwsx - wBorderWidth(pSib),
-                    .u.gravity.y = cwsy - wBorderWidth(pSib)
-                };
+                xEvent event;
+                event.u.gravity.window = pSib->drawable.id;
+                event.u.gravity.x = cwsx - wBorderWidth(pSib);
+                event.u.gravity.y = cwsy - wBorderWidth(pSib);
+                
                 event.u.u.type = GravityNotify;
                 DeliverEvents(pSib, &event, 1, NullWindow);
                 pSib->origin.x = cwsx;
@@ -2285,17 +2289,17 @@ ConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
         pSib = pWin->nextSib;
 
     if ((!pWin->overrideRedirect) && (RedirectSend(pParent))) {
-        xEvent event = {
-            .u.configureRequest.window = pWin->drawable.id,
-            .u.configureRequest.sibling = (mask & CWSibling) ? sibwid : None,
-            .u.configureRequest.x = x,
-            .u.configureRequest.y = y,
-            .u.configureRequest.width = w,
-            .u.configureRequest.height = h,
-            .u.configureRequest.borderWidth = bw,
-            .u.configureRequest.valueMask = mask,
-            .u.configureRequest.parent = pParent->drawable.id
-        };
+        xEvent event; memset(&event, 0, sizeof(xEvent));
+        event.u.configureRequest.window = pWin->drawable.id;
+        event.u.configureRequest.sibling = (mask & CWSibling) ? sibwid : None;
+        event.u.configureRequest.x = x;
+        event.u.configureRequest.y = y;
+        event.u.configureRequest.width = w;
+        event.u.configureRequest.height = h;
+        event.u.configureRequest.borderWidth = bw;
+        event.u.configureRequest.valueMask = mask;
+        event.u.configureRequest.parent = pParent->drawable.id;
+
         event.u.u.type = ConfigureRequest;
         event.u.u.detail = (mask & CWStackMode) ? smode : Above;
 #ifdef PANORAMIX
@@ -2314,11 +2318,11 @@ ConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
 
         if (size_change &&
             ((pWin->eventMask | wOtherEventMasks(pWin)) & ResizeRedirectMask)) {
-            xEvent eventT = {
-                .u.resizeRequest.window = pWin->drawable.id,
-                .u.resizeRequest.width = w,
-                .u.resizeRequest.height = h
-            };
+            xEvent eventT; memset(&eventT, 0, sizeof(xEvent));
+            eventT.u.resizeRequest.window = pWin->drawable.id;
+            eventT.u.resizeRequest.width = w;
+            eventT.u.resizeRequest.height = h;
+            
             eventT.u.u.type = ResizeRequest;
             if (MaybeDeliverEventsToClient(pWin, &eventT, 1,
                                            ResizeRedirectMask, client) == 1) {
@@ -2370,16 +2374,16 @@ ConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
     }
 
     if (SubStrSend(pWin, pParent)) {
-        xEvent event = {
-            .u.configureNotify.window = pWin->drawable.id,
-            .u.configureNotify.aboveSibling = pSib ? pSib->drawable.id : None,
-            .u.configureNotify.x = x,
-            .u.configureNotify.y = y,
-            .u.configureNotify.width = w,
-            .u.configureNotify.height = h,
-            .u.configureNotify.borderWidth = bw,
-            .u.configureNotify.override = pWin->overrideRedirect
-        };
+        xEvent event; memset(&event, 0, sizeof(xEvent));
+        event.u.configureNotify.window = pWin->drawable.id;
+        event.u.configureNotify.aboveSibling = pSib ? pSib->drawable.id : None;
+        event.u.configureNotify.x = x;
+        event.u.configureNotify.y = y;
+        event.u.configureNotify.width = w;
+        event.u.configureNotify.height = h;
+        event.u.configureNotify.borderWidth = bw;
+        event.u.configureNotify.override = pWin->overrideRedirect;
+        
         event.u.u.type = ConfigureNotify;
 #ifdef PANORAMIX
         if (!noPanoramiXExtension && (!pParent || !pParent->parent)) {
@@ -2459,13 +2463,12 @@ CirculateWindow(WindowPtr pParent, int direction, ClientPtr client)
             return Success;
     }
 
-    event = (xEvent) {
-        .u.circulate.window = pWin->drawable.id,
-        .u.circulate.parent = pParent->drawable.id,
-        .u.circulate.event = pParent->drawable.id,
-        .u.circulate.place = (direction == RaiseLowest) ?
-                              PlaceOnTop : PlaceOnBottom,
-    };
+
+    event.u.circulate.window = pWin->drawable.id;
+    event.u.circulate.parent = pParent->drawable.id;
+    event.u.circulate.event = pParent->drawable.id;
+    event.u.circulate.place = (direction == RaiseLowest) ?
+                              PlaceOnTop : PlaceOnBottom;
 
     if (RedirectSend(pParent)) {
         event.u.u.type = CirculateRequest;
@@ -2518,13 +2521,13 @@ ReparentWindow(WindowPtr pWin, WindowPtr pParent,
     if (WasMapped)
         UnmapWindow(pWin, FALSE);
 
-    event = (xEvent) {
-        .u.reparent.window = pWin->drawable.id,
-        .u.reparent.parent = pParent->drawable.id,
-        .u.reparent.x = x,
-        .u.reparent.y = y,
-        .u.reparent.override = pWin->overrideRedirect
-    };
+    memset(&event, 0, sizeof(xEvent));
+    event.u.reparent.window = pWin->drawable.id;
+    event.u.reparent.parent = pParent->drawable.id;
+    event.u.reparent.x = x;
+    event.u.reparent.y = y;
+    event.u.reparent.override = pWin->overrideRedirect;
+    
     event.u.u.type = ReparentNotify;
 #ifdef PANORAMIX
     if (!noPanoramiXExtension && !pParent->parent) {
@@ -2620,10 +2623,10 @@ RealizeTree(WindowPtr pWin)
 static Bool
 MaybeDeliverMapRequest(WindowPtr pWin, WindowPtr pParent, ClientPtr client)
 {
-    xEvent event = {
-        .u.mapRequest.window = pWin->drawable.id,
-        .u.mapRequest.parent = pParent->drawable.id
-    };
+    xEvent event; memset(&event, 0, sizeof(event));
+    event.u.mapRequest.window = pWin->drawable.id;
+    event.u.mapRequest.parent = pParent->drawable.id;
+
     event.u.u.type = MapRequest;
 
     return MaybeDeliverEventsToClient(pParent, &event, 1,
@@ -2634,10 +2637,10 @@ MaybeDeliverMapRequest(WindowPtr pWin, WindowPtr pParent, ClientPtr client)
 static void
 DeliverMapNotify(WindowPtr pWin)
 {
-    xEvent event = {
-        .u.mapNotify.window = pWin->drawable.id,
-        .u.mapNotify.override = pWin->overrideRedirect,
-    };
+    xEvent event; memset(&event, 0, sizeof(event));
+    event.u.mapNotify.window = pWin->drawable.id;
+    event.u.mapNotify.override = pWin->overrideRedirect;
+
     event.u.u.type = MapNotify;
     DeliverEvents(pWin, &event, 1, NullWindow);
 }
@@ -2825,10 +2828,10 @@ UnrealizeTree(WindowPtr pWin, Bool fromConfigure)
 static void
 DeliverUnmapNotify(WindowPtr pWin, Bool fromConfigure)
 {
-    xEvent event = {
-        .u.unmapNotify.window = pWin->drawable.id,
-        .u.unmapNotify.fromConfigure = fromConfigure
-    };
+    xEvent event; memset(&event, 0, sizeof(event));
+    event.u.unmapNotify.window = pWin->drawable.id;
+    event.u.unmapNotify.fromConfigure = fromConfigure;
+
     event.u.u.type = UnmapNotify;
     DeliverEvents(pWin, &event, 1, NullWindow);
 }
@@ -3081,10 +3084,10 @@ SendVisibilityNotify(WindowPtr pWin)
     }
 #endif
 
-    event = (xEvent) {
-        .u.visibility.window = pWin->drawable.id,
-        .u.visibility.state = visibility
-    };
+    memset(&event, 0, sizeof(xEvent));
+    event.u.visibility.window = pWin->drawable.id;
+    event.u.visibility.state = visibility;
+    
     event.u.u.type = VisibilityNotify;
     DeliverEvents(pWin, &event, 1, NullWindow);
 }
diff --git a/xserver/exa/exa_accel.c b/vcxsrv-code/xorg-server/exa/exa_accel.c
index e632331..6662da9 100644
--- a/xserver/exa/exa_accel.c
+++ b/vcxsrv-code/xorg-server/exa/exa_accel.c
@@ -236,7 +236,7 @@ exaPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
                          bits);
 }
 
-static Bool inline
+static Bool __inline
 exaCopyNtoNTwoDir(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
                   GCPtr pGC, BoxPtr pbox, int nbox, int dx, int dy)
 {
diff --git a/xserver/exa/exa_migration_classic.c b/vcxsrv-code/xorg-server/exa/exa_migration_classic.c
index f712e19..89eff62 100644
--- a/xserver/exa/exa_migration_classic.c
+++ b/vcxsrv-code/xorg-server/exa/exa_migration_classic.c
@@ -379,8 +379,8 @@ exaDoMoveInPixmap(ExaMigrationPtr migrate)
 void
 exaMoveInPixmap_classic(PixmapPtr pPixmap)
 {
-    static ExaMigrationRec migrate = {.as_dst = FALSE,.as_src = TRUE,
-        .pReg = NULL
+    static ExaMigrationRec migrate =  {FALSE, TRUE,
+        NULL, NULL
     };
 
     migrate.pPix = pPixmap;
@@ -422,8 +422,8 @@ exaDoMoveOutPixmap(ExaMigrationPtr migrate)
 void
 exaMoveOutPixmap_classic(PixmapPtr pPixmap)
 {
-    static ExaMigrationRec migrate = {.as_dst = FALSE,.as_src = TRUE,
-        .pReg = NULL
+    static ExaMigrationRec migrate = { FALSE, TRUE,
+        NULL, NULL
     };
 
     migrate.pPix = pPixmap;
@@ -628,7 +628,7 @@ exaDoMigration_classic(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel)
             if (!exaPixmapIsDirty(pixmaps[i].pPix) &&
                 !exaAssertNotDirty(pixmaps[i].pPix))
                 ErrorF("%s: Pixmap %d dirty but not marked as such!\n",
-                       __func__, i);
+                       __FUNCTION__, i);
         }
     }
     /* If anything is pinned in system memory, we won't be able to
diff --git a/xserver/exa/exa_unaccel.c b/vcxsrv-code/xorg-server/exa/exa_unaccel.c
index ed1401a..eaa65de 100644
--- a/xserver/exa/exa_unaccel.c
+++ b/vcxsrv-code/xorg-server/exa/exa_unaccel.c
@@ -727,7 +727,7 @@ exaGetPixmapFirstPixel(PixmapPtr pPixmap)
         return pixel;
     }
     default:
-        FatalError("%s called for invalid bpp %d\n", __func__,
+        FatalError("%s called for invalid bpp %d\n", __FUNCTION__,
                    pPixmap->drawable.bitsPerPixel);
     }
 }
diff --git a/xserver/fb/fb.h b/vcxsrv-code/xorg-server/fb/fb.h
index 8ab050d..969851e 100644
--- a/xserver/fb/fb.h
+++ b/vcxsrv-code/xorg-server/fb/fb.h
@@ -69,7 +69,7 @@
 #define FBPREFIX(x) fb##x
 #define WRITE(ptr, val) (*(ptr) = (val))
 #define READ(ptr) (*(ptr))
-#define MEMCPY_WRAPPED(dst, src, size) memcpy((dst), (src), (size))
+#define MEMCPY_WRAPPED(dst, src, size) memmove((dst), (src), (size))
 #define MEMSET_WRAPPED(dst, val, size) memset((dst), (val), (size))
 
 #endif
diff --git a/xserver/fb/fbgetsp.c b/vcxsrv-code/xorg-server/fb/fbgetsp.c
index 445a4e3..7cd63d9 100644
--- a/xserver/fb/fbgetsp.c
+++ b/vcxsrv-code/xorg-server/fb/fbgetsp.c
@@ -47,7 +47,7 @@ fbGetSpans(DrawablePtr pDrawable,
     fbGetDrawable(pDrawable, src, srcStride, srcBpp, srcXoff, srcYoff);
 
     while (nspans--) {
-        xoff = (int) (((long) pchardstStart) & (FB_MASK >> 3));
+        xoff = (int) (((long)(uintptr_t) pchardstStart) & (FB_MASK >> 3));
         dst = (FbBits *) (pchardstStart - xoff);
         xoff <<= 3;
         fbBlt(src + (ppt->y + srcYoff) * srcStride, srcStride,
diff --git a/xserver/fb/fboverlay.c b/vcxsrv-code/xorg-server/fb/fboverlay.c
index d47a7c6..2e4588e 100644
--- a/xserver/fb/fboverlay.c
+++ b/vcxsrv-code/xorg-server/fb/fboverlay.c
@@ -220,7 +220,7 @@ fbOverlayCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
             miCopyRegion(&pPixmap->drawable, &pPixmap->drawable,
                          0,
                          &layerRgn[i], dx, dy, pScrPriv->CopyWindow, 0,
-                         (void *) (long) i);
+                         (void *) (uintptr_t) i);
         }
     }
     /*
diff --git a/xserver/fb/fbpixmap.c b/vcxsrv-code/xorg-server/fb/fbpixmap.c
index af5d7be..5bc32ef 100644
--- a/xserver/fb/fbpixmap.c
+++ b/vcxsrv-code/xorg-server/fb/fbpixmap.c
@@ -290,24 +290,14 @@ fbPixmapToRegion(PixmapPtr pPix)
 
 #ifdef FB_DEBUG
 
-#ifndef WIN32
 #include <stdio.h>
-#else
-#include <dbg.h>
-#endif
 
 static Bool
 fbValidateBits(FbStip * bits, int stride, FbStip data)
 {
     while (stride--) {
         if (*bits != data) {
-#ifdef WIN32
-            NCD_DEBUG((DEBUG_FAILURE,
-                       "fdValidateBits failed at 0x%x (is 0x%x want 0x%x)",
-                       bits, *bits, data));
-#else
-            fprintf(stderr, "fbValidateBits failed\n");
-#endif
+            fprintf (stderr, "fbValidateBits failed at 0x%x (is 0x%x want 0x%x)\n",bits, *bits, data);
             return FALSE;
         }
         bits++;
diff --git a/xserver/fb/fbsetsp.c b/vcxsrv-code/xorg-server/fb/fbsetsp.c
index fe94e28..6372b38 100644
--- a/xserver/fb/fbsetsp.c
+++ b/vcxsrv-code/xorg-server/fb/fbsetsp.c
@@ -45,7 +45,7 @@ fbSetSpans(DrawablePtr pDrawable,
     fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
     while (nspans--) {
         d = dst + (ppt->y + dstYoff) * dstStride;
-        xoff = (int) (((long) src) & (FB_MASK >> 3));
+        xoff = (int) (((long)(uintptr_t) src) & (FB_MASK >> 3));
         s = (FbBits *) (src - xoff);
         xoff <<= 3;
         n = RegionNumRects(pClip);
diff --git a/xserver/fb/fbwindow.c b/vcxsrv-code/xorg-server/fb/fbwindow.c
index fca871d..258ab8a 100644
--- a/xserver/fb/fbwindow.c
+++ b/vcxsrv-code/xorg-server/fb/fbwindow.c
@@ -77,21 +77,60 @@ fbCopyWindowProc(DrawablePtr pSrcDrawable,
     FbBits *dst;
     FbStride dstStride;
     int dstBpp;
+    int numerr = 0;
     int dstXoff, dstYoff;
 
     fbGetDrawable(pSrcDrawable, src, srcStride, srcBpp, srcXoff, srcYoff);
     fbGetDrawable(pDstDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
 
-    while (nbox--) {
-        fbBlt(src + (pbox->y1 + dy + srcYoff) * srcStride,
-              srcStride,
-              (pbox->x1 + dx + srcXoff) * srcBpp,
-              dst + (pbox->y1 + dstYoff) * dstStride,
-              dstStride,
-              (pbox->x1 + dstXoff) * dstBpp,
-              (pbox->x2 - pbox->x1) * dstBpp,
-              (pbox->y2 - pbox->y1),
-              GXcopy, FB_ALLONES, dstBpp, reverse, upsidedown);
+    while (nbox--)
+    {
+        int srcYoffset = pbox->y1 + dy + srcYoff;
+        int dstYoffset = pbox->y1 + dstYoff;
+        int copyLines = (pbox->y2 - pbox->y1);
+        int copyLines_src = copyLines;
+        int copyLines_dst = copyLines;
+
+        // There is a crash with BitBlt, when moving bits on same source, but shifted for some pixels
+        if (srcYoffset >= pSrcDrawable->height ||
+            dstYoffset >= pDstDrawable->height )
+        {
+            numerr++;
+            ErrorF("fbCopyWindowProc ERROR\n");
+        }
+        else
+        {
+            if (srcYoffset < 0 )
+            {
+                copyLines_src += srcYoffset+1;
+                srcYoffset = 0;
+            }
+            else if ( (srcYoffset+copyLines) > pSrcDrawable->height )
+            {
+                copyLines_src = pSrcDrawable->height - srcYoffset;
+            }
+
+            if (dstYoffset < 0 )
+            {
+                copyLines_dst += dstYoffset+1;
+                dstYoffset = 0;
+            }
+            else if ( (dstYoffset+copyLines) > pDstDrawable->height )
+            {
+                copyLines_dst = pDstDrawable->height - dstYoffset;
+            }
+            copyLines = copyLines_src < copyLines_dst ? copyLines_src : copyLines_dst;
+
+            fbBlt(src + srcYoffset * srcStride,
+                  srcStride,
+                  (pbox->x1 + dx + srcXoff) * srcBpp,
+                  dst + dstYoffset * dstStride,
+                  dstStride,
+                  (pbox->x1 + dstXoff) * dstBpp,
+                  (pbox->x2 - pbox->x1) * dstBpp,
+                  copyLines,
+                  GXcopy, FB_ALLONES, dstBpp, reverse, upsidedown);
+        }
         pbox++;
     }
 
diff --git a/xserver/fb/wfbrename.h b/vcxsrv-code/xorg-server/fb/wfbrename.h
index ffdcbed..47b17e2 100644
--- a/xserver/fb/wfbrename.h
+++ b/vcxsrv-code/xorg-server/fb/wfbrename.h
@@ -28,7 +28,6 @@
 #define fbCopyNto1 wfbCopyNto1
 #define fbCopyNtoN wfbCopyNtoN
 #define fbCopyPlane wfbCopyPlane
-#define fbCopyRegion wfbCopyRegion
 #define fbCopyWindow wfbCopyWindow
 #define fbCopyWindowProc wfbCopyWindowProc
 #define fbCreateDefColormap wfbCreateDefColormap
@@ -38,7 +37,6 @@
 #define fbDestroyGlyphCache wfbDestroyGlyphCache
 #define fbDestroyPixmap wfbDestroyPixmap
 #define fbDestroyWindow wfbDestroyWindow
-#define fbDoCopy wfbDoCopy
 #define fbDots wfbDots
 #define fbDots16 wfbDots16
 #define fbDots32 wfbDots32
diff --git a/xserver/glx/glxcmds.c b/vcxsrv-code/xorg-server/glx/glxcmds.c
index fc26a2e..6501844 100644
--- a/xserver/glx/glxcmds.c
+++ b/vcxsrv-code/xorg-server/glx/glxcmds.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <string.h>
 #include <assert.h>
@@ -49,6 +50,13 @@
 #include "protocol-versions.h"
 #include "glxvndabi.h"
 
+#include "glfunctions.h"
+
+#ifdef PANORAMIX
+#include "panoramiX.h"
+#include "panoramiXsrv.h"
+#endif
+
 static char GLXServerVendorName[] = "SGI";
 
 _X_HIDDEN int
@@ -514,6 +522,65 @@ __glXGetDrawable(__GLXcontext * glxc, GLXDrawable drawId, ClientPtr client,
         return NULL;
     }
 
+#ifdef PANORAMIX
+    if (!noPanoramiXExtension)
+    {
+      PanoramiXRes *draw;
+
+      rc = dixLookupResourceByClass((void **)&draw, drawId, XRC_DRAWABLE, client, DixGetAttrAccess);
+
+      if (rc != Success)
+      {
+        client->errorValue = drawId;
+        *error = (rc == BadValue) ? BadDrawable : rc;
+        return NULL;
+      }
+
+      if (!IS_SHARED_PIXMAP(draw))
+      {
+        int j;
+        __GLXdrawable **ret=malloc(screenInfo.numScreens*sizeof(__GLXdrawable *));
+
+        for (j = screenInfo.numScreens-1; j >= 0; j--)
+        {
+          GLXDrawable drawId = draw->info[j].id;
+
+          rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixGetAttrAccess);
+
+          if (rc != Success || pDraw->type != DRAWABLE_WINDOW)
+          {
+            client->errorValue = drawId;
+            *error = __glXError(GLXBadDrawable);
+            return NULL;
+          }
+
+          if (!validGlxFBConfigForWindow(client, glxc->config, pDraw, error))
+            return NULL;
+
+          __GLXscreen *pGlxScreen = glxGetScreen(screenInfo.screens[j]);
+          pGlxDraw = pGlxScreen->createDrawable(client, pGlxScreen, pDraw, drawId,
+                                                GLX_DRAWABLE_WINDOW, drawId, glxc->config);
+          if (!pGlxDraw)
+          {
+            client->errorValue = drawId;
+            *error = BadMatch;
+            return NULL;
+          }
+
+          /* since we are creating the drawablePrivate, drawId should be new */
+          if (!AddResource(drawId, __glXDrawableRes, pGlxDraw))
+          {
+            *error = BadAlloc;
+            return NULL;
+          }
+          ret[j]=pGlxDraw;
+        }
+        pGlxDraw->pAll=ret;
+        return pGlxDraw;
+      }
+    }
+#endif
+
     /* The drawId wasn't a GLX drawable.  Make sure it's a window and
      * create a GLXWindow for it.  Check that the drawable screen
      * matches the context screen and that the context fbconfig is
@@ -526,12 +593,12 @@ __glXGetDrawable(__GLXcontext * glxc, GLXDrawable drawId, ClientPtr client,
         return NULL;
     }
 
-    pGlxScreen = glxc->pGlxScreen;
-    if (pDraw->pScreen != pGlxScreen->pScreen) {
+    if (!glxc || pDraw->pScreen != glxc->pGlxScreen->pScreen) {
         client->errorValue = pDraw->pScreen->myNum;
         *error = BadMatch;
         return NULL;
     }
+    pGlxScreen = glxc->pGlxScreen;
 
     config = glxc->config;
     if (!config)
@@ -555,9 +622,11 @@ __glXGetDrawable(__GLXcontext * glxc, GLXDrawable drawId, ClientPtr client,
 
     pGlxDraw = pGlxScreen->createDrawable(client, pGlxScreen, pDraw, drawId,
                                           GLX_DRAWABLE_WINDOW, drawId, config);
-    if (!pGlxDraw) {
-	*error = BadAlloc;
-	return NULL;
+    if (!pGlxDraw)
+    {
+        client->errorValue = drawId;
+        *error = BadMatch;
+        return NULL;
     }
 
     /* since we are creating the drawablePrivate, drawId should be new */
@@ -1158,13 +1227,19 @@ __glXDrawableInit(__GLXdrawable * drawable,
     drawable->drawId = drawId;
     drawable->config = config;
     drawable->eventMask = 0;
-
+#ifdef PANORAMIX
+    drawable->pAll = NULL;
+#endif
     return GL_TRUE;
 }
 
 void
 __glXDrawableRelease(__GLXdrawable * drawable)
 {
+#ifdef PANORAMIX
+    if (drawable->pAll)
+      free(drawable->pAll);
+#endif
 }
 
 static int
@@ -1655,7 +1730,7 @@ DoQueryContext(__GLXclientState * cl, GLXContextID gcId)
     ClientPtr client = cl->client;
     __GLXcontext *ctx;
     xGLXQueryContextInfoEXTReply reply;
-    int nProps = 5;
+    #define nProps 5
     int sendBuf[nProps * 2];
     int nReplyBytes;
     int err;
diff --git a/xserver/glx/glxcmdsswap.c b/vcxsrv-code/xorg-server/glx/glxcmdsswap.c
index 7d66744..e4a01bf 100644
--- a/xserver/glx/glxcmdsswap.c
+++ b/vcxsrv-code/xorg-server/glx/glxcmdsswap.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <string.h>
 #include "glxserver.h"
@@ -40,6 +41,7 @@
 #include <pixmapstr.h>
 #include <windowstr.h>
 #include "glxext.h"
+#include "GL/gl.h"
 #include "indirect_dispatch.h"
 #include "indirect_table.h"
 #include "indirect_util.h"
diff --git a/xserver/glx/glxdrawable.h b/vcxsrv-code/xorg-server/glx/glxdrawable.h
index 441d72d..4cfe569 100644
--- a/xserver/glx/glxdrawable.h
+++ b/vcxsrv-code/xorg-server/glx/glxdrawable.h
@@ -72,6 +72,10 @@ struct __GLXdrawable {
      ** Event mask
      */
     unsigned long eventMask;
+
+#ifdef PANORAMIX
+    struct __GLXdrawable ** pAll;  /* Points the array containing the drawables for all screens */
+#endif
 };
 
 extern int validGlxDrawable(ClientPtr client, XID id, int type, int access_mode,
diff --git a/xserver/glx/glxdricommon.c b/vcxsrv-code/xorg-server/glx/glxdricommon.c
index 35a5396..d688a13 100644
--- a/xserver/glx/glxdricommon.c
+++ b/vcxsrv-code/xorg-server/glx/glxdricommon.c
@@ -25,6 +25,10 @@
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+
+#include "glheader.h"
+
 #endif
 
 #include <ctype.h>
@@ -43,6 +47,12 @@
 #include "glxscreens.h"
 #include "glxdricommon.h"
 
+#ifdef _MSC_VER
+#define dlerror() "Getting loadlibrary error string not implemented"
+#endif
+
+
+
 #define __ATTRIB(attrib, field) \
     { attrib, offsetof(__GLXconfig, field) }
 
@@ -320,10 +330,18 @@ glxProbeDriver(const char *driverName,
             next = NULL;
         }
 
+#ifdef _MSC_VER
+#define DLLNAME "%.*s%s_dri.dll"
+        snprintf(filename, sizeof filename, DLLNAME, path_len, path,
+                 driverName);
+
+        driver = LoadLibrary(filename);
+#else
         snprintf(filename, sizeof filename, "%.*s/%s_dri.so", path_len, path,
                  driverName);
 
         driver = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);
+#endif
         if (driver != NULL)
             break;
 
@@ -352,14 +370,22 @@ glxProbeDriver(const char *driverName,
                 get_extensions_name[i] = '_';
         }
 
+#ifdef _MSC_VER
+        get_extensions = (const __DRIextension **(*)(void))GetProcAddress(driver, get_extensions_name);
+#else
         get_extensions = dlsym(driver, get_extensions_name);
+#endif
         if (get_extensions)
             extensions = get_extensions();
         free(get_extensions_name);
     }
 
     if (!extensions)
+#ifdef _MSC_VER
+        extensions = (const __DRIextension **)GetProcAddress(driver, __DRI_DRIVER_EXTENSIONS);
+#else
         extensions = dlsym(driver, __DRI_DRIVER_EXTENSIONS);
+#endif
     if (extensions == NULL) {
         LogMessage(X_ERROR, "AIGLX error: %s exports no extensions (%s)\n",
                    driverName, dlerror());
@@ -388,7 +414,11 @@ glxProbeDriver(const char *driverName,
 
  cleanup_failure:
     if (driver)
+#ifdef _MSC_VER
+        FreeLibrary(driver);
+#else
         dlclose(driver);
+#endif
     *coreExt = *renderExt = NULL;
     return NULL;
 }
diff --git a/xserver/glx/glxdriswrast.c b/vcxsrv-code/xorg-server/glx/glxdriswrast.c
index c57d80d..d5f9f81 100644
--- a/xserver/glx/glxdriswrast.c
+++ b/vcxsrv-code/xorg-server/glx/glxdriswrast.c
@@ -27,6 +27,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <stdint.h>
 #include <stdio.h>
@@ -276,6 +277,11 @@ __glXDRIscreenCreateDrawable(ClientPtr client,
     private->driDrawable =
         (*driScreen->swrast->createNewDrawable) (driScreen->driScreen,
                                                  config->driConfig, private);
+    if (!private->driDrawable)
+    {
+        free(private);
+        return NULL;
+    }
 
     return &private->base;
 }
@@ -297,22 +303,41 @@ static void
 swrastPutImage(__DRIdrawable * draw, int op,
                int x, int y, int w, int h, char *data, void *loaderPrivate)
 {
-    __GLXDRIdrawable *drawable = loaderPrivate;
-    DrawablePtr pDraw = drawable->base.pDraw;
-    GCPtr gc;
-    __GLXcontext *cx = lastGLContext;
-
-    if ((gc = GetScratchGC(pDraw->depth, pDraw->pScreen))) {
+  __GLXDRIdrawable *drawable = loaderPrivate;
+  DrawablePtr pDraw = drawable->base.pDraw;
+  GCPtr gc;
+  __GLXcontext *cx = lastGLContext;
+
+#ifdef PANORAMIX
+  if (drawable->base.pAll)
+  {
+    int j;
+
+    for(j = screenInfo.numScreens - 1; j >= 0; j--)
+    {
+      pDraw = drawable->base.pAll[j]->pDraw;
+      if ((gc = GetScratchGC(pDraw->depth, screenInfo.screens[j])))
+      {
         ValidateGC(pDraw, gc);
         gc->ops->PutImage(pDraw, gc, pDraw->depth, x, y, w, h, 0, ZPixmap,
                           data);
         FreeScratchGC(gc);
+      }
     }
-
-    if (cx != lastGLContext) {
-        lastGLContext = cx;
-        cx->makeCurrent(cx);
+  }
+  else
+#endif
+    if ((gc = GetScratchGC(pDraw->depth, pDraw->pScreen))) {
+      ValidateGC(pDraw, gc);
+      gc->ops->PutImage(pDraw, gc, pDraw->depth, x, y, w, h, 0, ZPixmap,
+                        data);
+      FreeScratchGC(gc);
     }
+
+  if (cx != lastGLContext) {
+    lastGLContext = cx;
+    cx->makeCurrent(cx);
+  }
 }
 
 static void
@@ -395,6 +420,7 @@ initializeExtensions(__GLXscreen * screen)
     }
 }
 
+extern Bool g_fswrastwgl;
 static void
 __glXDRIscreenDestroy(__GLXscreen * baseScreen)
 {
@@ -404,14 +430,18 @@ __glXDRIscreenDestroy(__GLXscreen * baseScreen)
 
     (*screen->core->destroyScreen) (screen->driScreen);
 
+#ifdef _MSC_VER
+    FreeLibrary(screen->driver);
+#else
     dlclose(screen->driver);
+#endif
 
     __glXScreenDestroy(baseScreen);
 
     if (screen->driConfigs) {
         for (i = 0; screen->driConfigs[i] != NULL; i++)
             free((__DRIconfig **) screen->driConfigs[i]);
-        free(screen->driConfigs);
+        free((void*)screen->driConfigs);
     }
 
     free(screen);
@@ -420,8 +450,13 @@ __glXDRIscreenDestroy(__GLXscreen * baseScreen)
 static __GLXscreen *
 __glXDRIscreenProbe(ScreenPtr pScreen)
 {
-    const char *driverName = "swrast";
+    const char *driverName;
     __GLXDRIscreen *screen;
+    
+    if (g_fswrastwgl)
+      driverName = "swrastwgl";
+    else
+      driverName = "swrast";
 
     screen = calloc(1, sizeof *screen);
     if (screen == NULL)
@@ -437,9 +472,9 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 
     screen->driver = glxProbeDriver(driverName,
                                     (void **) &screen->core,
-                                    __DRI_CORE, 1,
+                                    __DRI_CORE, __DRI_CORE_VERSION,
                                     (void **) &screen->swrast,
-                                    __DRI_SWRAST, 1);
+                                    __DRI_SWRAST, __DRI_SWRAST_VERSION);
     if (screen->driver == NULL) {
         goto handle_error;
     }
@@ -464,15 +499,17 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 #endif
     __glXScreenInit(&screen->base, pScreen);
 
-    __glXsetGetProcAddress(glXGetProcAddressARB);
-
     LogMessage(X_INFO, "IGLX: Loaded and initialized %s\n", driverName);
 
     return &screen->base;
 
  handle_error:
     if (screen->driver)
+#ifdef _MSC_VER
+        FreeLibrary(screen->driver);
+#else
         dlclose(screen->driver);
+#endif
 
     free(screen);
 
diff --git a/xserver/glx/glxext.c b/vcxsrv-code/xorg-server/glx/glxext.c
index 99f8661..240582e 100644
--- a/xserver/glx/glxext.c
+++ b/vcxsrv-code/xorg-server/glx/glxext.c
@@ -30,6 +30,10 @@
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+
+#include "glheader.h"
+
 #endif
 
 #include <string.h>
@@ -47,6 +51,7 @@
 #include "indirect_table.h"
 #include "indirect_util.h"
 #include "glxvndabi.h"
+#include "glapi.h"
 
 /*
 ** X resources.
@@ -621,7 +626,7 @@ __glXForceCurrent(__GLXclientState * cl, GLXContextTag tag, int *error)
     if (cx->wait && (*cx->wait) (cx, cl, error))
         return NULL;
 
-    if (cx == lastGLContext) {
+    if (cx == lastGLContext && GET_DISPATCH()) {
         /* No need to re-bind */
         return cx;
     }
diff --git a/xserver/glx/glxext.h b/vcxsrv-code/xorg-server/glx/glxext.h
index abaf122..4416de9 100644
--- a/xserver/glx/glxext.h
+++ b/vcxsrv-code/xorg-server/glx/glxext.h
@@ -35,6 +35,12 @@
  * Silicon Graphics, Inc.
  */
 
+#ifdef INSERVER
+#define SERVEXTERN _declspec(dllimport)
+#else
+#define SERVEXTERN _declspec(dllexport)
+#endif
+
 /* doing #include <GL/glx.h> & #include <GL/glxext.h> could cause problems
  * with overlapping definitions, so let's use the easy way
  */
@@ -59,7 +65,7 @@
 extern void __glXFlushContextCache(void);
 
 extern Bool __glXAddContext(__GLXcontext * cx);
-extern void __glXErrorCallBack(GLenum code);
+SERVEXTERN void __glXErrorCallBack(GLenum code);
 extern void __glXClearErrorOccured(void);
 extern GLboolean __glXErrorOccured(void);
 
diff --git a/xserver/glx/glxscreens.c b/vcxsrv-code/xorg-server/glx/glxscreens.c
index 5cd9fcf..bb9e941 100644
--- a/xserver/glx/glxscreens.c
+++ b/vcxsrv-code/xorg-server/glx/glxscreens.c
@@ -30,6 +30,10 @@
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+
+#include "glheader.h"
+
 #endif
 
 #include <GL/glxtokens.h>
@@ -418,6 +422,7 @@ __glXScreenInit(__GLXscreen * pGlxScreen, ScreenPtr pScreen)
 #endif
         pGlxScreen->visuals[pGlxScreen->numVisuals++] = config;
         initGlxVisual(visual, config);
+        visual->nplanes = depth;  /* sometimes initGlxVisual create a wrong value for nplanes, causing a heap corruption later on */
     }
 
     dixSetPrivate(&pScreen->devPrivates, glxScreenPrivateKey, pGlxScreen);
diff --git a/xserver/glx/indirect_dispatch.c b/vcxsrv-code/xorg-server/glx/indirect_dispatch.c
index 24784e6..9f26fce 100644
--- a/xserver/glx/indirect_dispatch.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_dispatch.c
@@ -25,6 +25,14 @@
  * SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "glheader.h"
+
+#include <X11/Xmd.h>
+#include <GL/gl.h>
+#include <GL/glxproto.h>
 #include <inttypes.h>
 #include "glxserver.h"
 #include "indirect_size.h"
@@ -33,6 +41,9 @@
 #include "glxbyteorder.h"
 #include "indirect_util.h"
 #include "singlesize.h"
+#include "glapi.h"
+#include "glapitable.h"
+#include "dispatch.h"
 
 #define __GLX_PAD(x)  (((x) + 3) & ~3)
 
@@ -40,89 +51,94 @@ typedef struct {
     __GLX_PIXEL_3D_HDR;
 } __GLXpixel3DHeader;
 
-extern GLboolean __glXErrorOccured(void);
-extern void __glXClearErrorOccured(void);
+extern GLboolean __glXErrorOccured( void );
+extern void __glXClearErrorOccured( void );
 
-static const unsigned dummy_answer[2] = { 0, 0 };
+static const unsigned dummy_answer[2] = {0, 0};
 
-int
-__glXDisp_NewList(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_NewList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glNewList(*(GLuint *) (pc + 0), *(GLenum *) (pc + 4));
+    if ( cx != NULL ) {
+        CALL_NewList( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            *(GLenum   *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_EndList(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_EndList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glEndList();
+    if ( cx != NULL ) {
+        CALL_EndList( GET_DISPATCH(), () );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDisp_CallList(GLbyte * pc)
+void __glXDisp_CallList(GLbyte * pc)
 {
-    glCallList(*(GLuint *) (pc + 0));
+    CALL_CallList( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_CallLists(GLbyte * pc)
+void __glXDisp_CallLists(GLbyte * pc)
 {
-    const GLsizei n = *(GLsizei *) (pc + 0);
-    const GLenum type = *(GLenum *) (pc + 4);
-    const GLvoid *lists = (const GLvoid *) (pc + 8);
+    const GLsizei n = *(GLsizei  *)(pc +  0);
+    const GLenum type = *(GLenum   *)(pc +  4);
+    const GLvoid * lists =  (const GLvoid *)(pc +  8);
 
-    lists = (const GLvoid *) (pc + 8);
-
-    glCallLists(n, type, lists);
+    CALL_CallLists( GET_DISPATCH(), (
+        n,
+        type,
+        lists
+    ) );
 }
 
-int
-__glXDisp_DeleteLists(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_DeleteLists(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glDeleteLists(*(GLuint *) (pc + 0), *(GLsizei *) (pc + 4));
+    if ( cx != NULL ) {
+        CALL_DeleteLists( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            *(GLsizei  *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_GenLists(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenLists(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLuint retval;
-
-        retval = glGenLists(*(GLsizei *) (pc + 0));
+        retval = CALL_GenLists( GET_DISPATCH(), (
+            *(GLsizei  *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -130,1399 +146,1648 @@ __glXDisp_GenLists(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_ListBase(GLbyte * pc)
+void __glXDisp_ListBase(GLbyte * pc)
 {
-    glListBase(*(GLuint *) (pc + 0));
+    CALL_ListBase( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Begin(GLbyte * pc)
+void __glXDisp_Begin(GLbyte * pc)
 {
-    glBegin(*(GLenum *) (pc + 0));
+    CALL_Begin( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Bitmap(GLbyte * pc)
+void __glXDisp_Bitmap(GLbyte * pc)
 {
-    const GLubyte *const bitmap = (const GLubyte *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLubyte * const bitmap = (const GLubyte *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glBitmap(*(GLsizei *) (pc + 20),
-             *(GLsizei *) (pc + 24),
-             *(GLfloat *) (pc + 28),
-             *(GLfloat *) (pc + 32),
-             *(GLfloat *) (pc + 36), *(GLfloat *) (pc + 40), bitmap);
+    CALL_Bitmap( GET_DISPATCH(), (
+        *(GLsizei  *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLfloat  *)(pc + 28),
+        *(GLfloat  *)(pc + 32),
+        *(GLfloat  *)(pc + 36),
+        *(GLfloat  *)(pc + 40),
+        bitmap
+    ) );
 }
 
-void
-__glXDisp_Color3bv(GLbyte * pc)
+void __glXDisp_Color3bv(GLbyte * pc)
 {
-    glColor3bv((const GLbyte *) (pc + 0));
+    CALL_Color3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3dv(GLbyte * pc)
+void __glXDisp_Color3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glColor3dv((const GLdouble *) (pc + 0));
+    CALL_Color3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3fv(GLbyte * pc)
+void __glXDisp_Color3fv(GLbyte * pc)
 {
-    glColor3fv((const GLfloat *) (pc + 0));
+    CALL_Color3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3iv(GLbyte * pc)
+void __glXDisp_Color3iv(GLbyte * pc)
 {
-    glColor3iv((const GLint *) (pc + 0));
+    CALL_Color3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3sv(GLbyte * pc)
+void __glXDisp_Color3sv(GLbyte * pc)
 {
-    glColor3sv((const GLshort *) (pc + 0));
+    CALL_Color3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3ubv(GLbyte * pc)
+void __glXDisp_Color3ubv(GLbyte * pc)
 {
-    glColor3ubv((const GLubyte *) (pc + 0));
+    CALL_Color3ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3uiv(GLbyte * pc)
+void __glXDisp_Color3uiv(GLbyte * pc)
 {
-    glColor3uiv((const GLuint *) (pc + 0));
+    CALL_Color3uiv( GET_DISPATCH(), (
+         (const GLuint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color3usv(GLbyte * pc)
+void __glXDisp_Color3usv(GLbyte * pc)
 {
-    glColor3usv((const GLushort *) (pc + 0));
+    CALL_Color3usv( GET_DISPATCH(), (
+         (const GLushort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4bv(GLbyte * pc)
+void __glXDisp_Color4bv(GLbyte * pc)
 {
-    glColor4bv((const GLbyte *) (pc + 0));
+    CALL_Color4bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4dv(GLbyte * pc)
+void __glXDisp_Color4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glColor4dv((const GLdouble *) (pc + 0));
+    CALL_Color4dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4fv(GLbyte * pc)
+void __glXDisp_Color4fv(GLbyte * pc)
 {
-    glColor4fv((const GLfloat *) (pc + 0));
+    CALL_Color4fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4iv(GLbyte * pc)
+void __glXDisp_Color4iv(GLbyte * pc)
 {
-    glColor4iv((const GLint *) (pc + 0));
+    CALL_Color4iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4sv(GLbyte * pc)
+void __glXDisp_Color4sv(GLbyte * pc)
 {
-    glColor4sv((const GLshort *) (pc + 0));
+    CALL_Color4sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4ubv(GLbyte * pc)
+void __glXDisp_Color4ubv(GLbyte * pc)
 {
-    glColor4ubv((const GLubyte *) (pc + 0));
+    CALL_Color4ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4uiv(GLbyte * pc)
+void __glXDisp_Color4uiv(GLbyte * pc)
 {
-    glColor4uiv((const GLuint *) (pc + 0));
+    CALL_Color4uiv( GET_DISPATCH(), (
+         (const GLuint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Color4usv(GLbyte * pc)
+void __glXDisp_Color4usv(GLbyte * pc)
 {
-    glColor4usv((const GLushort *) (pc + 0));
+    CALL_Color4usv( GET_DISPATCH(), (
+         (const GLushort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EdgeFlagv(GLbyte * pc)
+void __glXDisp_EdgeFlagv(GLbyte * pc)
 {
-    glEdgeFlagv((const GLboolean *) (pc + 0));
+    CALL_EdgeFlagv( GET_DISPATCH(), (
+         (const GLboolean *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_End(GLbyte * pc)
+void __glXDisp_End(GLbyte * pc)
 {
-    glEnd();
+    CALL_End( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_Indexdv(GLbyte * pc)
+void __glXDisp_Indexdv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glIndexdv((const GLdouble *) (pc + 0));
+    CALL_Indexdv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Indexfv(GLbyte * pc)
+void __glXDisp_Indexfv(GLbyte * pc)
 {
-    glIndexfv((const GLfloat *) (pc + 0));
+    CALL_Indexfv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Indexiv(GLbyte * pc)
+void __glXDisp_Indexiv(GLbyte * pc)
 {
-    glIndexiv((const GLint *) (pc + 0));
+    CALL_Indexiv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Indexsv(GLbyte * pc)
+void __glXDisp_Indexsv(GLbyte * pc)
 {
-    glIndexsv((const GLshort *) (pc + 0));
+    CALL_Indexsv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Normal3bv(GLbyte * pc)
+void __glXDisp_Normal3bv(GLbyte * pc)
 {
-    glNormal3bv((const GLbyte *) (pc + 0));
+    CALL_Normal3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Normal3dv(GLbyte * pc)
+void __glXDisp_Normal3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glNormal3dv((const GLdouble *) (pc + 0));
+    CALL_Normal3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Normal3fv(GLbyte * pc)
+void __glXDisp_Normal3fv(GLbyte * pc)
 {
-    glNormal3fv((const GLfloat *) (pc + 0));
+    CALL_Normal3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Normal3iv(GLbyte * pc)
+void __glXDisp_Normal3iv(GLbyte * pc)
 {
-    glNormal3iv((const GLint *) (pc + 0));
+    CALL_Normal3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Normal3sv(GLbyte * pc)
+void __glXDisp_Normal3sv(GLbyte * pc)
 {
-    glNormal3sv((const GLshort *) (pc + 0));
+    CALL_Normal3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos2dv(GLbyte * pc)
+void __glXDisp_RasterPos2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glRasterPos2dv((const GLdouble *) (pc + 0));
+    CALL_RasterPos2dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos2fv(GLbyte * pc)
+void __glXDisp_RasterPos2fv(GLbyte * pc)
 {
-    glRasterPos2fv((const GLfloat *) (pc + 0));
+    CALL_RasterPos2fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos2iv(GLbyte * pc)
+void __glXDisp_RasterPos2iv(GLbyte * pc)
 {
-    glRasterPos2iv((const GLint *) (pc + 0));
+    CALL_RasterPos2iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos2sv(GLbyte * pc)
+void __glXDisp_RasterPos2sv(GLbyte * pc)
 {
-    glRasterPos2sv((const GLshort *) (pc + 0));
+    CALL_RasterPos2sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos3dv(GLbyte * pc)
+void __glXDisp_RasterPos3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glRasterPos3dv((const GLdouble *) (pc + 0));
+    CALL_RasterPos3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos3fv(GLbyte * pc)
+void __glXDisp_RasterPos3fv(GLbyte * pc)
 {
-    glRasterPos3fv((const GLfloat *) (pc + 0));
+    CALL_RasterPos3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos3iv(GLbyte * pc)
+void __glXDisp_RasterPos3iv(GLbyte * pc)
 {
-    glRasterPos3iv((const GLint *) (pc + 0));
+    CALL_RasterPos3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos3sv(GLbyte * pc)
+void __glXDisp_RasterPos3sv(GLbyte * pc)
 {
-    glRasterPos3sv((const GLshort *) (pc + 0));
+    CALL_RasterPos3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos4dv(GLbyte * pc)
+void __glXDisp_RasterPos4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRasterPos4dv((const GLdouble *) (pc + 0));
+    CALL_RasterPos4dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos4fv(GLbyte * pc)
+void __glXDisp_RasterPos4fv(GLbyte * pc)
 {
-    glRasterPos4fv((const GLfloat *) (pc + 0));
+    CALL_RasterPos4fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos4iv(GLbyte * pc)
+void __glXDisp_RasterPos4iv(GLbyte * pc)
 {
-    glRasterPos4iv((const GLint *) (pc + 0));
+    CALL_RasterPos4iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_RasterPos4sv(GLbyte * pc)
+void __glXDisp_RasterPos4sv(GLbyte * pc)
 {
-    glRasterPos4sv((const GLshort *) (pc + 0));
+    CALL_RasterPos4sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Rectdv(GLbyte * pc)
+void __glXDisp_Rectdv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRectdv((const GLdouble *) (pc + 0), (const GLdouble *) (pc + 16));
+    CALL_Rectdv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0),
+         (const GLdouble *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_Rectfv(GLbyte * pc)
+void __glXDisp_Rectfv(GLbyte * pc)
 {
-    glRectfv((const GLfloat *) (pc + 0), (const GLfloat *) (pc + 8));
+    CALL_Rectfv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0),
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Rectiv(GLbyte * pc)
+void __glXDisp_Rectiv(GLbyte * pc)
 {
-    glRectiv((const GLint *) (pc + 0), (const GLint *) (pc + 8));
+    CALL_Rectiv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0),
+         (const GLint *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Rectsv(GLbyte * pc)
+void __glXDisp_Rectsv(GLbyte * pc)
 {
-    glRectsv((const GLshort *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_Rectsv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_TexCoord1dv(GLbyte * pc)
+void __glXDisp_TexCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glTexCoord1dv((const GLdouble *) (pc + 0));
+    CALL_TexCoord1dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord1fv(GLbyte * pc)
+void __glXDisp_TexCoord1fv(GLbyte * pc)
 {
-    glTexCoord1fv((const GLfloat *) (pc + 0));
+    CALL_TexCoord1fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord1iv(GLbyte * pc)
+void __glXDisp_TexCoord1iv(GLbyte * pc)
 {
-    glTexCoord1iv((const GLint *) (pc + 0));
+    CALL_TexCoord1iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord1sv(GLbyte * pc)
+void __glXDisp_TexCoord1sv(GLbyte * pc)
 {
-    glTexCoord1sv((const GLshort *) (pc + 0));
+    CALL_TexCoord1sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord2dv(GLbyte * pc)
+void __glXDisp_TexCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glTexCoord2dv((const GLdouble *) (pc + 0));
+    CALL_TexCoord2dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord2fv(GLbyte * pc)
+void __glXDisp_TexCoord2fv(GLbyte * pc)
 {
-    glTexCoord2fv((const GLfloat *) (pc + 0));
+    CALL_TexCoord2fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord2iv(GLbyte * pc)
+void __glXDisp_TexCoord2iv(GLbyte * pc)
 {
-    glTexCoord2iv((const GLint *) (pc + 0));
+    CALL_TexCoord2iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord2sv(GLbyte * pc)
+void __glXDisp_TexCoord2sv(GLbyte * pc)
 {
-    glTexCoord2sv((const GLshort *) (pc + 0));
+    CALL_TexCoord2sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord3dv(GLbyte * pc)
+void __glXDisp_TexCoord3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glTexCoord3dv((const GLdouble *) (pc + 0));
+    CALL_TexCoord3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord3fv(GLbyte * pc)
+void __glXDisp_TexCoord3fv(GLbyte * pc)
 {
-    glTexCoord3fv((const GLfloat *) (pc + 0));
+    CALL_TexCoord3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord3iv(GLbyte * pc)
+void __glXDisp_TexCoord3iv(GLbyte * pc)
 {
-    glTexCoord3iv((const GLint *) (pc + 0));
+    CALL_TexCoord3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord3sv(GLbyte * pc)
+void __glXDisp_TexCoord3sv(GLbyte * pc)
 {
-    glTexCoord3sv((const GLshort *) (pc + 0));
+    CALL_TexCoord3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord4dv(GLbyte * pc)
+void __glXDisp_TexCoord4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glTexCoord4dv((const GLdouble *) (pc + 0));
+    CALL_TexCoord4dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord4fv(GLbyte * pc)
+void __glXDisp_TexCoord4fv(GLbyte * pc)
 {
-    glTexCoord4fv((const GLfloat *) (pc + 0));
+    CALL_TexCoord4fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord4iv(GLbyte * pc)
+void __glXDisp_TexCoord4iv(GLbyte * pc)
 {
-    glTexCoord4iv((const GLint *) (pc + 0));
+    CALL_TexCoord4iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexCoord4sv(GLbyte * pc)
+void __glXDisp_TexCoord4sv(GLbyte * pc)
 {
-    glTexCoord4sv((const GLshort *) (pc + 0));
+    CALL_TexCoord4sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex2dv(GLbyte * pc)
+void __glXDisp_Vertex2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glVertex2dv((const GLdouble *) (pc + 0));
+    CALL_Vertex2dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex2fv(GLbyte * pc)
+void __glXDisp_Vertex2fv(GLbyte * pc)
 {
-    glVertex2fv((const GLfloat *) (pc + 0));
+    CALL_Vertex2fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex2iv(GLbyte * pc)
+void __glXDisp_Vertex2iv(GLbyte * pc)
 {
-    glVertex2iv((const GLint *) (pc + 0));
+    CALL_Vertex2iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex2sv(GLbyte * pc)
+void __glXDisp_Vertex2sv(GLbyte * pc)
 {
-    glVertex2sv((const GLshort *) (pc + 0));
+    CALL_Vertex2sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex3dv(GLbyte * pc)
+void __glXDisp_Vertex3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glVertex3dv((const GLdouble *) (pc + 0));
+    CALL_Vertex3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex3fv(GLbyte * pc)
+void __glXDisp_Vertex3fv(GLbyte * pc)
 {
-    glVertex3fv((const GLfloat *) (pc + 0));
+    CALL_Vertex3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex3iv(GLbyte * pc)
+void __glXDisp_Vertex3iv(GLbyte * pc)
 {
-    glVertex3iv((const GLint *) (pc + 0));
+    CALL_Vertex3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex3sv(GLbyte * pc)
+void __glXDisp_Vertex3sv(GLbyte * pc)
 {
-    glVertex3sv((const GLshort *) (pc + 0));
+    CALL_Vertex3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex4dv(GLbyte * pc)
+void __glXDisp_Vertex4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glVertex4dv((const GLdouble *) (pc + 0));
+    CALL_Vertex4dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex4fv(GLbyte * pc)
+void __glXDisp_Vertex4fv(GLbyte * pc)
 {
-    glVertex4fv((const GLfloat *) (pc + 0));
+    CALL_Vertex4fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex4iv(GLbyte * pc)
+void __glXDisp_Vertex4iv(GLbyte * pc)
 {
-    glVertex4iv((const GLint *) (pc + 0));
+    CALL_Vertex4iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Vertex4sv(GLbyte * pc)
+void __glXDisp_Vertex4sv(GLbyte * pc)
 {
-    glVertex4sv((const GLshort *) (pc + 0));
+    CALL_Vertex4sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ClipPlane(GLbyte * pc)
+void __glXDisp_ClipPlane(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    glClipPlane(*(GLenum *) (pc + 32), (const GLdouble *) (pc + 0));
+    CALL_ClipPlane( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 32),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ColorMaterial(GLbyte * pc)
+void __glXDisp_ColorMaterial(GLbyte * pc)
 {
-    glColorMaterial(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    CALL_ColorMaterial( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_CullFace(GLbyte * pc)
+void __glXDisp_CullFace(GLbyte * pc)
 {
-    glCullFace(*(GLenum *) (pc + 0));
+    CALL_CullFace( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Fogf(GLbyte * pc)
+void __glXDisp_Fogf(GLbyte * pc)
 {
-    glFogf(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_Fogf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_Fogfv(GLbyte * pc)
+void __glXDisp_Fogfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 4);
 
-    glFogfv(pname, params);
+    CALL_Fogfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_Fogi(GLbyte * pc)
+void __glXDisp_Fogi(GLbyte * pc)
 {
-    glFogi(*(GLenum *) (pc + 0), *(GLint *) (pc + 4));
+    CALL_Fogi( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_Fogiv(GLbyte * pc)
+void __glXDisp_Fogiv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLint * params;
 
     params = (const GLint *) (pc + 4);
 
-    glFogiv(pname, params);
+    CALL_Fogiv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_FrontFace(GLbyte * pc)
+void __glXDisp_FrontFace(GLbyte * pc)
 {
-    glFrontFace(*(GLenum *) (pc + 0));
+    CALL_FrontFace( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Hint(GLbyte * pc)
+void __glXDisp_Hint(GLbyte * pc)
 {
-    glHint(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    CALL_Hint( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_Lightf(GLbyte * pc)
+void __glXDisp_Lightf(GLbyte * pc)
 {
-    glLightf(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_Lightf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Lightfv(GLbyte * pc)
+void __glXDisp_Lightfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glLightfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_Lightfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_Lighti(GLbyte * pc)
+void __glXDisp_Lighti(GLbyte * pc)
 {
-    glLighti(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_Lighti( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Lightiv(GLbyte * pc)
+void __glXDisp_Lightiv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glLightiv(*(GLenum *) (pc + 0), pname, params);
+    CALL_Lightiv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_LightModelf(GLbyte * pc)
+void __glXDisp_LightModelf(GLbyte * pc)
 {
-    glLightModelf(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_LightModelf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_LightModelfv(GLbyte * pc)
+void __glXDisp_LightModelfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 4);
 
-    glLightModelfv(pname, params);
+    CALL_LightModelfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_LightModeli(GLbyte * pc)
+void __glXDisp_LightModeli(GLbyte * pc)
 {
-    glLightModeli(*(GLenum *) (pc + 0), *(GLint *) (pc + 4));
+    CALL_LightModeli( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_LightModeliv(GLbyte * pc)
+void __glXDisp_LightModeliv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLint * params;
 
     params = (const GLint *) (pc + 4);
 
-    glLightModeliv(pname, params);
+    CALL_LightModeliv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_LineStipple(GLbyte * pc)
+void __glXDisp_LineStipple(GLbyte * pc)
 {
-    glLineStipple(*(GLint *) (pc + 0), *(GLushort *) (pc + 4));
+    CALL_LineStipple( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLushort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_LineWidth(GLbyte * pc)
+void __glXDisp_LineWidth(GLbyte * pc)
 {
-    glLineWidth(*(GLfloat *) (pc + 0));
+    CALL_LineWidth( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Materialf(GLbyte * pc)
+void __glXDisp_Materialf(GLbyte * pc)
 {
-    glMaterialf(*(GLenum *) (pc + 0),
-                *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_Materialf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Materialfv(GLbyte * pc)
+void __glXDisp_Materialfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glMaterialfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_Materialfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_Materiali(GLbyte * pc)
+void __glXDisp_Materiali(GLbyte * pc)
 {
-    glMateriali(*(GLenum *) (pc + 0),
-                *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_Materiali( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Materialiv(GLbyte * pc)
+void __glXDisp_Materialiv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glMaterialiv(*(GLenum *) (pc + 0), pname, params);
+    CALL_Materialiv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_PointSize(GLbyte * pc)
+void __glXDisp_PointSize(GLbyte * pc)
 {
-    glPointSize(*(GLfloat *) (pc + 0));
+    CALL_PointSize( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PolygonMode(GLbyte * pc)
+void __glXDisp_PolygonMode(GLbyte * pc)
 {
-    glPolygonMode(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    CALL_PolygonMode( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_PolygonStipple(GLbyte * pc)
+void __glXDisp_PolygonStipple(GLbyte * pc)
 {
-    const GLubyte *const mask = (const GLubyte *) ((pc + 20));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLubyte * const mask = (const GLubyte *) (pc + 20);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glPolygonStipple(mask);
+    CALL_PolygonStipple( GET_DISPATCH(), (
+        mask
+    ) );
 }
 
-void
-__glXDisp_Scissor(GLbyte * pc)
+void __glXDisp_Scissor(GLbyte * pc)
 {
-    glScissor(*(GLint *) (pc + 0),
-              *(GLint *) (pc + 4),
-              *(GLsizei *) (pc + 8), *(GLsizei *) (pc + 12));
+    CALL_Scissor( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLsizei  *)(pc +  8),
+        *(GLsizei  *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_ShadeModel(GLbyte * pc)
+void __glXDisp_ShadeModel(GLbyte * pc)
 {
-    glShadeModel(*(GLenum *) (pc + 0));
+    CALL_ShadeModel( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexParameterf(GLbyte * pc)
+void __glXDisp_TexParameterf(GLbyte * pc)
 {
-    glTexParameterf(*(GLenum *) (pc + 0),
-                    *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_TexParameterf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexParameterfv(GLbyte * pc)
+void __glXDisp_TexParameterfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glTexParameterfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexParameterfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexParameteri(GLbyte * pc)
+void __glXDisp_TexParameteri(GLbyte * pc)
 {
-    glTexParameteri(*(GLenum *) (pc + 0),
-                    *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_TexParameteri( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexParameteriv(GLbyte * pc)
+void __glXDisp_TexParameteriv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glTexParameteriv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexParameteriv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexImage1D(GLbyte * pc)
+void __glXDisp_TexImage1D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 52));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 52);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexImage1D(*(GLenum *) (pc + 20),
-                 *(GLint *) (pc + 24),
-                 *(GLint *) (pc + 28),
-                 *(GLsizei *) (pc + 32),
-                 *(GLint *) (pc + 40),
-                 *(GLenum *) (pc + 44), *(GLenum *) (pc + 48), pixels);
+    CALL_TexImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLint    *)(pc + 28),
+        *(GLsizei  *)(pc + 32),
+        *(GLint    *)(pc + 40),
+        *(GLenum   *)(pc + 44),
+        *(GLenum   *)(pc + 48),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_TexImage2D(GLbyte * pc)
+void __glXDisp_TexImage2D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 52));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 52);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexImage2D(*(GLenum *) (pc + 20),
-                 *(GLint *) (pc + 24),
-                 *(GLint *) (pc + 28),
-                 *(GLsizei *) (pc + 32),
-                 *(GLsizei *) (pc + 36),
-                 *(GLint *) (pc + 40),
-                 *(GLenum *) (pc + 44), *(GLenum *) (pc + 48), pixels);
+    CALL_TexImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLint    *)(pc + 28),
+        *(GLsizei  *)(pc + 32),
+        *(GLsizei  *)(pc + 36),
+        *(GLint    *)(pc + 40),
+        *(GLenum   *)(pc + 44),
+        *(GLenum   *)(pc + 48),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_TexEnvf(GLbyte * pc)
+void __glXDisp_TexEnvf(GLbyte * pc)
 {
-    glTexEnvf(*(GLenum *) (pc + 0),
-              *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_TexEnvf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexEnvfv(GLbyte * pc)
+void __glXDisp_TexEnvfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glTexEnvfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexEnvfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexEnvi(GLbyte * pc)
+void __glXDisp_TexEnvi(GLbyte * pc)
 {
-    glTexEnvi(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_TexEnvi( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexEnviv(GLbyte * pc)
+void __glXDisp_TexEnviv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glTexEnviv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexEnviv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexGend(GLbyte * pc)
+void __glXDisp_TexGend(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glTexGend(*(GLenum *) (pc + 8),
-              *(GLenum *) (pc + 12), *(GLdouble *) (pc + 0));
+    CALL_TexGend( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  8),
+        *(GLenum   *)(pc + 12),
+        *(GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexGendv(GLbyte * pc)
+void __glXDisp_TexGendv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLdouble *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLdouble * params;
 
 #ifdef __GLX_ALIGN64
     const GLuint compsize = __glTexGendv_size(pname);
-    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 8)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(compsize, 1 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
     params = (const GLdouble *) (pc + 8);
 
-    glTexGendv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexGendv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexGenf(GLbyte * pc)
+void __glXDisp_TexGenf(GLbyte * pc)
 {
-    glTexGenf(*(GLenum *) (pc + 0),
-              *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_TexGenf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexGenfv(GLbyte * pc)
+void __glXDisp_TexGenfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glTexGenfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexGenfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_TexGeni(GLbyte * pc)
+void __glXDisp_TexGeni(GLbyte * pc)
 {
-    glTexGeni(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_TexGeni( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_TexGeniv(GLbyte * pc)
+void __glXDisp_TexGeniv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glTexGeniv(*(GLenum *) (pc + 0), pname, params);
+    CALL_TexGeniv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_InitNames(GLbyte * pc)
+void __glXDisp_InitNames(GLbyte * pc)
 {
-    glInitNames();
+    CALL_InitNames( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_LoadName(GLbyte * pc)
+void __glXDisp_LoadName(GLbyte * pc)
 {
-    glLoadName(*(GLuint *) (pc + 0));
+    CALL_LoadName( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PassThrough(GLbyte * pc)
+void __glXDisp_PassThrough(GLbyte * pc)
 {
-    glPassThrough(*(GLfloat *) (pc + 0));
+    CALL_PassThrough( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PopName(GLbyte * pc)
+void __glXDisp_PopName(GLbyte * pc)
 {
-    glPopName();
+    CALL_PopName( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_PushName(GLbyte * pc)
+void __glXDisp_PushName(GLbyte * pc)
 {
-    glPushName(*(GLuint *) (pc + 0));
+    CALL_PushName( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_DrawBuffer(GLbyte * pc)
+void __glXDisp_DrawBuffer(GLbyte * pc)
 {
-    glDrawBuffer(*(GLenum *) (pc + 0));
+    CALL_DrawBuffer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Clear(GLbyte * pc)
+void __glXDisp_Clear(GLbyte * pc)
 {
-    glClear(*(GLbitfield *) (pc + 0));
+    CALL_Clear( GET_DISPATCH(), (
+        *(GLbitfield *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ClearAccum(GLbyte * pc)
+void __glXDisp_ClearAccum(GLbyte * pc)
 {
-    glClearAccum(*(GLfloat *) (pc + 0),
-                 *(GLfloat *) (pc + 4),
-                 *(GLfloat *) (pc + 8), *(GLfloat *) (pc + 12));
+    CALL_ClearAccum( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8),
+        *(GLfloat  *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_ClearIndex(GLbyte * pc)
+void __glXDisp_ClearIndex(GLbyte * pc)
 {
-    glClearIndex(*(GLfloat *) (pc + 0));
+    CALL_ClearIndex( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ClearColor(GLbyte * pc)
+void __glXDisp_ClearColor(GLbyte * pc)
 {
-    glClearColor(*(GLclampf *) (pc + 0),
-                 *(GLclampf *) (pc + 4),
-                 *(GLclampf *) (pc + 8), *(GLclampf *) (pc + 12));
+    CALL_ClearColor( GET_DISPATCH(), (
+        *(GLclampf *)(pc +  0),
+        *(GLclampf *)(pc +  4),
+        *(GLclampf *)(pc +  8),
+        *(GLclampf *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_ClearStencil(GLbyte * pc)
+void __glXDisp_ClearStencil(GLbyte * pc)
 {
-    glClearStencil(*(GLint *) (pc + 0));
+    CALL_ClearStencil( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ClearDepth(GLbyte * pc)
+void __glXDisp_ClearDepth(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glClearDepth(*(GLclampd *) (pc + 0));
+    CALL_ClearDepth( GET_DISPATCH(), (
+        *(GLclampd *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_StencilMask(GLbyte * pc)
+void __glXDisp_StencilMask(GLbyte * pc)
 {
-    glStencilMask(*(GLuint *) (pc + 0));
+    CALL_StencilMask( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ColorMask(GLbyte * pc)
+void __glXDisp_ColorMask(GLbyte * pc)
 {
-    glColorMask(*(GLboolean *) (pc + 0),
-                *(GLboolean *) (pc + 1),
-                *(GLboolean *) (pc + 2), *(GLboolean *) (pc + 3));
+    CALL_ColorMask( GET_DISPATCH(), (
+        *(GLboolean *)(pc +  0),
+        *(GLboolean *)(pc +  1),
+        *(GLboolean *)(pc +  2),
+        *(GLboolean *)(pc +  3)
+    ) );
 }
 
-void
-__glXDisp_DepthMask(GLbyte * pc)
+void __glXDisp_DepthMask(GLbyte * pc)
 {
-    glDepthMask(*(GLboolean *) (pc + 0));
+    CALL_DepthMask( GET_DISPATCH(), (
+        *(GLboolean *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_IndexMask(GLbyte * pc)
+void __glXDisp_IndexMask(GLbyte * pc)
 {
-    glIndexMask(*(GLuint *) (pc + 0));
+    CALL_IndexMask( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Accum(GLbyte * pc)
+void __glXDisp_Accum(GLbyte * pc)
 {
-    glAccum(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_Accum( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_Disable(GLbyte * pc)
+void __glXDisp_Disable(GLbyte * pc)
 {
-    glDisable(*(GLenum *) (pc + 0));
+    CALL_Disable( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Enable(GLbyte * pc)
+void __glXDisp_Enable(GLbyte * pc)
 {
-    glEnable(*(GLenum *) (pc + 0));
+    CALL_Enable( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PopAttrib(GLbyte * pc)
+void __glXDisp_PopAttrib(GLbyte * pc)
 {
-    glPopAttrib();
+    CALL_PopAttrib( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_PushAttrib(GLbyte * pc)
+void __glXDisp_PushAttrib(GLbyte * pc)
 {
-    glPushAttrib(*(GLbitfield *) (pc + 0));
+    CALL_PushAttrib( GET_DISPATCH(), (
+        *(GLbitfield *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MapGrid1d(GLbyte * pc)
+void __glXDisp_MapGrid1d(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    glMapGrid1d(*(GLint *) (pc + 16),
-                *(GLdouble *) (pc + 0), *(GLdouble *) (pc + 8));
+    CALL_MapGrid1d( GET_DISPATCH(), (
+        *(GLint    *)(pc + 16),
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_MapGrid1f(GLbyte * pc)
+void __glXDisp_MapGrid1f(GLbyte * pc)
 {
-    glMapGrid1f(*(GLint *) (pc + 0),
-                *(GLfloat *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_MapGrid1f( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_MapGrid2d(GLbyte * pc)
+void __glXDisp_MapGrid2d(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    glMapGrid2d(*(GLint *) (pc + 32),
-                *(GLdouble *) (pc + 0),
-                *(GLdouble *) (pc + 8),
-                *(GLint *) (pc + 36),
-                *(GLdouble *) (pc + 16), *(GLdouble *) (pc + 24));
+    CALL_MapGrid2d( GET_DISPATCH(), (
+        *(GLint    *)(pc + 32),
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLint    *)(pc + 36),
+        *(GLdouble *)(pc + 16),
+        *(GLdouble *)(pc + 24)
+    ) );
 }
 
-void
-__glXDisp_MapGrid2f(GLbyte * pc)
+void __glXDisp_MapGrid2f(GLbyte * pc)
 {
-    glMapGrid2f(*(GLint *) (pc + 0),
-                *(GLfloat *) (pc + 4),
-                *(GLfloat *) (pc + 8),
-                *(GLint *) (pc + 12),
-                *(GLfloat *) (pc + 16), *(GLfloat *) (pc + 20));
+    CALL_MapGrid2f( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLfloat  *)(pc + 16),
+        *(GLfloat  *)(pc + 20)
+    ) );
 }
 
-void
-__glXDisp_EvalCoord1dv(GLbyte * pc)
+void __glXDisp_EvalCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glEvalCoord1dv((const GLdouble *) (pc + 0));
+    CALL_EvalCoord1dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EvalCoord1fv(GLbyte * pc)
+void __glXDisp_EvalCoord1fv(GLbyte * pc)
 {
-    glEvalCoord1fv((const GLfloat *) (pc + 0));
+    CALL_EvalCoord1fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EvalCoord2dv(GLbyte * pc)
+void __glXDisp_EvalCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glEvalCoord2dv((const GLdouble *) (pc + 0));
+    CALL_EvalCoord2dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EvalCoord2fv(GLbyte * pc)
+void __glXDisp_EvalCoord2fv(GLbyte * pc)
 {
-    glEvalCoord2fv((const GLfloat *) (pc + 0));
+    CALL_EvalCoord2fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EvalMesh1(GLbyte * pc)
+void __glXDisp_EvalMesh1(GLbyte * pc)
 {
-    glEvalMesh1(*(GLenum *) (pc + 0), *(GLint *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_EvalMesh1( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_EvalPoint1(GLbyte * pc)
+void __glXDisp_EvalPoint1(GLbyte * pc)
 {
-    glEvalPoint1(*(GLint *) (pc + 0));
+    CALL_EvalPoint1( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_EvalMesh2(GLbyte * pc)
+void __glXDisp_EvalMesh2(GLbyte * pc)
 {
-    glEvalMesh2(*(GLenum *) (pc + 0),
-                *(GLint *) (pc + 4),
-                *(GLint *) (pc + 8),
-                *(GLint *) (pc + 12), *(GLint *) (pc + 16));
+    CALL_EvalMesh2( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_EvalPoint2(GLbyte * pc)
+void __glXDisp_EvalPoint2(GLbyte * pc)
 {
-    glEvalPoint2(*(GLint *) (pc + 0), *(GLint *) (pc + 4));
+    CALL_EvalPoint2( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLint    *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_AlphaFunc(GLbyte * pc)
+void __glXDisp_AlphaFunc(GLbyte * pc)
 {
-    glAlphaFunc(*(GLenum *) (pc + 0), *(GLclampf *) (pc + 4));
+    CALL_AlphaFunc( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLclampf *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BlendFunc(GLbyte * pc)
+void __glXDisp_BlendFunc(GLbyte * pc)
 {
-    glBlendFunc(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    CALL_BlendFunc( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_LogicOp(GLbyte * pc)
+void __glXDisp_LogicOp(GLbyte * pc)
 {
-    glLogicOp(*(GLenum *) (pc + 0));
+    CALL_LogicOp( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_StencilFunc(GLbyte * pc)
+void __glXDisp_StencilFunc(GLbyte * pc)
 {
-    glStencilFunc(*(GLenum *) (pc + 0),
-                  *(GLint *) (pc + 4), *(GLuint *) (pc + 8));
+    CALL_StencilFunc( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLuint   *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_StencilOp(GLbyte * pc)
+void __glXDisp_StencilOp(GLbyte * pc)
 {
-    glStencilOp(*(GLenum *) (pc + 0),
-                *(GLenum *) (pc + 4), *(GLenum *) (pc + 8));
+    CALL_StencilOp( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_DepthFunc(GLbyte * pc)
+void __glXDisp_DepthFunc(GLbyte * pc)
 {
-    glDepthFunc(*(GLenum *) (pc + 0));
+    CALL_DepthFunc( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PixelZoom(GLbyte * pc)
+void __glXDisp_PixelZoom(GLbyte * pc)
 {
-    glPixelZoom(*(GLfloat *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_PixelZoom( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_PixelTransferf(GLbyte * pc)
+void __glXDisp_PixelTransferf(GLbyte * pc)
 {
-    glPixelTransferf(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_PixelTransferf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_PixelTransferi(GLbyte * pc)
+void __glXDisp_PixelTransferi(GLbyte * pc)
 {
-    glPixelTransferi(*(GLenum *) (pc + 0), *(GLint *) (pc + 4));
+    CALL_PixelTransferi( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4)
+    ) );
 }
 
-int
-__glXDisp_PixelStoref(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_PixelStoref(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glPixelStoref(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    if ( cx != NULL ) {
+        CALL_PixelStoref( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLfloat  *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_PixelStorei(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_PixelStorei(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glPixelStorei(*(GLenum *) (pc + 0), *(GLint *) (pc + 4));
+    if ( cx != NULL ) {
+        CALL_PixelStorei( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLint    *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDisp_PixelMapfv(GLbyte * pc)
+void __glXDisp_PixelMapfv(GLbyte * pc)
 {
-    const GLsizei mapsize = *(GLsizei *) (pc + 4);
+    const GLsizei mapsize = *(GLsizei  *)(pc +  4);
 
-    glPixelMapfv(*(GLenum *) (pc + 0), mapsize, (const GLfloat *) (pc + 8));
+    CALL_PixelMapfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        mapsize,
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_PixelMapuiv(GLbyte * pc)
+void __glXDisp_PixelMapuiv(GLbyte * pc)
 {
-    const GLsizei mapsize = *(GLsizei *) (pc + 4);
+    const GLsizei mapsize = *(GLsizei  *)(pc +  4);
 
-    glPixelMapuiv(*(GLenum *) (pc + 0), mapsize, (const GLuint *) (pc + 8));
+    CALL_PixelMapuiv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        mapsize,
+         (const GLuint *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_PixelMapusv(GLbyte * pc)
+void __glXDisp_PixelMapusv(GLbyte * pc)
 {
-    const GLsizei mapsize = *(GLsizei *) (pc + 4);
+    const GLsizei mapsize = *(GLsizei  *)(pc +  4);
 
-    glPixelMapusv(*(GLenum *) (pc + 0), mapsize, (const GLushort *) (pc + 8));
+    CALL_PixelMapusv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        mapsize,
+         (const GLushort *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ReadBuffer(GLbyte * pc)
+void __glXDisp_ReadBuffer(GLbyte * pc)
 {
-    glReadBuffer(*(GLenum *) (pc + 0));
+    CALL_ReadBuffer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_CopyPixels(GLbyte * pc)
+void __glXDisp_CopyPixels(GLbyte * pc)
 {
-    glCopyPixels(*(GLint *) (pc + 0),
-                 *(GLint *) (pc + 4),
-                 *(GLsizei *) (pc + 8),
-                 *(GLsizei *) (pc + 12), *(GLenum *) (pc + 16));
+    CALL_CopyPixels( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLsizei  *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLenum   *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_DrawPixels(GLbyte * pc)
+void __glXDisp_DrawPixels(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 36));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 36);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glDrawPixels(*(GLsizei *) (pc + 20),
-                 *(GLsizei *) (pc + 24),
-                 *(GLenum *) (pc + 28), *(GLenum *) (pc + 32), pixels);
+    CALL_DrawPixels( GET_DISPATCH(), (
+        *(GLsizei  *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLenum   *)(pc + 28),
+        *(GLenum   *)(pc + 32),
+        pixels
+    ) );
 }
 
-int
-__glXDisp_GetBooleanv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetBooleanv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetBooleanv_size(pname);
         GLboolean answerBuffer[200];
-        GLboolean *params =
-            __glXGetAnswerBuffer(cl, compsize, answerBuffer,
-                                 sizeof(answerBuffer), 1);
+        GLboolean * params = __glXGetAnswerBuffer(cl, compsize, answerBuffer, sizeof(answerBuffer), 1);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetBooleanv(pname, params);
+        CALL_GetBooleanv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 1, GL_FALSE, 0);
         error = Success;
     }
@@ -1530,18 +1795,19 @@ __glXDisp_GetBooleanv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetClipPlane(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetClipPlane(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble equation[4];
-
-        glGetClipPlane(*(GLenum *) (pc + 0), equation);
+        CALL_GetClipPlane( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            equation
+        ) );
         __glXSendReply(cl->client, equation, 4, 8, GL_TRUE, 0);
         error = Success;
     }
@@ -1549,28 +1815,27 @@ __glXDisp_GetClipPlane(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetDoublev(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetDoublev(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetDoublev_size(pname);
         GLdouble answerBuffer[200];
-        GLdouble *params =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetDoublev(pname, params);
+        CALL_GetDoublev( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -1578,18 +1843,16 @@ __glXDisp_GetDoublev(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetError(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetError(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLenum retval;
-
-        retval = glGetError();
+        retval = CALL_GetError( GET_DISPATCH(), () );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -1597,28 +1860,27 @@ __glXDisp_GetError(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetFloatv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetFloatv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetFloatv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetFloatv(pname, params);
+        CALL_GetFloatv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1626,28 +1888,27 @@ __glXDisp_GetFloatv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetIntegerv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetIntegerv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetIntegerv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetIntegerv(pname, params);
+        CALL_GetIntegerv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1655,28 +1916,28 @@ __glXDisp_GetIntegerv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetLightfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetLightfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetLightfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetLightfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetLightfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1684,28 +1945,28 @@ __glXDisp_GetLightfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetLightiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetLightiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetLightiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetLightiv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetLightiv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1713,29 +1974,29 @@ __glXDisp_GetLightiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMapdv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMapdv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = *(GLenum *) (pc + 0);
-        const GLenum query = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target = *(GLenum   *)(pc +  0);
+        const GLenum query = *(GLenum   *)(pc +  4);
 
-        const GLuint compsize = __glGetMapdv_size(target, query);
+        const GLuint compsize = __glGetMapdv_size(target,query);
         GLdouble answerBuffer[200];
-        GLdouble *v =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * v = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapdv(target, query, v);
+        CALL_GetMapdv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
         __glXSendReply(cl->client, v, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -1743,29 +2004,29 @@ __glXDisp_GetMapdv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMapfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMapfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = *(GLenum *) (pc + 0);
-        const GLenum query = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target = *(GLenum   *)(pc +  0);
+        const GLenum query = *(GLenum   *)(pc +  4);
 
-        const GLuint compsize = __glGetMapfv_size(target, query);
+        const GLuint compsize = __glGetMapfv_size(target,query);
         GLfloat answerBuffer[200];
-        GLfloat *v =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * v = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapfv(target, query, v);
+        CALL_GetMapfv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
         __glXSendReply(cl->client, v, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1773,29 +2034,29 @@ __glXDisp_GetMapfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMapiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMapiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = *(GLenum *) (pc + 0);
-        const GLenum query = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target = *(GLenum   *)(pc +  0);
+        const GLenum query = *(GLenum   *)(pc +  4);
 
-        const GLuint compsize = __glGetMapiv_size(target, query);
+        const GLuint compsize = __glGetMapiv_size(target,query);
         GLint answerBuffer[200];
-        GLint *v =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * v = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapiv(target, query, v);
+        CALL_GetMapiv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
         __glXSendReply(cl->client, v, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1803,28 +2064,28 @@ __glXDisp_GetMapiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMaterialfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMaterialfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetMaterialfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMaterialfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetMaterialfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1832,28 +2093,28 @@ __glXDisp_GetMaterialfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMaterialiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMaterialiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetMaterialiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMaterialiv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetMaterialiv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1861,28 +2122,27 @@ __glXDisp_GetMaterialiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetPixelMapfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetPixelMapfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetPixelMapfv_size(map);
         GLfloat answerBuffer[200];
-        GLfloat *values =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * values = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapfv(map, values);
+        CALL_GetPixelMapfv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
         __glXSendReply(cl->client, values, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1890,28 +2150,27 @@ __glXDisp_GetPixelMapfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetPixelMapuiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetPixelMapuiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetPixelMapuiv_size(map);
         GLuint answerBuffer[200];
-        GLuint *values =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLuint * values = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapuiv(map, values);
+        CALL_GetPixelMapuiv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
         __glXSendReply(cl->client, values, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1919,28 +2178,27 @@ __glXDisp_GetPixelMapuiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetPixelMapusv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetPixelMapusv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = *(GLenum *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map = *(GLenum   *)(pc +  0);
 
         const GLuint compsize = __glGetPixelMapusv_size(map);
         GLushort answerBuffer[200];
-        GLushort *values =
-            __glXGetAnswerBuffer(cl, compsize * 2, answerBuffer,
-                                 sizeof(answerBuffer), 2);
+        GLushort * values = __glXGetAnswerBuffer(cl, compsize * 2, answerBuffer, sizeof(answerBuffer), 2);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapusv(map, values);
+        CALL_GetPixelMapusv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
         __glXSendReply(cl->client, values, compsize, 2, GL_FALSE, 0);
         error = Success;
     }
@@ -1948,28 +2206,28 @@ __glXDisp_GetPixelMapusv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexEnvfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexEnvfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexEnvfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexEnvfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexEnvfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1977,28 +2235,28 @@ __glXDisp_GetTexEnvfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexEnviv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexEnviv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexEnviv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexEnviv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexEnviv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2006,28 +2264,28 @@ __glXDisp_GetTexEnviv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexGendv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexGendv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexGendv_size(pname);
         GLdouble answerBuffer[200];
-        GLdouble *params =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGendv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexGendv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -2035,28 +2293,28 @@ __glXDisp_GetTexGendv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexGenfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexGenfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexGenfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGenfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexGenfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2064,28 +2322,28 @@ __glXDisp_GetTexGenfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexGeniv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexGeniv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexGeniv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGeniv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexGeniv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2093,28 +2351,28 @@ __glXDisp_GetTexGeniv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexParameterfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2122,28 +2380,28 @@ __glXDisp_GetTexParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetTexParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexParameteriv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetTexParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2151,29 +2409,29 @@ __glXDisp_GetTexParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexLevelParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexLevelParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 8);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  8);
 
         const GLuint compsize = __glGetTexLevelParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexLevelParameterfv(*(GLenum *) (pc + 0),
-                                 *(GLint *) (pc + 4), pname, params);
+        CALL_GetTexLevelParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLint    *)(pc +  4),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2181,29 +2439,29 @@ __glXDisp_GetTexLevelParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetTexLevelParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetTexLevelParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 8);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  8);
 
         const GLuint compsize = __glGetTexLevelParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexLevelParameteriv(*(GLenum *) (pc + 0),
-                                 *(GLint *) (pc + 4), pname, params);
+        CALL_GetTexLevelParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLint    *)(pc +  4),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2211,18 +2469,18 @@ __glXDisp_GetTexLevelParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsEnabled(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsEnabled(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsEnabled(*(GLenum *) (pc + 0));
+        retval = CALL_IsEnabled( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2230,18 +2488,18 @@ __glXDisp_IsEnabled(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsList(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsList(*(GLuint *) (pc + 0));
+        retval = CALL_IsList( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2249,226 +2507,257 @@ __glXDisp_IsList(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_DepthRange(GLbyte * pc)
+void __glXDisp_DepthRange(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glDepthRange(*(GLclampd *) (pc + 0), *(GLclampd *) (pc + 8));
+    CALL_DepthRange( GET_DISPATCH(), (
+        *(GLclampd *)(pc +  0),
+        *(GLclampd *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Frustum(GLbyte * pc)
+void __glXDisp_Frustum(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 48);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 48);
         pc -= 4;
     }
 #endif
 
-    glFrustum(*(GLdouble *) (pc + 0),
-              *(GLdouble *) (pc + 8),
-              *(GLdouble *) (pc + 16),
-              *(GLdouble *) (pc + 24),
-              *(GLdouble *) (pc + 32), *(GLdouble *) (pc + 40));
+    CALL_Frustum( GET_DISPATCH(), (
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLdouble *)(pc + 16),
+        *(GLdouble *)(pc + 24),
+        *(GLdouble *)(pc + 32),
+        *(GLdouble *)(pc + 40)
+    ) );
 }
 
-void
-__glXDisp_LoadIdentity(GLbyte * pc)
+void __glXDisp_LoadIdentity(GLbyte * pc)
 {
-    glLoadIdentity();
+    CALL_LoadIdentity( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_LoadMatrixf(GLbyte * pc)
+void __glXDisp_LoadMatrixf(GLbyte * pc)
 {
-    glLoadMatrixf((const GLfloat *) (pc + 0));
+    CALL_LoadMatrixf( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_LoadMatrixd(GLbyte * pc)
+void __glXDisp_LoadMatrixd(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 128);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 128);
         pc -= 4;
     }
 #endif
 
-    glLoadMatrixd((const GLdouble *) (pc + 0));
+    CALL_LoadMatrixd( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MatrixMode(GLbyte * pc)
+void __glXDisp_MatrixMode(GLbyte * pc)
 {
-    glMatrixMode(*(GLenum *) (pc + 0));
+    CALL_MatrixMode( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultMatrixf(GLbyte * pc)
+void __glXDisp_MultMatrixf(GLbyte * pc)
 {
-    glMultMatrixf((const GLfloat *) (pc + 0));
+    CALL_MultMatrixf( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultMatrixd(GLbyte * pc)
+void __glXDisp_MultMatrixd(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 128);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 128);
         pc -= 4;
     }
 #endif
 
-    glMultMatrixd((const GLdouble *) (pc + 0));
+    CALL_MultMatrixd( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_Ortho(GLbyte * pc)
+void __glXDisp_Ortho(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 48);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 48);
         pc -= 4;
     }
 #endif
 
-    glOrtho(*(GLdouble *) (pc + 0),
-            *(GLdouble *) (pc + 8),
-            *(GLdouble *) (pc + 16),
-            *(GLdouble *) (pc + 24),
-            *(GLdouble *) (pc + 32), *(GLdouble *) (pc + 40));
+    CALL_Ortho( GET_DISPATCH(), (
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLdouble *)(pc + 16),
+        *(GLdouble *)(pc + 24),
+        *(GLdouble *)(pc + 32),
+        *(GLdouble *)(pc + 40)
+    ) );
 }
 
-void
-__glXDisp_PopMatrix(GLbyte * pc)
+void __glXDisp_PopMatrix(GLbyte * pc)
 {
-    glPopMatrix();
+    CALL_PopMatrix( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_PushMatrix(GLbyte * pc)
+void __glXDisp_PushMatrix(GLbyte * pc)
 {
-    glPushMatrix();
+    CALL_PushMatrix( GET_DISPATCH(), () );
 }
 
-void
-__glXDisp_Rotated(GLbyte * pc)
+void __glXDisp_Rotated(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRotated(*(GLdouble *) (pc + 0),
-              *(GLdouble *) (pc + 8),
-              *(GLdouble *) (pc + 16), *(GLdouble *) (pc + 24));
+    CALL_Rotated( GET_DISPATCH(), (
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLdouble *)(pc + 16),
+        *(GLdouble *)(pc + 24)
+    ) );
 }
 
-void
-__glXDisp_Rotatef(GLbyte * pc)
+void __glXDisp_Rotatef(GLbyte * pc)
 {
-    glRotatef(*(GLfloat *) (pc + 0),
-              *(GLfloat *) (pc + 4),
-              *(GLfloat *) (pc + 8), *(GLfloat *) (pc + 12));
+    CALL_Rotatef( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8),
+        *(GLfloat  *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_Scaled(GLbyte * pc)
+void __glXDisp_Scaled(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glScaled(*(GLdouble *) (pc + 0),
-             *(GLdouble *) (pc + 8), *(GLdouble *) (pc + 16));
+    CALL_Scaled( GET_DISPATCH(), (
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLdouble *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_Scalef(GLbyte * pc)
+void __glXDisp_Scalef(GLbyte * pc)
 {
-    glScalef(*(GLfloat *) (pc + 0),
-             *(GLfloat *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_Scalef( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Translated(GLbyte * pc)
+void __glXDisp_Translated(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glTranslated(*(GLdouble *) (pc + 0),
-                 *(GLdouble *) (pc + 8), *(GLdouble *) (pc + 16));
+    CALL_Translated( GET_DISPATCH(), (
+        *(GLdouble *)(pc +  0),
+        *(GLdouble *)(pc +  8),
+        *(GLdouble *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_Translatef(GLbyte * pc)
+void __glXDisp_Translatef(GLbyte * pc)
 {
-    glTranslatef(*(GLfloat *) (pc + 0),
-                 *(GLfloat *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_Translatef( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_Viewport(GLbyte * pc)
+void __glXDisp_Viewport(GLbyte * pc)
 {
-    glViewport(*(GLint *) (pc + 0),
-               *(GLint *) (pc + 4),
-               *(GLsizei *) (pc + 8), *(GLsizei *) (pc + 12));
+    CALL_Viewport( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLsizei  *)(pc +  8),
+        *(GLsizei  *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_BindTexture(GLbyte * pc)
+void __glXDisp_BindTexture(GLbyte * pc)
 {
-    glBindTexture(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4));
+    CALL_BindTexture( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_Indexubv(GLbyte * pc)
+void __glXDisp_Indexubv(GLbyte * pc)
 {
-    glIndexubv((const GLubyte *) (pc + 0));
+    CALL_Indexubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PolygonOffset(GLbyte * pc)
+void __glXDisp_PolygonOffset(GLbyte * pc)
 {
-    glPolygonOffset(*(GLfloat *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_PolygonOffset( GET_DISPATCH(), (
+        *(GLfloat  *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-int
-__glXDisp_AreTexturesResident(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_AreTexturesResident(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLboolean retval;
         GLboolean answerBuffer[200];
-        GLboolean *residences =
-            __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
-
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
         if (residences == NULL)
             return BadAlloc;
-        retval =
-            glAreTexturesResident(n, (const GLuint *) (pc + 4), residences);
+
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreTexturesResident( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4),
+            residences
+        ) );
         __glXSendReply(cl->client, residences, n, 1, GL_TRUE, retval);
         error = Success;
     }
@@ -2476,26 +2765,30 @@ __glXDisp_AreTexturesResident(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_AreTexturesResidentEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_AreTexturesResidentEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLboolean retval;
         GLboolean answerBuffer[200];
-        GLboolean *residences =
-            __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
-
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
         if (residences == NULL)
             return BadAlloc;
-        retval =
-            glAreTexturesResident(n, (const GLuint *) (pc + 4), residences);
+
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreTexturesResident( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4),
+            residences
+        ) );
         __glXSendReply(cl->client, residences, n, 1, GL_TRUE, retval);
         error = Success;
     }
@@ -2503,106 +2796,121 @@ __glXDisp_AreTexturesResidentEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_CopyTexImage1D(GLbyte * pc)
+void __glXDisp_CopyTexImage1D(GLbyte * pc)
 {
-    glCopyTexImage1D(*(GLenum *) (pc + 0),
-                     *(GLint *) (pc + 4),
-                     *(GLenum *) (pc + 8),
-                     *(GLint *) (pc + 12),
-                     *(GLint *) (pc + 16),
-                     *(GLsizei *) (pc + 20), *(GLint *) (pc + 24));
+    CALL_CopyTexImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLsizei  *)(pc + 20),
+        *(GLint    *)(pc + 24)
+    ) );
 }
 
-void
-__glXDisp_CopyTexImage2D(GLbyte * pc)
+void __glXDisp_CopyTexImage2D(GLbyte * pc)
 {
-    glCopyTexImage2D(*(GLenum *) (pc + 0),
-                     *(GLint *) (pc + 4),
-                     *(GLenum *) (pc + 8),
-                     *(GLint *) (pc + 12),
-                     *(GLint *) (pc + 16),
-                     *(GLsizei *) (pc + 20),
-                     *(GLsizei *) (pc + 24), *(GLint *) (pc + 28));
+    CALL_CopyTexImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLsizei  *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLint    *)(pc + 28)
+    ) );
 }
 
-void
-__glXDisp_CopyTexSubImage1D(GLbyte * pc)
+void __glXDisp_CopyTexSubImage1D(GLbyte * pc)
 {
-    glCopyTexSubImage1D(*(GLenum *) (pc + 0),
-                        *(GLint *) (pc + 4),
-                        *(GLint *) (pc + 8),
-                        *(GLint *) (pc + 12),
-                        *(GLint *) (pc + 16), *(GLsizei *) (pc + 20));
+    CALL_CopyTexSubImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLsizei  *)(pc + 20)
+    ) );
 }
 
-void
-__glXDisp_CopyTexSubImage2D(GLbyte * pc)
+void __glXDisp_CopyTexSubImage2D(GLbyte * pc)
 {
-    glCopyTexSubImage2D(*(GLenum *) (pc + 0),
-                        *(GLint *) (pc + 4),
-                        *(GLint *) (pc + 8),
-                        *(GLint *) (pc + 12),
-                        *(GLint *) (pc + 16),
-                        *(GLint *) (pc + 20),
-                        *(GLsizei *) (pc + 24), *(GLsizei *) (pc + 28));
+    CALL_CopyTexSubImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLint    *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLsizei  *)(pc + 28)
+    ) );
 }
 
-int
-__glXDisp_DeleteTextures(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_DeleteTextures(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
-        glDeleteTextures(n, (const GLuint *) (pc + 4));
+        CALL_DeleteTextures( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_DeleteTexturesEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_DeleteTexturesEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
-        glDeleteTextures(n, (const GLuint *) (pc + 4));
+        CALL_DeleteTextures( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_GenTextures(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenTextures(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *textures =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * textures = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (textures == NULL)
             return BadAlloc;
-        glGenTextures(n, textures);
+
+        if (textures == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenTextures( GET_DISPATCH(), (
+            n,
+            textures
+        ) );
         __glXSendReply(cl->client, textures, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -2610,25 +2918,28 @@ __glXDisp_GenTextures(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GenTexturesEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenTexturesEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *textures =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * textures = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (textures == NULL)
             return BadAlloc;
-        glGenTextures(n, textures);
+
+        if (textures == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenTextures( GET_DISPATCH(), (
+            n,
+            textures
+        ) );
         __glXSendReply(cl->client, textures, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -2636,18 +2947,18 @@ __glXDisp_GenTexturesEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsTexture(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsTexture(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsTexture(*(GLuint *) (pc + 0));
+        retval = CALL_IsTexture( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2655,18 +2966,18 @@ __glXDisp_IsTexture(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsTextureEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsTextureEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsTexture(*(GLuint *) (pc + 0));
+        retval = CALL_IsTexture( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2674,144 +2985,165 @@ __glXDisp_IsTextureEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_PrioritizeTextures(GLbyte * pc)
+void __glXDisp_PrioritizeTextures(GLbyte * pc)
 {
-    const GLsizei n = *(GLsizei *) (pc + 0);
+    const GLsizei n = *(GLsizei  *)(pc +  0);
 
-    glPrioritizeTextures(n,
-                         (const GLuint *) (pc + 4),
-                         (const GLclampf *) (pc + 4));
+    CALL_PrioritizeTextures( GET_DISPATCH(), (
+        n,
+         (const GLuint *)(pc +  4),
+         (const GLclampf *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_TexSubImage1D(GLbyte * pc)
+void __glXDisp_TexSubImage1D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 56));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 56);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexSubImage1D(*(GLenum *) (pc + 20),
-                    *(GLint *) (pc + 24),
-                    *(GLint *) (pc + 28),
-                    *(GLsizei *) (pc + 36),
-                    *(GLenum *) (pc + 44), *(GLenum *) (pc + 48), pixels);
+    CALL_TexSubImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLint    *)(pc + 28),
+        *(GLsizei  *)(pc + 36),
+        *(GLenum   *)(pc + 44),
+        *(GLenum   *)(pc + 48),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_TexSubImage2D(GLbyte * pc)
+void __glXDisp_TexSubImage2D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 56));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 56);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexSubImage2D(*(GLenum *) (pc + 20),
-                    *(GLint *) (pc + 24),
-                    *(GLint *) (pc + 28),
-                    *(GLint *) (pc + 32),
-                    *(GLsizei *) (pc + 36),
-                    *(GLsizei *) (pc + 40),
-                    *(GLenum *) (pc + 44), *(GLenum *) (pc + 48), pixels);
+    CALL_TexSubImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLint    *)(pc + 28),
+        *(GLint    *)(pc + 32),
+        *(GLsizei  *)(pc + 36),
+        *(GLsizei  *)(pc + 40),
+        *(GLenum   *)(pc + 44),
+        *(GLenum   *)(pc + 48),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_BlendColor(GLbyte * pc)
+void __glXDisp_BlendColor(GLbyte * pc)
 {
-    glBlendColor(*(GLclampf *) (pc + 0),
-                 *(GLclampf *) (pc + 4),
-                 *(GLclampf *) (pc + 8), *(GLclampf *) (pc + 12));
+    CALL_BlendColor( GET_DISPATCH(), (
+        *(GLclampf *)(pc +  0),
+        *(GLclampf *)(pc +  4),
+        *(GLclampf *)(pc +  8),
+        *(GLclampf *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_BlendEquation(GLbyte * pc)
+void __glXDisp_BlendEquation(GLbyte * pc)
 {
-    glBlendEquation(*(GLenum *) (pc + 0));
+    CALL_BlendEquation( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ColorTable(GLbyte * pc)
+void __glXDisp_ColorTable(GLbyte * pc)
 {
-    const GLvoid *const table = (const GLvoid *) ((pc + 40));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const table = (const GLvoid *) (pc + 40);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glColorTable(*(GLenum *) (pc + 20),
-                 *(GLenum *) (pc + 24),
-                 *(GLsizei *) (pc + 28),
-                 *(GLenum *) (pc + 32), *(GLenum *) (pc + 36), table);
+    CALL_ColorTable( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLenum   *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLenum   *)(pc + 32),
+        *(GLenum   *)(pc + 36),
+        table
+    ) );
 }
 
-void
-__glXDisp_ColorTableParameterfv(GLbyte * pc)
+void __glXDisp_ColorTableParameterfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glColorTableParameterfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_ColorTableParameterfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_ColorTableParameteriv(GLbyte * pc)
+void __glXDisp_ColorTableParameteriv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glColorTableParameteriv(*(GLenum *) (pc + 0), pname, params);
+    CALL_ColorTableParameteriv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_CopyColorTable(GLbyte * pc)
+void __glXDisp_CopyColorTable(GLbyte * pc)
 {
-    glCopyColorTable(*(GLenum *) (pc + 0),
-                     *(GLenum *) (pc + 4),
-                     *(GLint *) (pc + 8),
-                     *(GLint *) (pc + 12), *(GLsizei *) (pc + 16));
+    CALL_CopyColorTable( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLsizei  *)(pc + 16)
+    ) );
 }
 
-int
-__glXDisp_GetColorTableParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetColorTableParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetColorTableParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetColorTableParameterfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetColorTableParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2819,86 +3151,28 @@ __glXDisp_GetColorTableParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetColorTableParameterfvSGI(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetColorTableParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetColorTableParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetColorTableParameterfv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetColorTableParameteriv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetColorTableParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetColorTableParameteriv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetColorTableParameterivSGI(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetColorTableParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetColorTableParameteriv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetColorTableParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2906,179 +3180,175 @@ __glXDisp_GetColorTableParameterivSGI(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_ColorSubTable(GLbyte * pc)
+void __glXDisp_ColorSubTable(GLbyte * pc)
 {
-    const GLvoid *const data = (const GLvoid *) ((pc + 40));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const data = (const GLvoid *) (pc + 40);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glColorSubTable(*(GLenum *) (pc + 20),
-                    *(GLsizei *) (pc + 24),
-                    *(GLsizei *) (pc + 28),
-                    *(GLenum *) (pc + 32), *(GLenum *) (pc + 36), data);
+    CALL_ColorSubTable( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLenum   *)(pc + 32),
+        *(GLenum   *)(pc + 36),
+        data
+    ) );
 }
 
-void
-__glXDisp_CopyColorSubTable(GLbyte * pc)
+void __glXDisp_CopyColorSubTable(GLbyte * pc)
 {
-    glCopyColorSubTable(*(GLenum *) (pc + 0),
-                        *(GLsizei *) (pc + 4),
-                        *(GLint *) (pc + 8),
-                        *(GLint *) (pc + 12), *(GLsizei *) (pc + 16));
+    CALL_CopyColorSubTable( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLsizei  *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLsizei  *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_ConvolutionFilter1D(GLbyte * pc)
+void __glXDisp_ConvolutionFilter1D(GLbyte * pc)
 {
-    const GLvoid *const image = (const GLvoid *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const image = (const GLvoid *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glConvolutionFilter1D(*(GLenum *) (pc + 20),
-                          *(GLenum *) (pc + 24),
-                          *(GLsizei *) (pc + 28),
-                          *(GLenum *) (pc + 36), *(GLenum *) (pc + 40), image);
+    CALL_ConvolutionFilter1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLenum   *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLenum   *)(pc + 36),
+        *(GLenum   *)(pc + 40),
+        image
+    ) );
 }
 
-void
-__glXDisp_ConvolutionFilter2D(GLbyte * pc)
+void __glXDisp_ConvolutionFilter2D(GLbyte * pc)
 {
-    const GLvoid *const image = (const GLvoid *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const image = (const GLvoid *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glConvolutionFilter2D(*(GLenum *) (pc + 20),
-                          *(GLenum *) (pc + 24),
-                          *(GLsizei *) (pc + 28),
-                          *(GLsizei *) (pc + 32),
-                          *(GLenum *) (pc + 36), *(GLenum *) (pc + 40), image);
+    CALL_ConvolutionFilter2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 20),
+        *(GLenum   *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLsizei  *)(pc + 32),
+        *(GLenum   *)(pc + 36),
+        *(GLenum   *)(pc + 40),
+        image
+    ) );
 }
 
-void
-__glXDisp_ConvolutionParameterf(GLbyte * pc)
+void __glXDisp_ConvolutionParameterf(GLbyte * pc)
 {
-    glConvolutionParameterf(*(GLenum *) (pc + 0),
-                            *(GLenum *) (pc + 4), *(GLfloat *) (pc + 8));
+    CALL_ConvolutionParameterf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLfloat  *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ConvolutionParameterfv(GLbyte * pc)
+void __glXDisp_ConvolutionParameterfv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 8);
 
-    glConvolutionParameterfv(*(GLenum *) (pc + 0), pname, params);
+    CALL_ConvolutionParameterfv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_ConvolutionParameteri(GLbyte * pc)
+void __glXDisp_ConvolutionParameteri(GLbyte * pc)
 {
-    glConvolutionParameteri(*(GLenum *) (pc + 0),
-                            *(GLenum *) (pc + 4), *(GLint *) (pc + 8));
+    CALL_ConvolutionParameteri( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ConvolutionParameteriv(GLbyte * pc)
+void __glXDisp_ConvolutionParameteriv(GLbyte * pc)
 {
-    const GLenum pname = *(GLenum *) (pc + 4);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  4);
+    const GLint * params;
 
     params = (const GLint *) (pc + 8);
 
-    glConvolutionParameteriv(*(GLenum *) (pc + 0), pname, params);
+    CALL_ConvolutionParameteriv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_CopyConvolutionFilter1D(GLbyte * pc)
+void __glXDisp_CopyConvolutionFilter1D(GLbyte * pc)
 {
-    glCopyConvolutionFilter1D(*(GLenum *) (pc + 0),
-                              *(GLenum *) (pc + 4),
-                              *(GLint *) (pc + 8),
-                              *(GLint *) (pc + 12), *(GLsizei *) (pc + 16));
+    CALL_CopyConvolutionFilter1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLsizei  *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_CopyConvolutionFilter2D(GLbyte * pc)
+void __glXDisp_CopyConvolutionFilter2D(GLbyte * pc)
 {
-    glCopyConvolutionFilter2D(*(GLenum *) (pc + 0),
-                              *(GLenum *) (pc + 4),
-                              *(GLint *) (pc + 8),
-                              *(GLint *) (pc + 12),
-                              *(GLsizei *) (pc + 16), *(GLsizei *) (pc + 20));
+    CALL_CopyConvolutionFilter2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLsizei  *)(pc + 16),
+        *(GLsizei  *)(pc + 20)
+    ) );
 }
 
-int
-__glXDisp_GetConvolutionParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetConvolutionParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetConvolutionParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetConvolutionParameterfv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetConvolutionParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetConvolutionParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetConvolutionParameterfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetConvolutionParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3086,57 +3356,28 @@ __glXDisp_GetConvolutionParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetConvolutionParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetConvolutionParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetConvolutionParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetConvolutionParameteriv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetConvolutionParameterivEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetConvolutionParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetConvolutionParameteriv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetConvolutionParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3144,28 +3385,28 @@ __glXDisp_GetConvolutionParameterivEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetHistogramParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetHistogramParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetHistogramParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetHistogramParameterfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetHistogramParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3173,57 +3414,28 @@ __glXDisp_GetHistogramParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetHistogramParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetHistogramParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetHistogramParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetHistogramParameterfv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetHistogramParameteriv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetHistogramParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetHistogramParameteriv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetHistogramParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3231,57 +3443,28 @@ __glXDisp_GetHistogramParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetHistogramParameterivEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMinmaxParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetHistogramParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetHistogramParameteriv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetMinmaxParameterfv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetMinmaxParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMinmaxParameterfv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetMinmaxParameterfv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3289,86 +3472,28 @@ __glXDisp_GetMinmaxParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetMinmaxParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetMinmaxParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetMinmaxParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetMinmaxParameterfv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetMinmaxParameteriv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
-
-        const GLuint compsize = __glGetMinmaxParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetMinmaxParameteriv(*(GLenum *) (pc + 0), pname, params);
-        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDisp_GetMinmaxParameterivEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetMinmaxParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMinmaxParameteriv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetMinmaxParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3376,529 +3501,568 @@ __glXDisp_GetMinmaxParameterivEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_Histogram(GLbyte * pc)
-{
-    glHistogram(*(GLenum *) (pc + 0),
-                *(GLsizei *) (pc + 4),
-                *(GLenum *) (pc + 8), *(GLboolean *) (pc + 12));
+void __glXDisp_Histogram(GLbyte * pc)
+{
+    CALL_Histogram( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLsizei  *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLboolean *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_Minmax(GLbyte * pc)
+void __glXDisp_Minmax(GLbyte * pc)
 {
-    glMinmax(*(GLenum *) (pc + 0),
-             *(GLenum *) (pc + 4), *(GLboolean *) (pc + 8));
+    CALL_Minmax( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLboolean *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ResetHistogram(GLbyte * pc)
+void __glXDisp_ResetHistogram(GLbyte * pc)
 {
-    glResetHistogram(*(GLenum *) (pc + 0));
+    CALL_ResetHistogram( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_ResetMinmax(GLbyte * pc)
+void __glXDisp_ResetMinmax(GLbyte * pc)
 {
-    glResetMinmax(*(GLenum *) (pc + 0));
+    CALL_ResetMinmax( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_TexImage3D(GLbyte * pc)
+void __glXDisp_TexImage3D(GLbyte * pc)
 {
-    const CARD32 ptr_is_null = *(CARD32 *) (pc + 76);
-    const GLvoid *const pixels =
-        (const GLvoid *) ((ptr_is_null != 0) ? NULL : (pc + 80));
-    __GLXpixel3DHeader *const hdr = (__GLXpixel3DHeader *) (pc);
+    const CARD32 ptr_is_null = *(CARD32 *)(pc + 76);
+    const GLvoid * const pixels = (const GLvoid *) ((ptr_is_null != 0) ? NULL : (pc + 80));
+    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, (GLint) hdr->imageHeight);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_IMAGES, (GLint) hdr->skipImages);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) hdr->imageHeight) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) hdr->skipImages) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexImage3D(*(GLenum *) (pc + 36),
-                 *(GLint *) (pc + 40),
-                 *(GLint *) (pc + 44),
-                 *(GLsizei *) (pc + 48),
-                 *(GLsizei *) (pc + 52),
-                 *(GLsizei *) (pc + 56),
-                 *(GLint *) (pc + 64),
-                 *(GLenum *) (pc + 68), *(GLenum *) (pc + 72), pixels);
+    CALL_TexImage3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 36),
+        *(GLint    *)(pc + 40),
+        *(GLint    *)(pc + 44),
+        *(GLsizei  *)(pc + 48),
+        *(GLsizei  *)(pc + 52),
+        *(GLsizei  *)(pc + 56),
+        *(GLint    *)(pc + 64),
+        *(GLenum   *)(pc + 68),
+        *(GLenum   *)(pc + 72),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_TexSubImage3D(GLbyte * pc)
+void __glXDisp_TexSubImage3D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 88));
-    __GLXpixel3DHeader *const hdr = (__GLXpixel3DHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 88);
+    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) hdr->rowLength);
-    glPixelStorei(GL_UNPACK_IMAGE_HEIGHT, (GLint) hdr->imageHeight);
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) hdr->skipRows);
-    glPixelStorei(GL_UNPACK_SKIP_IMAGES, (GLint) hdr->skipImages);
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS, (GLint) hdr->skipPixels);
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) hdr->alignment);
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) hdr->rowLength) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) hdr->imageHeight) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) hdr->skipRows) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) hdr->skipImages) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) hdr->skipPixels) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) hdr->alignment) );
 
-    glTexSubImage3D(*(GLenum *) (pc + 36),
-                    *(GLint *) (pc + 40),
-                    *(GLint *) (pc + 44),
-                    *(GLint *) (pc + 48),
-                    *(GLint *) (pc + 52),
-                    *(GLsizei *) (pc + 60),
-                    *(GLsizei *) (pc + 64),
-                    *(GLsizei *) (pc + 68),
-                    *(GLenum *) (pc + 76), *(GLenum *) (pc + 80), pixels);
+    CALL_TexSubImage3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 36),
+        *(GLint    *)(pc + 40),
+        *(GLint    *)(pc + 44),
+        *(GLint    *)(pc + 48),
+        *(GLint    *)(pc + 52),
+        *(GLsizei  *)(pc + 60),
+        *(GLsizei  *)(pc + 64),
+        *(GLsizei  *)(pc + 68),
+        *(GLenum   *)(pc + 76),
+        *(GLenum   *)(pc + 80),
+        pixels
+    ) );
 }
 
-void
-__glXDisp_CopyTexSubImage3D(GLbyte * pc)
+void __glXDisp_CopyTexSubImage3D(GLbyte * pc)
 {
-    glCopyTexSubImage3D(*(GLenum *) (pc + 0),
-                        *(GLint *) (pc + 4),
-                        *(GLint *) (pc + 8),
-                        *(GLint *) (pc + 12),
-                        *(GLint *) (pc + 16),
-                        *(GLint *) (pc + 20),
-                        *(GLint *) (pc + 24),
-                        *(GLsizei *) (pc + 28), *(GLsizei *) (pc + 32));
+    CALL_CopyTexSubImage3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLint    *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLsizei  *)(pc + 32)
+    ) );
 }
 
-void
-__glXDisp_ActiveTexture(GLbyte * pc)
+void __glXDisp_ActiveTexture(GLbyte * pc)
 {
-    glActiveTextureARB(*(GLenum *) (pc + 0));
+    CALL_ActiveTexture( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord1dv(GLbyte * pc)
+void __glXDisp_MultiTexCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord1dvARB(*(GLenum *) (pc + 8), (const GLdouble *) (pc + 0));
+    CALL_MultiTexCoord1dv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  8),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord1fvARB(GLbyte * pc)
+void __glXDisp_MultiTexCoord1fvARB(GLbyte * pc)
 {
-    glMultiTexCoord1fvARB(*(GLenum *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_MultiTexCoord1fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord1iv(GLbyte * pc)
+void __glXDisp_MultiTexCoord1iv(GLbyte * pc)
 {
-    glMultiTexCoord1ivARB(*(GLenum *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_MultiTexCoord1iv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord1sv(GLbyte * pc)
+void __glXDisp_MultiTexCoord1sv(GLbyte * pc)
 {
-    glMultiTexCoord1svARB(*(GLenum *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_MultiTexCoord1sv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord2dv(GLbyte * pc)
+void __glXDisp_MultiTexCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord2dvARB(*(GLenum *) (pc + 16), (const GLdouble *) (pc + 0));
+    CALL_MultiTexCoord2dv( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 16),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord2fvARB(GLbyte * pc)
+void __glXDisp_MultiTexCoord2fvARB(GLbyte * pc)
 {
-    glMultiTexCoord2fvARB(*(GLenum *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_MultiTexCoord2fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord2iv(GLbyte * pc)
+void __glXDisp_MultiTexCoord2iv(GLbyte * pc)
 {
-    glMultiTexCoord2ivARB(*(GLenum *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_MultiTexCoord2iv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord2sv(GLbyte * pc)
+void __glXDisp_MultiTexCoord2sv(GLbyte * pc)
 {
-    glMultiTexCoord2svARB(*(GLenum *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_MultiTexCoord2sv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord3dv(GLbyte * pc)
+void __glXDisp_MultiTexCoord3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord3dvARB(*(GLenum *) (pc + 24), (const GLdouble *) (pc + 0));
+    CALL_MultiTexCoord3dv( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 24),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord3fvARB(GLbyte * pc)
+void __glXDisp_MultiTexCoord3fvARB(GLbyte * pc)
 {
-    glMultiTexCoord3fvARB(*(GLenum *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_MultiTexCoord3fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord3iv(GLbyte * pc)
+void __glXDisp_MultiTexCoord3iv(GLbyte * pc)
 {
-    glMultiTexCoord3ivARB(*(GLenum *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_MultiTexCoord3iv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord3sv(GLbyte * pc)
+void __glXDisp_MultiTexCoord3sv(GLbyte * pc)
 {
-    glMultiTexCoord3svARB(*(GLenum *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_MultiTexCoord3sv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord4dv(GLbyte * pc)
+void __glXDisp_MultiTexCoord4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord4dvARB(*(GLenum *) (pc + 32), (const GLdouble *) (pc + 0));
+    CALL_MultiTexCoord4dv( GET_DISPATCH(), (
+        *(GLenum   *)(pc + 32),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord4fvARB(GLbyte * pc)
+void __glXDisp_MultiTexCoord4fvARB(GLbyte * pc)
 {
-    glMultiTexCoord4fvARB(*(GLenum *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_MultiTexCoord4fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord4iv(GLbyte * pc)
+void __glXDisp_MultiTexCoord4iv(GLbyte * pc)
 {
-    glMultiTexCoord4ivARB(*(GLenum *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_MultiTexCoord4iv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_MultiTexCoord4sv(GLbyte * pc)
+void __glXDisp_MultiTexCoord4sv(GLbyte * pc)
 {
-    glMultiTexCoord4svARB(*(GLenum *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_MultiTexCoord4sv( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexImage1D(GLbyte * pc)
+void __glXDisp_CompressedTexImage1D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE1DPROC CompressedTexImage1D =
-        __glGetProcAddress("glCompressedTexImage1D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 20);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 20);
 
-    CompressedTexImage1D(*(GLenum *) (pc + 0),
-                         *(GLint *) (pc + 4),
-                         *(GLenum *) (pc + 8),
-                         *(GLsizei *) (pc + 12),
-                         *(GLint *) (pc + 16),
-                         imageSize, (const GLvoid *) (pc + 24));
+    CALL_CompressedTexImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        imageSize,
+         (const GLvoid *)(pc + 24)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexImage2D(GLbyte * pc)
+void __glXDisp_CompressedTexImage2D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE2DPROC CompressedTexImage2D =
-        __glGetProcAddress("glCompressedTexImage2D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 24);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 24);
 
-    CompressedTexImage2D(*(GLenum *) (pc + 0),
-                         *(GLint *) (pc + 4),
-                         *(GLenum *) (pc + 8),
-                         *(GLsizei *) (pc + 12),
-                         *(GLsizei *) (pc + 16),
-                         *(GLint *) (pc + 20),
-                         imageSize, (const GLvoid *) (pc + 28));
+    CALL_CompressedTexImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLsizei  *)(pc + 16),
+        *(GLint    *)(pc + 20),
+        imageSize,
+         (const GLvoid *)(pc + 28)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexImage3D(GLbyte * pc)
+void __glXDisp_CompressedTexImage3D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE3DPROC CompressedTexImage3D =
-        __glGetProcAddress("glCompressedTexImage3D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 28);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 28);
 
-    CompressedTexImage3D(*(GLenum *) (pc + 0),
-                         *(GLint *) (pc + 4),
-                         *(GLenum *) (pc + 8),
-                         *(GLsizei *) (pc + 12),
-                         *(GLsizei *) (pc + 16),
-                         *(GLsizei *) (pc + 20),
-                         *(GLint *) (pc + 24),
-                         imageSize, (const GLvoid *) (pc + 32));
+    CALL_CompressedTexImage3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLsizei  *)(pc + 16),
+        *(GLsizei  *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        imageSize,
+         (const GLvoid *)(pc + 32)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexSubImage1D(GLbyte * pc)
+void __glXDisp_CompressedTexSubImage1D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC CompressedTexSubImage1D =
-        __glGetProcAddress("glCompressedTexSubImage1D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 20);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 20);
 
-    CompressedTexSubImage1D(*(GLenum *) (pc + 0),
-                            *(GLint *) (pc + 4),
-                            *(GLint *) (pc + 8),
-                            *(GLsizei *) (pc + 12),
-                            *(GLenum *) (pc + 16),
-                            imageSize, (const GLvoid *) (pc + 24));
+    CALL_CompressedTexSubImage1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLenum   *)(pc + 16),
+        imageSize,
+         (const GLvoid *)(pc + 24)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexSubImage2D(GLbyte * pc)
+void __glXDisp_CompressedTexSubImage2D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC CompressedTexSubImage2D =
-        __glGetProcAddress("glCompressedTexSubImage2D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 28);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 28);
 
-    CompressedTexSubImage2D(*(GLenum *) (pc + 0),
-                            *(GLint *) (pc + 4),
-                            *(GLint *) (pc + 8),
-                            *(GLint *) (pc + 12),
-                            *(GLsizei *) (pc + 16),
-                            *(GLsizei *) (pc + 20),
-                            *(GLenum *) (pc + 24),
-                            imageSize, (const GLvoid *) (pc + 32));
+    CALL_CompressedTexSubImage2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLsizei  *)(pc + 16),
+        *(GLsizei  *)(pc + 20),
+        *(GLenum   *)(pc + 24),
+        imageSize,
+         (const GLvoid *)(pc + 32)
+    ) );
 }
 
-void
-__glXDisp_CompressedTexSubImage3D(GLbyte * pc)
+void __glXDisp_CompressedTexSubImage3D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC CompressedTexSubImage3D =
-        __glGetProcAddress("glCompressedTexSubImage3D");
-    const GLsizei imageSize = *(GLsizei *) (pc + 36);
+    const GLsizei imageSize = *(GLsizei  *)(pc + 36);
 
-    CompressedTexSubImage3D(*(GLenum *) (pc + 0),
-                            *(GLint *) (pc + 4),
-                            *(GLint *) (pc + 8),
-                            *(GLint *) (pc + 12),
-                            *(GLint *) (pc + 16),
-                            *(GLsizei *) (pc + 20),
-                            *(GLsizei *) (pc + 24),
-                            *(GLsizei *) (pc + 28),
-                            *(GLenum *) (pc + 32),
-                            imageSize, (const GLvoid *) (pc + 40));
+    CALL_CompressedTexSubImage3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLsizei  *)(pc + 20),
+        *(GLsizei  *)(pc + 24),
+        *(GLsizei  *)(pc + 28),
+        *(GLenum   *)(pc + 32),
+        imageSize,
+         (const GLvoid *)(pc + 40)
+    ) );
 }
 
-void
-__glXDisp_SampleCoverage(GLbyte * pc)
+void __glXDisp_SampleCoverage(GLbyte * pc)
 {
-    PFNGLSAMPLECOVERAGEPROC SampleCoverage =
-        __glGetProcAddress("glSampleCoverage");
-    SampleCoverage(*(GLclampf *) (pc + 0), *(GLboolean *) (pc + 4));
+    CALL_SampleCoverage( GET_DISPATCH(), (
+        *(GLclampf *)(pc +  0),
+        *(GLboolean *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BlendFuncSeparate(GLbyte * pc)
+void __glXDisp_BlendFuncSeparate(GLbyte * pc)
 {
-    PFNGLBLENDFUNCSEPARATEPROC BlendFuncSeparate =
-        __glGetProcAddress("glBlendFuncSeparate");
-    BlendFuncSeparate(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                      *(GLenum *) (pc + 8), *(GLenum *) (pc + 12));
+    CALL_BlendFuncSeparate( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLenum   *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_FogCoorddv(GLbyte * pc)
+void __glXDisp_FogCoorddv(GLbyte * pc)
 {
-    PFNGLFOGCOORDDVPROC FogCoorddv = __glGetProcAddress("glFogCoorddv");
-
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    FogCoorddv((const GLdouble *) (pc + 0));
+    CALL_FogCoorddv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_PointParameterf(GLbyte * pc)
+void __glXDisp_PointParameterf(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERFPROC PointParameterf =
-        __glGetProcAddress("glPointParameterf");
-    PointParameterf(*(GLenum *) (pc + 0), *(GLfloat *) (pc + 4));
+    CALL_PointParameterf( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLfloat  *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_PointParameterfv(GLbyte * pc)
+void __glXDisp_PointParameterfv(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERFVPROC PointParameterfv =
-        __glGetProcAddress("glPointParameterfv");
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLfloat *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLfloat * params;
 
     params = (const GLfloat *) (pc + 4);
 
-    PointParameterfv(pname, params);
+    CALL_PointParameterfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_PointParameteri(GLbyte * pc)
+void __glXDisp_PointParameteri(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERIPROC PointParameteri =
-        __glGetProcAddress("glPointParameteri");
-    PointParameteri(*(GLenum *) (pc + 0), *(GLint *) (pc + 4));
+    CALL_PointParameteri( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLint    *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_PointParameteriv(GLbyte * pc)
+void __glXDisp_PointParameteriv(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERIVPROC PointParameteriv =
-        __glGetProcAddress("glPointParameteriv");
-    const GLenum pname = *(GLenum *) (pc + 0);
-    const GLint *params;
+    const GLenum pname = *(GLenum   *)(pc +  0);
+    const GLint * params;
 
     params = (const GLint *) (pc + 4);
 
-    PointParameteriv(pname, params);
+    CALL_PointParameteriv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3bv(GLbyte * pc)
+void __glXDisp_SecondaryColor3bv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3BVPROC SecondaryColor3bv =
-        __glGetProcAddress("glSecondaryColor3bv");
-    SecondaryColor3bv((const GLbyte *) (pc + 0));
+    CALL_SecondaryColor3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3dv(GLbyte * pc)
+void __glXDisp_SecondaryColor3dv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3DVPROC SecondaryColor3dv =
-        __glGetProcAddress("glSecondaryColor3dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    SecondaryColor3dv((const GLdouble *) (pc + 0));
+    CALL_SecondaryColor3dv( GET_DISPATCH(), (
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3iv(GLbyte * pc)
+void __glXDisp_SecondaryColor3iv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3IVPROC SecondaryColor3iv =
-        __glGetProcAddress("glSecondaryColor3iv");
-    SecondaryColor3iv((const GLint *) (pc + 0));
+    CALL_SecondaryColor3iv( GET_DISPATCH(), (
+         (const GLint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3sv(GLbyte * pc)
+void __glXDisp_SecondaryColor3sv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3SVPROC SecondaryColor3sv =
-        __glGetProcAddress("glSecondaryColor3sv");
-    SecondaryColor3sv((const GLshort *) (pc + 0));
+    CALL_SecondaryColor3sv( GET_DISPATCH(), (
+         (const GLshort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3ubv(GLbyte * pc)
+void __glXDisp_SecondaryColor3ubv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3UBVPROC SecondaryColor3ubv =
-        __glGetProcAddress("glSecondaryColor3ubv");
-    SecondaryColor3ubv((const GLubyte *) (pc + 0));
+    CALL_SecondaryColor3ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3uiv(GLbyte * pc)
+void __glXDisp_SecondaryColor3uiv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3UIVPROC SecondaryColor3uiv =
-        __glGetProcAddress("glSecondaryColor3uiv");
-    SecondaryColor3uiv((const GLuint *) (pc + 0));
+    CALL_SecondaryColor3uiv( GET_DISPATCH(), (
+         (const GLuint *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_SecondaryColor3usv(GLbyte * pc)
+void __glXDisp_SecondaryColor3usv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3USVPROC SecondaryColor3usv =
-        __glGetProcAddress("glSecondaryColor3usv");
-    SecondaryColor3usv((const GLushort *) (pc + 0));
+    CALL_SecondaryColor3usv( GET_DISPATCH(), (
+         (const GLushort *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_WindowPos3fv(GLbyte * pc)
+void __glXDisp_WindowPos3fv(GLbyte * pc)
 {
-    PFNGLWINDOWPOS3FVPROC WindowPos3fv = __glGetProcAddress("glWindowPos3fv");
-
-    WindowPos3fv((const GLfloat *) (pc + 0));
+    CALL_WindowPos3fv( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_BeginQuery(GLbyte * pc)
+void __glXDisp_BeginQuery(GLbyte * pc)
 {
-    PFNGLBEGINQUERYPROC BeginQuery = __glGetProcAddress("glBeginQuery");
-
-    BeginQuery(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4));
+    CALL_BeginQuery( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
 
-int
-__glXDisp_DeleteQueries(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_DeleteQueries(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLDELETEQUERIESPROC DeleteQueries =
-        __glGetProcAddress("glDeleteQueries");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
-        DeleteQueries(n, (const GLuint *) (pc + 4));
+        CALL_DeleteQueries( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDisp_EndQuery(GLbyte * pc)
+void __glXDisp_EndQuery(GLbyte * pc)
 {
-    PFNGLENDQUERYPROC EndQuery = __glGetProcAddress("glEndQuery");
-
-    EndQuery(*(GLenum *) (pc + 0));
+    CALL_EndQuery( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-int
-__glXDisp_GenQueries(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenQueries(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENQUERIESPROC GenQueries = __glGetProcAddress("glGenQueries");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *ids =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * ids = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (ids == NULL)
             return BadAlloc;
-        GenQueries(n, ids);
+
+        if (ids == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenQueries( GET_DISPATCH(), (
+            n,
+            ids
+        ) );
         __glXSendReply(cl->client, ids, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -3906,30 +4070,28 @@ __glXDisp_GenQueries(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetQueryObjectiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetQueryObjectiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYOBJECTIVPROC GetQueryObjectiv =
-        __glGetProcAddress("glGetQueryObjectiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetQueryObjectiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryObjectiv(*(GLuint *) (pc + 0), pname, params);
+        CALL_GetQueryObjectiv( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3937,30 +4099,28 @@ __glXDisp_GetQueryObjectiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetQueryObjectuiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetQueryObjectuiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYOBJECTUIVPROC GetQueryObjectuiv =
-        __glGetProcAddress("glGetQueryObjectuiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetQueryObjectuiv_size(pname);
         GLuint answerBuffer[200];
-        GLuint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLuint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryObjectuiv(*(GLuint *) (pc + 0), pname, params);
+        CALL_GetQueryObjectuiv( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3968,29 +4128,28 @@ __glXDisp_GetQueryObjectuiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetQueryiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetQueryiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYIVPROC GetQueryiv = __glGetProcAddress("glGetQueryiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetQueryiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryiv(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetQueryiv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3998,19 +4157,18 @@ __glXDisp_GetQueryiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsQuery(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsQuery(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISQUERYPROC IsQuery = __glGetProcAddress("glIsQuery");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = IsQuery(*(GLuint *) (pc + 0));
+        retval = CALL_IsQuery( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4018,260 +4176,349 @@ __glXDisp_IsQuery(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_BlendEquationSeparate(GLbyte * pc)
+void __glXDisp_BlendEquationSeparate(GLbyte * pc)
+{
+    CALL_BlendEquationSeparate( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
+}
+
+void __glXDisp_DrawBuffers(GLbyte * pc)
 {
-    PFNGLBLENDEQUATIONSEPARATEPROC BlendEquationSeparate =
-        __glGetProcAddress("glBlendEquationSeparate");
-    BlendEquationSeparate(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    const GLsizei n = *(GLsizei  *)(pc +  0);
+
+    CALL_DrawBuffers( GET_DISPATCH(), (
+        n,
+         (const GLenum *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_DrawBuffers(GLbyte * pc)
+int __glXDisp_GetVertexAttribdv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLDRAWBUFFERSPROC DrawBuffers = __glGetProcAddress("glDrawBuffers");
-    const GLsizei n = *(GLsizei *) (pc + 0);
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribdv_size(pname);
+        GLdouble answerBuffer[200];
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribdv( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 8, GL_FALSE, 0);
+        error = Success;
+    }
 
-    DrawBuffers(n, (const GLenum *) (pc + 4));
+    return error;
 }
 
-void
-__glXDisp_VertexAttrib1dv(GLbyte * pc)
+int __glXDisp_GetVertexAttribfv(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribfv_size(pname);
+        GLfloat answerBuffer[200];
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribfv( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_GetVertexAttribiv(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribiv_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribiv( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+void __glXDisp_VertexAttrib1dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1DVPROC VertexAttrib1dv =
-        __glGetProcAddress("glVertexAttrib1dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib1dv(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib1dv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib1sv(GLbyte * pc)
+void __glXDisp_VertexAttrib1sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1SVPROC VertexAttrib1sv =
-        __glGetProcAddress("glVertexAttrib1sv");
-    VertexAttrib1sv(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib1sv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2dv(GLbyte * pc)
+void __glXDisp_VertexAttrib2dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2DVPROC VertexAttrib2dv =
-        __glGetProcAddress("glVertexAttrib2dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib2dv(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib2dv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2sv(GLbyte * pc)
+void __glXDisp_VertexAttrib2sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2SVPROC VertexAttrib2sv =
-        __glGetProcAddress("glVertexAttrib2sv");
-    VertexAttrib2sv(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib2sv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3dv(GLbyte * pc)
+void __glXDisp_VertexAttrib3dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3DVPROC VertexAttrib3dv =
-        __glGetProcAddress("glVertexAttrib3dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib3dv(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib3dv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3sv(GLbyte * pc)
+void __glXDisp_VertexAttrib3sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3SVPROC VertexAttrib3sv =
-        __glGetProcAddress("glVertexAttrib3sv");
-    VertexAttrib3sv(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib3sv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Nbv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Nbv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NBVPROC VertexAttrib4Nbv =
-        __glGetProcAddress("glVertexAttrib4Nbv");
-    VertexAttrib4Nbv(*(GLuint *) (pc + 0), (const GLbyte *) (pc + 4));
+    CALL_VertexAttrib4Nbv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLbyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Niv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Niv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NIVPROC VertexAttrib4Niv =
-        __glGetProcAddress("glVertexAttrib4Niv");
-    VertexAttrib4Niv(*(GLuint *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_VertexAttrib4Niv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Nsv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Nsv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NSVPROC VertexAttrib4Nsv =
-        __glGetProcAddress("glVertexAttrib4Nsv");
-    VertexAttrib4Nsv(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib4Nsv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Nubv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Nubv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUBVPROC VertexAttrib4Nubv =
-        __glGetProcAddress("glVertexAttrib4Nubv");
-    VertexAttrib4Nubv(*(GLuint *) (pc + 0), (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4Nubv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Nuiv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Nuiv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUIVPROC VertexAttrib4Nuiv =
-        __glGetProcAddress("glVertexAttrib4Nuiv");
-    VertexAttrib4Nuiv(*(GLuint *) (pc + 0), (const GLuint *) (pc + 4));
+    CALL_VertexAttrib4Nuiv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLuint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4Nusv(GLbyte * pc)
+void __glXDisp_VertexAttrib4Nusv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUSVPROC VertexAttrib4Nusv =
-        __glGetProcAddress("glVertexAttrib4Nusv");
-    VertexAttrib4Nusv(*(GLuint *) (pc + 0), (const GLushort *) (pc + 4));
+    CALL_VertexAttrib4Nusv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLushort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4bv(GLbyte * pc)
+void __glXDisp_VertexAttrib4bv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4BVPROC VertexAttrib4bv =
-        __glGetProcAddress("glVertexAttrib4bv");
-    VertexAttrib4bv(*(GLuint *) (pc + 0), (const GLbyte *) (pc + 4));
+    CALL_VertexAttrib4bv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLbyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4dv(GLbyte * pc)
+void __glXDisp_VertexAttrib4dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4DVPROC VertexAttrib4dv =
-        __glGetProcAddress("glVertexAttrib4dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib4dv(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib4dv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4iv(GLbyte * pc)
+void __glXDisp_VertexAttrib4iv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4IVPROC VertexAttrib4iv =
-        __glGetProcAddress("glVertexAttrib4iv");
-    VertexAttrib4iv(*(GLuint *) (pc + 0), (const GLint *) (pc + 4));
+    CALL_VertexAttrib4iv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4sv(GLbyte * pc)
+void __glXDisp_VertexAttrib4sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4SVPROC VertexAttrib4sv =
-        __glGetProcAddress("glVertexAttrib4sv");
-    VertexAttrib4sv(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib4sv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4ubv(GLbyte * pc)
+void __glXDisp_VertexAttrib4ubv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UBVPROC VertexAttrib4ubv =
-        __glGetProcAddress("glVertexAttrib4ubv");
-    VertexAttrib4ubv(*(GLuint *) (pc + 0), (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4ubv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4uiv(GLbyte * pc)
+void __glXDisp_VertexAttrib4uiv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UIVPROC VertexAttrib4uiv =
-        __glGetProcAddress("glVertexAttrib4uiv");
-    VertexAttrib4uiv(*(GLuint *) (pc + 0), (const GLuint *) (pc + 4));
+    CALL_VertexAttrib4uiv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLuint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4usv(GLbyte * pc)
+void __glXDisp_VertexAttrib4usv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4USVPROC VertexAttrib4usv =
-        __glGetProcAddress("glVertexAttrib4usv");
-    VertexAttrib4usv(*(GLuint *) (pc + 0), (const GLushort *) (pc + 4));
+    CALL_VertexAttrib4usv( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLushort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_ClampColor(GLbyte * pc)
+void __glXDisp_ClampColor(GLbyte * pc)
 {
-    PFNGLCLAMPCOLORPROC ClampColor = __glGetProcAddress("glClampColor");
-
-    ClampColor(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4));
+    CALL_ClampColor( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BindProgramARB(GLbyte * pc)
+void __glXDisp_BindProgramARB(GLbyte * pc)
 {
-    PFNGLBINDPROGRAMARBPROC BindProgramARB =
-        __glGetProcAddress("glBindProgramARB");
-    BindProgramARB(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4));
+    CALL_BindProgramARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
 
-int
-__glXDisp_DeleteProgramsARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_DeleteProgramsARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLDELETEPROGRAMSARBPROC DeleteProgramsARB =
-        __glGetProcAddress("glDeleteProgramsARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
-        DeleteProgramsARB(n, (const GLuint *) (pc + 4));
+        CALL_DeleteProgramsARB( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4)
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDisp_GenProgramsARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenProgramsARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENPROGRAMSARBPROC GenProgramsARB =
-        __glGetProcAddress("glGenProgramsARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *programs =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * programs = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (programs == NULL)
             return BadAlloc;
-        GenProgramsARB(n, programs);
+
+        if (programs == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenProgramsARB( GET_DISPATCH(), (
+            n,
+            programs
+        ) );
         __glXSendReply(cl->client, programs, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -4279,21 +4526,20 @@ __glXDisp_GenProgramsARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetProgramEnvParameterdvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetProgramEnvParameterdvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMENVPARAMETERDVARBPROC GetProgramEnvParameterdvARB =
-        __glGetProcAddress("glGetProgramEnvParameterdvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble params[4];
-
-        GetProgramEnvParameterdvARB(*(GLenum *) (pc + 0),
-                                    *(GLuint *) (pc + 4), params);
+        CALL_GetProgramEnvParameterdvARB( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            params
+        ) );
         __glXSendReply(cl->client, params, 4, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -4301,21 +4547,20 @@ __glXDisp_GetProgramEnvParameterdvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetProgramEnvParameterfvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetProgramEnvParameterfvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMENVPARAMETERFVARBPROC GetProgramEnvParameterfvARB =
-        __glGetProcAddress("glGetProgramEnvParameterfvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLfloat params[4];
-
-        GetProgramEnvParameterfvARB(*(GLenum *) (pc + 0),
-                                    *(GLuint *) (pc + 4), params);
+        CALL_GetProgramEnvParameterfvARB( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            params
+        ) );
         __glXSendReply(cl->client, params, 4, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4323,21 +4568,20 @@ __glXDisp_GetProgramEnvParameterfvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetProgramLocalParameterdvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetProgramLocalParameterdvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC GetProgramLocalParameterdvARB =
-        __glGetProcAddress("glGetProgramLocalParameterdvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble params[4];
-
-        GetProgramLocalParameterdvARB(*(GLenum *) (pc + 0),
-                                      *(GLuint *) (pc + 4), params);
+        CALL_GetProgramLocalParameterdvARB( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            params
+        ) );
         __glXSendReply(cl->client, params, 4, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -4345,21 +4589,20 @@ __glXDisp_GetProgramLocalParameterdvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetProgramLocalParameterfvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetProgramLocalParameterfvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC GetProgramLocalParameterfvARB =
-        __glGetProcAddress("glGetProgramLocalParameterfvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLfloat params[4];
-
-        GetProgramLocalParameterfvARB(*(GLenum *) (pc + 0),
-                                      *(GLuint *) (pc + 4), params);
+        CALL_GetProgramLocalParameterfvARB( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            params
+        ) );
         __glXSendReply(cl->client, params, 4, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4367,30 +4610,28 @@ __glXDisp_GetProgramLocalParameterfvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GetProgramivARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetProgramivARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMIVARBPROC GetProgramivARB =
-        __glGetProcAddress("glGetProgramivARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = *(GLenum *) (pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
 
         const GLuint compsize = __glGetProgramivARB_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetProgramivARB(*(GLenum *) (pc + 0), pname, params);
+        CALL_GetProgramivARB( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            pname,
+            params
+        ) );
         __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4398,19 +4639,18 @@ __glXDisp_GetProgramivARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsProgramARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsProgramARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISPROGRAMARBPROC IsProgramARB = __glGetProcAddress("glIsProgramARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = IsProgramARB(*(GLuint *) (pc + 0));
+        retval = CALL_IsProgramARB( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4418,143 +4658,144 @@ __glXDisp_IsProgramARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc)
+void __glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMENVPARAMETER4DVARBPROC ProgramEnvParameter4dvARB =
-        __glGetProcAddress("glProgramEnvParameter4dvARB");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    ProgramEnvParameter4dvARB(*(GLenum *) (pc + 0),
-                              *(GLuint *) (pc + 4),
-                              (const GLdouble *) (pc + 8));
+    CALL_ProgramEnvParameter4dvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+         (const GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc)
+void __glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMENVPARAMETER4FVARBPROC ProgramEnvParameter4fvARB =
-        __glGetProcAddress("glProgramEnvParameter4fvARB");
-    ProgramEnvParameter4fvARB(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4),
-                              (const GLfloat *) (pc + 8));
+    CALL_ProgramEnvParameter4fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc)
+void __glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMLOCALPARAMETER4DVARBPROC ProgramLocalParameter4dvARB =
-        __glGetProcAddress("glProgramLocalParameter4dvARB");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    ProgramLocalParameter4dvARB(*(GLenum *) (pc + 0),
-                                *(GLuint *) (pc + 4),
-                                (const GLdouble *) (pc + 8));
+    CALL_ProgramLocalParameter4dvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+         (const GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc)
+void __glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMLOCALPARAMETER4FVARBPROC ProgramLocalParameter4fvARB =
-        __glGetProcAddress("glProgramLocalParameter4fvARB");
-    ProgramLocalParameter4fvARB(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4),
-                                (const GLfloat *) (pc + 8));
+    CALL_ProgramLocalParameter4fvARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ProgramStringARB(GLbyte * pc)
+void __glXDisp_ProgramStringARB(GLbyte * pc)
 {
-    PFNGLPROGRAMSTRINGARBPROC ProgramStringARB =
-        __glGetProcAddress("glProgramStringARB");
-    const GLsizei len = *(GLsizei *) (pc + 8);
+    const GLsizei len = *(GLsizei  *)(pc +  8);
 
-    ProgramStringARB(*(GLenum *) (pc + 0),
-                     *(GLenum *) (pc + 4), len, (const GLvoid *) (pc + 12));
+    CALL_ProgramStringARB( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        len,
+         (const GLvoid *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib1fvARB(GLbyte * pc)
+void __glXDisp_VertexAttrib1fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1FVARBPROC VertexAttrib1fvARB =
-        __glGetProcAddress("glVertexAttrib1fvARB");
-    VertexAttrib1fvARB(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib1fvARB( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2fvARB(GLbyte * pc)
+void __glXDisp_VertexAttrib2fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2FVARBPROC VertexAttrib2fvARB =
-        __glGetProcAddress("glVertexAttrib2fvARB");
-    VertexAttrib2fvARB(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib2fvARB( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3fvARB(GLbyte * pc)
+void __glXDisp_VertexAttrib3fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3FVARBPROC VertexAttrib3fvARB =
-        __glGetProcAddress("glVertexAttrib3fvARB");
-    VertexAttrib3fvARB(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib3fvARB( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4fvARB(GLbyte * pc)
+void __glXDisp_VertexAttrib4fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4FVARBPROC VertexAttrib4fvARB =
-        __glGetProcAddress("glVertexAttrib4fvARB");
-    VertexAttrib4fvARB(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib4fvARB( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BindFramebuffer(GLbyte * pc)
+void __glXDisp_BindFramebuffer(GLbyte * pc)
 {
-    PFNGLBINDFRAMEBUFFERPROC BindFramebuffer =
-        __glGetProcAddress("glBindFramebuffer");
-    BindFramebuffer(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4));
+    CALL_BindFramebuffer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BindRenderbuffer(GLbyte * pc)
+void __glXDisp_BindRenderbuffer(GLbyte * pc)
 {
-    PFNGLBINDRENDERBUFFERPROC BindRenderbuffer =
-        __glGetProcAddress("glBindRenderbuffer");
-    BindRenderbuffer(*(GLenum *) (pc + 0), *(GLuint *) (pc + 4));
+    CALL_BindRenderbuffer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_BlitFramebuffer(GLbyte * pc)
+void __glXDisp_BlitFramebuffer(GLbyte * pc)
 {
-    PFNGLBLITFRAMEBUFFERPROC BlitFramebuffer =
-        __glGetProcAddress("glBlitFramebuffer");
-    BlitFramebuffer(*(GLint *) (pc + 0), *(GLint *) (pc + 4),
-                    *(GLint *) (pc + 8), *(GLint *) (pc + 12),
-                    *(GLint *) (pc + 16), *(GLint *) (pc + 20),
-                    *(GLint *) (pc + 24), *(GLint *) (pc + 28),
-                    *(GLbitfield *) (pc + 32), *(GLenum *) (pc + 36));
+    CALL_BlitFramebuffer( GET_DISPATCH(), (
+        *(GLint    *)(pc +  0),
+        *(GLint    *)(pc +  4),
+        *(GLint    *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLint    *)(pc + 20),
+        *(GLint    *)(pc + 24),
+        *(GLint    *)(pc + 28),
+        *(GLbitfield *)(pc + 32),
+        *(GLenum   *)(pc + 36)
+    ) );
 }
 
-int
-__glXDisp_CheckFramebufferStatus(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_CheckFramebufferStatus(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLCHECKFRAMEBUFFERSTATUSPROC CheckFramebufferStatus =
-        __glGetProcAddress("glCheckFramebufferStatus");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLenum retval;
-
-        retval = CheckFramebufferStatus(*(GLenum *) (pc + 0));
+        retval = CALL_CheckFramebufferStatus( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4562,97 +4803,103 @@ __glXDisp_CheckFramebufferStatus(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_DeleteFramebuffers(GLbyte * pc)
+void __glXDisp_DeleteFramebuffers(GLbyte * pc)
 {
-    PFNGLDELETEFRAMEBUFFERSPROC DeleteFramebuffers =
-        __glGetProcAddress("glDeleteFramebuffers");
-    const GLsizei n = *(GLsizei *) (pc + 0);
+    const GLsizei n = *(GLsizei  *)(pc +  0);
 
-    DeleteFramebuffers(n, (const GLuint *) (pc + 4));
+    CALL_DeleteFramebuffers( GET_DISPATCH(), (
+        n,
+         (const GLuint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_DeleteRenderbuffers(GLbyte * pc)
+void __glXDisp_DeleteRenderbuffers(GLbyte * pc)
 {
-    PFNGLDELETERENDERBUFFERSPROC DeleteRenderbuffers =
-        __glGetProcAddress("glDeleteRenderbuffers");
-    const GLsizei n = *(GLsizei *) (pc + 0);
+    const GLsizei n = *(GLsizei  *)(pc +  0);
 
-    DeleteRenderbuffers(n, (const GLuint *) (pc + 4));
+    CALL_DeleteRenderbuffers( GET_DISPATCH(), (
+        n,
+         (const GLuint *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_FramebufferRenderbuffer(GLbyte * pc)
+void __glXDisp_FramebufferRenderbuffer(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERRENDERBUFFERPROC FramebufferRenderbuffer =
-        __glGetProcAddress("glFramebufferRenderbuffer");
-    FramebufferRenderbuffer(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                            *(GLenum *) (pc + 8), *(GLuint *) (pc + 12));
+    CALL_FramebufferRenderbuffer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLuint   *)(pc + 12)
+    ) );
 }
 
-void
-__glXDisp_FramebufferTexture1D(GLbyte * pc)
+void __glXDisp_FramebufferTexture1D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE1DPROC FramebufferTexture1D =
-        __glGetProcAddress("glFramebufferTexture1D");
-    FramebufferTexture1D(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                         *(GLenum *) (pc + 8), *(GLuint *) (pc + 12),
-                         *(GLint *) (pc + 16));
+    CALL_FramebufferTexture1D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLuint   *)(pc + 12),
+        *(GLint    *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_FramebufferTexture2D(GLbyte * pc)
+void __glXDisp_FramebufferTexture2D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE2DPROC FramebufferTexture2D =
-        __glGetProcAddress("glFramebufferTexture2D");
-    FramebufferTexture2D(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                         *(GLenum *) (pc + 8), *(GLuint *) (pc + 12),
-                         *(GLint *) (pc + 16));
+    CALL_FramebufferTexture2D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLuint   *)(pc + 12),
+        *(GLint    *)(pc + 16)
+    ) );
 }
 
-void
-__glXDisp_FramebufferTexture3D(GLbyte * pc)
+void __glXDisp_FramebufferTexture3D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE3DPROC FramebufferTexture3D =
-        __glGetProcAddress("glFramebufferTexture3D");
-    FramebufferTexture3D(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                         *(GLenum *) (pc + 8), *(GLuint *) (pc + 12),
-                         *(GLint *) (pc + 16), *(GLint *) (pc + 20));
+    CALL_FramebufferTexture3D( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLuint   *)(pc + 12),
+        *(GLint    *)(pc + 16),
+        *(GLint    *)(pc + 20)
+    ) );
 }
 
-void
-__glXDisp_FramebufferTextureLayer(GLbyte * pc)
+void __glXDisp_FramebufferTextureLayer(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURELAYERPROC FramebufferTextureLayer =
-        __glGetProcAddress("glFramebufferTextureLayer");
-    FramebufferTextureLayer(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                            *(GLuint *) (pc + 8), *(GLint *) (pc + 12),
-                            *(GLint *) (pc + 16));
+    CALL_FramebufferTextureLayer( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLuint   *)(pc +  8),
+        *(GLint    *)(pc + 12),
+        *(GLint    *)(pc + 16)
+    ) );
 }
 
-int
-__glXDisp_GenFramebuffers(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenFramebuffers(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENFRAMEBUFFERSPROC GenFramebuffers =
-        __glGetProcAddress("glGenFramebuffers");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *framebuffers =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * framebuffers = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (framebuffers == NULL)
             return BadAlloc;
 
-        GenFramebuffers(n, framebuffers);
+        if (framebuffers == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenFramebuffers( GET_DISPATCH(), (
+            n,
+            framebuffers
+        ) );
         __glXSendReply(cl->client, framebuffers, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -4660,27 +4907,28 @@ __glXDisp_GenFramebuffers(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_GenRenderbuffers(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GenRenderbuffers(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENRENDERBUFFERSPROC GenRenderbuffers =
-        __glGetProcAddress("glGenRenderbuffers");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = *(GLsizei *) (pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
 
         GLuint answerBuffer[200];
-        GLuint *renderbuffers =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * renderbuffers = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (renderbuffers == NULL)
             return BadAlloc;
-        GenRenderbuffers(n, renderbuffers);
+
+        if (renderbuffers == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenRenderbuffers( GET_DISPATCH(), (
+            n,
+            renderbuffers
+        ) );
         __glXSendReply(cl->client, renderbuffers, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -4688,32 +4936,28 @@ __glXDisp_GenRenderbuffers(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDisp_GenerateMipmap(GLbyte * pc)
+void __glXDisp_GenerateMipmap(GLbyte * pc)
 {
-    PFNGLGENERATEMIPMAPPROC GenerateMipmap =
-        __glGetProcAddress("glGenerateMipmap");
-    GenerateMipmap(*(GLenum *) (pc + 0));
+    CALL_GenerateMipmap( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-int
-__glXDisp_GetFramebufferAttachmentParameteriv(__GLXclientState * cl,
-                                              GLbyte * pc)
+int __glXDisp_GetFramebufferAttachmentParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC
-        GetFramebufferAttachmentParameteriv =
-        __glGetProcAddress("glGetFramebufferAttachmentParameteriv");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLint params[1];
-
-        GetFramebufferAttachmentParameteriv(*(GLenum *) (pc + 0),
-                                            *(GLenum *) (pc + 4),
-                                            *(GLenum *) (pc + 8), params);
+        CALL_GetFramebufferAttachmentParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLenum   *)(pc +  4),
+            *(GLenum   *)(pc +  8),
+            params
+        ) );
         __glXSendReply(cl->client, params, 1, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4721,21 +4965,20 @@ __glXDisp_GetFramebufferAttachmentParameteriv(__GLXclientState * cl,
     return error;
 }
 
-int
-__glXDisp_GetRenderbufferParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_GetRenderbufferParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETRENDERBUFFERPARAMETERIVPROC GetRenderbufferParameteriv =
-        __glGetProcAddress("glGetRenderbufferParameteriv");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLint params[1];
-
-        GetRenderbufferParameteriv(*(GLenum *) (pc + 0),
-                                   *(GLenum *) (pc + 4), params);
+        CALL_GetRenderbufferParameteriv( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLenum   *)(pc +  4),
+            params
+        ) );
         __glXSendReply(cl->client, params, 1, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4743,20 +4986,37 @@ __glXDisp_GetRenderbufferParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsFramebuffer(__GLXclientState * cl, GLbyte * pc)
+int __glXDisp_IsFramebuffer(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISFRAMEBUFFERPROC IsFramebuffer =
-        __glGetProcAddress("glIsFramebuffer");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
+        retval = CALL_IsFramebuffer( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
+        __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_IsRenderbuffer(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
-        retval = IsFramebuffer(*(GLuint *) (pc + 0));
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLboolean retval;
+        retval = CALL_IsRenderbuffer( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0)
+        ) );
         __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4764,364 +5024,749 @@ __glXDisp_IsFramebuffer(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDisp_IsRenderbuffer(__GLXclientState * cl, GLbyte * pc)
+void __glXDisp_RenderbufferStorage(GLbyte * pc)
 {
-    PFNGLISRENDERBUFFERPROC IsRenderbuffer =
-        __glGetProcAddress("glIsRenderbuffer");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    CALL_RenderbufferStorage( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLenum   *)(pc +  4),
+        *(GLsizei  *)(pc +  8),
+        *(GLsizei  *)(pc + 12)
+    ) );
+}
+
+void __glXDisp_RenderbufferStorageMultisample(GLbyte * pc)
+{
+    CALL_RenderbufferStorageMultisample( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLsizei  *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLsizei  *)(pc + 12),
+        *(GLsizei  *)(pc + 16)
+    ) );
+}
+
+void __glXDisp_SampleMaskSGIS(GLbyte * pc)
+{
+    CALL_SampleMaskSGIS( GET_DISPATCH(), (
+        *(GLclampf *)(pc +  0),
+        *(GLboolean *)(pc +  4)
+    ) );
+}
+
+void __glXDisp_SamplePatternSGIS(GLbyte * pc)
+{
+    CALL_SamplePatternSGIS( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
+}
+
+void __glXDisp_SecondaryColor3fvEXT(GLbyte * pc)
+{
+    CALL_SecondaryColor3fvEXT( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
+}
+
+void __glXDisp_FogCoordfvEXT(GLbyte * pc)
+{
+    CALL_FogCoordfvEXT( GET_DISPATCH(), (
+         (const GLfloat *)(pc +  0)
+    ) );
+}
+
+int __glXDisp_AreProgramsResidentNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx = __glXForceCurrent(cl, req->contextTag, &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
+        const GLsizei n = *(GLsizei  *)(pc +  0);
+
         GLboolean retval;
+        GLboolean answerBuffer[200];
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
+        if (residences == NULL)
+            return BadAlloc;
 
-        retval = IsRenderbuffer(*(GLuint *) (pc + 0));
-        __glXSendReply(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreProgramsResidentNV( GET_DISPATCH(), (
+            n,
+             (const GLuint *)(pc +  4),
+            residences
+        ) );
+        __glXSendReply(cl->client, residences, n, 1, GL_FALSE, retval);
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDisp_RenderbufferStorage(GLbyte * pc)
+void __glXDisp_ExecuteProgramNV(GLbyte * pc)
 {
-    PFNGLRENDERBUFFERSTORAGEPROC RenderbufferStorage =
-        __glGetProcAddress("glRenderbufferStorage");
-    RenderbufferStorage(*(GLenum *) (pc + 0), *(GLenum *) (pc + 4),
-                        *(GLsizei *) (pc + 8), *(GLsizei *) (pc + 12));
+    CALL_ExecuteProgramNV( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_RenderbufferStorageMultisample(GLbyte * pc)
+int __glXDisp_GetProgramParameterdvNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC RenderbufferStorageMultisample =
-        __glGetProcAddress("glRenderbufferStorageMultisample");
-    RenderbufferStorageMultisample(*(GLenum *) (pc + 0), *(GLsizei *) (pc + 4),
-                                   *(GLenum *) (pc + 8), *(GLsizei *) (pc + 12),
-                                   *(GLsizei *) (pc + 16));
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLdouble params[4];
+        CALL_GetProgramParameterdvNV( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            *(GLenum   *)(pc +  8),
+            params
+        ) );
+        __glXSendReply(cl->client, params, 4, 8, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_GetProgramParameterfvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLfloat params[4];
+        CALL_GetProgramParameterfvNV( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            *(GLenum   *)(pc +  8),
+            params
+        ) );
+        __glXSendReply(cl->client, params, 4, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
 }
 
-void
-__glXDisp_SecondaryColor3fvEXT(GLbyte * pc)
+int __glXDisp_GetProgramivNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLSECONDARYCOLOR3FVEXTPROC SecondaryColor3fvEXT =
-        __glGetProcAddress("glSecondaryColor3fvEXT");
-    SecondaryColor3fvEXT((const GLfloat *) (pc + 0));
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetProgramivNV_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetProgramivNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
 }
 
-void
-__glXDisp_FogCoordfvEXT(GLbyte * pc)
+int __glXDisp_GetTrackMatrixivNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLFOGCOORDFVEXTPROC FogCoordfvEXT =
-        __glGetProcAddress("glFogCoordfvEXT");
-    FogCoordfvEXT((const GLfloat *) (pc + 0));
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLint params[1];
+        CALL_GetTrackMatrixivNV( GET_DISPATCH(), (
+            *(GLenum   *)(pc +  0),
+            *(GLuint   *)(pc +  4),
+            *(GLenum   *)(pc +  8),
+            params
+        ) );
+        __glXSendReply(cl->client, params, 1, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
 }
 
-void
-__glXDisp_VertexAttrib1dvNV(GLbyte * pc)
+int __glXDisp_GetVertexAttribdvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribdvNV_size(pname);
+        GLdouble answerBuffer[200];
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribdvNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 8, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_GetVertexAttribfvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribfvNV_size(pname);
+        GLfloat answerBuffer[200];
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribfvNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_GetVertexAttribivNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname = *(GLenum   *)(pc +  4);
+
+        const GLuint compsize = __glGetVertexAttribivNV_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribivNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            pname,
+            params
+        ) );
+        __glXSendReply(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+void __glXDisp_LoadProgramNV(GLbyte * pc)
+{
+    const GLsizei len = *(GLsizei  *)(pc +  8);
+
+    CALL_LoadProgramNV( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+        len,
+         (const GLubyte *)(pc + 12)
+    ) );
+}
+
+void __glXDisp_ProgramParameters4dvNV(GLbyte * pc)
+{
+    const GLsizei num = *(GLsizei  *)(pc +  8);
+
+#ifdef __GLX_ALIGN64
+    const GLuint cmdlen = 16 + safe_pad(safe_mul(num, 4 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
+        pc -= 4;
+    }
+#endif
+
+    CALL_ProgramParameters4dvNV( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+        num,
+         (const GLdouble *)(pc + 12)
+    ) );
+}
+
+void __glXDisp_ProgramParameters4fvNV(GLbyte * pc)
+{
+    const GLsizei num = *(GLsizei  *)(pc +  8);
+
+    CALL_ProgramParameters4fvNV( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+        num,
+         (const GLfloat *)(pc + 12)
+    ) );
+}
+
+void __glXDisp_RequestResidentProgramsNV(GLbyte * pc)
+{
+    const GLsizei n = *(GLsizei  *)(pc +  0);
+
+    CALL_RequestResidentProgramsNV( GET_DISPATCH(), (
+        n,
+         (const GLuint *)(pc +  4)
+    ) );
+}
+
+void __glXDisp_TrackMatrixNV(GLbyte * pc)
+{
+    CALL_TrackMatrixNV( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4),
+        *(GLenum   *)(pc +  8),
+        *(GLenum   *)(pc + 12)
+    ) );
+}
+
+void __glXDisp_VertexAttrib1dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1DVNVPROC VertexAttrib1dvNV =
-        __glGetProcAddress("glVertexAttrib1dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib1dvNV(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib1dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib1fvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib1fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1FVNVPROC VertexAttrib1fvNV =
-        __glGetProcAddress("glVertexAttrib1fvNV");
-    VertexAttrib1fvNV(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib1fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib1svNV(GLbyte * pc)
+void __glXDisp_VertexAttrib1svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1SVNVPROC VertexAttrib1svNV =
-        __glGetProcAddress("glVertexAttrib1svNV");
-    VertexAttrib1svNV(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib1svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2dvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib2dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2DVNVPROC VertexAttrib2dvNV =
-        __glGetProcAddress("glVertexAttrib2dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib2dvNV(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib2dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2fvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib2fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2FVNVPROC VertexAttrib2fvNV =
-        __glGetProcAddress("glVertexAttrib2fvNV");
-    VertexAttrib2fvNV(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib2fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib2svNV(GLbyte * pc)
+void __glXDisp_VertexAttrib2svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2SVNVPROC VertexAttrib2svNV =
-        __glGetProcAddress("glVertexAttrib2svNV");
-    VertexAttrib2svNV(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib2svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3dvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib3dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3DVNVPROC VertexAttrib3dvNV =
-        __glGetProcAddress("glVertexAttrib3dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib3dvNV(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib3dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3fvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib3fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3FVNVPROC VertexAttrib3fvNV =
-        __glGetProcAddress("glVertexAttrib3fvNV");
-    VertexAttrib3fvNV(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib3fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib3svNV(GLbyte * pc)
+void __glXDisp_VertexAttrib3svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3SVNVPROC VertexAttrib3svNV =
-        __glGetProcAddress("glVertexAttrib3svNV");
-    VertexAttrib3svNV(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib3svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4dvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4DVNVPROC VertexAttrib4dvNV =
-        __glGetProcAddress("glVertexAttrib4dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib4dvNV(*(GLuint *) (pc + 0), (const GLdouble *) (pc + 4));
+    CALL_VertexAttrib4dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLdouble *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4fvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib4fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4FVNVPROC VertexAttrib4fvNV =
-        __glGetProcAddress("glVertexAttrib4fvNV");
-    VertexAttrib4fvNV(*(GLuint *) (pc + 0), (const GLfloat *) (pc + 4));
+    CALL_VertexAttrib4fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLfloat *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4svNV(GLbyte * pc)
+void __glXDisp_VertexAttrib4svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4SVNVPROC VertexAttrib4svNV =
-        __glGetProcAddress("glVertexAttrib4svNV");
-    VertexAttrib4svNV(*(GLuint *) (pc + 0), (const GLshort *) (pc + 4));
+    CALL_VertexAttrib4svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLshort *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttrib4ubvNV(GLbyte * pc)
+void __glXDisp_VertexAttrib4ubvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UBVNVPROC VertexAttrib4ubvNV =
-        __glGetProcAddress("glVertexAttrib4ubvNV");
-    VertexAttrib4ubvNV(*(GLuint *) (pc + 0), (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4ubvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs1dvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs1dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1DVNVPROC VertexAttribs1dvNV =
-        __glGetProcAddress("glVertexAttribs1dvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 8)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 1 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs1dvNV(*(GLuint *) (pc + 0), n, (const GLdouble *) (pc + 8));
+    CALL_VertexAttribs1dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs1fvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs1fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1FVNVPROC VertexAttribs1fvNV =
-        __glGetProcAddress("glVertexAttribs1fvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs1fvNV(*(GLuint *) (pc + 0), n, (const GLfloat *) (pc + 8));
+    CALL_VertexAttribs1fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs1svNV(GLbyte * pc)
+void __glXDisp_VertexAttribs1svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1SVNVPROC VertexAttribs1svNV =
-        __glGetProcAddress("glVertexAttribs1svNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs1svNV(*(GLuint *) (pc + 0), n, (const GLshort *) (pc + 8));
+    CALL_VertexAttribs1svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLshort *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs2dvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs2dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2DVNVPROC VertexAttribs2dvNV =
-        __glGetProcAddress("glVertexAttribs2dvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 16)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 2 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs2dvNV(*(GLuint *) (pc + 0), n, (const GLdouble *) (pc + 8));
+    CALL_VertexAttribs2dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs2fvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs2fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2FVNVPROC VertexAttribs2fvNV =
-        __glGetProcAddress("glVertexAttribs2fvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs2fvNV(*(GLuint *) (pc + 0), n, (const GLfloat *) (pc + 8));
+    CALL_VertexAttribs2fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs2svNV(GLbyte * pc)
+void __glXDisp_VertexAttribs2svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2SVNVPROC VertexAttribs2svNV =
-        __glGetProcAddress("glVertexAttribs2svNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs2svNV(*(GLuint *) (pc + 0), n, (const GLshort *) (pc + 8));
+    CALL_VertexAttribs2svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLshort *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs3dvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs3dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3DVNVPROC VertexAttribs3dvNV =
-        __glGetProcAddress("glVertexAttribs3dvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 24)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 3 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs3dvNV(*(GLuint *) (pc + 0), n, (const GLdouble *) (pc + 8));
+    CALL_VertexAttribs3dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLdouble *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs3fvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs3fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3FVNVPROC VertexAttribs3fvNV =
-        __glGetProcAddress("glVertexAttribs3fvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs3fvNV(*(GLuint *) (pc + 0), n, (const GLfloat *) (pc + 8));
+    CALL_VertexAttribs3fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs3svNV(GLbyte * pc)
+void __glXDisp_VertexAttribs3svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3SVNVPROC VertexAttribs3svNV =
-        __glGetProcAddress("glVertexAttribs3svNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs3svNV(*(GLuint *) (pc + 0), n, (const GLshort *) (pc + 8));
+    CALL_VertexAttribs3svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLshort *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs4dvNV(GLbyte * pc)
+void __glXDisp_VertexAttribs4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS4DVNVPROC VertexAttribs4dvNV =
-        __glGetProcAddress("glVertexAttribs4dvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei n = *(GLsizei  *)(pc +  4);
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 32)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 4 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs4dvNV(*(GLuint *) (pc + 0), n, (const GLdouble *) (pc + 8));
+    CALL_VertexAttribs4dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLdouble *)(pc +  8)
+    ) );
+}
+
+void __glXDisp_VertexAttribs4fvNV(GLbyte * pc)
+{
+    const GLsizei n = *(GLsizei  *)(pc +  4);
+
+    CALL_VertexAttribs4fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLfloat *)(pc +  8)
+    ) );
+}
+
+void __glXDisp_VertexAttribs4svNV(GLbyte * pc)
+{
+    const GLsizei n = *(GLsizei  *)(pc +  4);
+
+    CALL_VertexAttribs4svNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLshort *)(pc +  8)
+    ) );
+}
+
+void __glXDisp_VertexAttribs4ubvNV(GLbyte * pc)
+{
+    const GLsizei n = *(GLsizei  *)(pc +  4);
+
+    CALL_VertexAttribs4ubvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        n,
+         (const GLubyte *)(pc +  8)
+    ) );
+}
+
+void __glXDisp_ActiveStencilFaceEXT(GLbyte * pc)
+{
+    CALL_ActiveStencilFaceEXT( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs4fvNV(GLbyte * pc)
+int __glXDisp_GetProgramNamedParameterdvNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLVERTEXATTRIBS4FVNVPROC VertexAttribs4fvNV =
-        __glGetProcAddress("glVertexAttribs4fvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLsizei len = *(GLsizei  *)(pc +  4);
+
+        GLdouble params[4];
+        CALL_GetProgramNamedParameterdvNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            len,
+             (const GLubyte *)(pc +  8),
+            params
+        ) );
+        __glXSendReply(cl->client, params, 4, 8, GL_TRUE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDisp_GetProgramNamedParameterfvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, req->contextTag, &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLsizei len = *(GLsizei  *)(pc +  4);
+
+        GLfloat params[4];
+        CALL_GetProgramNamedParameterfvNV( GET_DISPATCH(), (
+            *(GLuint   *)(pc +  0),
+            len,
+             (const GLubyte *)(pc +  8),
+            params
+        ) );
+        __glXSendReply(cl->client, params, 4, 4, GL_TRUE, 0);
+        error = Success;
+    }
 
-    VertexAttribs4fvNV(*(GLuint *) (pc + 0), n, (const GLfloat *) (pc + 8));
+    return error;
 }
 
-void
-__glXDisp_VertexAttribs4svNV(GLbyte * pc)
+void __glXDisp_ProgramNamedParameter4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS4SVNVPROC VertexAttribs4svNV =
-        __glGetProcAddress("glVertexAttribs4svNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei len = *(GLsizei  *)(pc + 36);
 
-    VertexAttribs4svNV(*(GLuint *) (pc + 0), n, (const GLshort *) (pc + 8));
+#ifdef __GLX_ALIGN64
+    const GLuint cmdlen = 44 + safe_pad(len) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
+        pc -= 4;
+    }
+#endif
+
+    CALL_ProgramNamedParameter4dvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc + 32),
+        len,
+         (const GLubyte *)(pc + 40),
+         (const GLdouble *)(pc +  0)
+    ) );
 }
 
-void
-__glXDisp_VertexAttribs4ubvNV(GLbyte * pc)
+void __glXDisp_ProgramNamedParameter4fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS4UBVNVPROC VertexAttribs4ubvNV =
-        __glGetProcAddress("glVertexAttribs4ubvNV");
-    const GLsizei n = *(GLsizei *) (pc + 4);
+    const GLsizei len = *(GLsizei  *)(pc +  4);
 
-    VertexAttribs4ubvNV(*(GLuint *) (pc + 0), n, (const GLubyte *) (pc + 8));
+    CALL_ProgramNamedParameter4fvNV( GET_DISPATCH(), (
+        *(GLuint   *)(pc +  0),
+        len,
+         (const GLubyte *)(pc + 24),
+         (const GLfloat *)(pc +  8)
+    ) );
 }
 
-void
-__glXDisp_ActiveStencilFaceEXT(GLbyte * pc)
+void __glXDisp_BindFramebufferEXT(GLbyte * pc)
 {
-    PFNGLACTIVESTENCILFACEEXTPROC ActiveStencilFaceEXT =
-        __glGetProcAddress("glActiveStencilFaceEXT");
-    ActiveStencilFaceEXT(*(GLenum *) (pc + 0));
+    CALL_BindFramebufferEXT( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
 }
+
+void __glXDisp_BindRenderbufferEXT(GLbyte * pc)
+{
+    CALL_BindRenderbufferEXT( GET_DISPATCH(), (
+        *(GLenum   *)(pc +  0),
+        *(GLuint   *)(pc +  4)
+    ) );
+}
+
diff --git a/xserver/glx/indirect_dispatch.h b/vcxsrv-code/xorg-server/glx/indirect_dispatch.h
index 536be60..1aa6cb0 100644
--- a/xserver/glx/indirect_dispatch.h
+++ b/vcxsrv-code/xorg-server/glx/indirect_dispatch.h
@@ -26,1334 +26,1009 @@
  */
 
 #if !defined( _INDIRECT_DISPATCH_H_ )
-#define _INDIRECT_DISPATCH_H_
+#  define _INDIRECT_DISPATCH_H_
 
-#include <X11/Xfuncproto.h>
+#  include <X11/Xfuncproto.h>
 
 struct __GLXclientStateRec;
 
-extern _X_HIDDEN void __glXDisp_MapGrid1d(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MapGrid1d(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MapGrid1f(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MapGrid1f(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_Render(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_Render(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_RenderLarge(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_RenderLarge(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_MakeCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_MakeCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsDirect(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsDirect(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_QueryVersion(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_QueryVersion(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_WaitGL(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_WaitGL(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_WaitX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_WaitX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CopyContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CopyContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SwapBuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_SwapBuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_UseXFont(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_UseXFont(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVisualConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVisualConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_VendorPrivate(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_VendorPrivate(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_VendorPrivateWithReply(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_VendorPrivateWithReply(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_QueryExtensionsString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_QueryExtensionsString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_QueryServerString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_QueryServerString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_ClientInfo(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_ClientInfo(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetFBConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetFBConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreatePixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreatePixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateNewContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateNewContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_QueryContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_QueryContext(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_MakeContextCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_MakeContextCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreatePbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreatePbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyPbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyPbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_ChangeDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateWindow(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateWindow(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyWindow(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyWindow(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SwapIntervalSGI(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_SwapIntervalSGI(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_MakeCurrentReadSGI(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_MakeCurrentReadSGI(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_QueryContextInfoEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_QueryContextInfoEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetFBConfigsSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetFBConfigsSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateContextWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateContextWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateGLXPixmapWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DestroyGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_ChangeDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CopySubBufferMESA(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CopySubBufferMESA(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_BindTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_BindTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_ReleaseTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_ReleaseTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SetClientInfoARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_SetClientInfoARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateContextAttribsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CreateContextAttribsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SetClientInfo2ARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_SetClientInfo2ARB(struct __GLXclientStateRec *, GLbyte *);
 extern _X_HIDDEN int __glXDisp_NewList(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_NewList(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN void __glXDisp_LoadIdentity(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LoadIdentity(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ConvolutionFilter1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_NewList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_EndList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_EndList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_CallList(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CallList(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CallLists(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CallLists(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteLists(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DeleteLists(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GenLists(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenLists(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ListBase(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ListBase(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Begin(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Begin(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Bitmap(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Bitmap(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3bv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3ubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3uiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3usv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4bv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4ubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4uiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4usv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Color4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EdgeFlagv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EdgeFlagv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_End(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_End(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexdv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Indexdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Indexfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Indexiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexsv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Indexsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3bv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Normal3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Normal3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Normal3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Normal3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Normal3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos2sv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_RasterPos3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RasterPos4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectdv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rectdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rectfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rectiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectsv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rectsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord1fv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_TexCoord1iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord4iv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_TexCoord4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4ubvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Histogram(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Histogram(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMapfv(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_RasterPos4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PolygonStipple(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PolygonStipple(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1dv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetPixelMapfv(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetPixelMapfv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_Color3uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3uiv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_IsEnabled(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsEnabled(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EvalCoord2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalCoord2fv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DestroyPixmap(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyPixmap(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_FramebufferTexture1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FramebufferTexture1D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMapiv(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDisp_SwapBuffers(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_SwapBuffers(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_Indexubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Indexubv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_Render(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_Render(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexImage3D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_MakeContextCurrent(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_MakeContextCurrent(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetFBConfigs(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetFBConfigs(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3ubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex2sv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Vertex3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LightModeliv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LightModeliv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs1dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs1dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Normal3bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Normal3bv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_VendorPrivate(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_VendorPrivate(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexGeniv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGeniv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex3fv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Vertex3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RenderbufferStorage(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RenderbufferStorage(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenQueries(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenQueries(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_BlendColor(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlendColor(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CompressedTexImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Scalef(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Scalef(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Normal3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Normal3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PassThrough(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PassThrough(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Viewport(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Viewport(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyTexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_DepthRange(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DepthRange(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetQueryiv(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetQueryiv(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_ResetHistogram(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ResetHistogram(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CompressedTexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex3sv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Vertex4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Nbv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nbv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs2svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs2svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetConvolutionParameteriv(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameteriv(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetConvolutionParameterivEXT(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterivEXT(struct
-                                                                __GLXclientStateRec
-                                                                *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_Vertex2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex2dv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetVisualConfigs(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetVisualConfigs(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_DeleteRenderbuffers(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DeleteRenderbuffers(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord1fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord3iv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CopyContext(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CopyContext(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PointSize(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PointSize(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PopName(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PopName(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Nusv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nusv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex4iv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Vertex4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ClampColor(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClampColor(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexEnvfv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexEnvfv(struct __GLXclientStateRec *,
-                                               GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Vertex4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClipPlane(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClipPlane(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorMaterial(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorMaterial(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CullFace(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CullFace(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Fogf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Fogfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogi(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Fogi(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Fogiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FrontFace(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FrontFace(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Hint(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Hint(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lightf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Lightf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lightfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Lightfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lighti(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Lighti(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lightiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Lightiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModelf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LightModelf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModelfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LightModelfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModeli(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LightModeli(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModeliv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LightModeliv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_LineStipple(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LineStipple(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexEnvi(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexEnvi(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetClipPlane(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetClipPlane(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttribs3dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs3dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs4fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs4fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Scaled(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Scaled(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CallLists(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CallLists(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_AlphaFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_AlphaFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Rotated(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rotated(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_ReadPixels(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_ReadPixels(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_EdgeFlagv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EdgeFlagv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CompressedTexSubImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LineStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LineWidth(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LineWidth(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Materialf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Materialfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materiali(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Materiali(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Materialiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointSize(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PointSize(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PolygonMode(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PolygonMode(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PolygonStipple(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PolygonStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scissor(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Scissor(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ShadeModel(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ShadeModel(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_TexParameterf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexParameterf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexParameterfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexParameterfv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_TexParameteri(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexParameteri(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DestroyContext(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyContext(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_DrawPixels(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DrawPixels(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenLists(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenLists(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_MapGrid2d(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MapGrid2d(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MapGrid2f(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MapGrid2f(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Scissor(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Scissor(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Fogf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Fogf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexSubImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexSubImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Fogi(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Fogi(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PixelMapfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelMapfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2iv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_AreTexturesResident(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_AreTexturesResident(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDisp_AreTexturesResidentEXT(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_AreTexturesResidentEXT(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_Color3bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2fvARB(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterfvARB(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramLocalParameterfvARB(struct
-                                                                 __GLXclientStateRec
-                                                                 *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_ColorTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexParameteriv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnvf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexEnvf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnvfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexEnvfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnvi(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexEnvi(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnviv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexEnviv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGend(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGend(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGendv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGendv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGenf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGenf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGenfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGenfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGeni(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGeni(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGeniv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexGeniv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_FeedbackBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_FeedbackBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SelectBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_SelectBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_RenderMode(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_RenderMode(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_InitNames(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_InitNames(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LoadName(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LoadName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PassThrough(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PassThrough(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PopName(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PopName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushName(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PushName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawBuffer(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DrawBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Clear(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Clear(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearAccum(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClearAccum(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearIndex(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClearIndex(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearColor(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClearColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearStencil(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClearStencil(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearDepth(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClearDepth(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_StencilMask(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_StencilMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorMask(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DepthMask(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DepthMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_IndexMask(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_IndexMask(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Accum(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Accum(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexImage(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexImage(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_ConvolutionFilter2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Accum(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Disable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Disable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Enable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Enable(GLbyte * pc);
 extern _X_HIDDEN int __glXDisp_Finish(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_Finish(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_ClearStencil(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClearStencil(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs4ubvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ConvolutionParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord1fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord1fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ClearIndex(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClearIndex(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LoadMatrixd(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LoadMatrixd(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PushMatrix(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PushMatrix(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ConvolutionParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionParameterfv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexGendv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexGendv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_EndList(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_EndList(struct __GLXclientStateRec *,
-                                           GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_Finish(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_Flush(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_Flush(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_PopAttrib(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PopAttrib(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushAttrib(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PushAttrib(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map1d(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Map1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map1f(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Map1f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map2d(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Map2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map2f(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Map2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid1d(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MapGrid1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid1f(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MapGrid1f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid2d(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MapGrid2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid2f(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MapGrid2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalCoord1dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalCoord1dv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_EvalCoord1fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalCoord1fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalCoord1fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalCoord2dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalCoord2fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalCoord2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalMesh1(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalMesh1(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalPoint1(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalPoint1(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_EvalMesh2(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalMesh2(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs3fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs3fvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterdvARB(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramEnvParameterdvARB(struct
-                                                               __GLXclientStateRec
-                                                               *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetFBConfigsSGIX(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetFBConfigsSGIX(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_BindFramebuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BindFramebuffer(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateNewContext(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateNewContext(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmax(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmax(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmaxEXT(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmaxEXT(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_BlendFuncSeparate(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlendFuncSeparate(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Normal3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Normal3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_End(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_End(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs3svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs3svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs2dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs2dvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateContextAttribsARB(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateContextAttribsARB(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_BindTexture(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BindTexture(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexSubImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexGenfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGenfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_DrawBuffers(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DrawBuffers(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateContextWithConfigSGIX(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateContextWithConfigSGIX(struct
-                                                               __GLXclientStateRec
-                                                               *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_CopySubBufferMESA(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CopySubBufferMESA(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_BlendEquation(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlendEquation(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetError(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetError(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexCoord3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Indexdv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Indexdv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PushName(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PushName(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1dv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateGLXPbufferSGIX(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateGLXPbufferSGIX(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDisp_IsRenderbuffer(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsRenderbuffer(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_DepthMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DepthMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4iv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetMaterialiv(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMaterialiv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_StencilOp(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_StencilOp(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_FramebufferTextureLayer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FramebufferTextureLayer(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Ortho(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Ortho(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexEnvfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexEnvfv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_QueryServerString(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_QueryServerString(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_LoadMatrixf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LoadMatrixf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4bv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetCompressedTexImage(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetCompressedTexImage(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DeleteLists(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DeleteLists(struct __GLXclientStateRec *,
-                                               GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalMesh2(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalPoint2(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EvalPoint2(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_AlphaFunc(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_AlphaFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BlendFunc(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlendFunc(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_LogicOp(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LogicOp(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RenderbufferStorageMultisample(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RenderbufferStorageMultisample(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ActiveTexture(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ActiveTexture(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3bv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_WaitX(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_WaitX(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1dvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenTextures(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenTextures(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_GenTexturesEXT(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenTexturesEXT(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetDrawableAttributes(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetDrawableAttributes(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_RasterPos2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_DrawBuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DrawBuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord1sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord1sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateGLXPixmapWithConfigSGIX(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(struct
-                                                                 __GLXclientStateRec
-                                                                 *, GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LogicOp(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_StencilFunc(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_StencilFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_StencilOp(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_StencilOp(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_DepthFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DepthFunc(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DepthFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelZoom(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelZoom(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelTransferf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelTransferf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelTransferi(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelTransferi(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_PixelStoref(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_PixelStoref(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_PixelMapfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelMapfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelMapuiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelMapuiv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_PixelMapusv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelMapusv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_BlendFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlendFunc(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_WaitGL(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_WaitGL(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_CompressedTexImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexImage2D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_Flush(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_Flush(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_Color4uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord1sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PushAttrib(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PushAttrib(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DestroyPbuffer(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyPbuffer(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexParameteriv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_QueryExtensionsString(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_QueryExtensionsString(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_RasterPos3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyTexSubImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage3D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetColorTable(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTable(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetColorTableSGI(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTableSGI(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_Indexiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Indexiv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateContext(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateContext(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_CopyColorTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyColorTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PointParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PointParameterfv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetHistogramParameterfv(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterfv(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetHistogramParameterfvEXT(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterfvEXT(struct
-                                                              __GLXclientStateRec
-                                                              *, GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PixelMapusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ReadBuffer(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ReadBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyPixels(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyPixels(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_ReadPixels(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_ReadPixels(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_DrawPixels(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DrawPixels(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetBooleanv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetBooleanv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetClipPlane(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetClipPlane(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetDoublev(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetDoublev(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetError(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetError(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetFloatv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetFloatv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetIntegerv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetIntegerv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetLightfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetLightfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetLightiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetLightiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMaterialfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMaterialfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetPixelMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetPixelMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetPixelMapuiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetPixelMapuiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetPixelMapusv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetPixelMapusv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetPolygonStipple(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetPolygonStipple(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetString(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexEnvfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexEnvfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexEnviv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexEnviv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexGendv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexGendv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexGenfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexGenfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexGeniv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexGeniv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexLevelParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexLevelParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexLevelParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTexLevelParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsEnabled(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsEnabled(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_DepthRange(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DepthRange(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_Frustum(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Frustum(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetString(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetString(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDisp_CreateGLXPixmap(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateGLXPixmap(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexEnvf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexEnvf(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenProgramsARB(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenProgramsARB(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDisp_DeleteTextures(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DeleteTextures(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDisp_DeleteTexturesEXT(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DeleteTexturesEXT(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetTexLevelParameteriv(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexLevelParameteriv(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_ClearAccum(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClearAccum(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_QueryVersion(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_QueryVersion(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexCoord4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_FramebufferTexture3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FramebufferTexture3D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetDrawableAttributesSGIX(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetDrawableAttributesSGIX(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_ColorTableParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorTableParameteriv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Frustum(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LoadIdentity(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LoadIdentity(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LoadMatrixf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LoadMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LoadMatrixd(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LoadMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MatrixMode(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MatrixMode(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultMatrixf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultMatrixd(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Ortho(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Ortho(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PopMatrix(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PopMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushMatrix(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PushMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rotated(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rotated(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rotatef(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Rotatef(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scaled(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Scaled(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scalef(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Scalef(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Translated(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Translated(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Translatef(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Translatef(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Viewport(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Viewport(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawArrays(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DrawArrays(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PolygonOffset(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PolygonOffset(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyTexImage1D(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_CopyTexImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyTexImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyTexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_AreTexturesResident(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_AreTexturesResident(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_AreTexturesResidentEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_AreTexturesResidentEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindTexture(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindTexture(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteTextures(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DeleteTextures(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DeleteTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DeleteTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GenTextures(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenTextures(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GenTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsTexture(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsTexture(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsTextureEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsTextureEXT(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_PrioritizeTextures(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PrioritizeTextures(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Indexubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BlendColor(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlendColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BlendEquation(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlendEquation(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorTableParameterfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorTableParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorTableParameteriv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorTableParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyColorTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyColorTable(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetColorTable(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetColorTable(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetColorTableParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetColorTableParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ColorSubTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyColorSubTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameterf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameterfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameteri(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameteriv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ConvolutionParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetConvolutionFilter(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetConvolutionFilter(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetConvolutionParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetConvolutionParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetSeparableFilter(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetSeparableFilter(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_SeparableFilter2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SeparableFilter2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetHistogram(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetHistogram(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetHistogramParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetHistogramParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmax(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMinmax(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMinmaxParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetMinmaxParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_Histogram(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Histogram(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Minmax(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_Minmax(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ResetHistogram(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ResetHistogram(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ResetMinmax(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ResetMinmax(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CopyTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ActiveTexture(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ActiveTexture(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord1sv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_MultiTexCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Lightfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Lightfv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetFramebufferAttachmentParameteriv(struct
-                                                                   __GLXclientStateRec
-                                                                   *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetFramebufferAttachmentParameteriv(struct
-                                                                       __GLXclientStateRec
-                                                                       *,
-                                                                       GLbyte
-                                                                       *);
-extern _X_HIDDEN void __glXDisp_ClearDepth(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClearDepth(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ColorSubTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorSubTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4fv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreatePixmap(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreatePixmap(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_Lightiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Lightiv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexParameteriv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexParameteriv(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_IsQuery(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsQuery(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN void __glXDisp_Rectdv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rectdv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Materialiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Materialiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_MultiTexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SampleCoverage(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SampleCoverage(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_CompressedTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetCompressedTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetCompressedTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BlendFuncSeparate(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlendFuncSeparate(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FogCoordfvEXT(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FogCoordfvEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FogCoorddv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FogCoorddv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameterf(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PointParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameterfv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PointParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameteri(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PointParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameteriv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_PointParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3bv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3dv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_SecondaryColor3fvEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PolygonMode(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PolygonMode(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_SecondaryColor3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Niv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Niv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramStringARB(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexGeni(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGeni(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexGenf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGenf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexGend(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGend(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetPolygonStipple(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetPolygonStipple(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs1fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs1fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib2dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib2dvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DestroyWindow(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyWindow(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_Color4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PixelZoom(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelZoom(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ColorTableParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorTableParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PixelMapuiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelMapuiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3dv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_IsTexture(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsTexture(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDisp_IsTextureEXT(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsTextureEXT(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3ubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3uiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3usv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SecondaryColor3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_WindowPos3fv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_WindowPos3fv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenQueries(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenQueries(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_DeleteQueries(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DeleteQueries(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsQuery(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsQuery(struct __GLXclientStateRec *, GLbyte *);
 extern _X_HIDDEN void __glXDisp_BeginQuery(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BeginQuery(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_SetClientInfo2ARB(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_SetClientInfo2ARB(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMapdv(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3iv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DestroyGLXPixmap(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyGLXPixmap(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_PixelStoref(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_PixelStoref(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_PrioritizeTextures(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PrioritizeTextures(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_PixelStorei(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_PixelStorei(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_DestroyGLXPbufferSGIX(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DestroyGLXPbufferSGIX(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN void __glXDisp_EvalCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ColorMaterial(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorMaterial(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttribs1svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs1svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1fvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetSeparableFilter(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetSeparableFilter(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetSeparableFilterEXT(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetSeparableFilterEXT(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN int __glXDisp_FeedbackBuffer(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_FeedbackBuffer(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_RasterPos2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_FrontFace(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FrontFace(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_RenderLarge(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_RenderLarge(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_PolygonOffset(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PolygonOffset(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Normal3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Normal3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Lightf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Lightf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MatrixMode(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MatrixMode(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetPixelMapusv(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetPixelMapusv(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_Lighti(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Lighti(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenFramebuffers(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenFramebuffers(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN int __glXDisp_IsFramebuffer(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsFramebuffer(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributesSGIX(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_ChangeDrawableAttributesSGIX(struct
-                                                                __GLXclientStateRec
-                                                                *, GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BeginQuery(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EndQuery(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_EndQuery(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetQueryiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetQueryiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetQueryObjectiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetQueryObjectiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetQueryObjectuiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetQueryObjectuiv(struct __GLXclientStateRec *, GLbyte *);
 extern _X_HIDDEN void __glXDisp_BlendEquationSeparate(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlendEquationSeparate(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreatePbuffer(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreatePbuffer(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetDoublev(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetDoublev(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_MultMatrixd(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultMatrixd(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultMatrixf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultMatrixf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CompressedTexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos4sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlendEquationSeparate(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawBuffers(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DrawBuffers(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribdv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribdv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3dv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttrib3fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ClearColor(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClearColor(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_IsDirect(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsDirect(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PointParameteri(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PointParameteri(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PointParameterf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PointParameterf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexEnviv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexEnviv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexSubImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nbv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Nbv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Niv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Niv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nsv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Nsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nubv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Nubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nuiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Nuiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nusv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4Nusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4bv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4dv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4fvARB(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttrib4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4iv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_SwapIntervalSGI(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_SwapIntervalSGI(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetColorTableParameterfv(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterfv(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetColorTableParameterfvSGI(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterfvSGI(struct
-                                                               __GLXclientStateRec
-                                                               *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_FramebufferTexture2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FramebufferTexture2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Bitmap(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Bitmap(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexLevelParameterfv(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexLevelParameterfv(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN int __glXDisp_CheckFramebufferStatus(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CheckFramebufferStatus(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_Vertex2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex2sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetIntegerv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetIntegerv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_BindProgramARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BindProgramARB(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterfvARB(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramEnvParameterfvARB(struct
-                                                               __GLXclientStateRec
-                                                               *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib3svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3svNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexEnviv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexEnviv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_VendorPrivateWithReply(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_VendorPrivateWithReply(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN void __glXDisp_SeparableFilter2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SeparableFilter2D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetQueryObjectuiv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetQueryObjectuiv(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_Map1d(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Map1d(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Map1f(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Map1f(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexImage2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexImage2D(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributes(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_ChangeDrawableAttributes(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmaxParameteriv(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameteriv(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmaxParameterivEXT(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterivEXT(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_PixelTransferf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelTransferf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyTexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyTexImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Fogiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Fogiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EndQuery(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EndQuery(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PixelTransferi(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PixelTransferi(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib3fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Clear(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Clear(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ReadBuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ReadBuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ConvolutionParameteri(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionParameteri(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4iv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttrib4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LightModeli(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LightModeli(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ListBase(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ListBase(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ConvolutionParameterf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ConvolutionParameterf(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetColorTableParameteriv(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTableParameteriv(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetColorTableParameterivSGI(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterivSGI(struct
-                                                               __GLXclientStateRec
-                                                               *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_ReleaseTexImageEXT(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_ReleaseTexImageEXT(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_CallList(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CallList(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_GenerateMipmap(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_GenerateMipmap(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Rectiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rectiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord1iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex2fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex3sv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetQueryObjectiv(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetQueryObjectiv(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_SetClientInfoARB(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_SetClientInfoARB(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_BindTexImageEXT(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_BindTexImageEXT(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EvalMesh1(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalMesh1(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CompressedTexSubImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage3D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex2iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LineWidth(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LineWidth(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexGendv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexGendv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ResetMinmax(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ResetMinmax(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetConvolutionParameterfv(struct
-                                                         __GLXclientStateRec *,
-                                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterfv(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetConvolutionParameterfvEXT(struct
-                                                            __GLXclientStateRec
-                                                            *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterfvEXT(struct
-                                                                __GLXclientStateRec
-                                                                *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMaterialfv(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMaterialfv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN void __glXDisp_WindowPos3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_WindowPos3fv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DeleteProgramsARB(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DeleteProgramsARB(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_UseXFont(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_UseXFont(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN void __glXDisp_ShadeModel(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ShadeModel(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Materialfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Materialfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_FogCoordfvEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FogCoordfvEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_DrawArrays(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DrawArrays(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SampleCoverage(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SampleCoverage(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color3iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color3iv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4sv(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttrib4ubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4ubv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterdvARB(struct
-                                                             __GLXclientStateRec
-                                                             *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramLocalParameterdvARB(struct
-                                                                 __GLXclientStateRec
-                                                                 *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetHistogramParameteriv(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogramParameteriv(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetHistogramParameterivEXT(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterivEXT(struct
-                                                              __GLXclientStateRec
-                                                              *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_PointParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PointParameteriv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Rotatef(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rotatef(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetProgramivARB(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetProgramivARB(struct __GLXclientStateRec *,
-                                                   GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4uiv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4usv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramStringARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramStringARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BindProgramARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindProgramARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteProgramsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_DeleteProgramsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GenProgramsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenProgramsARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsProgramARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsProgramARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramEnvParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramEnvParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramLocalParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramLocalParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramivARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramivARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramStringARB(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ClampColor(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ClampColor(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsRenderbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsRenderbuffer(struct __GLXclientStateRec *, GLbyte *);
 extern _X_HIDDEN void __glXDisp_BindRenderbuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BindRenderbuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EvalPoint2(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalPoint2(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EvalPoint1(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalPoint1(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PopMatrix(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PopMatrix(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DeleteRenderbuffers(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DeleteRenderbuffers(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenRenderbuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenRenderbuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_RenderbufferStorage(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RenderbufferStorage(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RenderbufferStorageMultisample(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RenderbufferStorageMultisample(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetRenderbufferParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetRenderbufferParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsFramebuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_IsFramebuffer(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindFramebuffer(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindFramebuffer(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_DeleteFramebuffers(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_DeleteFramebuffers(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_MakeCurrentReadSGI(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_MakeCurrentReadSGI(struct __GLXclientStateRec
-                                                      *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetTexGeniv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexGeniv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_MakeCurrent(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_MakeCurrent(struct __GLXclientStateRec *,
-                                               GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_DeleteFramebuffers(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenFramebuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GenFramebuffers(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CheckFramebufferStatus(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_CheckFramebufferStatus(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture1D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FramebufferTexture1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture2D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FramebufferTexture2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture3D(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FramebufferTexture3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FramebufferTextureLayer(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FramebufferTextureLayer(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_FramebufferRenderbuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FramebufferRenderbuffer(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_IsProgramARB(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsProgramARB(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4uiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Nsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Map2d(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Map2d(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Map2f(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Map2f(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ProgramStringARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ProgramStringARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4bv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4bv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetConvolutionFilter(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionFilter(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetConvolutionFilterEXT(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetConvolutionFilterEXT(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttribs4dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs4dvNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexGenfv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexGenfv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetHistogram(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogram(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetHistogramEXT(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetHistogramEXT(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN void __glXDisp_ActiveStencilFaceEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Materialf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Materialf(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Materiali(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Materiali(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Indexsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Indexsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib1fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib1fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LightModelfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LightModelfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord2dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_EvalCoord1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_EvalCoord1dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Translated(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Translated(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Translatef(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Translatef(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_StencilMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_StencilMask(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_CreateWindow(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_CreateWindow(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetLightiv(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetLightiv(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDisp_IsList(struct __GLXclientStateRec *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_IsList(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDisp_RenderMode(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_RenderMode(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_LoadName(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LoadName(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyTexSubImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage1D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CullFace(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CullFace(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_QueryContextInfoEXT(struct __GLXclientStateRec *,
-                                                   GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_QueryContextInfoEXT(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttribs2fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs2fvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_StencilFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_StencilFunc(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyPixels(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyPixels(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Rectsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rectsv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexParameterfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Nubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nubv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_ClipPlane(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ClipPlane(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3usv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord3dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3dv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetPixelMapuiv(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetPixelMapuiv(struct __GLXclientStateRec *,
-                                                  GLbyte *);
-extern _X_HIDDEN void __glXDisp_Indexfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Indexfv(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_QueryContext(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_QueryContext(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord3fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_FramebufferRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetFramebufferAttachmentParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetFramebufferAttachmentParameteriv(struct __GLXclientStateRec *, GLbyte *);
 extern _X_HIDDEN void __glXDisp_BlitFramebuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_BlitFramebuffer(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_IndexMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_IndexMask(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetFloatv(struct __GLXclientStateRec *,
-                                         GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetFloatv(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN void __glXDisp_TexCoord3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_FogCoorddv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_FogCoorddv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_PopAttrib(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_PopAttrib(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Fogfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Fogfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_InitNames(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_InitNames(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Normal3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Normal3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Minmax(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Minmax(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_DeleteQueries(struct __GLXclientStateRec *,
-                                             GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_DeleteQueries(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetBooleanv(struct __GLXclientStateRec *,
-                                           GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetBooleanv(struct __GLXclientStateRec *,
-                                               GLbyte *);
-extern _X_HIDDEN void __glXDisp_Hint(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Hint(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Color4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Color4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_CopyColorSubTable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_CopyColorSubTable(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BlitFramebuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_GenerateMipmap(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_GenerateMipmap(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SampleMaskSGIS(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SampleMaskSGIS(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SamplePatternSGIS(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_SamplePatternSGIS(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_AreProgramsResidentNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_AreProgramsResidentNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ExecuteProgramNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ExecuteProgramNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramStringNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramStringNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTrackMatrixivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetTrackMatrixivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetVertexAttribivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetVertexAttribivNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_LoadProgramNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_LoadProgramNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramParameters4dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramParameters4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramParameters4fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramParameters4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RequestResidentProgramsNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_RequestResidentProgramsNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TrackMatrixNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_TrackMatrixNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib1dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib2dvNV(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttrib3dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib3dvNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_TexCoord4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_TexCoord4dv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Begin(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Begin(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_ClientInfo(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_ClientInfo(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_Rectfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Rectfv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_LightModelf(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_LightModelf(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetTexParameterfv(struct __GLXclientStateRec *,
-                                                 GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetTexParameterfv(struct __GLXclientStateRec
-                                                     *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetLightfv(struct __GLXclientStateRec *,
-                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetLightfv(struct __GLXclientStateRec *,
-                                              GLbyte *);
-extern _X_HIDDEN void __glXDisp_Disable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Disable(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord2fvARB(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_SelectBuffer(struct __GLXclientStateRec *,
-                                            GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_SelectBuffer(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN void __glXDisp_ColorMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_ColorMask(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_RasterPos4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_RasterPos4iv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Enable(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Enable(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GetRenderbufferParameteriv(struct
-                                                          __GLXclientStateRec *,
-                                                          GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetRenderbufferParameteriv(struct
-                                                              __GLXclientStateRec
-                                                              *, GLbyte *);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4ubvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3svNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs3svNV(GLbyte * pc);
 extern _X_HIDDEN void __glXDisp_VertexAttribs4svNV(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttribs4svNV(GLbyte * pc);
-extern _X_HIDDEN int __glXDisp_GenRenderbuffers(struct __GLXclientStateRec *,
-                                                GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GenRenderbuffers(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmaxParameterfv(struct __GLXclientStateRec
-                                                    *, GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterfv(struct
-                                                        __GLXclientStateRec *,
-                                                        GLbyte *);
-extern _X_HIDDEN int __glXDisp_GetMinmaxParameterfvEXT(struct
-                                                       __GLXclientStateRec *,
-                                                       GLbyte *);
-extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterfvEXT(struct
-                                                           __GLXclientStateRec
-                                                           *, GLbyte *);
-extern _X_HIDDEN void __glXDisp_VertexAttrib4Nuiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nuiv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_Vertex3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_Vertex3fv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_SecondaryColor3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_SecondaryColor3sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDisp_MultiTexCoord2sv(GLbyte * pc);
-extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs4svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs1fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs3fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs1dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs2dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4ubvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ActiveStencilFaceEXT(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramNamedParameter4fvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramNamedParameter4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramNamedParameter4dvNV(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_ProgramNamedParameter4dvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramNamedParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramNamedParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetProgramNamedParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN _X_COLD int __glXDispSwap_GetProgramNamedParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindRenderbufferEXT(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindRenderbufferEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BindFramebufferEXT(GLbyte * pc);
+extern _X_HIDDEN _X_COLD void __glXDispSwap_BindFramebufferEXT(GLbyte * pc);
 
-#endif                          /* !defined( _INDIRECT_DISPATCH_H_ ) */
+#endif /* !defined( _INDIRECT_DISPATCH_H_ ) */
diff --git a/xserver/glx/indirect_dispatch_swap.c b/vcxsrv-code/xorg-server/glx/indirect_dispatch_swap.c
index 3eeed00..da96511 100644
--- a/xserver/glx/indirect_dispatch_swap.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_dispatch_swap.c
@@ -25,6 +25,14 @@
  * SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "glheader.h"
+
+#include <X11/Xmd.h>
+#include <GL/gl.h>
+#include <GL/glxproto.h>
 #include <inttypes.h>
 #include "glxserver.h"
 #include "indirect_size.h"
@@ -33,6 +41,9 @@
 #include "glxbyteorder.h"
 #include "indirect_util.h"
 #include "singlesize.h"
+#include "glapi.h"
+#include "glapitable.h"
+#include "dispatch.h"
 
 #define __GLX_PAD(x)  (((x) + 3) & ~3)
 
@@ -40,79 +51,74 @@ typedef struct {
     __GLX_PIXEL_3D_HDR;
 } __GLXpixel3DHeader;
 
-extern GLboolean __glXErrorOccured(void);
-extern void __glXClearErrorOccured(void);
+extern GLboolean __glXErrorOccured( void );
+extern void __glXClearErrorOccured( void );
 
-static const unsigned dummy_answer[2] = { 0, 0 };
+static const unsigned dummy_answer[2] = {0, 0};
 
-static GLsizei
-bswap_CARD32(const void *src)
+static _X_UNUSED GLdouble
+bswap_FLOAT64(const void * src)
 {
-    union {
-        uint32_t dst;
-        GLsizei ret;
-    } x;
-
-    x.dst = bswap_32(*(uint32_t *) src);
+    union { uint64_t dst; GLdouble ret; } x;
+    x.dst = bswap_64(*(uint64_t *) src);
     return x.ret;
 }
 
-static GLshort
-bswap_CARD16(const void *src)
+static _X_UNUSED GLhalfNV
+bswap_FLOAT16(const void * src)
 {
-    union {
-        uint16_t dst;
-        GLshort ret;
-    } x;
-
+    union { uint16_t dst; GLhalfNV ret; } x;
     x.dst = bswap_16(*(uint16_t *) src);
     return x.ret;
 }
 
-static GLenum
-bswap_ENUM(const void *src)
+static _X_UNUSED GLfloat
+bswap_FLOAT32(const void * src)
 {
-    union {
-        uint32_t dst;
-        GLenum ret;
-    } x;
-
+    union { uint32_t dst; GLfloat ret; } x;
     x.dst = bswap_32(*(uint32_t *) src);
     return x.ret;
 }
 
-static GLdouble
-bswap_FLOAT64(const void *src)
+static _X_UNUSED GLint
+bswap_CARD32(const void * src)
 {
-    union {
-        uint64_t dst;
-        GLdouble ret;
-    } x;
+    union { uint32_t dst; GLint ret; } x;
+    x.dst = bswap_32(*(uint32_t *) src);
+    return x.ret;
+}
 
-    x.dst = bswap_64(*(uint64_t *) src);
+static _X_UNUSED GLenum
+bswap_ENUM(const void * src)
+{
+    union { uint32_t dst; GLenum ret; } x;
+    x.dst = bswap_32(*(uint32_t *) src);
     return x.ret;
 }
 
-static GLfloat
-bswap_FLOAT32(const void *src)
+static _X_UNUSED GLshort
+bswap_CARD16(const void * src)
 {
-    union {
-        uint32_t dst;
-        GLfloat ret;
-    } x;
+    union { uint16_t dst; GLshort ret; } x;
+    x.dst = bswap_16(*(uint16_t *) src);
+    return x.ret;
+}
 
-    x.dst = bswap_32(*(uint32_t *) src);
+static _X_UNUSED GLsync
+bswap_CARD64(const void * src)
+{
+    union { uint64_t dst; GLsync ret; } x;
+    x.dst = bswap_64(*(uint64_t *) src);
     return x.ret;
 }
 
 static void *
 bswap_16_array(uint16_t * src, unsigned count)
 {
-    unsigned i;
+    unsigned  i;
 
-    for (i = 0; i < count; i++) {
+    for (i = 0 ; i < count ; i++) {
         uint16_t temp = bswap_16(src[i]);
-
         src[i] = temp;
     }
 
@@ -122,11 +128,10 @@ bswap_16_array(uint16_t * src, unsigned count)
 static void *
 bswap_32_array(uint32_t * src, unsigned count)
 {
-    unsigned i;
+    unsigned  i;
 
-    for (i = 0; i < count; i++) {
+    for (i = 0 ; i < count ; i++) {
         uint32_t temp = bswap_32(src[i]);
-
         src[i] = temp;
     }
 
@@ -136,119 +141,117 @@ bswap_32_array(uint32_t * src, unsigned count)
 static void *
 bswap_64_array(uint64_t * src, unsigned count)
 {
-    unsigned i;
+    unsigned  i;
 
-    for (i = 0; i < count; i++) {
+    for (i = 0 ; i < count ; i++) {
         uint64_t temp = bswap_64(src[i]);
-
         src[i] = temp;
     }
 
     return src;
 }
 
-int
-__glXDispSwap_NewList(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_NewList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glNewList((GLuint) bswap_CARD32(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    if ( cx != NULL ) {
+        CALL_NewList( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+             (GLenum  )bswap_ENUM   ( pc +  4 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_EndList(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_EndList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glEndList();
+    if ( cx != NULL ) {
+        CALL_EndList( GET_DISPATCH(), () );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDispSwap_CallList(GLbyte * pc)
+void __glXDispSwap_CallList(GLbyte * pc)
 {
-    glCallList((GLuint) bswap_CARD32(pc + 0));
+    CALL_CallList( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_CallLists(GLbyte * pc)
+void __glXDispSwap_CallLists(GLbyte * pc)
 {
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
-    const GLenum type = (GLenum) bswap_ENUM(pc + 4);
-    const GLvoid *lists;
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
+    const GLenum type =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLvoid * lists;
 
-    switch (type) {
+    switch(type) {
     case GL_BYTE:
     case GL_UNSIGNED_BYTE:
     case GL_2_BYTES:
     case GL_3_BYTES:
     case GL_4_BYTES:
-        lists = (const GLvoid *) (pc + 8);
-        break;
+        lists = (const GLvoid *) (pc + 8); break;
     case GL_SHORT:
     case GL_UNSIGNED_SHORT:
-        lists = (const GLvoid *) bswap_16_array((uint16_t *) (pc + 8), n);
-        break;
+        lists = (const GLvoid *) bswap_16_array( (uint16_t *) (pc + 8), n ); break;
     case GL_INT:
     case GL_UNSIGNED_INT:
     case GL_FLOAT:
-        lists = (const GLvoid *) bswap_32_array((uint32_t *) (pc + 8), n);
-        break;
+        lists = (const GLvoid *) bswap_32_array( (uint32_t *) (pc + 8), n ); break;
     default:
         return;
     }
 
-    glCallLists(n, type, lists);
+    CALL_CallLists( GET_DISPATCH(), (
+        n,
+        type,
+        lists
+    ) );
 }
 
-int
-__glXDispSwap_DeleteLists(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_DeleteLists(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glDeleteLists((GLuint) bswap_CARD32(pc + 0),
-                      (GLsizei) bswap_CARD32(pc + 4));
+    if ( cx != NULL ) {
+        CALL_DeleteLists( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+             (GLsizei )bswap_CARD32 ( pc +  4 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_GenLists(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenLists(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLuint retval;
-
-        retval = glGenLists((GLsizei) bswap_CARD32(pc + 0));
+        retval = CALL_GenLists( GET_DISPATCH(), (
+             (GLsizei )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -256,1469 +259,1648 @@ __glXDispSwap_GenLists(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_ListBase(GLbyte * pc)
+void __glXDispSwap_ListBase(GLbyte * pc)
 {
-    glListBase((GLuint) bswap_CARD32(pc + 0));
+    CALL_ListBase( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Begin(GLbyte * pc)
+void __glXDispSwap_Begin(GLbyte * pc)
 {
-    glBegin((GLenum) bswap_ENUM(pc + 0));
+    CALL_Begin( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Bitmap(GLbyte * pc)
+void __glXDispSwap_Bitmap(GLbyte * pc)
 {
-    const GLubyte *const bitmap = (const GLubyte *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLubyte * const bitmap = (const GLubyte *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glBitmap((GLsizei) bswap_CARD32(pc + 20),
-             (GLsizei) bswap_CARD32(pc + 24),
-             (GLfloat) bswap_FLOAT32(pc + 28),
-             (GLfloat) bswap_FLOAT32(pc + 32),
-             (GLfloat) bswap_FLOAT32(pc + 36),
-             (GLfloat) bswap_FLOAT32(pc + 40), bitmap);
+    CALL_Bitmap( GET_DISPATCH(), (
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLfloat )bswap_FLOAT32( pc + 28 ),
+         (GLfloat )bswap_FLOAT32( pc + 32 ),
+         (GLfloat )bswap_FLOAT32( pc + 36 ),
+         (GLfloat )bswap_FLOAT32( pc + 40 ),
+        bitmap
+    ) );
 }
 
-void
-__glXDispSwap_Color3bv(GLbyte * pc)
+void __glXDispSwap_Color3bv(GLbyte * pc)
 {
-    glColor3bv((const GLbyte *) (pc + 0));
+    CALL_Color3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_Color3dv(GLbyte * pc)
+void __glXDispSwap_Color3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glColor3dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_Color3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color3fv(GLbyte * pc)
+void __glXDispSwap_Color3fv(GLbyte * pc)
 {
-    glColor3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Color3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color3iv(GLbyte * pc)
+void __glXDispSwap_Color3iv(GLbyte * pc)
 {
-    glColor3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Color3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color3sv(GLbyte * pc)
+void __glXDispSwap_Color3sv(GLbyte * pc)
 {
-    glColor3sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_Color3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color3ubv(GLbyte * pc)
+void __glXDispSwap_Color3ubv(GLbyte * pc)
 {
-    glColor3ubv((const GLubyte *) (pc + 0));
+    CALL_Color3ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_Color3uiv(GLbyte * pc)
+void __glXDispSwap_Color3uiv(GLbyte * pc)
 {
-    glColor3uiv((const GLuint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Color3uiv( GET_DISPATCH(), (
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color3usv(GLbyte * pc)
+void __glXDispSwap_Color3usv(GLbyte * pc)
 {
-    glColor3usv((const GLushort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_Color3usv( GET_DISPATCH(), (
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4bv(GLbyte * pc)
+void __glXDispSwap_Color4bv(GLbyte * pc)
 {
-    glColor4bv((const GLbyte *) (pc + 0));
+    CALL_Color4bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_Color4dv(GLbyte * pc)
+void __glXDispSwap_Color4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glColor4dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 4));
+    CALL_Color4dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4fv(GLbyte * pc)
+void __glXDispSwap_Color4fv(GLbyte * pc)
 {
-    glColor4fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_Color4fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4iv(GLbyte * pc)
+void __glXDispSwap_Color4iv(GLbyte * pc)
 {
-    glColor4iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_Color4iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4sv(GLbyte * pc)
+void __glXDispSwap_Color4sv(GLbyte * pc)
 {
-    glColor4sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 4));
+    CALL_Color4sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4ubv(GLbyte * pc)
+void __glXDispSwap_Color4ubv(GLbyte * pc)
 {
-    glColor4ubv((const GLubyte *) (pc + 0));
+    CALL_Color4ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_Color4uiv(GLbyte * pc)
+void __glXDispSwap_Color4uiv(GLbyte * pc)
 {
-    glColor4uiv((const GLuint *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_Color4uiv( GET_DISPATCH(), (
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Color4usv(GLbyte * pc)
+void __glXDispSwap_Color4usv(GLbyte * pc)
 {
-    glColor4usv((const GLushort *) bswap_16_array((uint16_t *) (pc + 0), 4));
+    CALL_Color4usv( GET_DISPATCH(), (
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_EdgeFlagv(GLbyte * pc)
+void __glXDispSwap_EdgeFlagv(GLbyte * pc)
 {
-    glEdgeFlagv((const GLboolean *) (pc + 0));
+    CALL_EdgeFlagv( GET_DISPATCH(), (
+         (const GLboolean *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_End(GLbyte * pc)
+void __glXDispSwap_End(GLbyte * pc)
 {
-    glEnd();
+    CALL_End( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_Indexdv(GLbyte * pc)
+void __glXDispSwap_Indexdv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glIndexdv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 1));
+    CALL_Indexdv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_Indexfv(GLbyte * pc)
+void __glXDispSwap_Indexfv(GLbyte * pc)
 {
-    glIndexfv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_Indexfv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_Indexiv(GLbyte * pc)
+void __glXDispSwap_Indexiv(GLbyte * pc)
 {
-    glIndexiv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_Indexiv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_Indexsv(GLbyte * pc)
+void __glXDispSwap_Indexsv(GLbyte * pc)
 {
-    glIndexsv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 1));
+    CALL_Indexsv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_Normal3bv(GLbyte * pc)
+void __glXDispSwap_Normal3bv(GLbyte * pc)
 {
-    glNormal3bv((const GLbyte *) (pc + 0));
+    CALL_Normal3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_Normal3dv(GLbyte * pc)
+void __glXDispSwap_Normal3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glNormal3dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_Normal3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Normal3fv(GLbyte * pc)
+void __glXDispSwap_Normal3fv(GLbyte * pc)
 {
-    glNormal3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Normal3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Normal3iv(GLbyte * pc)
+void __glXDispSwap_Normal3iv(GLbyte * pc)
 {
-    glNormal3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Normal3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Normal3sv(GLbyte * pc)
+void __glXDispSwap_Normal3sv(GLbyte * pc)
 {
-    glNormal3sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_Normal3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos2dv(GLbyte * pc)
+void __glXDispSwap_RasterPos2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glRasterPos2dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 2));
+    CALL_RasterPos2dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos2fv(GLbyte * pc)
+void __glXDispSwap_RasterPos2fv(GLbyte * pc)
 {
-    glRasterPos2fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_RasterPos2fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos2iv(GLbyte * pc)
+void __glXDispSwap_RasterPos2iv(GLbyte * pc)
 {
-    glRasterPos2iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_RasterPos2iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos2sv(GLbyte * pc)
+void __glXDispSwap_RasterPos2sv(GLbyte * pc)
 {
-    glRasterPos2sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 2));
+    CALL_RasterPos2sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos3dv(GLbyte * pc)
+void __glXDispSwap_RasterPos3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glRasterPos3dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_RasterPos3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos3fv(GLbyte * pc)
+void __glXDispSwap_RasterPos3fv(GLbyte * pc)
 {
-    glRasterPos3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_RasterPos3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos3iv(GLbyte * pc)
+void __glXDispSwap_RasterPos3iv(GLbyte * pc)
 {
-    glRasterPos3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_RasterPos3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos3sv(GLbyte * pc)
+void __glXDispSwap_RasterPos3sv(GLbyte * pc)
 {
-    glRasterPos3sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_RasterPos3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos4dv(GLbyte * pc)
+void __glXDispSwap_RasterPos4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRasterPos4dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 4));
+    CALL_RasterPos4dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos4fv(GLbyte * pc)
+void __glXDispSwap_RasterPos4fv(GLbyte * pc)
 {
-    glRasterPos4fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_RasterPos4fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos4iv(GLbyte * pc)
+void __glXDispSwap_RasterPos4iv(GLbyte * pc)
 {
-    glRasterPos4iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_RasterPos4iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_RasterPos4sv(GLbyte * pc)
+void __glXDispSwap_RasterPos4sv(GLbyte * pc)
 {
-    glRasterPos4sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 4));
+    CALL_RasterPos4sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Rectdv(GLbyte * pc)
+void __glXDispSwap_Rectdv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRectdv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 2),
-             (const GLdouble *) bswap_64_array((uint64_t *) (pc + 16), 2));
+    CALL_Rectdv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc + 16), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Rectfv(GLbyte * pc)
+void __glXDispSwap_Rectfv(GLbyte * pc)
 {
-    glRectfv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 2),
-             (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8), 2));
+    CALL_Rectfv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 2 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Rectiv(GLbyte * pc)
+void __glXDispSwap_Rectiv(GLbyte * pc)
 {
-    glRectiv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 2),
-             (const GLint *) bswap_32_array((uint32_t *) (pc + 8), 2));
+    CALL_Rectiv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 2 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  8), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Rectsv(GLbyte * pc)
+void __glXDispSwap_Rectsv(GLbyte * pc)
 {
-    glRectsv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 2),
-             (const GLshort *) bswap_16_array((uint16_t *) (pc + 4), 2));
+    CALL_Rectsv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 2 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord1dv(GLbyte * pc)
+void __glXDispSwap_TexCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glTexCoord1dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 1));
+    CALL_TexCoord1dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord1fv(GLbyte * pc)
+void __glXDispSwap_TexCoord1fv(GLbyte * pc)
 {
-    glTexCoord1fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_TexCoord1fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord1iv(GLbyte * pc)
+void __glXDispSwap_TexCoord1iv(GLbyte * pc)
 {
-    glTexCoord1iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_TexCoord1iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord1sv(GLbyte * pc)
+void __glXDispSwap_TexCoord1sv(GLbyte * pc)
 {
-    glTexCoord1sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 1));
+    CALL_TexCoord1sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord2dv(GLbyte * pc)
+void __glXDispSwap_TexCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glTexCoord2dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 2));
+    CALL_TexCoord2dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord2fv(GLbyte * pc)
+void __glXDispSwap_TexCoord2fv(GLbyte * pc)
 {
-    glTexCoord2fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_TexCoord2fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord2iv(GLbyte * pc)
+void __glXDispSwap_TexCoord2iv(GLbyte * pc)
 {
-    glTexCoord2iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_TexCoord2iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord2sv(GLbyte * pc)
+void __glXDispSwap_TexCoord2sv(GLbyte * pc)
 {
-    glTexCoord2sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 2));
+    CALL_TexCoord2sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord3dv(GLbyte * pc)
+void __glXDispSwap_TexCoord3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glTexCoord3dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_TexCoord3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord3fv(GLbyte * pc)
+void __glXDispSwap_TexCoord3fv(GLbyte * pc)
 {
-    glTexCoord3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_TexCoord3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord3iv(GLbyte * pc)
+void __glXDispSwap_TexCoord3iv(GLbyte * pc)
 {
-    glTexCoord3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_TexCoord3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord3sv(GLbyte * pc)
+void __glXDispSwap_TexCoord3sv(GLbyte * pc)
 {
-    glTexCoord3sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_TexCoord3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord4dv(GLbyte * pc)
+void __glXDispSwap_TexCoord4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glTexCoord4dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 4));
+    CALL_TexCoord4dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord4fv(GLbyte * pc)
+void __glXDispSwap_TexCoord4fv(GLbyte * pc)
 {
-    glTexCoord4fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_TexCoord4fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord4iv(GLbyte * pc)
+void __glXDispSwap_TexCoord4iv(GLbyte * pc)
 {
-    glTexCoord4iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_TexCoord4iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_TexCoord4sv(GLbyte * pc)
+void __glXDispSwap_TexCoord4sv(GLbyte * pc)
 {
-    glTexCoord4sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 4));
+    CALL_TexCoord4sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex2dv(GLbyte * pc)
+void __glXDispSwap_Vertex2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glVertex2dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 2));
+    CALL_Vertex2dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex2fv(GLbyte * pc)
+void __glXDispSwap_Vertex2fv(GLbyte * pc)
 {
-    glVertex2fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_Vertex2fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex2iv(GLbyte * pc)
+void __glXDispSwap_Vertex2iv(GLbyte * pc)
 {
-    glVertex2iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_Vertex2iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex2sv(GLbyte * pc)
+void __glXDispSwap_Vertex2sv(GLbyte * pc)
 {
-    glVertex2sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 2));
+    CALL_Vertex2sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex3dv(GLbyte * pc)
+void __glXDispSwap_Vertex3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glVertex3dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_Vertex3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex3fv(GLbyte * pc)
+void __glXDispSwap_Vertex3fv(GLbyte * pc)
 {
-    glVertex3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Vertex3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex3iv(GLbyte * pc)
+void __glXDispSwap_Vertex3iv(GLbyte * pc)
 {
-    glVertex3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_Vertex3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex3sv(GLbyte * pc)
+void __glXDispSwap_Vertex3sv(GLbyte * pc)
 {
-    glVertex3sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_Vertex3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex4dv(GLbyte * pc)
+void __glXDispSwap_Vertex4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glVertex4dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 4));
+    CALL_Vertex4dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex4fv(GLbyte * pc)
+void __glXDispSwap_Vertex4fv(GLbyte * pc)
 {
-    glVertex4fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_Vertex4fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex4iv(GLbyte * pc)
+void __glXDispSwap_Vertex4iv(GLbyte * pc)
 {
-    glVertex4iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 4));
+    CALL_Vertex4iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_Vertex4sv(GLbyte * pc)
+void __glXDispSwap_Vertex4sv(GLbyte * pc)
 {
-    glVertex4sv((const GLshort *) bswap_16_array((uint16_t *) (pc + 0), 4));
+    CALL_Vertex4sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ClipPlane(GLbyte * pc)
+void __glXDispSwap_ClipPlane(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    glClipPlane((GLenum) bswap_ENUM(pc + 32),
-                (const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 4));
+    CALL_ClipPlane( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ColorMaterial(GLbyte * pc)
+void __glXDispSwap_ColorMaterial(GLbyte * pc)
 {
-    glColorMaterial((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    CALL_ColorMaterial( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_CullFace(GLbyte * pc)
+void __glXDispSwap_CullFace(GLbyte * pc)
 {
-    glCullFace((GLenum) bswap_ENUM(pc + 0));
+    CALL_CullFace( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Fogf(GLbyte * pc)
+void __glXDispSwap_Fogf(GLbyte * pc)
 {
-    glFogf((GLenum) bswap_ENUM(pc + 0), (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_Fogf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_Fogfv(GLbyte * pc)
+void __glXDispSwap_Fogfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                         __glFogfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 4), __glFogfv_size(pname) );
 
-    glFogfv(pname, params);
+    CALL_Fogfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_Fogi(GLbyte * pc)
+void __glXDispSwap_Fogi(GLbyte * pc)
 {
-    glFogi((GLenum) bswap_ENUM(pc + 0), (GLint) bswap_CARD32(pc + 4));
+    CALL_Fogi( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_Fogiv(GLbyte * pc)
+void __glXDispSwap_Fogiv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                       __glFogiv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 4), __glFogiv_size(pname) );
 
-    glFogiv(pname, params);
+    CALL_Fogiv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_FrontFace(GLbyte * pc)
+void __glXDispSwap_FrontFace(GLbyte * pc)
 {
-    glFrontFace((GLenum) bswap_ENUM(pc + 0));
+    CALL_FrontFace( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Hint(GLbyte * pc)
+void __glXDispSwap_Hint(GLbyte * pc)
 {
-    glHint((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    CALL_Hint( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_Lightf(GLbyte * pc)
+void __glXDispSwap_Lightf(GLbyte * pc)
 {
-    glLightf((GLenum) bswap_ENUM(pc + 0),
-             (GLenum) bswap_ENUM(pc + 4), (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_Lightf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Lightfv(GLbyte * pc)
+void __glXDispSwap_Lightfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glLightfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glLightfv_size(pname) );
 
-    glLightfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_Lightfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_Lighti(GLbyte * pc)
+void __glXDispSwap_Lighti(GLbyte * pc)
 {
-    glLighti((GLenum) bswap_ENUM(pc + 0),
-             (GLenum) bswap_ENUM(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_Lighti( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Lightiv(GLbyte * pc)
+void __glXDispSwap_Lightiv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glLightiv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glLightiv_size(pname) );
 
-    glLightiv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_Lightiv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_LightModelf(GLbyte * pc)
+void __glXDispSwap_LightModelf(GLbyte * pc)
 {
-    glLightModelf((GLenum) bswap_ENUM(pc + 0), (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_LightModelf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_LightModelfv(GLbyte * pc)
+void __glXDispSwap_LightModelfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                         __glLightModelfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 4), __glLightModelfv_size(pname) );
 
-    glLightModelfv(pname, params);
+    CALL_LightModelfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_LightModeli(GLbyte * pc)
+void __glXDispSwap_LightModeli(GLbyte * pc)
 {
-    glLightModeli((GLenum) bswap_ENUM(pc + 0), (GLint) bswap_CARD32(pc + 4));
+    CALL_LightModeli( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_LightModeliv(GLbyte * pc)
+void __glXDispSwap_LightModeliv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                       __glLightModeliv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 4), __glLightModeliv_size(pname) );
 
-    glLightModeliv(pname, params);
+    CALL_LightModeliv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_LineStipple(GLbyte * pc)
+void __glXDispSwap_LineStipple(GLbyte * pc)
 {
-    glLineStipple((GLint) bswap_CARD32(pc + 0),
-                  (GLushort) bswap_CARD16(pc + 4));
+    CALL_LineStipple( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLushort)bswap_CARD16 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_LineWidth(GLbyte * pc)
+void __glXDispSwap_LineWidth(GLbyte * pc)
 {
-    glLineWidth((GLfloat) bswap_FLOAT32(pc + 0));
+    CALL_LineWidth( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Materialf(GLbyte * pc)
+void __glXDispSwap_Materialf(GLbyte * pc)
 {
-    glMaterialf((GLenum) bswap_ENUM(pc + 0),
-                (GLenum) bswap_ENUM(pc + 4), (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_Materialf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Materialfv(GLbyte * pc)
+void __glXDispSwap_Materialfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glMaterialfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glMaterialfv_size(pname) );
 
-    glMaterialfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_Materialfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_Materiali(GLbyte * pc)
+void __glXDispSwap_Materiali(GLbyte * pc)
 {
-    glMateriali((GLenum) bswap_ENUM(pc + 0),
-                (GLenum) bswap_ENUM(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_Materiali( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Materialiv(GLbyte * pc)
+void __glXDispSwap_Materialiv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glMaterialiv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glMaterialiv_size(pname) );
 
-    glMaterialiv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_Materialiv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_PointSize(GLbyte * pc)
+void __glXDispSwap_PointSize(GLbyte * pc)
 {
-    glPointSize((GLfloat) bswap_FLOAT32(pc + 0));
+    CALL_PointSize( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_PolygonMode(GLbyte * pc)
+void __glXDispSwap_PolygonMode(GLbyte * pc)
 {
-    glPolygonMode((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    CALL_PolygonMode( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_PolygonStipple(GLbyte * pc)
+void __glXDispSwap_PolygonStipple(GLbyte * pc)
 {
-    const GLubyte *const mask = (const GLubyte *) ((pc + 20));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLubyte * const mask = (const GLubyte *) (pc + 20);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glPolygonStipple(mask);
+    CALL_PolygonStipple( GET_DISPATCH(), (
+        mask
+    ) );
 }
 
-void
-__glXDispSwap_Scissor(GLbyte * pc)
+void __glXDispSwap_Scissor(GLbyte * pc)
 {
-    glScissor((GLint) bswap_CARD32(pc + 0),
-              (GLint) bswap_CARD32(pc + 4),
-              (GLsizei) bswap_CARD32(pc + 8), (GLsizei) bswap_CARD32(pc + 12));
+    CALL_Scissor( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLsizei )bswap_CARD32 ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_ShadeModel(GLbyte * pc)
+void __glXDispSwap_ShadeModel(GLbyte * pc)
 {
-    glShadeModel((GLenum) bswap_ENUM(pc + 0));
+    CALL_ShadeModel( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_TexParameterf(GLbyte * pc)
+void __glXDispSwap_TexParameterf(GLbyte * pc)
 {
-    glTexParameterf((GLenum) bswap_ENUM(pc + 0),
-                    (GLenum) bswap_ENUM(pc + 4),
-                    (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_TexParameterf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexParameterfv(GLbyte * pc)
+void __glXDispSwap_TexParameterfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glTexParameterfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glTexParameterfv_size(pname) );
 
-    glTexParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexParameterfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexParameteri(GLbyte * pc)
+void __glXDispSwap_TexParameteri(GLbyte * pc)
 {
-    glTexParameteri((GLenum) bswap_ENUM(pc + 0),
-                    (GLenum) bswap_ENUM(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_TexParameteri( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexParameteriv(GLbyte * pc)
+void __glXDispSwap_TexParameteriv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glTexParameteriv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glTexParameteriv_size(pname) );
 
-    glTexParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexParameteriv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexImage1D(GLbyte * pc)
+void __glXDispSwap_TexImage1D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 52));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 52);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexImage1D((GLenum) bswap_ENUM(pc + 20),
-                 (GLint) bswap_CARD32(pc + 24),
-                 (GLint) bswap_CARD32(pc + 28),
-                 (GLsizei) bswap_CARD32(pc + 32),
-                 (GLint) bswap_CARD32(pc + 40),
-                 (GLenum) bswap_ENUM(pc + 44),
-                 (GLenum) bswap_ENUM(pc + 48), pixels);
+    CALL_TexImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 ),
+         (GLsizei )bswap_CARD32 ( pc + 32 ),
+         (GLint   )bswap_CARD32 ( pc + 40 ),
+         (GLenum  )bswap_ENUM   ( pc + 44 ),
+         (GLenum  )bswap_ENUM   ( pc + 48 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_TexImage2D(GLbyte * pc)
+void __glXDispSwap_TexImage2D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 52));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 52);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexImage2D((GLenum) bswap_ENUM(pc + 20),
-                 (GLint) bswap_CARD32(pc + 24),
-                 (GLint) bswap_CARD32(pc + 28),
-                 (GLsizei) bswap_CARD32(pc + 32),
-                 (GLsizei) bswap_CARD32(pc + 36),
-                 (GLint) bswap_CARD32(pc + 40),
-                 (GLenum) bswap_ENUM(pc + 44),
-                 (GLenum) bswap_ENUM(pc + 48), pixels);
+    CALL_TexImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 ),
+         (GLsizei )bswap_CARD32 ( pc + 32 ),
+         (GLsizei )bswap_CARD32 ( pc + 36 ),
+         (GLint   )bswap_CARD32 ( pc + 40 ),
+         (GLenum  )bswap_ENUM   ( pc + 44 ),
+         (GLenum  )bswap_ENUM   ( pc + 48 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_TexEnvf(GLbyte * pc)
+void __glXDispSwap_TexEnvf(GLbyte * pc)
 {
-    glTexEnvf((GLenum) bswap_ENUM(pc + 0),
-              (GLenum) bswap_ENUM(pc + 4), (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_TexEnvf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexEnvfv(GLbyte * pc)
+void __glXDispSwap_TexEnvfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glTexEnvfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glTexEnvfv_size(pname) );
 
-    glTexEnvfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexEnvfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexEnvi(GLbyte * pc)
+void __glXDispSwap_TexEnvi(GLbyte * pc)
 {
-    glTexEnvi((GLenum) bswap_ENUM(pc + 0),
-              (GLenum) bswap_ENUM(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_TexEnvi( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexEnviv(GLbyte * pc)
+void __glXDispSwap_TexEnviv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glTexEnviv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glTexEnviv_size(pname) );
 
-    glTexEnviv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexEnviv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexGend(GLbyte * pc)
+void __glXDispSwap_TexGend(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glTexGend((GLenum) bswap_ENUM(pc + 8),
-              (GLenum) bswap_ENUM(pc + 12), (GLdouble) bswap_FLOAT64(pc + 0));
+    CALL_TexGend( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLenum  )bswap_ENUM   ( pc + 12 ),
+         (GLdouble)bswap_FLOAT64( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_TexGendv(GLbyte * pc)
+void __glXDispSwap_TexGendv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLdouble *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLdouble * params;
 
 #ifdef __GLX_ALIGN64
     const GLuint compsize = __glTexGendv_size(pname);
-    const GLuint cmdlen = 12 + __GLX_PAD((compsize * 8)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(compsize, 1 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    params =
-        (const GLdouble *) bswap_64_array((uint64_t *) (pc + 8),
-                                          __glTexGendv_size(pname));
+    params = (const GLdouble *) bswap_64_array( (uint64_t *) (pc + 8), __glTexGendv_size(pname) );
 
-    glTexGendv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexGendv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexGenf(GLbyte * pc)
+void __glXDispSwap_TexGenf(GLbyte * pc)
 {
-    glTexGenf((GLenum) bswap_ENUM(pc + 0),
-              (GLenum) bswap_ENUM(pc + 4), (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_TexGenf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexGenfv(GLbyte * pc)
+void __glXDispSwap_TexGenfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glTexGenfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glTexGenfv_size(pname) );
 
-    glTexGenfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexGenfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_TexGeni(GLbyte * pc)
+void __glXDispSwap_TexGeni(GLbyte * pc)
 {
-    glTexGeni((GLenum) bswap_ENUM(pc + 0),
-              (GLenum) bswap_ENUM(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_TexGeni( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_TexGeniv(GLbyte * pc)
+void __glXDispSwap_TexGeniv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glTexGeniv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glTexGeniv_size(pname) );
 
-    glTexGeniv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_TexGeniv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_InitNames(GLbyte * pc)
+void __glXDispSwap_InitNames(GLbyte * pc)
 {
-    glInitNames();
+    CALL_InitNames( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_LoadName(GLbyte * pc)
+void __glXDispSwap_LoadName(GLbyte * pc)
 {
-    glLoadName((GLuint) bswap_CARD32(pc + 0));
+    CALL_LoadName( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_PassThrough(GLbyte * pc)
+void __glXDispSwap_PassThrough(GLbyte * pc)
 {
-    glPassThrough((GLfloat) bswap_FLOAT32(pc + 0));
+    CALL_PassThrough( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_PopName(GLbyte * pc)
+void __glXDispSwap_PopName(GLbyte * pc)
 {
-    glPopName();
+    CALL_PopName( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_PushName(GLbyte * pc)
+void __glXDispSwap_PushName(GLbyte * pc)
 {
-    glPushName((GLuint) bswap_CARD32(pc + 0));
+    CALL_PushName( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_DrawBuffer(GLbyte * pc)
+void __glXDispSwap_DrawBuffer(GLbyte * pc)
 {
-    glDrawBuffer((GLenum) bswap_ENUM(pc + 0));
+    CALL_DrawBuffer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Clear(GLbyte * pc)
+void __glXDispSwap_Clear(GLbyte * pc)
 {
-    glClear((GLbitfield) bswap_CARD32(pc + 0));
+    CALL_Clear( GET_DISPATCH(), (
+         (GLbitfield)bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ClearAccum(GLbyte * pc)
+void __glXDispSwap_ClearAccum(GLbyte * pc)
 {
-    glClearAccum((GLfloat) bswap_FLOAT32(pc + 0),
-                 (GLfloat) bswap_FLOAT32(pc + 4),
-                 (GLfloat) bswap_FLOAT32(pc + 8),
-                 (GLfloat) bswap_FLOAT32(pc + 12));
+    CALL_ClearAccum( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 ),
+         (GLfloat )bswap_FLOAT32( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_ClearIndex(GLbyte * pc)
+void __glXDispSwap_ClearIndex(GLbyte * pc)
 {
-    glClearIndex((GLfloat) bswap_FLOAT32(pc + 0));
+    CALL_ClearIndex( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ClearColor(GLbyte * pc)
+void __glXDispSwap_ClearColor(GLbyte * pc)
 {
-    glClearColor((GLclampf) bswap_FLOAT32(pc + 0),
-                 (GLclampf) bswap_FLOAT32(pc + 4),
-                 (GLclampf) bswap_FLOAT32(pc + 8),
-                 (GLclampf) bswap_FLOAT32(pc + 12));
+    CALL_ClearColor( GET_DISPATCH(), (
+         (GLclampf)bswap_FLOAT32( pc +  0 ),
+         (GLclampf)bswap_FLOAT32( pc +  4 ),
+         (GLclampf)bswap_FLOAT32( pc +  8 ),
+         (GLclampf)bswap_FLOAT32( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_ClearStencil(GLbyte * pc)
+void __glXDispSwap_ClearStencil(GLbyte * pc)
 {
-    glClearStencil((GLint) bswap_CARD32(pc + 0));
+    CALL_ClearStencil( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ClearDepth(GLbyte * pc)
+void __glXDispSwap_ClearDepth(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glClearDepth((GLclampd) bswap_FLOAT64(pc + 0));
+    CALL_ClearDepth( GET_DISPATCH(), (
+         (GLclampd)bswap_FLOAT64( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_StencilMask(GLbyte * pc)
+void __glXDispSwap_StencilMask(GLbyte * pc)
 {
-    glStencilMask((GLuint) bswap_CARD32(pc + 0));
+    CALL_StencilMask( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ColorMask(GLbyte * pc)
+void __glXDispSwap_ColorMask(GLbyte * pc)
 {
-    glColorMask(*(GLboolean *) (pc + 0),
-                *(GLboolean *) (pc + 1),
-                *(GLboolean *) (pc + 2), *(GLboolean *) (pc + 3));
+    CALL_ColorMask( GET_DISPATCH(), (
+        *(GLboolean *)(pc +  0),
+        *(GLboolean *)(pc +  1),
+        *(GLboolean *)(pc +  2),
+        *(GLboolean *)(pc +  3)
+    ) );
 }
 
-void
-__glXDispSwap_DepthMask(GLbyte * pc)
+void __glXDispSwap_DepthMask(GLbyte * pc)
 {
-    glDepthMask(*(GLboolean *) (pc + 0));
+    CALL_DepthMask( GET_DISPATCH(), (
+        *(GLboolean *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_IndexMask(GLbyte * pc)
+void __glXDispSwap_IndexMask(GLbyte * pc)
 {
-    glIndexMask((GLuint) bswap_CARD32(pc + 0));
+    CALL_IndexMask( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Accum(GLbyte * pc)
+void __glXDispSwap_Accum(GLbyte * pc)
 {
-    glAccum((GLenum) bswap_ENUM(pc + 0), (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_Accum( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_Disable(GLbyte * pc)
+void __glXDispSwap_Disable(GLbyte * pc)
 {
-    glDisable((GLenum) bswap_ENUM(pc + 0));
+    CALL_Disable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_Enable(GLbyte * pc)
+void __glXDispSwap_Enable(GLbyte * pc)
 {
-    glEnable((GLenum) bswap_ENUM(pc + 0));
+    CALL_Enable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_PopAttrib(GLbyte * pc)
+void __glXDispSwap_PopAttrib(GLbyte * pc)
 {
-    glPopAttrib();
+    CALL_PopAttrib( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_PushAttrib(GLbyte * pc)
+void __glXDispSwap_PushAttrib(GLbyte * pc)
 {
-    glPushAttrib((GLbitfield) bswap_CARD32(pc + 0));
+    CALL_PushAttrib( GET_DISPATCH(), (
+         (GLbitfield)bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_MapGrid1d(GLbyte * pc)
+void __glXDispSwap_MapGrid1d(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    glMapGrid1d((GLint) bswap_CARD32(pc + 16),
-                (GLdouble) bswap_FLOAT64(pc + 0),
-                (GLdouble) bswap_FLOAT64(pc + 8));
+    CALL_MapGrid1d( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_MapGrid1f(GLbyte * pc)
+void __glXDispSwap_MapGrid1f(GLbyte * pc)
 {
-    glMapGrid1f((GLint) bswap_CARD32(pc + 0),
-                (GLfloat) bswap_FLOAT32(pc + 4),
-                (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_MapGrid1f( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_MapGrid2d(GLbyte * pc)
+void __glXDispSwap_MapGrid2d(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    glMapGrid2d((GLint) bswap_CARD32(pc + 32),
-                (GLdouble) bswap_FLOAT64(pc + 0),
-                (GLdouble) bswap_FLOAT64(pc + 8),
-                (GLint) bswap_CARD32(pc + 36),
-                (GLdouble) bswap_FLOAT64(pc + 16),
-                (GLdouble) bswap_FLOAT64(pc + 24));
+    CALL_MapGrid2d( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc + 32 ),
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 36 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 ),
+         (GLdouble)bswap_FLOAT64( pc + 24 )
+    ) );
 }
 
-void
-__glXDispSwap_MapGrid2f(GLbyte * pc)
+void __glXDispSwap_MapGrid2f(GLbyte * pc)
 {
-    glMapGrid2f((GLint) bswap_CARD32(pc + 0),
-                (GLfloat) bswap_FLOAT32(pc + 4),
-                (GLfloat) bswap_FLOAT32(pc + 8),
-                (GLint) bswap_CARD32(pc + 12),
-                (GLfloat) bswap_FLOAT32(pc + 16),
-                (GLfloat) bswap_FLOAT32(pc + 20));
+    CALL_MapGrid2f( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLfloat )bswap_FLOAT32( pc + 16 ),
+         (GLfloat )bswap_FLOAT32( pc + 20 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalCoord1dv(GLbyte * pc)
+void __glXDispSwap_EvalCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    glEvalCoord1dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 1));
+    CALL_EvalCoord1dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalCoord1fv(GLbyte * pc)
+void __glXDispSwap_EvalCoord1fv(GLbyte * pc)
 {
-    glEvalCoord1fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_EvalCoord1fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalCoord2dv(GLbyte * pc)
+void __glXDispSwap_EvalCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glEvalCoord2dv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 2));
+    CALL_EvalCoord2dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalCoord2fv(GLbyte * pc)
+void __glXDispSwap_EvalCoord2fv(GLbyte * pc)
 {
-    glEvalCoord2fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 2));
+    CALL_EvalCoord2fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalMesh1(GLbyte * pc)
+void __glXDispSwap_EvalMesh1(GLbyte * pc)
 {
-    glEvalMesh1((GLenum) bswap_ENUM(pc + 0),
-                (GLint) bswap_CARD32(pc + 4), (GLint) bswap_CARD32(pc + 8));
+    CALL_EvalMesh1( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalPoint1(GLbyte * pc)
+void __glXDispSwap_EvalPoint1(GLbyte * pc)
 {
-    glEvalPoint1((GLint) bswap_CARD32(pc + 0));
+    CALL_EvalPoint1( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalMesh2(GLbyte * pc)
+void __glXDispSwap_EvalMesh2(GLbyte * pc)
 {
-    glEvalMesh2((GLenum) bswap_ENUM(pc + 0),
-                (GLint) bswap_CARD32(pc + 4),
-                (GLint) bswap_CARD32(pc + 8),
-                (GLint) bswap_CARD32(pc + 12), (GLint) bswap_CARD32(pc + 16));
+    CALL_EvalMesh2( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_EvalPoint2(GLbyte * pc)
+void __glXDispSwap_EvalPoint2(GLbyte * pc)
 {
-    glEvalPoint2((GLint) bswap_CARD32(pc + 0), (GLint) bswap_CARD32(pc + 4));
+    CALL_EvalPoint2( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_AlphaFunc(GLbyte * pc)
+void __glXDispSwap_AlphaFunc(GLbyte * pc)
 {
-    glAlphaFunc((GLenum) bswap_ENUM(pc + 0), (GLclampf) bswap_FLOAT32(pc + 4));
+    CALL_AlphaFunc( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLclampf)bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_BlendFunc(GLbyte * pc)
+void __glXDispSwap_BlendFunc(GLbyte * pc)
 {
-    glBlendFunc((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    CALL_BlendFunc( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_LogicOp(GLbyte * pc)
+void __glXDispSwap_LogicOp(GLbyte * pc)
 {
-    glLogicOp((GLenum) bswap_ENUM(pc + 0));
+    CALL_LogicOp( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_StencilFunc(GLbyte * pc)
+void __glXDispSwap_StencilFunc(GLbyte * pc)
 {
-    glStencilFunc((GLenum) bswap_ENUM(pc + 0),
-                  (GLint) bswap_CARD32(pc + 4), (GLuint) bswap_CARD32(pc + 8));
+    CALL_StencilFunc( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLuint  )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_StencilOp(GLbyte * pc)
+void __glXDispSwap_StencilOp(GLbyte * pc)
 {
-    glStencilOp((GLenum) bswap_ENUM(pc + 0),
-                (GLenum) bswap_ENUM(pc + 4), (GLenum) bswap_ENUM(pc + 8));
+    CALL_StencilOp( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_DepthFunc(GLbyte * pc)
+void __glXDispSwap_DepthFunc(GLbyte * pc)
 {
-    glDepthFunc((GLenum) bswap_ENUM(pc + 0));
+    CALL_DepthFunc( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_PixelZoom(GLbyte * pc)
+void __glXDispSwap_PixelZoom(GLbyte * pc)
 {
-    glPixelZoom((GLfloat) bswap_FLOAT32(pc + 0),
-                (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_PixelZoom( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_PixelTransferf(GLbyte * pc)
+void __glXDispSwap_PixelTransferf(GLbyte * pc)
 {
-    glPixelTransferf((GLenum) bswap_ENUM(pc + 0),
-                     (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_PixelTransferf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_PixelTransferi(GLbyte * pc)
+void __glXDispSwap_PixelTransferi(GLbyte * pc)
 {
-    glPixelTransferi((GLenum) bswap_ENUM(pc + 0), (GLint) bswap_CARD32(pc + 4));
+    CALL_PixelTransferi( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-int
-__glXDispSwap_PixelStoref(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_PixelStoref(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glPixelStoref((GLenum) bswap_ENUM(pc + 0),
-                      (GLfloat) bswap_FLOAT32(pc + 4));
+    if ( cx != NULL ) {
+        CALL_PixelStoref( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLfloat )bswap_FLOAT32( pc +  4 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_PixelStorei(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_PixelStorei(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        glPixelStorei((GLenum) bswap_ENUM(pc + 0),
-                      (GLint) bswap_CARD32(pc + 4));
+    if ( cx != NULL ) {
+        CALL_PixelStorei( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLint   )bswap_CARD32 ( pc +  4 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDispSwap_PixelMapfv(GLbyte * pc)
+void __glXDispSwap_PixelMapfv(GLbyte * pc)
 {
-    const GLsizei mapsize = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei mapsize =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    glPixelMapfv((GLenum) bswap_ENUM(pc + 0),
-                 mapsize,
-                 (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8), 0));
+    CALL_PixelMapfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        mapsize,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_PixelMapuiv(GLbyte * pc)
+void __glXDispSwap_PixelMapuiv(GLbyte * pc)
 {
-    const GLsizei mapsize = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei mapsize =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    glPixelMapuiv((GLenum) bswap_ENUM(pc + 0),
-                  mapsize,
-                  (const GLuint *) bswap_32_array((uint32_t *) (pc + 8), 0));
+    CALL_PixelMapuiv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        mapsize,
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_PixelMapusv(GLbyte * pc)
+void __glXDispSwap_PixelMapusv(GLbyte * pc)
 {
-    const GLsizei mapsize = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei mapsize =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    glPixelMapusv((GLenum) bswap_ENUM(pc + 0),
-                  mapsize,
-                  (const GLushort *) bswap_16_array((uint16_t *) (pc + 8), 0));
+    CALL_PixelMapusv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        mapsize,
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_ReadBuffer(GLbyte * pc)
+void __glXDispSwap_ReadBuffer(GLbyte * pc)
 {
-    glReadBuffer((GLenum) bswap_ENUM(pc + 0));
+    CALL_ReadBuffer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_CopyPixels(GLbyte * pc)
+void __glXDispSwap_CopyPixels(GLbyte * pc)
 {
-    glCopyPixels((GLint) bswap_CARD32(pc + 0),
-                 (GLint) bswap_CARD32(pc + 4),
-                 (GLsizei) bswap_CARD32(pc + 8),
-                 (GLsizei) bswap_CARD32(pc + 12), (GLenum) bswap_ENUM(pc + 16));
+    CALL_CopyPixels( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLsizei )bswap_CARD32 ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLenum  )bswap_ENUM   ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_DrawPixels(GLbyte * pc)
+void __glXDispSwap_DrawPixels(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 36));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 36);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glDrawPixels((GLsizei) bswap_CARD32(pc + 20),
-                 (GLsizei) bswap_CARD32(pc + 24),
-                 (GLenum) bswap_ENUM(pc + 28),
-                 (GLenum) bswap_ENUM(pc + 32), pixels);
+    CALL_DrawPixels( GET_DISPATCH(), (
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLenum  )bswap_ENUM   ( pc + 28 ),
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+        pixels
+    ) );
 }
 
-int
-__glXDispSwap_GetBooleanv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetBooleanv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetBooleanv_size(pname);
         GLboolean answerBuffer[200];
-        GLboolean *params =
-            __glXGetAnswerBuffer(cl, compsize, answerBuffer,
-                                 sizeof(answerBuffer), 1);
+        GLboolean * params = __glXGetAnswerBuffer(cl, compsize, answerBuffer, sizeof(answerBuffer), 1);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetBooleanv(pname, params);
+        CALL_GetBooleanv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
         __glXSendReplySwap(cl->client, params, compsize, 1, GL_FALSE, 0);
         error = Success;
     }
@@ -1726,20 +1908,20 @@ __glXDispSwap_GetBooleanv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetClipPlane(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetClipPlane(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble equation[4];
-
-        glGetClipPlane((GLenum) bswap_ENUM(pc + 0), equation);
-        (void) bswap_64_array((uint64_t *) equation, 4);
+        CALL_GetClipPlane( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            equation
+        ) );
+        (void) bswap_64_array( (uint64_t *) equation, 4 );
         __glXSendReplySwap(cl->client, equation, 4, 8, GL_TRUE, 0);
         error = Success;
     }
@@ -1747,30 +1929,28 @@ __glXDispSwap_GetClipPlane(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetDoublev(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetDoublev(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetDoublev_size(pname);
         GLdouble answerBuffer[200];
-        GLdouble *params =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetDoublev(pname, params);
-        (void) bswap_64_array((uint64_t *) params, compsize);
+        CALL_GetDoublev( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -1778,19 +1958,16 @@ __glXDispSwap_GetDoublev(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetError(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetError(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLenum retval;
-
-        retval = glGetError();
+        retval = CALL_GetError( GET_DISPATCH(), () );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -1798,30 +1975,28 @@ __glXDispSwap_GetError(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetFloatv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetFloatv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetFloatv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetFloatv(pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetFloatv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1829,30 +2004,28 @@ __glXDispSwap_GetFloatv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetIntegerv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetIntegerv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetIntegerv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetIntegerv(pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetIntegerv( GET_DISPATCH(), (
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1860,30 +2033,29 @@ __glXDispSwap_GetIntegerv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetLightfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetLightfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetLightfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetLightfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetLightfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1891,30 +2063,29 @@ __glXDispSwap_GetLightfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetLightiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetLightiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetLightiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetLightiv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetLightiv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1922,31 +2093,30 @@ __glXDispSwap_GetLightiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMapdv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMapdv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = (GLenum) bswap_ENUM(pc + 0);
-        const GLenum query = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target =  (GLenum  )bswap_ENUM   ( pc +  0 );
+        const GLenum query =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
-        const GLuint compsize = __glGetMapdv_size(target, query);
+        const GLuint compsize = __glGetMapdv_size(target,query);
         GLdouble answerBuffer[200];
-        GLdouble *v =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * v = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapdv(target, query, v);
-        (void) bswap_64_array((uint64_t *) v, compsize);
+        CALL_GetMapdv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
+        (void) bswap_64_array( (uint64_t *) v, compsize );
         __glXSendReplySwap(cl->client, v, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -1954,31 +2124,30 @@ __glXDispSwap_GetMapdv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMapfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMapfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = (GLenum) bswap_ENUM(pc + 0);
-        const GLenum query = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target =  (GLenum  )bswap_ENUM   ( pc +  0 );
+        const GLenum query =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
-        const GLuint compsize = __glGetMapfv_size(target, query);
+        const GLuint compsize = __glGetMapfv_size(target,query);
         GLfloat answerBuffer[200];
-        GLfloat *v =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * v = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapfv(target, query, v);
-        (void) bswap_32_array((uint32_t *) v, compsize);
+        CALL_GetMapfv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
+        (void) bswap_32_array( (uint32_t *) v, compsize );
         __glXSendReplySwap(cl->client, v, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -1986,31 +2155,30 @@ __glXDispSwap_GetMapfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMapiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMapiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum target = (GLenum) bswap_ENUM(pc + 0);
-        const GLenum query = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum target =  (GLenum  )bswap_ENUM   ( pc +  0 );
+        const GLenum query =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
-        const GLuint compsize = __glGetMapiv_size(target, query);
+        const GLuint compsize = __glGetMapiv_size(target,query);
         GLint answerBuffer[200];
-        GLint *v =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * v = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (v == NULL)
-            return BadAlloc;
+        if (v == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMapiv(target, query, v);
-        (void) bswap_32_array((uint32_t *) v, compsize);
+        CALL_GetMapiv( GET_DISPATCH(), (
+            target,
+            query,
+            v
+        ) );
+        (void) bswap_32_array( (uint32_t *) v, compsize );
         __glXSendReplySwap(cl->client, v, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2018,30 +2186,29 @@ __glXDispSwap_GetMapiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMaterialfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMaterialfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetMaterialfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMaterialfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetMaterialfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2049,30 +2216,29 @@ __glXDispSwap_GetMaterialfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMaterialiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMaterialiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetMaterialiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMaterialiv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetMaterialiv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2080,30 +2246,28 @@ __glXDispSwap_GetMaterialiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetPixelMapfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetPixelMapfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetPixelMapfv_size(map);
         GLfloat answerBuffer[200];
-        GLfloat *values =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * values = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapfv(map, values);
-        (void) bswap_32_array((uint32_t *) values, compsize);
+        CALL_GetPixelMapfv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
+        (void) bswap_32_array( (uint32_t *) values, compsize );
         __glXSendReplySwap(cl->client, values, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2111,30 +2275,28 @@ __glXDispSwap_GetPixelMapfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetPixelMapuiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetPixelMapuiv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetPixelMapuiv_size(map);
         GLuint answerBuffer[200];
-        GLuint *values =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLuint * values = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapuiv(map, values);
-        (void) bswap_32_array((uint32_t *) values, compsize);
+        CALL_GetPixelMapuiv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
+        (void) bswap_32_array( (uint32_t *) values, compsize );
         __glXSendReplySwap(cl->client, values, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2142,30 +2304,28 @@ __glXDispSwap_GetPixelMapuiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetPixelMapusv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetPixelMapusv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum map = (GLenum) bswap_ENUM(pc + 0);
+    if ( cx != NULL ) {
+        const GLenum map =  (GLenum  )bswap_ENUM   ( pc +  0 );
 
         const GLuint compsize = __glGetPixelMapusv_size(map);
         GLushort answerBuffer[200];
-        GLushort *values =
-            __glXGetAnswerBuffer(cl, compsize * 2, answerBuffer,
-                                 sizeof(answerBuffer), 2);
+        GLushort * values = __glXGetAnswerBuffer(cl, compsize * 2, answerBuffer, sizeof(answerBuffer), 2);
 
-        if (values == NULL)
-            return BadAlloc;
+        if (values == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetPixelMapusv(map, values);
-        (void) bswap_16_array((uint16_t *) values, compsize);
+        CALL_GetPixelMapusv( GET_DISPATCH(), (
+            map,
+            values
+        ) );
+        (void) bswap_16_array( (uint16_t *) values, compsize );
         __glXSendReplySwap(cl->client, values, compsize, 2, GL_FALSE, 0);
         error = Success;
     }
@@ -2173,30 +2333,29 @@ __glXDispSwap_GetPixelMapusv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexEnvfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexEnvfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexEnvfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexEnvfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexEnvfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2204,30 +2363,29 @@ __glXDispSwap_GetTexEnvfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexEnviv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexEnviv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexEnviv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexEnviv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexEnviv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2235,30 +2393,29 @@ __glXDispSwap_GetTexEnviv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexGendv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexGendv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexGendv_size(pname);
         GLdouble answerBuffer[200];
-        GLdouble *params =
-            __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer,
-                                 sizeof(answerBuffer), 8);
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGendv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_64_array((uint64_t *) params, compsize);
+        CALL_GetTexGendv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -2266,30 +2423,29 @@ __glXDispSwap_GetTexGendv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexGenfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexGenfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexGenfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGenfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexGenfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2297,30 +2453,29 @@ __glXDispSwap_GetTexGenfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexGeniv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexGeniv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexGeniv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexGeniv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexGeniv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2328,30 +2483,29 @@ __glXDispSwap_GetTexGeniv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2359,30 +2513,29 @@ __glXDispSwap_GetTexParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetTexParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2390,31 +2543,30 @@ __glXDispSwap_GetTexParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexLevelParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexLevelParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 8);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  8 );
 
         const GLuint compsize = __glGetTexLevelParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexLevelParameterfv((GLenum) bswap_ENUM(pc + 0),
-                                 (GLint) bswap_CARD32(pc + 4), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexLevelParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLint   )bswap_CARD32 ( pc +  4 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2422,31 +2574,30 @@ __glXDispSwap_GetTexLevelParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetTexLevelParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetTexLevelParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 8);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  8 );
 
         const GLuint compsize = __glGetTexLevelParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetTexLevelParameteriv((GLenum) bswap_ENUM(pc + 0),
-                                 (GLint) bswap_CARD32(pc + 4), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetTexLevelParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLint   )bswap_CARD32 ( pc +  4 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -2454,19 +2605,18 @@ __glXDispSwap_GetTexLevelParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsEnabled(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsEnabled(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsEnabled((GLenum) bswap_ENUM(pc + 0));
+        retval = CALL_IsEnabled( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2474,19 +2624,18 @@ __glXDispSwap_IsEnabled(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsList(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsList(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsList((GLuint) bswap_CARD32(pc + 0));
+        retval = CALL_IsList( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2494,239 +2643,257 @@ __glXDispSwap_IsList(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_DepthRange(GLbyte * pc)
+void __glXDispSwap_DepthRange(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 16);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 16);
         pc -= 4;
     }
 #endif
 
-    glDepthRange((GLclampd) bswap_FLOAT64(pc + 0),
-                 (GLclampd) bswap_FLOAT64(pc + 8));
+    CALL_DepthRange( GET_DISPATCH(), (
+         (GLclampd)bswap_FLOAT64( pc +  0 ),
+         (GLclampd)bswap_FLOAT64( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Frustum(GLbyte * pc)
+void __glXDispSwap_Frustum(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 48);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 48);
         pc -= 4;
     }
 #endif
 
-    glFrustum((GLdouble) bswap_FLOAT64(pc + 0),
-              (GLdouble) bswap_FLOAT64(pc + 8),
-              (GLdouble) bswap_FLOAT64(pc + 16),
-              (GLdouble) bswap_FLOAT64(pc + 24),
-              (GLdouble) bswap_FLOAT64(pc + 32),
-              (GLdouble) bswap_FLOAT64(pc + 40));
+    CALL_Frustum( GET_DISPATCH(), (
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 ),
+         (GLdouble)bswap_FLOAT64( pc + 24 ),
+         (GLdouble)bswap_FLOAT64( pc + 32 ),
+         (GLdouble)bswap_FLOAT64( pc + 40 )
+    ) );
 }
 
-void
-__glXDispSwap_LoadIdentity(GLbyte * pc)
+void __glXDispSwap_LoadIdentity(GLbyte * pc)
 {
-    glLoadIdentity();
+    CALL_LoadIdentity( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_LoadMatrixf(GLbyte * pc)
+void __glXDispSwap_LoadMatrixf(GLbyte * pc)
 {
-    glLoadMatrixf((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 16));
+    CALL_LoadMatrixf( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 16 )
+    ) );
 }
 
-void
-__glXDispSwap_LoadMatrixd(GLbyte * pc)
+void __glXDispSwap_LoadMatrixd(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 128);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 128);
         pc -= 4;
     }
 #endif
 
-    glLoadMatrixd((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 16));
+    CALL_LoadMatrixd( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 16 )
+    ) );
 }
 
-void
-__glXDispSwap_MatrixMode(GLbyte * pc)
+void __glXDispSwap_MatrixMode(GLbyte * pc)
 {
-    glMatrixMode((GLenum) bswap_ENUM(pc + 0));
+    CALL_MatrixMode( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_MultMatrixf(GLbyte * pc)
+void __glXDispSwap_MultMatrixf(GLbyte * pc)
 {
-    glMultMatrixf((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 16));
+    CALL_MultMatrixf( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 16 )
+    ) );
 }
 
-void
-__glXDispSwap_MultMatrixd(GLbyte * pc)
+void __glXDispSwap_MultMatrixd(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 128);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 128);
         pc -= 4;
     }
 #endif
 
-    glMultMatrixd((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 16));
+    CALL_MultMatrixd( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 16 )
+    ) );
 }
 
-void
-__glXDispSwap_Ortho(GLbyte * pc)
+void __glXDispSwap_Ortho(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 48);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 48);
         pc -= 4;
     }
 #endif
 
-    glOrtho((GLdouble) bswap_FLOAT64(pc + 0),
-            (GLdouble) bswap_FLOAT64(pc + 8),
-            (GLdouble) bswap_FLOAT64(pc + 16),
-            (GLdouble) bswap_FLOAT64(pc + 24),
-            (GLdouble) bswap_FLOAT64(pc + 32),
-            (GLdouble) bswap_FLOAT64(pc + 40));
+    CALL_Ortho( GET_DISPATCH(), (
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 ),
+         (GLdouble)bswap_FLOAT64( pc + 24 ),
+         (GLdouble)bswap_FLOAT64( pc + 32 ),
+         (GLdouble)bswap_FLOAT64( pc + 40 )
+    ) );
 }
 
-void
-__glXDispSwap_PopMatrix(GLbyte * pc)
+void __glXDispSwap_PopMatrix(GLbyte * pc)
 {
-    glPopMatrix();
+    CALL_PopMatrix( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_PushMatrix(GLbyte * pc)
+void __glXDispSwap_PushMatrix(GLbyte * pc)
 {
-    glPushMatrix();
+    CALL_PushMatrix( GET_DISPATCH(), () );
 }
 
-void
-__glXDispSwap_Rotated(GLbyte * pc)
+void __glXDispSwap_Rotated(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 32);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 32);
         pc -= 4;
     }
 #endif
 
-    glRotated((GLdouble) bswap_FLOAT64(pc + 0),
-              (GLdouble) bswap_FLOAT64(pc + 8),
-              (GLdouble) bswap_FLOAT64(pc + 16),
-              (GLdouble) bswap_FLOAT64(pc + 24));
+    CALL_Rotated( GET_DISPATCH(), (
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 ),
+         (GLdouble)bswap_FLOAT64( pc + 24 )
+    ) );
 }
 
-void
-__glXDispSwap_Rotatef(GLbyte * pc)
+void __glXDispSwap_Rotatef(GLbyte * pc)
 {
-    glRotatef((GLfloat) bswap_FLOAT32(pc + 0),
-              (GLfloat) bswap_FLOAT32(pc + 4),
-              (GLfloat) bswap_FLOAT32(pc + 8),
-              (GLfloat) bswap_FLOAT32(pc + 12));
+    CALL_Rotatef( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 ),
+         (GLfloat )bswap_FLOAT32( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_Scaled(GLbyte * pc)
+void __glXDispSwap_Scaled(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glScaled((GLdouble) bswap_FLOAT64(pc + 0),
-             (GLdouble) bswap_FLOAT64(pc + 8),
-             (GLdouble) bswap_FLOAT64(pc + 16));
+    CALL_Scaled( GET_DISPATCH(), (
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_Scalef(GLbyte * pc)
+void __glXDispSwap_Scalef(GLbyte * pc)
 {
-    glScalef((GLfloat) bswap_FLOAT32(pc + 0),
-             (GLfloat) bswap_FLOAT32(pc + 4), (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_Scalef( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Translated(GLbyte * pc)
+void __glXDispSwap_Translated(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    glTranslated((GLdouble) bswap_FLOAT64(pc + 0),
-                 (GLdouble) bswap_FLOAT64(pc + 8),
-                 (GLdouble) bswap_FLOAT64(pc + 16));
+    CALL_Translated( GET_DISPATCH(), (
+         (GLdouble)bswap_FLOAT64( pc +  0 ),
+         (GLdouble)bswap_FLOAT64( pc +  8 ),
+         (GLdouble)bswap_FLOAT64( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_Translatef(GLbyte * pc)
+void __glXDispSwap_Translatef(GLbyte * pc)
 {
-    glTranslatef((GLfloat) bswap_FLOAT32(pc + 0),
-                 (GLfloat) bswap_FLOAT32(pc + 4),
-                 (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_Translatef( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_Viewport(GLbyte * pc)
+void __glXDispSwap_Viewport(GLbyte * pc)
 {
-    glViewport((GLint) bswap_CARD32(pc + 0),
-               (GLint) bswap_CARD32(pc + 4),
-               (GLsizei) bswap_CARD32(pc + 8), (GLsizei) bswap_CARD32(pc + 12));
+    CALL_Viewport( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLsizei )bswap_CARD32 ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_BindTexture(GLbyte * pc)
+void __glXDispSwap_BindTexture(GLbyte * pc)
 {
-    glBindTexture((GLenum) bswap_ENUM(pc + 0), (GLuint) bswap_CARD32(pc + 4));
+    CALL_BindTexture( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_Indexubv(GLbyte * pc)
+void __glXDispSwap_Indexubv(GLbyte * pc)
 {
-    glIndexubv((const GLubyte *) (pc + 0));
+    CALL_Indexubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_PolygonOffset(GLbyte * pc)
+void __glXDispSwap_PolygonOffset(GLbyte * pc)
 {
-    glPolygonOffset((GLfloat) bswap_FLOAT32(pc + 0),
-                    (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_PolygonOffset( GET_DISPATCH(), (
+         (GLfloat )bswap_FLOAT32( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-int
-__glXDispSwap_AreTexturesResident(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_AreTexturesResident(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLboolean retval;
         GLboolean answerBuffer[200];
-        GLboolean *residences =
-            __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
-
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
         if (residences == NULL)
             return BadAlloc;
-        retval =
-            glAreTexturesResident(n,
-                                  (const GLuint *)
-                                  bswap_32_array((uint32_t *) (pc + 4), 0),
-                                  residences);
+
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreTexturesResident( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 ),
+            residences
+        ) );
         __glXSendReplySwap(cl->client, residences, n, 1, GL_TRUE, retval);
         error = Success;
     }
@@ -2734,30 +2901,30 @@ __glXDispSwap_AreTexturesResident(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_AreTexturesResidentEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_AreTexturesResidentEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLboolean retval;
         GLboolean answerBuffer[200];
-        GLboolean *residences =
-            __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
-
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
         if (residences == NULL)
             return BadAlloc;
-        retval =
-            glAreTexturesResident(n,
-                                  (const GLuint *)
-                                  bswap_32_array((uint32_t *) (pc + 4), 0),
-                                  residences);
+
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreTexturesResident( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 ),
+            residences
+        ) );
         __glXSendReplySwap(cl->client, residences, n, 1, GL_TRUE, retval);
         error = Success;
     }
@@ -2765,118 +2932,122 @@ __glXDispSwap_AreTexturesResidentEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_CopyTexImage1D(GLbyte * pc)
+void __glXDispSwap_CopyTexImage1D(GLbyte * pc)
 {
-    glCopyTexImage1D((GLenum) bswap_ENUM(pc + 0),
-                     (GLint) bswap_CARD32(pc + 4),
-                     (GLenum) bswap_ENUM(pc + 8),
-                     (GLint) bswap_CARD32(pc + 12),
-                     (GLint) bswap_CARD32(pc + 16),
-                     (GLsizei) bswap_CARD32(pc + 20),
-                     (GLint) bswap_CARD32(pc + 24));
+    CALL_CopyTexImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 )
+    ) );
 }
 
-void
-__glXDispSwap_CopyTexImage2D(GLbyte * pc)
+void __glXDispSwap_CopyTexImage2D(GLbyte * pc)
 {
-    glCopyTexImage2D((GLenum) bswap_ENUM(pc + 0),
-                     (GLint) bswap_CARD32(pc + 4),
-                     (GLenum) bswap_ENUM(pc + 8),
-                     (GLint) bswap_CARD32(pc + 12),
-                     (GLint) bswap_CARD32(pc + 16),
-                     (GLsizei) bswap_CARD32(pc + 20),
-                     (GLsizei) bswap_CARD32(pc + 24),
-                     (GLint) bswap_CARD32(pc + 28));
+    CALL_CopyTexImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 )
+    ) );
 }
 
-void
-__glXDispSwap_CopyTexSubImage1D(GLbyte * pc)
+void __glXDispSwap_CopyTexSubImage1D(GLbyte * pc)
 {
-    glCopyTexSubImage1D((GLenum) bswap_ENUM(pc + 0),
-                        (GLint) bswap_CARD32(pc + 4),
-                        (GLint) bswap_CARD32(pc + 8),
-                        (GLint) bswap_CARD32(pc + 12),
-                        (GLint) bswap_CARD32(pc + 16),
-                        (GLsizei) bswap_CARD32(pc + 20));
+    CALL_CopyTexSubImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 )
+    ) );
 }
 
-void
-__glXDispSwap_CopyTexSubImage2D(GLbyte * pc)
+void __glXDispSwap_CopyTexSubImage2D(GLbyte * pc)
 {
-    glCopyTexSubImage2D((GLenum) bswap_ENUM(pc + 0),
-                        (GLint) bswap_CARD32(pc + 4),
-                        (GLint) bswap_CARD32(pc + 8),
-                        (GLint) bswap_CARD32(pc + 12),
-                        (GLint) bswap_CARD32(pc + 16),
-                        (GLint) bswap_CARD32(pc + 20),
-                        (GLsizei) bswap_CARD32(pc + 24),
-                        (GLsizei) bswap_CARD32(pc + 28));
+    CALL_CopyTexSubImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLint   )bswap_CARD32 ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 )
+    ) );
 }
 
-int
-__glXDispSwap_DeleteTextures(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_DeleteTextures(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-        glDeleteTextures(n,
-                         (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         0));
+        CALL_DeleteTextures( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_DeleteTexturesEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_DeleteTexturesEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-        glDeleteTextures(n,
-                         (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         0));
+        CALL_DeleteTextures( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_GenTextures(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenTextures(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *textures =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * textures = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (textures == NULL)
             return BadAlloc;
-        glGenTextures(n, textures);
-        (void) bswap_32_array((uint32_t *) textures, n);
+
+        if (textures == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenTextures( GET_DISPATCH(), (
+            n,
+            textures
+        ) );
+        (void) bswap_32_array( (uint32_t *) textures, n );
         __glXSendReplySwap(cl->client, textures, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -2884,27 +3055,29 @@ __glXDispSwap_GenTextures(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GenTexturesEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenTexturesEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *textures =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * textures = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (textures == NULL)
             return BadAlloc;
-        glGenTextures(n, textures);
-        (void) bswap_32_array((uint32_t *) textures, n);
+
+        if (textures == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenTextures( GET_DISPATCH(), (
+            n,
+            textures
+        ) );
+        (void) bswap_32_array( (uint32_t *) textures, n );
         __glXSendReplySwap(cl->client, textures, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -2912,19 +3085,18 @@ __glXDispSwap_GenTexturesEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsTexture(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsTexture(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsTexture((GLuint) bswap_CARD32(pc + 0));
+        retval = CALL_IsTexture( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2932,19 +3104,18 @@ __glXDispSwap_IsTexture(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsTextureEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsTextureEXT(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = glIsTexture((GLuint) bswap_CARD32(pc + 0));
+        retval = CALL_IsTexture( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -2952,160 +3123,166 @@ __glXDispSwap_IsTextureEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_PrioritizeTextures(GLbyte * pc)
+void __glXDispSwap_PrioritizeTextures(GLbyte * pc)
 {
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-    glPrioritizeTextures(n,
-                         (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         0),
-                         (const GLclampf *)
-                         bswap_32_array((uint32_t *) (pc + 4), 0));
+    CALL_PrioritizeTextures( GET_DISPATCH(), (
+        n,
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 ),
+         (const GLclampf *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_TexSubImage1D(GLbyte * pc)
+void __glXDispSwap_TexSubImage1D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 56));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 56);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexSubImage1D((GLenum) bswap_ENUM(pc + 20),
-                    (GLint) bswap_CARD32(pc + 24),
-                    (GLint) bswap_CARD32(pc + 28),
-                    (GLsizei) bswap_CARD32(pc + 36),
-                    (GLenum) bswap_ENUM(pc + 44),
-                    (GLenum) bswap_ENUM(pc + 48), pixels);
+    CALL_TexSubImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 ),
+         (GLsizei )bswap_CARD32 ( pc + 36 ),
+         (GLenum  )bswap_ENUM   ( pc + 44 ),
+         (GLenum  )bswap_ENUM   ( pc + 48 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_TexSubImage2D(GLbyte * pc)
+void __glXDispSwap_TexSubImage2D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 56));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 56);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexSubImage2D((GLenum) bswap_ENUM(pc + 20),
-                    (GLint) bswap_CARD32(pc + 24),
-                    (GLint) bswap_CARD32(pc + 28),
-                    (GLint) bswap_CARD32(pc + 32),
-                    (GLsizei) bswap_CARD32(pc + 36),
-                    (GLsizei) bswap_CARD32(pc + 40),
-                    (GLenum) bswap_ENUM(pc + 44),
-                    (GLenum) bswap_ENUM(pc + 48), pixels);
+    CALL_TexSubImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 ),
+         (GLint   )bswap_CARD32 ( pc + 32 ),
+         (GLsizei )bswap_CARD32 ( pc + 36 ),
+         (GLsizei )bswap_CARD32 ( pc + 40 ),
+         (GLenum  )bswap_ENUM   ( pc + 44 ),
+         (GLenum  )bswap_ENUM   ( pc + 48 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_BlendColor(GLbyte * pc)
+void __glXDispSwap_BlendColor(GLbyte * pc)
 {
-    glBlendColor((GLclampf) bswap_FLOAT32(pc + 0),
-                 (GLclampf) bswap_FLOAT32(pc + 4),
-                 (GLclampf) bswap_FLOAT32(pc + 8),
-                 (GLclampf) bswap_FLOAT32(pc + 12));
+    CALL_BlendColor( GET_DISPATCH(), (
+         (GLclampf)bswap_FLOAT32( pc +  0 ),
+         (GLclampf)bswap_FLOAT32( pc +  4 ),
+         (GLclampf)bswap_FLOAT32( pc +  8 ),
+         (GLclampf)bswap_FLOAT32( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_BlendEquation(GLbyte * pc)
+void __glXDispSwap_BlendEquation(GLbyte * pc)
 {
-    glBlendEquation((GLenum) bswap_ENUM(pc + 0));
+    CALL_BlendEquation( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ColorTable(GLbyte * pc)
+void __glXDispSwap_ColorTable(GLbyte * pc)
 {
-    const GLvoid *const table = (const GLvoid *) ((pc + 40));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const table = (const GLvoid *) (pc + 40);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glColorTable((GLenum) bswap_ENUM(pc + 20),
-                 (GLenum) bswap_ENUM(pc + 24),
-                 (GLsizei) bswap_CARD32(pc + 28),
-                 (GLenum) bswap_ENUM(pc + 32),
-                 (GLenum) bswap_ENUM(pc + 36), table);
+    CALL_ColorTable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLenum  )bswap_ENUM   ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+        table
+    ) );
 }
 
-void
-__glXDispSwap_ColorTableParameterfv(GLbyte * pc)
+void __glXDispSwap_ColorTableParameterfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glColorTableParameterfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glColorTableParameterfv_size(pname) );
 
-    glColorTableParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_ColorTableParameterfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_ColorTableParameteriv(GLbyte * pc)
+void __glXDispSwap_ColorTableParameteriv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glColorTableParameteriv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glColorTableParameteriv_size(pname) );
 
-    glColorTableParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_ColorTableParameteriv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_CopyColorTable(GLbyte * pc)
+void __glXDispSwap_CopyColorTable(GLbyte * pc)
 {
-    glCopyColorTable((GLenum) bswap_ENUM(pc + 0),
-                     (GLenum) bswap_ENUM(pc + 4),
-                     (GLint) bswap_CARD32(pc + 8),
-                     (GLint) bswap_CARD32(pc + 12),
-                     (GLsizei) bswap_CARD32(pc + 16));
+    CALL_CopyColorTable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-int
-__glXDispSwap_GetColorTableParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetColorTableParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetColorTableParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetColorTableParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetColorTableParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3113,92 +3290,29 @@ __glXDispSwap_GetColorTableParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetColorTableParameterfvSGI(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetColorTableParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetColorTableParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetColorTableParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetColorTableParameteriv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetColorTableParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetColorTableParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetColorTableParameterivSGI(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetColorTableParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetColorTableParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetColorTableParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3206,168 +3320,176 @@ __glXDispSwap_GetColorTableParameterivSGI(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_ColorSubTable(GLbyte * pc)
+void __glXDispSwap_ColorSubTable(GLbyte * pc)
 {
-    const GLvoid *const data = (const GLvoid *) ((pc + 40));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const data = (const GLvoid *) (pc + 40);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glColorSubTable((GLenum) bswap_ENUM(pc + 20),
-                    (GLsizei) bswap_CARD32(pc + 24),
-                    (GLsizei) bswap_CARD32(pc + 28),
-                    (GLenum) bswap_ENUM(pc + 32),
-                    (GLenum) bswap_ENUM(pc + 36), data);
+    CALL_ColorSubTable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+        data
+    ) );
 }
 
-void
-__glXDispSwap_CopyColorSubTable(GLbyte * pc)
+void __glXDispSwap_CopyColorSubTable(GLbyte * pc)
 {
-    glCopyColorSubTable((GLenum) bswap_ENUM(pc + 0),
-                        (GLsizei) bswap_CARD32(pc + 4),
-                        (GLint) bswap_CARD32(pc + 8),
-                        (GLint) bswap_CARD32(pc + 12),
-                        (GLsizei) bswap_CARD32(pc + 16));
+    CALL_CopyColorSubTable( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLsizei )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionFilter1D(GLbyte * pc)
+void __glXDispSwap_ConvolutionFilter1D(GLbyte * pc)
 {
-    const GLvoid *const image = (const GLvoid *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const image = (const GLvoid *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glConvolutionFilter1D((GLenum) bswap_ENUM(pc + 20),
-                          (GLenum) bswap_ENUM(pc + 24),
-                          (GLsizei) bswap_CARD32(pc + 28),
-                          (GLenum) bswap_ENUM(pc + 36),
-                          (GLenum) bswap_ENUM(pc + 40), image);
+    CALL_ConvolutionFilter1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLenum  )bswap_ENUM   ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+         (GLenum  )bswap_ENUM   ( pc + 40 ),
+        image
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionFilter2D(GLbyte * pc)
+void __glXDispSwap_ConvolutionFilter2D(GLbyte * pc)
 {
-    const GLvoid *const image = (const GLvoid *) ((pc + 44));
-    __GLXpixelHeader *const hdr = (__GLXpixelHeader *) (pc);
+    const GLvoid * const image = (const GLvoid *) (pc + 44);
+    __GLXpixelHeader * const hdr = (__GLXpixelHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glConvolutionFilter2D((GLenum) bswap_ENUM(pc + 20),
-                          (GLenum) bswap_ENUM(pc + 24),
-                          (GLsizei) bswap_CARD32(pc + 28),
-                          (GLsizei) bswap_CARD32(pc + 32),
-                          (GLenum) bswap_ENUM(pc + 36),
-                          (GLenum) bswap_ENUM(pc + 40), image);
+    CALL_ConvolutionFilter2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 20 ),
+         (GLenum  )bswap_ENUM   ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLsizei )bswap_CARD32 ( pc + 32 ),
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+         (GLenum  )bswap_ENUM   ( pc + 40 ),
+        image
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionParameterf(GLbyte * pc)
+void __glXDispSwap_ConvolutionParameterf(GLbyte * pc)
 {
-    glConvolutionParameterf((GLenum) bswap_ENUM(pc + 0),
-                            (GLenum) bswap_ENUM(pc + 4),
-                            (GLfloat) bswap_FLOAT32(pc + 8));
+    CALL_ConvolutionParameterf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLfloat )bswap_FLOAT32( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionParameterfv(GLbyte * pc)
+void __glXDispSwap_ConvolutionParameterfv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                         __glConvolutionParameterfv_size
-                                         (pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 8), __glConvolutionParameterfv_size(pname) );
 
-    glConvolutionParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_ConvolutionParameterfv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionParameteri(GLbyte * pc)
+void __glXDispSwap_ConvolutionParameteri(GLbyte * pc)
 {
-    glConvolutionParameteri((GLenum) bswap_ENUM(pc + 0),
-                            (GLenum) bswap_ENUM(pc + 4),
-                            (GLint) bswap_CARD32(pc + 8));
+    CALL_ConvolutionParameteri( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 )
+    ) );
 }
 
-void
-__glXDispSwap_ConvolutionParameteriv(GLbyte * pc)
+void __glXDispSwap_ConvolutionParameteriv(GLbyte * pc)
 {
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 8),
-                                       __glConvolutionParameteriv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 8), __glConvolutionParameteriv_size(pname) );
 
-    glConvolutionParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
+    CALL_ConvolutionParameteriv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc)
+void __glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc)
 {
-    glCopyConvolutionFilter1D((GLenum) bswap_ENUM(pc + 0),
-                              (GLenum) bswap_ENUM(pc + 4),
-                              (GLint) bswap_CARD32(pc + 8),
-                              (GLint) bswap_CARD32(pc + 12),
-                              (GLsizei) bswap_CARD32(pc + 16));
+    CALL_CopyConvolutionFilter1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc)
+void __glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc)
 {
-    glCopyConvolutionFilter2D((GLenum) bswap_ENUM(pc + 0),
-                              (GLenum) bswap_ENUM(pc + 4),
-                              (GLint) bswap_CARD32(pc + 8),
-                              (GLint) bswap_CARD32(pc + 12),
-                              (GLsizei) bswap_CARD32(pc + 16),
-                              (GLsizei) bswap_CARD32(pc + 20));
+    CALL_CopyConvolutionFilter2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 )
+    ) );
 }
 
-int
-__glXDispSwap_GetConvolutionParameterfv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetConvolutionParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetConvolutionParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetConvolutionParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetConvolutionParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3375,61 +3497,29 @@ __glXDispSwap_GetConvolutionParameterfv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetConvolutionParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetConvolutionParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetConvolutionParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetConvolutionParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetConvolutionParameteriv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetConvolutionParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetConvolutionParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetConvolutionParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3437,92 +3527,29 @@ __glXDispSwap_GetConvolutionParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetConvolutionParameterivEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetHistogramParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetConvolutionParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetConvolutionParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetHistogramParameterfv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetHistogramParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetHistogramParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetHistogramParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetHistogramParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetHistogramParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetHistogramParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3530,30 +3557,29 @@ __glXDispSwap_GetHistogramParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetHistogramParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetHistogramParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetHistogramParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetHistogramParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetHistogramParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3561,92 +3587,29 @@ __glXDispSwap_GetHistogramParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetHistogramParameterivEXT(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMinmaxParameterfv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetHistogramParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetHistogramParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetMinmaxParameterfv(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetMinmaxParameterfv_size(pname);
-        GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetMinmaxParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetMinmaxParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetMinmaxParameterfv_size(pname);
         GLfloat answerBuffer[200];
-        GLfloat *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMinmaxParameterfv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetMinmaxParameterfv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3654,61 +3617,29 @@ __glXDispSwap_GetMinmaxParameterfvEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetMinmaxParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetMinmaxParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
-
-        const GLuint compsize = __glGetMinmaxParameteriv_size(pname);
-        GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
-
-        if (params == NULL)
-            return BadAlloc;
-        __glXClearErrorOccured();
-
-        glGetMinmaxParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
-        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
-        error = Success;
-    }
-
-    return error;
-}
-
-int
-__glXDispSwap_GetMinmaxParameterivEXT(__GLXclientState * cl, GLbyte * pc)
-{
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
-    int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
-
-    pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetMinmaxParameteriv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        glGetMinmaxParameteriv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetMinmaxParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -3716,585 +3647,569 @@ __glXDispSwap_GetMinmaxParameterivEXT(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_Histogram(GLbyte * pc)
-{
-    glHistogram((GLenum) bswap_ENUM(pc + 0),
-                (GLsizei) bswap_CARD32(pc + 4),
-                (GLenum) bswap_ENUM(pc + 8), *(GLboolean *) (pc + 12));
+void __glXDispSwap_Histogram(GLbyte * pc)
+{
+    CALL_Histogram( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLsizei )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+        *(GLboolean *)(pc + 12)
+    ) );
 }
 
-void
-__glXDispSwap_Minmax(GLbyte * pc)
+void __glXDispSwap_Minmax(GLbyte * pc)
 {
-    glMinmax((GLenum) bswap_ENUM(pc + 0),
-             (GLenum) bswap_ENUM(pc + 4), *(GLboolean *) (pc + 8));
+    CALL_Minmax( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+        *(GLboolean *)(pc +  8)
+    ) );
 }
 
-void
-__glXDispSwap_ResetHistogram(GLbyte * pc)
+void __glXDispSwap_ResetHistogram(GLbyte * pc)
 {
-    glResetHistogram((GLenum) bswap_ENUM(pc + 0));
+    CALL_ResetHistogram( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_ResetMinmax(GLbyte * pc)
+void __glXDispSwap_ResetMinmax(GLbyte * pc)
 {
-    glResetMinmax((GLenum) bswap_ENUM(pc + 0));
+    CALL_ResetMinmax( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_TexImage3D(GLbyte * pc)
+void __glXDispSwap_TexImage3D(GLbyte * pc)
 {
-    const CARD32 ptr_is_null = *(CARD32 *) (pc + 76);
-    const GLvoid *const pixels =
-        (const GLvoid *) ((ptr_is_null != 0) ? NULL : (pc + 80));
-    __GLXpixel3DHeader *const hdr = (__GLXpixel3DHeader *) (pc);
+    const CARD32 ptr_is_null = *(CARD32 *)(pc + 76);
+    const GLvoid * const pixels = (const GLvoid *) ((ptr_is_null != 0) ? NULL : (pc + 80));
+    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_IMAGE_HEIGHT,
-                  (GLint) bswap_CARD32(&hdr->imageHeight));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_IMAGES,
-                  (GLint) bswap_CARD32(&hdr->skipImages));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) bswap_CARD32( & hdr->imageHeight )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) bswap_CARD32( & hdr->skipImages )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexImage3D((GLenum) bswap_ENUM(pc + 36),
-                 (GLint) bswap_CARD32(pc + 40),
-                 (GLint) bswap_CARD32(pc + 44),
-                 (GLsizei) bswap_CARD32(pc + 48),
-                 (GLsizei) bswap_CARD32(pc + 52),
-                 (GLsizei) bswap_CARD32(pc + 56),
-                 (GLint) bswap_CARD32(pc + 64),
-                 (GLenum) bswap_ENUM(pc + 68),
-                 (GLenum) bswap_ENUM(pc + 72), pixels);
+    CALL_TexImage3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+         (GLint   )bswap_CARD32 ( pc + 40 ),
+         (GLint   )bswap_CARD32 ( pc + 44 ),
+         (GLsizei )bswap_CARD32 ( pc + 48 ),
+         (GLsizei )bswap_CARD32 ( pc + 52 ),
+         (GLsizei )bswap_CARD32 ( pc + 56 ),
+         (GLint   )bswap_CARD32 ( pc + 64 ),
+         (GLenum  )bswap_ENUM   ( pc + 68 ),
+         (GLenum  )bswap_ENUM   ( pc + 72 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_TexSubImage3D(GLbyte * pc)
+void __glXDispSwap_TexSubImage3D(GLbyte * pc)
 {
-    const GLvoid *const pixels = (const GLvoid *) ((pc + 88));
-    __GLXpixel3DHeader *const hdr = (__GLXpixel3DHeader *) (pc);
+    const GLvoid * const pixels = (const GLvoid *) (pc + 88);
+    __GLXpixel3DHeader * const hdr = (__GLXpixel3DHeader *)(pc);
 
-    glPixelStorei(GL_UNPACK_SWAP_BYTES, hdr->swapBytes);
-    glPixelStorei(GL_UNPACK_LSB_FIRST, hdr->lsbFirst);
-    glPixelStorei(GL_UNPACK_ROW_LENGTH, (GLint) bswap_CARD32(&hdr->rowLength));
-    glPixelStorei(GL_UNPACK_IMAGE_HEIGHT,
-                  (GLint) bswap_CARD32(&hdr->imageHeight));
-    glPixelStorei(GL_UNPACK_SKIP_ROWS, (GLint) bswap_CARD32(&hdr->skipRows));
-    glPixelStorei(GL_UNPACK_SKIP_IMAGES,
-                  (GLint) bswap_CARD32(&hdr->skipImages));
-    glPixelStorei(GL_UNPACK_SKIP_PIXELS,
-                  (GLint) bswap_CARD32(&hdr->skipPixels));
-    glPixelStorei(GL_UNPACK_ALIGNMENT, (GLint) bswap_CARD32(&hdr->alignment));
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SWAP_BYTES,   hdr->swapBytes) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_LSB_FIRST,    hdr->lsbFirst) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,   (GLint) bswap_CARD32( & hdr->rowLength )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_IMAGE_HEIGHT, (GLint) bswap_CARD32( & hdr->imageHeight )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_ROWS,    (GLint) bswap_CARD32( & hdr->skipRows )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_IMAGES,  (GLint) bswap_CARD32( & hdr->skipImages )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_SKIP_PIXELS,  (GLint) bswap_CARD32( & hdr->skipPixels )) );
+    CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ALIGNMENT,    (GLint) bswap_CARD32( & hdr->alignment )) );
 
-    glTexSubImage3D((GLenum) bswap_ENUM(pc + 36),
-                    (GLint) bswap_CARD32(pc + 40),
-                    (GLint) bswap_CARD32(pc + 44),
-                    (GLint) bswap_CARD32(pc + 48),
-                    (GLint) bswap_CARD32(pc + 52),
-                    (GLsizei) bswap_CARD32(pc + 60),
-                    (GLsizei) bswap_CARD32(pc + 64),
-                    (GLsizei) bswap_CARD32(pc + 68),
-                    (GLenum) bswap_ENUM(pc + 76),
-                    (GLenum) bswap_ENUM(pc + 80), pixels);
+    CALL_TexSubImage3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 36 ),
+         (GLint   )bswap_CARD32 ( pc + 40 ),
+         (GLint   )bswap_CARD32 ( pc + 44 ),
+         (GLint   )bswap_CARD32 ( pc + 48 ),
+         (GLint   )bswap_CARD32 ( pc + 52 ),
+         (GLsizei )bswap_CARD32 ( pc + 60 ),
+         (GLsizei )bswap_CARD32 ( pc + 64 ),
+         (GLsizei )bswap_CARD32 ( pc + 68 ),
+         (GLenum  )bswap_ENUM   ( pc + 76 ),
+         (GLenum  )bswap_ENUM   ( pc + 80 ),
+        pixels
+    ) );
 }
 
-void
-__glXDispSwap_CopyTexSubImage3D(GLbyte * pc)
+void __glXDispSwap_CopyTexSubImage3D(GLbyte * pc)
 {
-    glCopyTexSubImage3D((GLenum) bswap_ENUM(pc + 0),
-                        (GLint) bswap_CARD32(pc + 4),
-                        (GLint) bswap_CARD32(pc + 8),
-                        (GLint) bswap_CARD32(pc + 12),
-                        (GLint) bswap_CARD32(pc + 16),
-                        (GLint) bswap_CARD32(pc + 20),
-                        (GLint) bswap_CARD32(pc + 24),
-                        (GLsizei) bswap_CARD32(pc + 28),
-                        (GLsizei) bswap_CARD32(pc + 32));
+    CALL_CopyTexSubImage3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLint   )bswap_CARD32 ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLsizei )bswap_CARD32 ( pc + 32 )
+    ) );
 }
 
-void
-__glXDispSwap_ActiveTexture(GLbyte * pc)
+void __glXDispSwap_ActiveTexture(GLbyte * pc)
 {
-    glActiveTextureARB((GLenum) bswap_ENUM(pc + 0));
+    CALL_ActiveTexture( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord1dv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord1dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord1dvARB((GLenum) bswap_ENUM(pc + 8),
-                          (const GLdouble *) bswap_64_array((uint64_t *) (pc + 0),
-                                                         1));
+    CALL_MultiTexCoord1dv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc)
 {
-    glMultiTexCoord1fvARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLfloat *)
-                          bswap_32_array((uint32_t *) (pc + 4), 1));
+    CALL_MultiTexCoord1fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord1iv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord1iv(GLbyte * pc)
 {
-    glMultiTexCoord1ivARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         1));
+    CALL_MultiTexCoord1iv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord1sv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord1sv(GLbyte * pc)
 {
-    glMultiTexCoord1svARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                           1));
+    CALL_MultiTexCoord1sv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord2dv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord2dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord2dvARB((GLenum) bswap_ENUM(pc + 16),
-                          (const GLdouble *) bswap_64_array((uint64_t *) (pc + 0),
-                                                            2));
+    CALL_MultiTexCoord2dv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 16 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc)
 {
-    glMultiTexCoord2fvARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLfloat *)
-                          bswap_32_array((uint32_t *) (pc + 4), 2));
+    CALL_MultiTexCoord2fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord2iv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord2iv(GLbyte * pc)
 {
-    glMultiTexCoord2ivARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         2));
+    CALL_MultiTexCoord2iv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord2sv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord2sv(GLbyte * pc)
 {
-    glMultiTexCoord2svARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                           2));
+    CALL_MultiTexCoord2sv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord3dv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord3dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord3dvARB((GLenum) bswap_ENUM(pc + 24),
-                          (const GLdouble *) bswap_64_array((uint64_t *) (pc + 0),
-                                                            3));
+    CALL_MultiTexCoord3dv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 24 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc)
 {
-    glMultiTexCoord3fvARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLfloat *)
-                          bswap_32_array((uint32_t *) (pc + 4), 3));
+    CALL_MultiTexCoord3fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord3iv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord3iv(GLbyte * pc)
 {
-    glMultiTexCoord3ivARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         3));
+    CALL_MultiTexCoord3iv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord3sv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord3sv(GLbyte * pc)
 {
-    glMultiTexCoord3svARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                           3));
+    CALL_MultiTexCoord3sv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord4dv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord4dv(GLbyte * pc)
 {
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    glMultiTexCoord4dvARB((GLenum) bswap_ENUM(pc + 32),
-                          (const GLdouble *) bswap_64_array((uint64_t *) (pc + 0),
-                                                            4));
+    CALL_MultiTexCoord4dv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc)
 {
-    glMultiTexCoord4fvARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLfloat *)
-                          bswap_32_array((uint32_t *) (pc + 4), 4));
+    CALL_MultiTexCoord4fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord4iv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord4iv(GLbyte * pc)
 {
-    glMultiTexCoord4ivARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                         4));
+    CALL_MultiTexCoord4iv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_MultiTexCoord4sv(GLbyte * pc)
+void __glXDispSwap_MultiTexCoord4sv(GLbyte * pc)
 {
-    glMultiTexCoord4svARB((GLenum) bswap_ENUM(pc + 0),
-                          (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                           4));
+    CALL_MultiTexCoord4sv( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexImage1D(GLbyte * pc)
+void __glXDispSwap_CompressedTexImage1D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE1DPROC CompressedTexImage1D =
-        __glGetProcAddress("glCompressedTexImage1D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 20);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 20 );
 
-    CompressedTexImage1D((GLenum) bswap_ENUM(pc + 0),
-                         (GLint) bswap_CARD32(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLsizei) bswap_CARD32(pc + 12),
-                         (GLint) bswap_CARD32(pc + 16),
-                         imageSize, (const GLvoid *) (pc + 24));
+    CALL_CompressedTexImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+        imageSize,
+         (const GLvoid *)(pc + 24)
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexImage2D(GLbyte * pc)
+void __glXDispSwap_CompressedTexImage2D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE2DPROC CompressedTexImage2D =
-        __glGetProcAddress("glCompressedTexImage2D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 24);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 24 );
 
-    CompressedTexImage2D((GLenum) bswap_ENUM(pc + 0),
-                         (GLint) bswap_CARD32(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLsizei) bswap_CARD32(pc + 12),
-                         (GLsizei) bswap_CARD32(pc + 16),
-                         (GLint) bswap_CARD32(pc + 20),
-                         imageSize, (const GLvoid *) (pc + 28));
+    CALL_CompressedTexImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 ),
+         (GLint   )bswap_CARD32 ( pc + 20 ),
+        imageSize,
+         (const GLvoid *)(pc + 28)
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexImage3D(GLbyte * pc)
+void __glXDispSwap_CompressedTexImage3D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXIMAGE3DPROC CompressedTexImage3D =
-        __glGetProcAddress("glCompressedTexImage3D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 28);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 28 );
 
-    CompressedTexImage3D((GLenum) bswap_ENUM(pc + 0),
-                         (GLint) bswap_CARD32(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLsizei) bswap_CARD32(pc + 12),
-                         (GLsizei) bswap_CARD32(pc + 16),
-                         (GLsizei) bswap_CARD32(pc + 20),
-                         (GLint) bswap_CARD32(pc + 24),
-                         imageSize, (const GLvoid *) (pc + 32));
+    CALL_CompressedTexImage3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+        imageSize,
+         (const GLvoid *)(pc + 32)
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexSubImage1D(GLbyte * pc)
+void __glXDispSwap_CompressedTexSubImage1D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC CompressedTexSubImage1D =
-        __glGetProcAddress("glCompressedTexSubImage1D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 20);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 20 );
 
-    CompressedTexSubImage1D((GLenum) bswap_ENUM(pc + 0),
-                            (GLint) bswap_CARD32(pc + 4),
-                            (GLint) bswap_CARD32(pc + 8),
-                            (GLsizei) bswap_CARD32(pc + 12),
-                            (GLenum) bswap_ENUM(pc + 16),
-                            imageSize, (const GLvoid *) (pc + 24));
+    CALL_CompressedTexSubImage1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLenum  )bswap_ENUM   ( pc + 16 ),
+        imageSize,
+         (const GLvoid *)(pc + 24)
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexSubImage2D(GLbyte * pc)
+void __glXDispSwap_CompressedTexSubImage2D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC CompressedTexSubImage2D =
-        __glGetProcAddress("glCompressedTexSubImage2D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 28);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 28 );
 
-    CompressedTexSubImage2D((GLenum) bswap_ENUM(pc + 0),
-                            (GLint) bswap_CARD32(pc + 4),
-                            (GLint) bswap_CARD32(pc + 8),
-                            (GLint) bswap_CARD32(pc + 12),
-                            (GLsizei) bswap_CARD32(pc + 16),
-                            (GLsizei) bswap_CARD32(pc + 20),
-                            (GLenum) bswap_ENUM(pc + 24),
-                            imageSize, (const GLvoid *) (pc + 32));
+    CALL_CompressedTexSubImage2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLenum  )bswap_ENUM   ( pc + 24 ),
+        imageSize,
+         (const GLvoid *)(pc + 32)
+    ) );
 }
 
-void
-__glXDispSwap_CompressedTexSubImage3D(GLbyte * pc)
+void __glXDispSwap_CompressedTexSubImage3D(GLbyte * pc)
 {
-    PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC CompressedTexSubImage3D =
-        __glGetProcAddress("glCompressedTexSubImage3D");
-    const GLsizei imageSize = (GLsizei) bswap_CARD32(pc + 36);
+    const GLsizei imageSize =  (GLsizei )bswap_CARD32 ( pc + 36 );
 
-    CompressedTexSubImage3D((GLenum) bswap_ENUM(pc + 0),
-                            (GLint) bswap_CARD32(pc + 4),
-                            (GLint) bswap_CARD32(pc + 8),
-                            (GLint) bswap_CARD32(pc + 12),
-                            (GLint) bswap_CARD32(pc + 16),
-                            (GLsizei) bswap_CARD32(pc + 20),
-                            (GLsizei) bswap_CARD32(pc + 24),
-                            (GLsizei) bswap_CARD32(pc + 28),
-                            (GLenum) bswap_ENUM(pc + 32),
-                            imageSize, (const GLvoid *) (pc + 40));
+    CALL_CompressedTexSubImage3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLsizei )bswap_CARD32 ( pc + 20 ),
+         (GLsizei )bswap_CARD32 ( pc + 24 ),
+         (GLsizei )bswap_CARD32 ( pc + 28 ),
+         (GLenum  )bswap_ENUM   ( pc + 32 ),
+        imageSize,
+         (const GLvoid *)(pc + 40)
+    ) );
 }
 
-void
-__glXDispSwap_SampleCoverage(GLbyte * pc)
+void __glXDispSwap_SampleCoverage(GLbyte * pc)
 {
-    PFNGLSAMPLECOVERAGEPROC SampleCoverage =
-        __glGetProcAddress("glSampleCoverage");
-    SampleCoverage((GLclampf) bswap_FLOAT32(pc + 0), *(GLboolean *) (pc + 4));
+    CALL_SampleCoverage( GET_DISPATCH(), (
+         (GLclampf)bswap_FLOAT32( pc +  0 ),
+        *(GLboolean *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_BlendFuncSeparate(GLbyte * pc)
+void __glXDispSwap_BlendFuncSeparate(GLbyte * pc)
 {
-    PFNGLBLENDFUNCSEPARATEPROC BlendFuncSeparate =
-        __glGetProcAddress("glBlendFuncSeparate");
-    BlendFuncSeparate((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4),
-                      (GLenum) bswap_ENUM(pc + 8),
-                      (GLenum) bswap_ENUM(pc + 12));
+    CALL_BlendFuncSeparate( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLenum  )bswap_ENUM   ( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_FogCoorddv(GLbyte * pc)
+void __glXDispSwap_FogCoorddv(GLbyte * pc)
 {
-    PFNGLFOGCOORDDVPROC FogCoorddv = __glGetProcAddress("glFogCoorddv");
-
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 8);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 8);
         pc -= 4;
     }
 #endif
 
-    FogCoorddv((const GLdouble *) bswap_64_array((uint64_t *) (pc + 0), 1));
+    CALL_FogCoorddv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_PointParameterf(GLbyte * pc)
+void __glXDispSwap_PointParameterf(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERFPROC PointParameterf =
-        __glGetProcAddress("glPointParameterf");
-    PointParameterf((GLenum) bswap_ENUM(pc + 0),
-                    (GLfloat) bswap_FLOAT32(pc + 4));
+    CALL_PointParameterf( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLfloat )bswap_FLOAT32( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_PointParameterfv(GLbyte * pc)
+void __glXDispSwap_PointParameterfv(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERFVPROC PointParameterfv =
-        __glGetProcAddress("glPointParameterfv");
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLfloat *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLfloat * params;
 
-    params =
-        (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                         __glPointParameterfv_size(pname));
+    params = (const GLfloat *) bswap_32_array( (uint32_t *) (pc + 4), __glPointParameterfv_size(pname) );
 
-    PointParameterfv(pname, params);
+    CALL_PointParameterfv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_PointParameteri(GLbyte * pc)
+void __glXDispSwap_PointParameteri(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERIPROC PointParameteri =
-        __glGetProcAddress("glPointParameteri");
-    PointParameteri((GLenum) bswap_ENUM(pc + 0), (GLint) bswap_CARD32(pc + 4));
+    CALL_PointParameteri( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_PointParameteriv(GLbyte * pc)
+void __glXDispSwap_PointParameteriv(GLbyte * pc)
 {
-    PFNGLPOINTPARAMETERIVPROC PointParameteriv =
-        __glGetProcAddress("glPointParameteriv");
-    const GLenum pname = (GLenum) bswap_ENUM(pc + 0);
-    const GLint *params;
+    const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  0 );
+    const GLint * params;
 
-    params =
-        (const GLint *) bswap_32_array((uint32_t *) (pc + 4),
-                                       __glPointParameteriv_size(pname));
+    params = (const GLint *) bswap_32_array( (uint32_t *) (pc + 4), __glPointParameteriv_size(pname) );
 
-    PointParameteriv(pname, params);
+    CALL_PointParameteriv( GET_DISPATCH(), (
+        pname,
+        params
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3bv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3bv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3BVPROC SecondaryColor3bv =
-        __glGetProcAddress("glSecondaryColor3bv");
-    SecondaryColor3bv((const GLbyte *) (pc + 0));
+    CALL_SecondaryColor3bv( GET_DISPATCH(), (
+         (const GLbyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3dv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3dv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3DVPROC SecondaryColor3dv =
-        __glGetProcAddress("glSecondaryColor3dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 24);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 24);
         pc -= 4;
     }
 #endif
 
-    SecondaryColor3dv((const GLdouble *)
-                      bswap_64_array((uint64_t *) (pc + 0), 3));
+    CALL_SecondaryColor3dv( GET_DISPATCH(), (
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3iv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3iv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3IVPROC SecondaryColor3iv =
-        __glGetProcAddress("glSecondaryColor3iv");
-    SecondaryColor3iv((const GLint *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_SecondaryColor3iv( GET_DISPATCH(), (
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3sv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3sv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3SVPROC SecondaryColor3sv =
-        __glGetProcAddress("glSecondaryColor3sv");
-    SecondaryColor3sv((const GLshort *)
-                      bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_SecondaryColor3sv( GET_DISPATCH(), (
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3ubv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3ubv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3UBVPROC SecondaryColor3ubv =
-        __glGetProcAddress("glSecondaryColor3ubv");
-    SecondaryColor3ubv((const GLubyte *) (pc + 0));
+    CALL_SecondaryColor3ubv( GET_DISPATCH(), (
+         (const GLubyte *)(pc +  0)
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3uiv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3uiv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3UIVPROC SecondaryColor3uiv =
-        __glGetProcAddress("glSecondaryColor3uiv");
-    SecondaryColor3uiv((const GLuint *)
-                       bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_SecondaryColor3uiv( GET_DISPATCH(), (
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3usv(GLbyte * pc)
+void __glXDispSwap_SecondaryColor3usv(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3USVPROC SecondaryColor3usv =
-        __glGetProcAddress("glSecondaryColor3usv");
-    SecondaryColor3usv((const GLushort *)
-                       bswap_16_array((uint16_t *) (pc + 0), 3));
+    CALL_SecondaryColor3usv( GET_DISPATCH(), (
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_WindowPos3fv(GLbyte * pc)
+void __glXDispSwap_WindowPos3fv(GLbyte * pc)
 {
-    PFNGLWINDOWPOS3FVPROC WindowPos3fv = __glGetProcAddress("glWindowPos3fv");
-
-    WindowPos3fv((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 3));
+    CALL_WindowPos3fv( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_BeginQuery(GLbyte * pc)
+void __glXDispSwap_BeginQuery(GLbyte * pc)
 {
-    PFNGLBEGINQUERYPROC BeginQuery = __glGetProcAddress("glBeginQuery");
-
-    BeginQuery((GLenum) bswap_ENUM(pc + 0), (GLuint) bswap_CARD32(pc + 4));
+    CALL_BeginQuery( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-int
-__glXDispSwap_DeleteQueries(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_DeleteQueries(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLDELETEQUERIESPROC DeleteQueries =
-        __glGetProcAddress("glDeleteQueries");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-        DeleteQueries(n,
-                      (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                      0));
+        CALL_DeleteQueries( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDispSwap_EndQuery(GLbyte * pc)
+void __glXDispSwap_EndQuery(GLbyte * pc)
 {
-    PFNGLENDQUERYPROC EndQuery = __glGetProcAddress("glEndQuery");
-
-    EndQuery((GLenum) bswap_ENUM(pc + 0));
+    CALL_EndQuery( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-int
-__glXDispSwap_GenQueries(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenQueries(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENQUERIESPROC GenQueries = __glGetProcAddress("glGenQueries");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *ids =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
+        GLuint * ids = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (ids == NULL)
             return BadAlloc;
 
-        GenQueries(n, ids);
-        (void) bswap_32_array((uint32_t *) ids, n);
+        if (ids == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenQueries( GET_DISPATCH(), (
+            n,
+            ids
+        ) );
+        (void) bswap_32_array( (uint32_t *) ids, n );
         __glXSendReplySwap(cl->client, ids, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -4302,32 +4217,29 @@ __glXDispSwap_GenQueries(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetQueryObjectiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetQueryObjectiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYOBJECTIVPROC GetQueryObjectiv =
-        __glGetProcAddress("glGetQueryObjectiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetQueryObjectiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryObjectiv((GLuint) bswap_CARD32(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetQueryObjectiv( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4335,32 +4247,29 @@ __glXDispSwap_GetQueryObjectiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetQueryObjectuiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetQueryObjectuiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYOBJECTUIVPROC GetQueryObjectuiv =
-        __glGetProcAddress("glGetQueryObjectuiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetQueryObjectuiv_size(pname);
         GLuint answerBuffer[200];
-        GLuint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLuint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryObjectuiv((GLuint) bswap_CARD32(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetQueryObjectuiv( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4368,31 +4277,29 @@ __glXDispSwap_GetQueryObjectuiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetQueryiv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetQueryiv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETQUERYIVPROC GetQueryiv = __glGetProcAddress("glGetQueryiv");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetQueryiv_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetQueryiv((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetQueryiv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4400,20 +4307,18 @@ __glXDispSwap_GetQueryiv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsQuery(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsQuery(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISQUERYPROC IsQuery = __glGetProcAddress("glIsQuery");
-    xGLXSingleReq *const req = (xGLXSingleReq *) pc;
+    xGLXSingleReq * const req = (xGLXSingleReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_SINGLE_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = IsQuery((GLuint) bswap_CARD32(pc + 0));
+        retval = CALL_IsQuery( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4421,290 +4326,353 @@ __glXDispSwap_IsQuery(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_BlendEquationSeparate(GLbyte * pc)
+void __glXDispSwap_BlendEquationSeparate(GLbyte * pc)
 {
-    PFNGLBLENDEQUATIONSEPARATEPROC BlendEquationSeparate =
-        __glGetProcAddress("glBlendEquationSeparate");
-    BlendEquationSeparate((GLenum) bswap_ENUM(pc + 0),
-                          (GLenum) bswap_ENUM(pc + 4));
+    CALL_BlendEquationSeparate( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_DrawBuffers(GLbyte * pc)
+void __glXDispSwap_DrawBuffers(GLbyte * pc)
 {
-    PFNGLDRAWBUFFERSPROC DrawBuffers = __glGetProcAddress("glDrawBuffers");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-    DrawBuffers(n, (const GLenum *) bswap_32_array((uint32_t *) (pc + 4), 0));
+    CALL_DrawBuffers( GET_DISPATCH(), (
+        n,
+         (const GLenum *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1dv(GLbyte * pc)
+int __glXDispSwap_GetVertexAttribdv(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribdv_size(pname);
+        GLdouble answerBuffer[200];
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribdv( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 8, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetVertexAttribfv(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribfv_size(pname);
+        GLfloat answerBuffer[200];
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribfv( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetVertexAttribiv(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribiv_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribiv( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+void __glXDispSwap_VertexAttrib1dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1DVPROC VertexAttrib1dv =
-        __glGetProcAddress("glVertexAttrib1dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib1dv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                      1));
+    CALL_VertexAttrib1dv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1sv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib1sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1SVPROC VertexAttrib1sv =
-        __glGetProcAddress("glVertexAttrib1sv");
-    VertexAttrib1sv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLshort *) bswap_16_array((uint16_t *) (pc + 4), 1));
+    CALL_VertexAttrib1sv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2dv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2DVPROC VertexAttrib2dv =
-        __glGetProcAddress("glVertexAttrib2dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib2dv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                      2));
+    CALL_VertexAttrib2dv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2sv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2SVPROC VertexAttrib2sv =
-        __glGetProcAddress("glVertexAttrib2sv");
-    VertexAttrib2sv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLshort *) bswap_16_array((uint16_t *) (pc + 4), 2));
+    CALL_VertexAttrib2sv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3dv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3DVPROC VertexAttrib3dv =
-        __glGetProcAddress("glVertexAttrib3dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib3dv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                      3));
+    CALL_VertexAttrib3dv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3sv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3SVPROC VertexAttrib3sv =
-        __glGetProcAddress("glVertexAttrib3sv");
-    VertexAttrib3sv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLshort *) bswap_16_array((uint16_t *) (pc + 4), 3));
+    CALL_VertexAttrib3sv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Nbv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Nbv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NBVPROC VertexAttrib4Nbv =
-        __glGetProcAddress("glVertexAttrib4Nbv");
-    VertexAttrib4Nbv((GLuint) bswap_CARD32(pc + 0), (const GLbyte *) (pc + 4));
+    CALL_VertexAttrib4Nbv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLbyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Niv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Niv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NIVPROC VertexAttrib4Niv =
-        __glGetProcAddress("glVertexAttrib4Niv");
-    VertexAttrib4Niv((GLuint) bswap_CARD32(pc + 0),
-                     (const GLint *) bswap_32_array((uint32_t *) (pc + 4), 4));
+    CALL_VertexAttrib4Niv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Nsv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Nsv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NSVPROC VertexAttrib4Nsv =
-        __glGetProcAddress("glVertexAttrib4Nsv");
-    VertexAttrib4Nsv((GLuint) bswap_CARD32(pc + 0),
-                     (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                      4));
+    CALL_VertexAttrib4Nsv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Nubv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Nubv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUBVPROC VertexAttrib4Nubv =
-        __glGetProcAddress("glVertexAttrib4Nubv");
-    VertexAttrib4Nubv((GLuint) bswap_CARD32(pc + 0),
-                      (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4Nubv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Nuiv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Nuiv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUIVPROC VertexAttrib4Nuiv =
-        __glGetProcAddress("glVertexAttrib4Nuiv");
-    VertexAttrib4Nuiv((GLuint) bswap_CARD32(pc + 0),
-                      (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                      4));
+    CALL_VertexAttrib4Nuiv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4Nusv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4Nusv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4NUSVPROC VertexAttrib4Nusv =
-        __glGetProcAddress("glVertexAttrib4Nusv");
-    VertexAttrib4Nusv((GLuint) bswap_CARD32(pc + 0),
-                      (const GLushort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                        4));
+    CALL_VertexAttrib4Nusv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4bv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4bv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4BVPROC VertexAttrib4bv =
-        __glGetProcAddress("glVertexAttrib4bv");
-    VertexAttrib4bv((GLuint) bswap_CARD32(pc + 0), (const GLbyte *) (pc + 4));
+    CALL_VertexAttrib4bv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLbyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4dv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4dv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4DVPROC VertexAttrib4dv =
-        __glGetProcAddress("glVertexAttrib4dv");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib4dv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                      4));
+    CALL_VertexAttrib4dv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4iv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4iv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4IVPROC VertexAttrib4iv =
-        __glGetProcAddress("glVertexAttrib4iv");
-    VertexAttrib4iv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLint *) bswap_32_array((uint32_t *) (pc + 4), 4));
+    CALL_VertexAttrib4iv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLint *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4sv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4sv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4SVPROC VertexAttrib4sv =
-        __glGetProcAddress("glVertexAttrib4sv");
-    VertexAttrib4sv((GLuint) bswap_CARD32(pc + 0),
-                    (const GLshort *) bswap_16_array((uint16_t *) (pc + 4), 4));
+    CALL_VertexAttrib4sv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4ubv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4ubv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UBVPROC VertexAttrib4ubv =
-        __glGetProcAddress("glVertexAttrib4ubv");
-    VertexAttrib4ubv((GLuint) bswap_CARD32(pc + 0), (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4ubv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4uiv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4uiv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UIVPROC VertexAttrib4uiv =
-        __glGetProcAddress("glVertexAttrib4uiv");
-    VertexAttrib4uiv((GLuint) bswap_CARD32(pc + 0),
-                     (const GLuint *) bswap_32_array((uint32_t *) (pc + 4), 4));
+    CALL_VertexAttrib4uiv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4usv(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4usv(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4USVPROC VertexAttrib4usv =
-        __glGetProcAddress("glVertexAttrib4usv");
-    VertexAttrib4usv((GLuint) bswap_CARD32(pc + 0),
-                     (const GLushort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                       4));
+    CALL_VertexAttrib4usv( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLushort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ClampColor(GLbyte * pc)
+void __glXDispSwap_ClampColor(GLbyte * pc)
 {
-    PFNGLCLAMPCOLORPROC ClampColor = __glGetProcAddress("glClampColor");
-
-    ClampColor((GLenum) bswap_ENUM(pc + 0), (GLenum) bswap_ENUM(pc + 4));
+    CALL_ClampColor( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_BindProgramARB(GLbyte * pc)
+void __glXDispSwap_BindProgramARB(GLbyte * pc)
 {
-    PFNGLBINDPROGRAMARBPROC BindProgramARB =
-        __glGetProcAddress("glBindProgramARB");
-    BindProgramARB((GLenum) bswap_ENUM(pc + 0), (GLuint) bswap_CARD32(pc + 4));
+    CALL_BindProgramARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-int
-__glXDispSwap_DeleteProgramsARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_DeleteProgramsARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLDELETEPROGRAMSARBPROC DeleteProgramsARB =
-        __glGetProcAddress("glDeleteProgramsARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-        DeleteProgramsARB(n,
-                          (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                          0));
+        CALL_DeleteProgramsARB( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+        ) );
         error = Success;
     }
 
     return error;
 }
 
-int
-__glXDispSwap_GenProgramsARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenProgramsARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENPROGRAMSARBPROC GenProgramsARB =
-        __glGetProcAddress("glGenProgramsARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *programs =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
+        GLuint * programs = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (programs == NULL)
             return BadAlloc;
 
-        GenProgramsARB(n, programs);
-        (void) bswap_32_array((uint32_t *) programs, n);
+        if (programs == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenProgramsARB( GET_DISPATCH(), (
+            n,
+            programs
+        ) );
+        (void) bswap_32_array( (uint32_t *) programs, n );
         __glXSendReplySwap(cl->client, programs, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -4712,23 +4680,21 @@ __glXDispSwap_GenProgramsARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetProgramEnvParameterdvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetProgramEnvParameterdvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMENVPARAMETERDVARBPROC GetProgramEnvParameterdvARB =
-        __glGetProcAddress("glGetProgramEnvParameterdvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble params[4];
-
-        GetProgramEnvParameterdvARB((GLenum) bswap_ENUM(pc + 0),
-                                    (GLuint) bswap_CARD32(pc + 4), params);
-        (void) bswap_64_array((uint64_t *) params, 4);
+        CALL_GetProgramEnvParameterdvARB( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, 4 );
         __glXSendReplySwap(cl->client, params, 4, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -4736,23 +4702,21 @@ __glXDispSwap_GetProgramEnvParameterdvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetProgramEnvParameterfvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetProgramEnvParameterfvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMENVPARAMETERFVARBPROC GetProgramEnvParameterfvARB =
-        __glGetProcAddress("glGetProgramEnvParameterfvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLfloat params[4];
-
-        GetProgramEnvParameterfvARB((GLenum) bswap_ENUM(pc + 0),
-                                    (GLuint) bswap_CARD32(pc + 4), params);
-        (void) bswap_32_array((uint32_t *) params, 4);
+        CALL_GetProgramEnvParameterfvARB( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 4 );
         __glXSendReplySwap(cl->client, params, 4, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4760,23 +4724,21 @@ __glXDispSwap_GetProgramEnvParameterfvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetProgramLocalParameterdvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetProgramLocalParameterdvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC GetProgramLocalParameterdvARB =
-        __glGetProcAddress("glGetProgramLocalParameterdvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLdouble params[4];
-
-        GetProgramLocalParameterdvARB((GLenum) bswap_ENUM(pc + 0),
-                                      (GLuint) bswap_CARD32(pc + 4), params);
-        (void) bswap_64_array((uint64_t *) params, 4);
+        CALL_GetProgramLocalParameterdvARB( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, 4 );
         __glXSendReplySwap(cl->client, params, 4, 8, GL_FALSE, 0);
         error = Success;
     }
@@ -4784,23 +4746,21 @@ __glXDispSwap_GetProgramLocalParameterdvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetProgramLocalParameterfvARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetProgramLocalParameterfvARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC GetProgramLocalParameterfvARB =
-        __glGetProcAddress("glGetProgramLocalParameterfvARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLfloat params[4];
-
-        GetProgramLocalParameterfvARB((GLenum) bswap_ENUM(pc + 0),
-                                      (GLuint) bswap_CARD32(pc + 4), params);
-        (void) bswap_32_array((uint32_t *) params, 4);
+        CALL_GetProgramLocalParameterfvARB( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 4 );
         __glXSendReplySwap(cl->client, params, 4, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4808,32 +4768,29 @@ __glXDispSwap_GetProgramLocalParameterfvARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GetProgramivARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetProgramivARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETPROGRAMIVARBPROC GetProgramivARB =
-        __glGetProcAddress("glGetProgramivARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLenum pname = (GLenum) bswap_ENUM(pc + 4);
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
 
         const GLuint compsize = __glGetProgramivARB_size(pname);
         GLint answerBuffer[200];
-        GLint *params =
-            __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer,
-                                 sizeof(answerBuffer), 4);
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
 
-        if (params == NULL)
-            return BadAlloc;
+        if (params == NULL) return BadAlloc;
         __glXClearErrorOccured();
 
-        GetProgramivARB((GLenum) bswap_ENUM(pc + 0), pname, params);
-        (void) bswap_32_array((uint32_t *) params, compsize);
+        CALL_GetProgramivARB( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
         __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -4841,20 +4798,18 @@ __glXDispSwap_GetProgramivARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsProgramARB(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsProgramARB(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISPROGRAMARBPROC IsProgramARB = __glGetProcAddress("glIsProgramARB");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
-
-        retval = IsProgramARB((GLuint) bswap_CARD32(pc + 0));
+        retval = CALL_IsProgramARB( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -4862,163 +4817,144 @@ __glXDispSwap_IsProgramARB(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc)
+void __glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMENVPARAMETER4DVARBPROC ProgramEnvParameter4dvARB =
-        __glGetProcAddress("glProgramEnvParameter4dvARB");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    ProgramEnvParameter4dvARB((GLenum) bswap_ENUM(pc + 0),
-                              (GLuint) bswap_CARD32(pc + 4),
-                              (const GLdouble *)
-                              bswap_64_array((uint64_t *) (pc + 8), 4));
+    CALL_ProgramEnvParameter4dvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc)
+void __glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMENVPARAMETER4FVARBPROC ProgramEnvParameter4fvARB =
-        __glGetProcAddress("glProgramEnvParameter4fvARB");
-    ProgramEnvParameter4fvARB((GLenum) bswap_ENUM(pc + 0),
-                              (GLuint) bswap_CARD32(pc + 4),
-                              (const GLfloat *)
-                              bswap_32_array((uint32_t *) (pc + 8), 4));
+    CALL_ProgramEnvParameter4fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc)
+void __glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMLOCALPARAMETER4DVARBPROC ProgramLocalParameter4dvARB =
-        __glGetProcAddress("glProgramLocalParameter4dvARB");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 40);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 40);
         pc -= 4;
     }
 #endif
 
-    ProgramLocalParameter4dvARB((GLenum) bswap_ENUM(pc + 0),
-                                (GLuint) bswap_CARD32(pc + 4),
-                                (const GLdouble *)
-                                bswap_64_array((uint64_t *) (pc + 8), 4));
+    CALL_ProgramLocalParameter4dvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc)
+void __glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc)
 {
-    PFNGLPROGRAMLOCALPARAMETER4FVARBPROC ProgramLocalParameter4fvARB =
-        __glGetProcAddress("glProgramLocalParameter4fvARB");
-    ProgramLocalParameter4fvARB((GLenum) bswap_ENUM(pc + 0),
-                                (GLuint) bswap_CARD32(pc + 4),
-                                (const GLfloat *)
-                                bswap_32_array((uint32_t *) (pc + 8), 4));
+    CALL_ProgramLocalParameter4fvARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ProgramStringARB(GLbyte * pc)
+void __glXDispSwap_ProgramStringARB(GLbyte * pc)
 {
-    PFNGLPROGRAMSTRINGARBPROC ProgramStringARB =
-        __glGetProcAddress("glProgramStringARB");
-    const GLsizei len = (GLsizei) bswap_CARD32(pc + 8);
+    const GLsizei len =  (GLsizei )bswap_CARD32 ( pc +  8 );
 
-    ProgramStringARB((GLenum) bswap_ENUM(pc + 0),
-                     (GLenum) bswap_ENUM(pc + 4),
-                     len, (const GLvoid *) (pc + 12));
+    CALL_ProgramStringARB( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+        len,
+         (const GLvoid *)(pc + 12)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1fvARB(GLbyte * pc)
+void __glXDispSwap_VertexAttrib1fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1FVARBPROC VertexAttrib1fvARB =
-        __glGetProcAddress("glVertexAttrib1fvARB");
-    VertexAttrib1fvARB((GLuint) bswap_CARD32(pc + 0),
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                        1));
+    CALL_VertexAttrib1fvARB( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2fvARB(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2FVARBPROC VertexAttrib2fvARB =
-        __glGetProcAddress("glVertexAttrib2fvARB");
-    VertexAttrib2fvARB((GLuint) bswap_CARD32(pc + 0),
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                        2));
+    CALL_VertexAttrib2fvARB( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3fvARB(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3FVARBPROC VertexAttrib3fvARB =
-        __glGetProcAddress("glVertexAttrib3fvARB");
-    VertexAttrib3fvARB((GLuint) bswap_CARD32(pc + 0),
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                        3));
+    CALL_VertexAttrib3fvARB( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4fvARB(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4fvARB(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4FVARBPROC VertexAttrib4fvARB =
-        __glGetProcAddress("glVertexAttrib4fvARB");
-    VertexAttrib4fvARB((GLuint) bswap_CARD32(pc + 0),
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                        4));
+    CALL_VertexAttrib4fvARB( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_BindFramebuffer(GLbyte * pc)
+void __glXDispSwap_BindFramebuffer(GLbyte * pc)
 {
-    PFNGLBINDFRAMEBUFFERPROC BindFramebuffer =
-        __glGetProcAddress("glBindFramebuffer");
-    BindFramebuffer((GLenum) bswap_ENUM(pc + 0), (GLuint) bswap_CARD32(pc + 4));
+    CALL_BindFramebuffer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_BindRenderbuffer(GLbyte * pc)
+void __glXDispSwap_BindRenderbuffer(GLbyte * pc)
 {
-    PFNGLBINDRENDERBUFFERPROC BindRenderbuffer =
-        __glGetProcAddress("glBindRenderbuffer");
-    BindRenderbuffer((GLenum) bswap_ENUM(pc + 0),
-                     (GLuint) bswap_CARD32(pc + 4));
+    CALL_BindRenderbuffer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
 }
 
-void
-__glXDispSwap_BlitFramebuffer(GLbyte * pc)
+void __glXDispSwap_BlitFramebuffer(GLbyte * pc)
 {
-    PFNGLBLITFRAMEBUFFERPROC BlitFramebuffer =
-        __glGetProcAddress("glBlitFramebuffer");
-    BlitFramebuffer((GLint) bswap_CARD32(pc + 0), (GLint) bswap_CARD32(pc + 4),
-                    (GLint) bswap_CARD32(pc + 8), (GLint) bswap_CARD32(pc + 12),
-                    (GLint) bswap_CARD32(pc + 16),
-                    (GLint) bswap_CARD32(pc + 20),
-                    (GLint) bswap_CARD32(pc + 24),
-                    (GLint) bswap_CARD32(pc + 28),
-                    (GLbitfield) bswap_CARD32(pc + 32),
-                    (GLenum) bswap_ENUM(pc + 36));
+    CALL_BlitFramebuffer( GET_DISPATCH(), (
+         (GLint   )bswap_CARD32 ( pc +  0 ),
+         (GLint   )bswap_CARD32 ( pc +  4 ),
+         (GLint   )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLint   )bswap_CARD32 ( pc + 20 ),
+         (GLint   )bswap_CARD32 ( pc + 24 ),
+         (GLint   )bswap_CARD32 ( pc + 28 ),
+         (GLbitfield)bswap_CARD32 ( pc + 32 ),
+         (GLenum  )bswap_ENUM   ( pc + 36 )
+    ) );
 }
 
-int
-__glXDispSwap_CheckFramebufferStatus(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_CheckFramebufferStatus(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLCHECKFRAMEBUFFERSTATUSPROC CheckFramebufferStatus =
-        __glGetProcAddress("glCheckFramebufferStatus");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLenum retval;
-
-        retval = CheckFramebufferStatus((GLenum) bswap_ENUM(pc + 0));
+        retval = CALL_CheckFramebufferStatus( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -5026,114 +4962,104 @@ __glXDispSwap_CheckFramebufferStatus(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_DeleteFramebuffers(GLbyte * pc)
+void __glXDispSwap_DeleteFramebuffers(GLbyte * pc)
 {
-    PFNGLDELETEFRAMEBUFFERSPROC DeleteFramebuffers =
-        __glGetProcAddress("glDeleteFramebuffers");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-    DeleteFramebuffers(n,
-                       (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                       0));
+    CALL_DeleteFramebuffers( GET_DISPATCH(), (
+        n,
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_DeleteRenderbuffers(GLbyte * pc)
+void __glXDispSwap_DeleteRenderbuffers(GLbyte * pc)
 {
-    PFNGLDELETERENDERBUFFERSPROC DeleteRenderbuffers =
-        __glGetProcAddress("glDeleteRenderbuffers");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
-    DeleteRenderbuffers(n,
-                        (const GLuint *) bswap_32_array((uint32_t *) (pc + 4),
-                                                        0));
+    CALL_DeleteRenderbuffers( GET_DISPATCH(), (
+        n,
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_FramebufferRenderbuffer(GLbyte * pc)
+void __glXDispSwap_FramebufferRenderbuffer(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERRENDERBUFFERPROC FramebufferRenderbuffer =
-        __glGetProcAddress("glFramebufferRenderbuffer");
-    FramebufferRenderbuffer((GLenum) bswap_ENUM(pc + 0),
-                            (GLenum) bswap_ENUM(pc + 4),
-                            (GLenum) bswap_ENUM(pc + 8),
-                            (GLuint) bswap_CARD32(pc + 12));
+    CALL_FramebufferRenderbuffer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLuint  )bswap_CARD32 ( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_FramebufferTexture1D(GLbyte * pc)
+void __glXDispSwap_FramebufferTexture1D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE1DPROC FramebufferTexture1D =
-        __glGetProcAddress("glFramebufferTexture1D");
-    FramebufferTexture1D((GLenum) bswap_ENUM(pc + 0),
-                         (GLenum) bswap_ENUM(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLuint) bswap_CARD32(pc + 12),
-                         (GLint) bswap_CARD32(pc + 16));
+    CALL_FramebufferTexture1D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLuint  )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_FramebufferTexture2D(GLbyte * pc)
+void __glXDispSwap_FramebufferTexture2D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE2DPROC FramebufferTexture2D =
-        __glGetProcAddress("glFramebufferTexture2D");
-    FramebufferTexture2D((GLenum) bswap_ENUM(pc + 0),
-                         (GLenum) bswap_ENUM(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLuint) bswap_CARD32(pc + 12),
-                         (GLint) bswap_CARD32(pc + 16));
+    CALL_FramebufferTexture2D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLuint  )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-void
-__glXDispSwap_FramebufferTexture3D(GLbyte * pc)
+void __glXDispSwap_FramebufferTexture3D(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURE3DPROC FramebufferTexture3D =
-        __glGetProcAddress("glFramebufferTexture3D");
-    FramebufferTexture3D((GLenum) bswap_ENUM(pc + 0),
-                         (GLenum) bswap_ENUM(pc + 4),
-                         (GLenum) bswap_ENUM(pc + 8),
-                         (GLuint) bswap_CARD32(pc + 12),
-                         (GLint) bswap_CARD32(pc + 16),
-                         (GLint) bswap_CARD32(pc + 20));
+    CALL_FramebufferTexture3D( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLuint  )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 ),
+         (GLint   )bswap_CARD32 ( pc + 20 )
+    ) );
 }
 
-void
-__glXDispSwap_FramebufferTextureLayer(GLbyte * pc)
+void __glXDispSwap_FramebufferTextureLayer(GLbyte * pc)
 {
-    PFNGLFRAMEBUFFERTEXTURELAYERPROC FramebufferTextureLayer =
-        __glGetProcAddress("glFramebufferTextureLayer");
-    FramebufferTextureLayer((GLenum) bswap_ENUM(pc + 0),
-                            (GLenum) bswap_ENUM(pc + 4),
-                            (GLuint) bswap_CARD32(pc + 8),
-                            (GLint) bswap_CARD32(pc + 12),
-                            (GLint) bswap_CARD32(pc + 16));
+    CALL_FramebufferTextureLayer( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLuint  )bswap_CARD32 ( pc +  8 ),
+         (GLint   )bswap_CARD32 ( pc + 12 ),
+         (GLint   )bswap_CARD32 ( pc + 16 )
+    ) );
 }
 
-int
-__glXDispSwap_GenFramebuffers(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenFramebuffers(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENFRAMEBUFFERSPROC GenFramebuffers =
-        __glGetProcAddress("glGenFramebuffers");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *framebuffers =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * framebuffers = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (framebuffers == NULL)
             return BadAlloc;
 
-        GenFramebuffers(n, framebuffers);
-        (void) bswap_32_array((uint32_t *) framebuffers, n);
+        if (framebuffers == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenFramebuffers( GET_DISPATCH(), (
+            n,
+            framebuffers
+        ) );
+        (void) bswap_32_array( (uint32_t *) framebuffers, n );
         __glXSendReplySwap(cl->client, framebuffers, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -5141,30 +5067,29 @@ __glXDispSwap_GenFramebuffers(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_GenRenderbuffers(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GenRenderbuffers(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGENRENDERBUFFERSPROC GenRenderbuffers =
-        __glGetProcAddress("glGenRenderbuffers");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
-        const GLsizei n = (GLsizei) bswap_CARD32(pc + 0);
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
 
         GLuint answerBuffer[200];
-        GLuint *renderbuffers =
-            __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer),
-                                 4);
-
+        GLuint * renderbuffers = __glXGetAnswerBuffer(cl, n * 4, answerBuffer, sizeof(answerBuffer), 4);
         if (renderbuffers == NULL)
             return BadAlloc;
 
-        GenRenderbuffers(n, renderbuffers);
-        (void) bswap_32_array((uint32_t *) renderbuffers, n);
+        if (renderbuffers == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GenRenderbuffers( GET_DISPATCH(), (
+            n,
+            renderbuffers
+        ) );
+        (void) bswap_32_array( (uint32_t *) renderbuffers, n );
         __glXSendReplySwap(cl->client, renderbuffers, n, 4, GL_TRUE, 0);
         error = Success;
     }
@@ -5172,35 +5097,29 @@ __glXDispSwap_GenRenderbuffers(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-void
-__glXDispSwap_GenerateMipmap(GLbyte * pc)
+void __glXDispSwap_GenerateMipmap(GLbyte * pc)
 {
-    PFNGLGENERATEMIPMAPPROC GenerateMipmap =
-        __glGetProcAddress("glGenerateMipmap");
-    GenerateMipmap((GLenum) bswap_ENUM(pc + 0));
+    CALL_GenerateMipmap( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-int
-__glXDispSwap_GetFramebufferAttachmentParameteriv(__GLXclientState * cl,
-                                                  GLbyte * pc)
+int __glXDispSwap_GetFramebufferAttachmentParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC
-        GetFramebufferAttachmentParameteriv =
-        __glGetProcAddress("glGetFramebufferAttachmentParameteriv");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLint params[1];
-
-        GetFramebufferAttachmentParameteriv((GLenum) bswap_ENUM(pc + 0),
-                                            (GLenum) bswap_ENUM(pc + 4),
-                                            (GLenum) bswap_ENUM(pc + 8),
-                                            params);
-        (void) bswap_32_array((uint32_t *) params, 1);
+        CALL_GetFramebufferAttachmentParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLenum  )bswap_ENUM   ( pc +  4 ),
+             (GLenum  )bswap_ENUM   ( pc +  8 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 1 );
         __glXSendReplySwap(cl->client, params, 1, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -5208,23 +5127,21 @@ __glXDispSwap_GetFramebufferAttachmentParameteriv(__GLXclientState * cl,
     return error;
 }
 
-int
-__glXDispSwap_GetRenderbufferParameteriv(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_GetRenderbufferParameteriv(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLGETRENDERBUFFERPARAMETERIVPROC GetRenderbufferParameteriv =
-        __glGetProcAddress("glGetRenderbufferParameteriv");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLint params[1];
-
-        GetRenderbufferParameteriv((GLenum) bswap_ENUM(pc + 0),
-                                   (GLenum) bswap_ENUM(pc + 4), params);
-        (void) bswap_32_array((uint32_t *) params, 1);
+        CALL_GetRenderbufferParameteriv( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLenum  )bswap_ENUM   ( pc +  4 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 1 );
         __glXSendReplySwap(cl->client, params, 1, 4, GL_FALSE, 0);
         error = Success;
     }
@@ -5232,21 +5149,37 @@ __glXDispSwap_GetRenderbufferParameteriv(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsFramebuffer(__GLXclientState * cl, GLbyte * pc)
+int __glXDispSwap_IsFramebuffer(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISFRAMEBUFFERPROC IsFramebuffer =
-        __glGetProcAddress("glIsFramebuffer");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
         GLboolean retval;
+        retval = CALL_IsFramebuffer( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
+        __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
+        error = Success;
+    }
+
+    return error;
+}
 
-        retval = IsFramebuffer((GLuint) bswap_CARD32(pc + 0));
+int __glXDispSwap_IsRenderbuffer(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLboolean retval;
+        retval = CALL_IsRenderbuffer( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 )
+        ) );
         __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
         error = Success;
     }
@@ -5254,432 +5187,758 @@ __glXDispSwap_IsFramebuffer(__GLXclientState * cl, GLbyte * pc)
     return error;
 }
 
-int
-__glXDispSwap_IsRenderbuffer(__GLXclientState * cl, GLbyte * pc)
+void __glXDispSwap_RenderbufferStorage(GLbyte * pc)
+{
+    CALL_RenderbufferStorage( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLenum  )bswap_ENUM   ( pc +  4 ),
+         (GLsizei )bswap_CARD32 ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 )
+    ) );
+}
+
+void __glXDispSwap_RenderbufferStorageMultisample(GLbyte * pc)
+{
+    CALL_RenderbufferStorageMultisample( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLsizei )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLsizei )bswap_CARD32 ( pc + 12 ),
+         (GLsizei )bswap_CARD32 ( pc + 16 )
+    ) );
+}
+
+void __glXDispSwap_SampleMaskSGIS(GLbyte * pc)
+{
+    CALL_SampleMaskSGIS( GET_DISPATCH(), (
+         (GLclampf)bswap_FLOAT32( pc +  0 ),
+        *(GLboolean *)(pc +  4)
+    ) );
+}
+
+void __glXDispSwap_SamplePatternSGIS(GLbyte * pc)
+{
+    CALL_SamplePatternSGIS( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
+}
+
+void __glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc)
+{
+    CALL_SecondaryColor3fvEXT( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 3 )
+    ) );
+}
+
+void __glXDispSwap_FogCoordfvEXT(GLbyte * pc)
+{
+    CALL_FogCoordfvEXT( GET_DISPATCH(), (
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  0), 1 )
+    ) );
+}
+
+int __glXDispSwap_AreProgramsResidentNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLISRENDERBUFFERPROC IsRenderbuffer =
-        __glGetProcAddress("glIsRenderbuffer");
-    xGLXVendorPrivateReq *const req = (xGLXVendorPrivateReq *) pc;
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
     int error;
-    __GLXcontext *const cx =
-        __glXForceCurrent(cl, bswap_CARD32(&req->contextTag), &error);
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
 
     pc += __GLX_VENDPRIV_HDR_SIZE;
-    if (cx != NULL) {
+    if ( cx != NULL ) {
+        const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
+
         GLboolean retval;
+        GLboolean answerBuffer[200];
+        GLboolean * residences = __glXGetAnswerBuffer(cl, n, answerBuffer, sizeof(answerBuffer), 1);
+        if (residences == NULL)
+            return BadAlloc;
 
-        retval = IsRenderbuffer((GLuint) bswap_CARD32(pc + 0));
-        __glXSendReplySwap(cl->client, dummy_answer, 0, 0, GL_FALSE, retval);
+        if (residences == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        retval = CALL_AreProgramsResidentNV( GET_DISPATCH(), (
+            n,
+             (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 ),
+            residences
+        ) );
+        __glXSendReplySwap(cl->client, residences, n, 1, GL_FALSE, retval);
+        error = Success;
+    }
+
+    return error;
+}
+
+void __glXDispSwap_ExecuteProgramNV(GLbyte * pc)
+{
+    CALL_ExecuteProgramNV( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 4 )
+    ) );
+}
+
+int __glXDispSwap_GetProgramParameterdvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLdouble params[4];
+        CALL_GetProgramParameterdvNV( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+             (GLenum  )bswap_ENUM   ( pc +  8 ),
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, 4 );
+        __glXSendReplySwap(cl->client, params, 4, 8, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetProgramParameterfvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLfloat params[4];
+        CALL_GetProgramParameterfvNV( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+             (GLenum  )bswap_ENUM   ( pc +  8 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 4 );
+        __glXSendReplySwap(cl->client, params, 4, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetProgramivNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetProgramivNV_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetProgramivNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetTrackMatrixivNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        GLint params[1];
+        CALL_GetTrackMatrixivNV( GET_DISPATCH(), (
+             (GLenum  )bswap_ENUM   ( pc +  0 ),
+             (GLuint  )bswap_CARD32 ( pc +  4 ),
+             (GLenum  )bswap_ENUM   ( pc +  8 ),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 1 );
+        __glXSendReplySwap(cl->client, params, 1, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetVertexAttribdvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribdvNV_size(pname);
+        GLdouble answerBuffer[200];
+        GLdouble * params = __glXGetAnswerBuffer(cl, compsize * 8, answerBuffer, sizeof(answerBuffer), 8);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribdvNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 8, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetVertexAttribfvNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribfvNV_size(pname);
+        GLfloat answerBuffer[200];
+        GLfloat * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribfvNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
+        error = Success;
+    }
+
+    return error;
+}
+
+int __glXDispSwap_GetVertexAttribivNV(__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLenum pname =  (GLenum  )bswap_ENUM   ( pc +  4 );
+
+        const GLuint compsize = __glGetVertexAttribivNV_size(pname);
+        GLint answerBuffer[200];
+        GLint * params = __glXGetAnswerBuffer(cl, compsize * 4, answerBuffer, sizeof(answerBuffer), 4);
+
+        if (params == NULL) return BadAlloc;
+        __glXClearErrorOccured();
+
+        CALL_GetVertexAttribivNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            pname,
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, compsize );
+        __glXSendReplySwap(cl->client, params, compsize, 4, GL_FALSE, 0);
         error = Success;
     }
 
     return error;
 }
 
-void
-__glXDispSwap_RenderbufferStorage(GLbyte * pc)
+void __glXDispSwap_LoadProgramNV(GLbyte * pc)
+{
+    const GLsizei len =  (GLsizei )bswap_CARD32 ( pc +  8 );
+
+    CALL_LoadProgramNV( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+        len,
+         (const GLubyte *)(pc + 12)
+    ) );
+}
+
+void __glXDispSwap_ProgramParameters4dvNV(GLbyte * pc)
 {
-    PFNGLRENDERBUFFERSTORAGEPROC RenderbufferStorage =
-        __glGetProcAddress("glRenderbufferStorage");
-    RenderbufferStorage((GLenum) bswap_ENUM(pc + 0),
-                        (GLenum) bswap_ENUM(pc + 4),
-                        (GLsizei) bswap_CARD32(pc + 8),
-                        (GLsizei) bswap_CARD32(pc + 12));
+    const GLsizei num =  (GLsizei )bswap_CARD32 ( pc +  8 );
+
+#ifdef __GLX_ALIGN64
+    const GLuint cmdlen = 16 + safe_pad(safe_mul(num, 4 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
+        pc -= 4;
+    }
+#endif
+
+    CALL_ProgramParameters4dvNV( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+        num,
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc + 12), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_RenderbufferStorageMultisample(GLbyte * pc)
+void __glXDispSwap_ProgramParameters4fvNV(GLbyte * pc)
 {
-    PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC RenderbufferStorageMultisample =
-        __glGetProcAddress("glRenderbufferStorageMultisample");
-    RenderbufferStorageMultisample((GLenum) bswap_ENUM(pc + 0),
-                                   (GLsizei) bswap_CARD32(pc + 4),
-                                   (GLenum) bswap_ENUM(pc + 8),
-                                   (GLsizei) bswap_CARD32(pc + 12),
-                                   (GLsizei) bswap_CARD32(pc + 16));
+    const GLsizei num =  (GLsizei )bswap_CARD32 ( pc +  8 );
+
+    CALL_ProgramParameters4fvNV( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+        num,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc + 12), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc)
+void __glXDispSwap_RequestResidentProgramsNV(GLbyte * pc)
 {
-    PFNGLSECONDARYCOLOR3FVEXTPROC SecondaryColor3fvEXT =
-        __glGetProcAddress("glSecondaryColor3fvEXT");
-    SecondaryColor3fvEXT((const GLfloat *)
-                         bswap_32_array((uint32_t *) (pc + 0), 3));
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  0 );
+
+    CALL_RequestResidentProgramsNV( GET_DISPATCH(), (
+        n,
+         (const GLuint *)bswap_32_array( (uint32_t *) (pc +  4), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_FogCoordfvEXT(GLbyte * pc)
+void __glXDispSwap_TrackMatrixNV(GLbyte * pc)
 {
-    PFNGLFOGCOORDFVEXTPROC FogCoordfvEXT =
-        __glGetProcAddress("glFogCoordfvEXT");
-    FogCoordfvEXT((const GLfloat *) bswap_32_array((uint32_t *) (pc + 0), 1));
+    CALL_TrackMatrixNV( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 ),
+         (GLenum  )bswap_ENUM   ( pc +  8 ),
+         (GLenum  )bswap_ENUM   ( pc + 12 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib1dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1DVNVPROC VertexAttrib1dvNV =
-        __glGetProcAddress("glVertexAttrib1dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 12);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 12);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib1dvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                        1));
+    CALL_VertexAttrib1dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib1fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1FVNVPROC VertexAttrib1fvNV =
-        __glGetProcAddress("glVertexAttrib1fvNV");
-    VertexAttrib1fvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                       1));
+    CALL_VertexAttrib1fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib1svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib1svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB1SVNVPROC VertexAttrib1svNV =
-        __glGetProcAddress("glVertexAttrib1svNV");
-    VertexAttrib1svNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                       1));
+    CALL_VertexAttrib1svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 1 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2DVNVPROC VertexAttrib2dvNV =
-        __glGetProcAddress("glVertexAttrib2dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 20);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 20);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib2dvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                        2));
+    CALL_VertexAttrib2dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2FVNVPROC VertexAttrib2fvNV =
-        __glGetProcAddress("glVertexAttrib2fvNV");
-    VertexAttrib2fvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                       2));
+    CALL_VertexAttrib2fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib2svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib2svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB2SVNVPROC VertexAttrib2svNV =
-        __glGetProcAddress("glVertexAttrib2svNV");
-    VertexAttrib2svNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                       2));
+    CALL_VertexAttrib2svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 2 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3DVNVPROC VertexAttrib3dvNV =
-        __glGetProcAddress("glVertexAttrib3dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 28);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 28);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib3dvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                        3));
+    CALL_VertexAttrib3dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3FVNVPROC VertexAttrib3fvNV =
-        __glGetProcAddress("glVertexAttrib3fvNV");
-    VertexAttrib3fvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                       3));
+    CALL_VertexAttrib3fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib3svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib3svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB3SVNVPROC VertexAttrib3svNV =
-        __glGetProcAddress("glVertexAttrib3svNV");
-    VertexAttrib3svNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                       3));
+    CALL_VertexAttrib3svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 3 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4DVNVPROC VertexAttrib4dvNV =
-        __glGetProcAddress("glVertexAttrib4dvNV");
 #ifdef __GLX_ALIGN64
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, 36);
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, 36);
         pc -= 4;
     }
 #endif
 
-    VertexAttrib4dvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLdouble *) bswap_64_array((uint64_t *) (pc + 4),
-                                                        4));
+    CALL_VertexAttrib4dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4FVNVPROC VertexAttrib4fvNV =
-        __glGetProcAddress("glVertexAttrib4fvNV");
-    VertexAttrib4fvNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLfloat *) bswap_32_array((uint32_t *) (pc + 4),
-                                                       4));
+    CALL_VertexAttrib4fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4SVNVPROC VertexAttrib4svNV =
-        __glGetProcAddress("glVertexAttrib4svNV");
-    VertexAttrib4svNV((GLuint) bswap_CARD32(pc + 0),
-                      (const GLshort *) bswap_16_array((uint16_t *) (pc + 4),
-                                                       4));
+    CALL_VertexAttrib4svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  4), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIB4UBVNVPROC VertexAttrib4ubvNV =
-        __glGetProcAddress("glVertexAttrib4ubvNV");
-    VertexAttrib4ubvNV((GLuint) bswap_CARD32(pc + 0),
-                       (const GLubyte *) (pc + 4));
+    CALL_VertexAttrib4ubvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+         (const GLubyte *)(pc +  4)
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs1dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs1dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1DVNVPROC VertexAttribs1dvNV =
-        __glGetProcAddress("glVertexAttribs1dvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 8)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 1 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs1dvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLdouble *) bswap_64_array((uint64_t *) (pc + 8),
-                                                         0));
+    CALL_VertexAttribs1dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs1fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs1fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1FVNVPROC VertexAttribs1fvNV =
-        __glGetProcAddress("glVertexAttribs1fvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs1fvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs1fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs1svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs1svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS1SVNVPROC VertexAttribs1svNV =
-        __glGetProcAddress("glVertexAttribs1svNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs1svNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLshort *) bswap_16_array((uint16_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs1svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs2dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs2dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2DVNVPROC VertexAttribs2dvNV =
-        __glGetProcAddress("glVertexAttribs2dvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 16)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 2 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs2dvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLdouble *) bswap_64_array((uint64_t *) (pc + 8),
-                                                         0));
+    CALL_VertexAttribs2dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs2fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs2fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2FVNVPROC VertexAttribs2fvNV =
-        __glGetProcAddress("glVertexAttribs2fvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs2fvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs2fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs2svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs2svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS2SVNVPROC VertexAttribs2svNV =
-        __glGetProcAddress("glVertexAttribs2svNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs2svNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLshort *) bswap_16_array((uint16_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs2svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs3dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs3dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3DVNVPROC VertexAttribs3dvNV =
-        __glGetProcAddress("glVertexAttribs3dvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 24)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 3 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs3dvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLdouble *) bswap_64_array((uint64_t *) (pc + 8),
-                                                         0));
+    CALL_VertexAttribs3dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs3fvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs3fvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3FVNVPROC VertexAttribs3fvNV =
-        __glGetProcAddress("glVertexAttribs3fvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs3fvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs3fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs3svNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs3svNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS3SVNVPROC VertexAttribs3svNV =
-        __glGetProcAddress("glVertexAttribs3svNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs3svNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLshort *) bswap_16_array((uint16_t *) (pc + 8),
-                                                        0));
+    CALL_VertexAttribs3svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  8), 0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs4dvNV(GLbyte * pc)
+void __glXDispSwap_VertexAttribs4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS4DVNVPROC VertexAttribs4dvNV =
-        __glGetProcAddress("glVertexAttribs4dvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
 #ifdef __GLX_ALIGN64
-    const GLuint cmdlen = 12 + __GLX_PAD((n * 32)) - 4;
-
-    if ((unsigned long) (pc) & 7) {
-        (void) memmove(pc - 4, pc, cmdlen);
+    const GLuint cmdlen = 12 + safe_pad(safe_mul(n, 4 * sizeof(GLdouble))) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
         pc -= 4;
     }
 #endif
 
-    VertexAttribs4dvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLdouble *) bswap_64_array((uint64_t *) (pc + 8),
-                                                         0));
+    CALL_VertexAttribs4dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  8), 0 )
+    ) );
+}
+
+void __glXDispSwap_VertexAttribs4fvNV(GLbyte * pc)
+{
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
+
+    CALL_VertexAttribs4fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 0 )
+    ) );
+}
+
+void __glXDispSwap_VertexAttribs4svNV(GLbyte * pc)
+{
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
+
+    CALL_VertexAttribs4svNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLshort *)bswap_16_array( (uint16_t *) (pc +  8), 0 )
+    ) );
+}
+
+void __glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc)
+{
+    const GLsizei n =  (GLsizei )bswap_CARD32 ( pc +  4 );
+
+    CALL_VertexAttribs4ubvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        n,
+         (const GLubyte *)(pc +  8)
+    ) );
+}
+
+void __glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc)
+{
+    CALL_ActiveStencilFaceEXT( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 )
+    ) );
 }
 
-void
-__glXDispSwap_VertexAttribs4fvNV(GLbyte * pc)
+int __glXDispSwap_GetProgramNamedParameterdvNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLVERTEXATTRIBS4FVNVPROC VertexAttribs4fvNV =
-        __glGetProcAddress("glVertexAttribs4fvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLsizei len =  (GLsizei )bswap_CARD32 ( pc +  4 );
+
+        GLdouble params[4];
+        CALL_GetProgramNamedParameterdvNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            len,
+             (const GLubyte *)(pc +  8),
+            params
+        ) );
+        (void) bswap_64_array( (uint64_t *) params, 4 );
+        __glXSendReplySwap(cl->client, params, 4, 8, GL_TRUE, 0);
+        error = Success;
+    }
 
-    VertexAttribs4fvNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLfloat *) bswap_32_array((uint32_t *) (pc + 8),
-                                                        0));
+    return error;
 }
 
-void
-__glXDispSwap_VertexAttribs4svNV(GLbyte * pc)
+int __glXDispSwap_GetProgramNamedParameterfvNV(__GLXclientState *cl, GLbyte *pc)
 {
-    PFNGLVERTEXATTRIBS4SVNVPROC VertexAttribs4svNV =
-        __glGetProcAddress("glVertexAttribs4svNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    xGLXVendorPrivateReq * const req = (xGLXVendorPrivateReq *) pc;
+    int error;
+    __GLXcontext * const cx = __glXForceCurrent(cl, bswap_CARD32( &req->contextTag ), &error);
+
+    pc += __GLX_VENDPRIV_HDR_SIZE;
+    if ( cx != NULL ) {
+        const GLsizei len =  (GLsizei )bswap_CARD32 ( pc +  4 );
 
-    VertexAttribs4svNV((GLuint) bswap_CARD32(pc + 0),
-                       n,
-                       (const GLshort *) bswap_16_array((uint16_t *) (pc + 8),
-                                                        0));
+        GLfloat params[4];
+        CALL_GetProgramNamedParameterfvNV( GET_DISPATCH(), (
+             (GLuint  )bswap_CARD32 ( pc +  0 ),
+            len,
+             (const GLubyte *)(pc +  8),
+            params
+        ) );
+        (void) bswap_32_array( (uint32_t *) params, 4 );
+        __glXSendReplySwap(cl->client, params, 4, 4, GL_TRUE, 0);
+        error = Success;
+    }
+
+    return error;
 }
 
-void
-__glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc)
+void __glXDispSwap_ProgramNamedParameter4dvNV(GLbyte * pc)
 {
-    PFNGLVERTEXATTRIBS4UBVNVPROC VertexAttribs4ubvNV =
-        __glGetProcAddress("glVertexAttribs4ubvNV");
-    const GLsizei n = (GLsizei) bswap_CARD32(pc + 4);
+    const GLsizei len =  (GLsizei )bswap_CARD32 ( pc + 36 );
+
+#ifdef __GLX_ALIGN64
+    const GLuint cmdlen = 44 + safe_pad(len) - 4;
+    if ((unsigned long)(pc) & 7) {
+        (void) memmove(pc-4, pc, cmdlen);
+        pc -= 4;
+    }
+#endif
 
-    VertexAttribs4ubvNV((GLuint) bswap_CARD32(pc + 0),
-                        n, (const GLubyte *) (pc + 8));
+    CALL_ProgramNamedParameter4dvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc + 32 ),
+        len,
+         (const GLubyte *)(pc + 40),
+         (const GLdouble *)bswap_64_array( (uint64_t *) (pc +  0), 4 )
+    ) );
 }
 
-void
-__glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc)
+void __glXDispSwap_ProgramNamedParameter4fvNV(GLbyte * pc)
 {
-    PFNGLACTIVESTENCILFACEEXTPROC ActiveStencilFaceEXT =
-        __glGetProcAddress("glActiveStencilFaceEXT");
-    ActiveStencilFaceEXT((GLenum) bswap_ENUM(pc + 0));
+    const GLsizei len =  (GLsizei )bswap_CARD32 ( pc +  4 );
+
+    CALL_ProgramNamedParameter4fvNV( GET_DISPATCH(), (
+         (GLuint  )bswap_CARD32 ( pc +  0 ),
+        len,
+         (const GLubyte *)(pc + 24),
+         (const GLfloat *)bswap_32_array( (uint32_t *) (pc +  8), 4 )
+    ) );
 }
+
+void __glXDispSwap_BindFramebufferEXT(GLbyte * pc)
+{
+    CALL_BindFramebufferEXT( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
+}
+
+void __glXDispSwap_BindRenderbufferEXT(GLbyte * pc)
+{
+    CALL_BindRenderbufferEXT( GET_DISPATCH(), (
+         (GLenum  )bswap_ENUM   ( pc +  0 ),
+         (GLuint  )bswap_CARD32 ( pc +  4 )
+    ) );
+}
+
diff --git a/xserver/glx/indirect_program.c b/vcxsrv-code/xorg-server/glx/indirect_program.c
index c7bfa03..bf77bfb 100644
--- a/xserver/glx/indirect_program.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_program.c
@@ -32,6 +32,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxbyteorder.h"
@@ -40,14 +41,13 @@
 #include "unpack.h"
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
+#include "glfunctions.h"
 
 /**
  * Handle both types of glGetProgramString calls.
  */
 static int
 DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte * pc,
-                   PFNGLGETPROGRAMIVARBPROC get_programiv,
-                   PFNGLGETPROGRAMSTRINGARBPROC get_program_string,
                    Bool do_swap)
 {
     xGLXVendorPrivateWithReplyReq *const req =
@@ -78,13 +78,13 @@ DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte * pc,
         /* The value of the GL_PROGRAM_LENGTH_ARB and GL_PROGRAM_LENGTH_NV
          * enumerants is the same.
          */
-        get_programiv(target, GL_PROGRAM_LENGTH_ARB, &compsize);
+        glGetProgramivARB(target, GL_PROGRAM_LENGTH_ARB, &compsize);
 
         if (compsize != 0) {
             __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
             __glXClearErrorOccured();
 
-            get_program_string(target, pname, (GLubyte *) answer);
+            glGetProgramStringARB(target, pname, (GLubyte *) answer);
         }
 
         if (__glXErrorOccured()) {
@@ -107,21 +107,23 @@ DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte * pc,
 int
 __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte * pc)
 {
-    PFNGLGETPROGRAMIVARBPROC get_program =
-        __glGetProcAddress("glGetProgramivARB");
-    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
-        __glGetProcAddress("glGetProgramStringARB");
-
-    return DoGetProgramString(cl, pc, get_program, get_program_string, FALSE);
+    return DoGetProgramString(cl, pc, FALSE);
 }
 
 int
 __glXDispSwap_GetProgramStringARB(struct __GLXclientStateRec *cl, GLbyte * pc)
 {
-    PFNGLGETPROGRAMIVARBPROC get_program =
-        __glGetProcAddress("glGetProgramivARB");
-    PFNGLGETPROGRAMSTRINGARBPROC get_program_string =
-        __glGetProcAddress("glGetProgramStringARB");
+    return DoGetProgramString(cl, pc, TRUE);
+}
+
+int
+__glXDisp_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte * pc)
+{
+    return DoGetProgramString(cl, pc, FALSE);
+}
 
-    return DoGetProgramString(cl, pc, get_program, get_program_string, TRUE);
+int
+__glXDispSwap_GetProgramStringNV(struct __GLXclientStateRec *cl, GLbyte * pc)
+{
+    return DoGetProgramString(cl, pc, TRUE);
 }
diff --git a/xserver/glx/indirect_reqsize.c b/vcxsrv-code/xorg-server/glx/indirect_reqsize.c
index 020aae2..ecb89d0 100644
--- a/xserver/glx/indirect_reqsize.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_reqsize.c
@@ -25,31 +25,38 @@
  * SOFTWARE.
  */
 
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#else
+
+#include "glheader.h"
+
+#endif
+
 #include <GL/gl.h>
 #include "glxserver.h"
 #include "glxbyteorder.h"
 #include "indirect_size.h"
 #include "indirect_reqsize.h"
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-#undef HAVE_ALIAS
-#endif
-#ifdef HAVE_ALIAS
-#define ALIAS2(from,to) \
+#ifdef HAVE_FUNC_ATTRIBUTE_ALIAS
+#  define ALIAS2(from,to) \
     GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap, int reqlen ) \
         __attribute__ ((alias( # to )));
-#define ALIAS(from,to) ALIAS2( from, __glX ## to ## ReqSize )
+#  define ALIAS(from,to) ALIAS2( from, __glX ## to ## ReqSize )
 #else
-#define ALIAS(from,to) \
+#  define ALIAS(from,to) \
     GLint __glX ## from ## ReqSize( const GLbyte * pc, Bool swap, int reqlen ) \
     { return __glX ## to ## ReqSize( pc, swap, reqlen ); }
 #endif
 
+
 int
-__glXCallListsReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXCallListsReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 0);
-    GLenum type = *(GLenum *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 0);
+GLenum type        = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -62,15 +69,15 @@ __glXCallListsReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXBitmapReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXBitmapReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLsizei width = *(GLsizei *) (pc + 20);
-    GLsizei height = *(GLsizei *) (pc + 24);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLsizei width      = *(GLsizei *)(pc + 20);
+GLsizei height     = *(GLsizei *)(pc + 24);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -86,9 +93,9 @@ __glXBitmapReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXFogfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXFogfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 0);
+GLenum pname       = * (GLenum *)(pc + 0);
     GLsizei compsize;
 
     if (swap) {
@@ -96,13 +103,13 @@ __glXFogfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glFogfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXLightfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXLightfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -110,13 +117,13 @@ __glXLightfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glLightfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXLightModelfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXLightModelfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 0);
+GLenum pname       = * (GLenum *)(pc + 0);
     GLsizei compsize;
 
     if (swap) {
@@ -124,13 +131,13 @@ __glXLightModelfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glLightModelfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXMaterialfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXMaterialfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -138,17 +145,17 @@ __glXMaterialfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glMaterialfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXPolygonStippleReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXPolygonStippleReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -162,9 +169,9 @@ __glXPolygonStippleReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXTexParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexParameterfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -172,21 +179,21 @@ __glXTexParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glTexParameterfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXTexImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexImage1DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 32);
-    GLenum format = *(GLenum *) (pc + 44);
-    GLenum type = *(GLenum *) (pc + 48);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 32);
+GLenum format      = * (GLenum *)(pc + 44);
+GLenum type        = * (GLenum *)(pc + 48);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -204,18 +211,18 @@ __glXTexImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXTexImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexImage2DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 32);
-    GLsizei height = *(GLsizei *) (pc + 36);
-    GLenum format = *(GLenum *) (pc + 44);
-    GLenum type = *(GLenum *) (pc + 48);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 32);
+GLsizei height     = *(GLsizei *)(pc + 36);
+GLenum format      = * (GLenum *)(pc + 44);
+GLenum type        = * (GLenum *)(pc + 48);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -234,9 +241,9 @@ __glXTexImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXTexEnvfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexEnvfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -244,13 +251,13 @@ __glXTexEnvfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glTexEnvfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXTexGendvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexGendvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -258,13 +265,13 @@ __glXTexGendvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glTexGendv_size(pname);
-    return safe_pad(safe_mul(compsize, 8));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLdouble)));
 }
 
 int
-__glXTexGenfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexGenfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -272,45 +279,45 @@ __glXTexGenfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glTexGenfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXPixelMapfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXPixelMapfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei mapsize = *(GLsizei *) (pc + 4);
+GLsizei mapsize    = *(GLsizei *)(pc + 4);
 
     if (swap) {
         mapsize = bswap_32(mapsize);
     }
 
-    return safe_pad(safe_mul(mapsize, 4));
+    return safe_pad(safe_mul(mapsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXPixelMapusvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXPixelMapusvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei mapsize = *(GLsizei *) (pc + 4);
+GLsizei mapsize    = *(GLsizei *)(pc + 4);
 
     if (swap) {
         mapsize = bswap_32(mapsize);
     }
 
-    return safe_pad(safe_mul(mapsize, 2));
+    return safe_pad(safe_mul(mapsize, 1 * sizeof(GLushort)));
 }
 
 int
-__glXDrawPixelsReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXDrawPixelsReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLsizei width = *(GLsizei *) (pc + 20);
-    GLsizei height = *(GLsizei *) (pc + 24);
-    GLenum format = *(GLenum *) (pc + 28);
-    GLenum type = *(GLenum *) (pc + 32);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLsizei width      = *(GLsizei *)(pc + 20);
+GLsizei height     = *(GLsizei *)(pc + 24);
+GLenum format      = * (GLenum *)(pc + 28);
+GLenum type        = * (GLenum *)(pc + 32);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -328,29 +335,29 @@ __glXDrawPixelsReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXPrioritizeTexturesReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXPrioritizeTexturesReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 0);
+GLsizei n          = *(GLsizei *)(pc + 0);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_add(safe_mul(n, 4), safe_mul(n, 4)));
+    return safe_pad(safe_add(safe_mul(n, 1 * sizeof(GLuint)), safe_mul(n, 1 * sizeof(GLclampf))));
 }
 
 int
-__glXTexSubImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexSubImage1DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 36);
-    GLenum format = *(GLenum *) (pc + 44);
-    GLenum type = *(GLenum *) (pc + 48);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 36);
+GLenum format      = * (GLenum *)(pc + 44);
+GLenum type        = * (GLenum *)(pc + 48);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -368,18 +375,18 @@ __glXTexSubImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXTexSubImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexSubImage2DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 36);
-    GLsizei height = *(GLsizei *) (pc + 40);
-    GLenum format = *(GLenum *) (pc + 44);
-    GLenum type = *(GLenum *) (pc + 48);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 36);
+GLsizei height     = *(GLsizei *)(pc + 40);
+GLenum format      = * (GLenum *)(pc + 44);
+GLenum type        = * (GLenum *)(pc + 48);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -398,17 +405,17 @@ __glXTexSubImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXColorTableReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXColorTableReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 28);
-    GLenum format = *(GLenum *) (pc + 32);
-    GLenum type = *(GLenum *) (pc + 36);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 28);
+GLenum format      = * (GLenum *)(pc + 32);
+GLenum type        = * (GLenum *)(pc + 36);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -426,9 +433,9 @@ __glXColorTableReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXColorTableParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXColorTableParameterfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -436,21 +443,21 @@ __glXColorTableParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glColorTableParameterfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXColorSubTableReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXColorSubTableReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei count = *(GLsizei *) (pc + 28);
-    GLenum format = *(GLenum *) (pc + 32);
-    GLenum type = *(GLenum *) (pc + 36);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei count      = *(GLsizei *)(pc + 28);
+GLenum format      = * (GLenum *)(pc + 32);
+GLenum type        = * (GLenum *)(pc + 36);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -468,17 +475,17 @@ __glXColorSubTableReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXConvolutionFilter1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXConvolutionFilter1DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 28);
-    GLenum format = *(GLenum *) (pc + 36);
-    GLenum type = *(GLenum *) (pc + 40);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 28);
+GLenum format      = * (GLenum *)(pc + 36);
+GLenum type        = * (GLenum *)(pc + 40);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -496,18 +503,18 @@ __glXConvolutionFilter1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXConvolutionFilter2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXConvolutionFilter2DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
+    GLint row_length   = *  (GLint *)(pc +  4);
     GLint image_height = 0;
-    GLint skip_images = 0;
-    GLint skip_rows = *(GLint *) (pc + 8);
-    GLint alignment = *(GLint *) (pc + 16);
-    GLenum target = *(GLenum *) (pc + 20);
-    GLsizei width = *(GLsizei *) (pc + 28);
-    GLsizei height = *(GLsizei *) (pc + 32);
-    GLenum format = *(GLenum *) (pc + 36);
-    GLenum type = *(GLenum *) (pc + 40);
+    GLint skip_images  = 0;
+    GLint skip_rows    = *  (GLint *)(pc +  8);
+    GLint alignment    = *  (GLint *)(pc + 16);
+GLenum target      = * (GLenum *)(pc + 20);
+GLsizei width      = *(GLsizei *)(pc + 28);
+GLsizei height     = *(GLsizei *)(pc + 32);
+GLenum format      = * (GLenum *)(pc + 36);
+GLenum type        = * (GLenum *)(pc + 40);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -526,9 +533,9 @@ __glXConvolutionFilter2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXConvolutionParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXConvolutionParameterfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 4);
+GLenum pname       = * (GLenum *)(pc + 4);
     GLsizei compsize;
 
     if (swap) {
@@ -536,23 +543,23 @@ __glXConvolutionParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glConvolutionParameterfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXTexImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexImage3DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
-    GLint image_height = *(GLint *) (pc + 8);
-    GLint skip_rows = *(GLint *) (pc + 16);
-    GLint skip_images = *(GLint *) (pc + 20);
-    GLint alignment = *(GLint *) (pc + 32);
-    GLenum target = *(GLenum *) (pc + 36);
-    GLsizei width = *(GLsizei *) (pc + 48);
-    GLsizei height = *(GLsizei *) (pc + 52);
-    GLsizei depth = *(GLsizei *) (pc + 56);
-    GLenum format = *(GLenum *) (pc + 68);
-    GLenum type = *(GLenum *) (pc + 72);
+    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint image_height = *  (GLint *)(pc +  8);
+    GLint skip_rows    = *  (GLint *)(pc + 16);
+    GLint skip_images  = *  (GLint *)(pc + 20);
+    GLint alignment    = *  (GLint *)(pc + 32);
+GLenum target      = * (GLenum *)(pc + 36);
+GLsizei width      = *(GLsizei *)(pc + 48);
+GLsizei height     = *(GLsizei *)(pc + 52);
+GLsizei depth      = *(GLsizei *)(pc + 56);
+GLenum format      = * (GLenum *)(pc + 68);
+GLenum type        = * (GLenum *)(pc + 72);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -568,8 +575,8 @@ __glXTexImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
         type = bswap_32(type);
     }
 
-    if (*(CARD32 *) (pc + 76))
-        return 0;
+	   if (*(CARD32 *) (pc + 76))
+	       return 0;
 
     return __glXImageSize(format, type, target, width, height, depth,
                           image_height, row_length, skip_images,
@@ -577,19 +584,19 @@ __glXTexImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXTexSubImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXTexSubImage3DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLint row_length = *(GLint *) (pc + 4);
-    GLint image_height = *(GLint *) (pc + 8);
-    GLint skip_rows = *(GLint *) (pc + 16);
-    GLint skip_images = *(GLint *) (pc + 20);
-    GLint alignment = *(GLint *) (pc + 32);
-    GLenum target = *(GLenum *) (pc + 36);
-    GLsizei width = *(GLsizei *) (pc + 60);
-    GLsizei height = *(GLsizei *) (pc + 64);
-    GLsizei depth = *(GLsizei *) (pc + 68);
-    GLenum format = *(GLenum *) (pc + 76);
-    GLenum type = *(GLenum *) (pc + 80);
+    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint image_height = *  (GLint *)(pc +  8);
+    GLint skip_rows    = *  (GLint *)(pc + 16);
+    GLint skip_images  = *  (GLint *)(pc + 20);
+    GLint alignment    = *  (GLint *)(pc + 32);
+GLenum target      = * (GLenum *)(pc + 36);
+GLsizei width      = *(GLsizei *)(pc + 60);
+GLsizei height     = *(GLsizei *)(pc + 64);
+GLsizei depth      = *(GLsizei *)(pc + 68);
+GLenum format      = * (GLenum *)(pc + 76);
+GLenum type        = * (GLenum *)(pc + 80);
 
     if (swap) {
         row_length = bswap_32(row_length);
@@ -611,9 +618,9 @@ __glXTexSubImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXCompressedTexImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXCompressedTexImage1DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei imageSize = *(GLsizei *) (pc + 20);
+GLsizei imageSize  = *(GLsizei *)(pc + 20);
 
     if (swap) {
         imageSize = bswap_32(imageSize);
@@ -623,9 +630,9 @@ __glXCompressedTexImage1DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXCompressedTexImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXCompressedTexImage2DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei imageSize = *(GLsizei *) (pc + 24);
+GLsizei imageSize  = *(GLsizei *)(pc + 24);
 
     if (swap) {
         imageSize = bswap_32(imageSize);
@@ -635,9 +642,9 @@ __glXCompressedTexImage2DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXCompressedTexImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXCompressedTexImage3DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei imageSize = *(GLsizei *) (pc + 28);
+GLsizei imageSize  = *(GLsizei *)(pc + 28);
 
     if (swap) {
         imageSize = bswap_32(imageSize);
@@ -647,9 +654,9 @@ __glXCompressedTexImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXCompressedTexSubImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXCompressedTexSubImage3DReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei imageSize = *(GLsizei *) (pc + 36);
+GLsizei imageSize  = *(GLsizei *)(pc + 36);
 
     if (swap) {
         imageSize = bswap_32(imageSize);
@@ -659,9 +666,9 @@ __glXCompressedTexSubImage3DReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXPointParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXPointParameterfvReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLenum pname = *(GLenum *) (pc + 0);
+GLenum pname       = * (GLenum *)(pc + 0);
     GLsizei compsize;
 
     if (swap) {
@@ -669,25 +676,25 @@ __glXPointParameterfvReqSize(const GLbyte * pc, Bool swap, int reqlen)
     }
 
     compsize = __glPointParameterfv_size(pname);
-    return safe_pad(safe_mul(compsize, 4));
+    return safe_pad(safe_mul(compsize, 1 * sizeof(GLfloat)));
 }
 
 int
-__glXDrawBuffersReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXDrawBuffersReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 0);
+GLsizei n          = *(GLsizei *)(pc + 0);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 4));
+    return safe_pad(safe_mul(n, 1 * sizeof(GLenum)));
 }
 
 int
-__glXProgramStringARBReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXProgramStringARBReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei len = *(GLsizei *) (pc + 8);
+GLsizei len        = *(GLsizei *)(pc + 8);
 
     if (swap) {
         len = bswap_32(len);
@@ -697,96 +704,135 @@ __glXProgramStringARBReqSize(const GLbyte * pc, Bool swap, int reqlen)
 }
 
 int
-__glXVertexAttribs1dvNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXProgramParameters4dvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
+{
+GLsizei num        = *(GLsizei *)(pc + 8);
+
+    if (swap) {
+        num = bswap_32(num);
+    }
+
+    return safe_pad(safe_mul(num, 4 * sizeof(GLdouble)));
+}
+
+int
+__glXProgramParameters4fvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
+{
+GLsizei num        = *(GLsizei *)(pc + 8);
+
+    if (swap) {
+        num = bswap_32(num);
+    }
+
+    return safe_pad(safe_mul(num, 4 * sizeof(GLfloat)));
+}
+
+int
+__glXVertexAttribs1dvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 8));
+    return safe_pad(safe_mul(n, 1 * sizeof(GLdouble)));
 }
 
 int
-__glXVertexAttribs2dvNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXVertexAttribs2dvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 16));
+    return safe_pad(safe_mul(n, 2 * sizeof(GLdouble)));
 }
 
 int
-__glXVertexAttribs3dvNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXVertexAttribs3dvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 24));
+    return safe_pad(safe_mul(n, 3 * sizeof(GLdouble)));
 }
 
 int
-__glXVertexAttribs3fvNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXVertexAttribs3fvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 12));
+    return safe_pad(safe_mul(n, 3 * sizeof(GLfloat)));
 }
 
 int
-__glXVertexAttribs3svNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXVertexAttribs3svNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 6));
+    return safe_pad(safe_mul(n, 3 * sizeof(GLshort)));
 }
 
 int
-__glXVertexAttribs4dvNVReqSize(const GLbyte * pc, Bool swap, int reqlen)
+__glXVertexAttribs4dvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
 {
-    GLsizei n = *(GLsizei *) (pc + 4);
+GLsizei n          = *(GLsizei *)(pc + 4);
 
     if (swap) {
         n = bswap_32(n);
     }
 
-    return safe_pad(safe_mul(n, 32));
-}
-
-ALIAS(Fogiv, Fogfv)
-    ALIAS(Lightiv, Lightfv)
-    ALIAS(LightModeliv, LightModelfv)
-    ALIAS(Materialiv, Materialfv)
-    ALIAS(TexParameteriv, TexParameterfv)
-    ALIAS(TexEnviv, TexEnvfv)
-    ALIAS(TexGeniv, TexGenfv)
-    ALIAS(PixelMapuiv, PixelMapfv)
-    ALIAS(ColorTableParameteriv, ColorTableParameterfv)
-    ALIAS(ConvolutionParameteriv, ConvolutionParameterfv)
-    ALIAS(CompressedTexSubImage1D, CompressedTexImage1D)
-    ALIAS(CompressedTexSubImage2D, CompressedTexImage3D)
-    ALIAS(PointParameteriv, PointParameterfv)
-    ALIAS(DeleteFramebuffers, DrawBuffers)
-    ALIAS(DeleteRenderbuffers, DrawBuffers)
-    ALIAS(VertexAttribs1fvNV, PixelMapfv)
-    ALIAS(VertexAttribs1svNV, PixelMapusv)
-    ALIAS(VertexAttribs2fvNV, VertexAttribs1dvNV)
-    ALIAS(VertexAttribs2svNV, PixelMapfv)
-    ALIAS(VertexAttribs4fvNV, VertexAttribs2dvNV)
-    ALIAS(VertexAttribs4svNV, VertexAttribs1dvNV)
-    ALIAS(VertexAttribs4ubvNV, PixelMapfv)
+    return safe_pad(safe_mul(n, 4 * sizeof(GLdouble)));
+}
+
+int
+__glXProgramNamedParameter4fvNVReqSize( const GLbyte * pc, Bool swap, int reqlen )
+{
+GLsizei len        = *(GLsizei *)(pc + 4);
+
+    if (swap) {
+        len = bswap_32(len);
+    }
+
+    return safe_pad(len);
+}
+
+ALIAS( Fogiv, Fogfv )
+ALIAS( Lightiv, Lightfv )
+ALIAS( LightModeliv, LightModelfv )
+ALIAS( Materialiv, Materialfv )
+ALIAS( TexParameteriv, TexParameterfv )
+ALIAS( TexEnviv, TexEnvfv )
+ALIAS( TexGeniv, TexGenfv )
+ALIAS( PixelMapuiv, PixelMapfv )
+ALIAS( ColorTableParameteriv, ColorTableParameterfv )
+ALIAS( ConvolutionParameteriv, ConvolutionParameterfv )
+ALIAS( CompressedTexSubImage1D, CompressedTexImage1D )
+ALIAS( CompressedTexSubImage2D, CompressedTexImage3D )
+ALIAS( PointParameteriv, PointParameterfv )
+ALIAS( DeleteFramebuffers, DrawBuffers )
+ALIAS( DeleteRenderbuffers, DrawBuffers )
+ALIAS( LoadProgramNV, ProgramStringARB )
+ALIAS( RequestResidentProgramsNV, DrawBuffers )
+ALIAS( VertexAttribs1fvNV, PixelMapfv )
+ALIAS( VertexAttribs1svNV, PixelMapusv )
+ALIAS( VertexAttribs2fvNV, VertexAttribs1dvNV )
+ALIAS( VertexAttribs2svNV, PixelMapfv )
+ALIAS( VertexAttribs4fvNV, VertexAttribs2dvNV )
+ALIAS( VertexAttribs4svNV, VertexAttribs1dvNV )
+ALIAS( VertexAttribs4ubvNV, PixelMapfv )
+ALIAS( ProgramNamedParameter4dvNV, CompressedTexSubImage3D )
diff --git a/xserver/glx/indirect_reqsize.h b/vcxsrv-code/xorg-server/glx/indirect_reqsize.h
index 632a85b..8468faf 100644
--- a/xserver/glx/indirect_reqsize.h
+++ b/vcxsrv-code/xorg-server/glx/indirect_reqsize.h
@@ -26,167 +26,91 @@
  */
 
 #if !defined( _INDIRECT_REQSIZE_H_ )
-#define _INDIRECT_REQSIZE_H_
+#  define _INDIRECT_REQSIZE_H_
 
 #include <X11/Xfuncproto.h>
 
-#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
-#define PURE __attribute__((pure))
-#else
-#define PURE
-#endif
+#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
 
-extern PURE _X_HIDDEN int __glXCallListsReqSize(const GLbyte * pc, Bool swap,
-                                                int reqlen);
-extern PURE _X_HIDDEN int __glXBitmapReqSize(const GLbyte * pc, Bool swap,
-                                             int reqlen);
-extern PURE _X_HIDDEN int __glXFogfvReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXFogivReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXLightfvReqSize(const GLbyte * pc, Bool swap,
-                                              int reqlen);
-extern PURE _X_HIDDEN int __glXLightivReqSize(const GLbyte * pc, Bool swap,
-                                              int reqlen);
-extern PURE _X_HIDDEN int __glXLightModelfvReqSize(const GLbyte * pc, Bool swap,
-                                                   int reqlen);
-extern PURE _X_HIDDEN int __glXLightModelivReqSize(const GLbyte * pc, Bool swap,
-                                                   int reqlen);
-extern PURE _X_HIDDEN int __glXMaterialfvReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXMaterialivReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXPolygonStippleReqSize(const GLbyte * pc,
-                                                     Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexParameterfvReqSize(const GLbyte * pc,
-                                                     Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexParameterivReqSize(const GLbyte * pc,
-                                                     Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexImage1DReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXTexImage2DReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXTexEnvfvReqSize(const GLbyte * pc, Bool swap,
-                                               int reqlen);
-extern PURE _X_HIDDEN int __glXTexEnvivReqSize(const GLbyte * pc, Bool swap,
-                                               int reqlen);
-extern PURE _X_HIDDEN int __glXTexGendvReqSize(const GLbyte * pc, Bool swap,
-                                               int reqlen);
-extern PURE _X_HIDDEN int __glXTexGenfvReqSize(const GLbyte * pc, Bool swap,
-                                               int reqlen);
-extern PURE _X_HIDDEN int __glXTexGenivReqSize(const GLbyte * pc, Bool swap,
-                                               int reqlen);
-extern PURE _X_HIDDEN int __glXMap1dReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXMap1fReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXMap2dReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXMap2fReqSize(const GLbyte * pc, Bool swap,
-                                            int reqlen);
-extern PURE _X_HIDDEN int __glXPixelMapfvReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXPixelMapuivReqSize(const GLbyte * pc, Bool swap,
-                                                  int reqlen);
-extern PURE _X_HIDDEN int __glXPixelMapusvReqSize(const GLbyte * pc, Bool swap,
-                                                  int reqlen);
-extern PURE _X_HIDDEN int __glXDrawPixelsReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXDrawArraysReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXPrioritizeTexturesReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexSubImage1DReqSize(const GLbyte * pc,
-                                                    Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexSubImage2DReqSize(const GLbyte * pc,
-                                                    Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXColorTableReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXColorTableParameterfvReqSize(const GLbyte * pc,
-                                                            Bool swap,
-                                                            int reqlen);
-extern PURE _X_HIDDEN int __glXColorTableParameterivReqSize(const GLbyte * pc,
-                                                            Bool swap,
-                                                            int reqlen);
-extern PURE _X_HIDDEN int __glXColorSubTableReqSize(const GLbyte * pc,
-                                                    Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXConvolutionFilter1DReqSize(const GLbyte * pc,
-                                                          Bool swap,
-                                                          int reqlen);
-extern PURE _X_HIDDEN int __glXConvolutionFilter2DReqSize(const GLbyte * pc,
-                                                          Bool swap,
-                                                          int reqlen);
-extern PURE _X_HIDDEN int __glXConvolutionParameterfvReqSize(const GLbyte * pc,
-                                                             Bool swap,
-                                                             int reqlen);
-extern PURE _X_HIDDEN int __glXConvolutionParameterivReqSize(const GLbyte * pc,
-                                                             Bool swap,
-                                                             int reqlen);
-extern PURE _X_HIDDEN int __glXSeparableFilter2DReqSize(const GLbyte * pc,
-                                                        Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXTexImage3DReqSize(const GLbyte * pc, Bool swap,
-                                                 int reqlen);
-extern PURE _X_HIDDEN int __glXTexSubImage3DReqSize(const GLbyte * pc,
-                                                    Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexImage1DReqSize(const GLbyte * pc,
-                                                           Bool swap,
-                                                           int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexImage2DReqSize(const GLbyte * pc,
-                                                           Bool swap,
-                                                           int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexImage3DReqSize(const GLbyte * pc,
-                                                           Bool swap,
-                                                           int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexSubImage1DReqSize(const GLbyte * pc,
-                                                              Bool swap,
-                                                              int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexSubImage2DReqSize(const GLbyte * pc,
-                                                              Bool swap,
-                                                              int reqlen);
-extern PURE _X_HIDDEN int __glXCompressedTexSubImage3DReqSize(const GLbyte * pc,
-                                                              Bool swap,
-                                                              int reqlen);
-extern PURE _X_HIDDEN int __glXPointParameterfvReqSize(const GLbyte * pc,
-                                                       Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXPointParameterivReqSize(const GLbyte * pc,
-                                                       Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXDrawBuffersReqSize(const GLbyte * pc, Bool swap,
-                                                  int reqlen);
-extern PURE _X_HIDDEN int __glXProgramStringARBReqSize(const GLbyte * pc,
-                                                       Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXDeleteFramebuffersReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXDeleteRenderbuffersReqSize(const GLbyte * pc,
-                                                          Bool swap,
-                                                          int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs1dvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs1fvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs1svNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs2dvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs2fvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs2svNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs3dvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs3fvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs3svNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs4dvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs4fvNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs4svNVReqSize(const GLbyte * pc,
-                                                         Bool swap, int reqlen);
-extern PURE _X_HIDDEN int __glXVertexAttribs4ubvNVReqSize(const GLbyte * pc,
-                                                          Bool swap,
-                                                          int reqlen);
+extern PURE _X_HIDDEN int __glXCallListsReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXBitmapReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXFogfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXFogivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXLightfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXLightivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXLightModelfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXLightModelivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMaterialfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMaterialivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPolygonStippleReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexParameterfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexParameterivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexImage1DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexImage2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexEnvfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexEnvivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexGendvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexGenfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexGenivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMap1dReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMap1fReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMap2dReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXMap2fReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPixelMapfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPixelMapuivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPixelMapusvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXDrawPixelsReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXDrawArraysReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPrioritizeTexturesReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexSubImage1DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexSubImage2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXColorTableReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXColorTableParameterfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXColorTableParameterivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXColorSubTableReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXConvolutionFilter1DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXConvolutionFilter2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXConvolutionParameterfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXConvolutionParameterivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXSeparableFilter2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexImage3DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXTexSubImage3DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexImage1DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexImage2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexImage3DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage1DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage2DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage3DReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPointParameterfvReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXPointParameterivReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXDrawBuffersReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXProgramStringARBReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXDeleteFramebuffersReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXDeleteRenderbuffersReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXLoadProgramNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXProgramParameters4dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXProgramParameters4fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXRequestResidentProgramsNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs1dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs1fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs1svNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs2dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs2fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs2svNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs3dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs3fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs3svNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs4dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs4fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs4svNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXVertexAttribs4ubvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXProgramNamedParameter4dvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
+extern PURE _X_HIDDEN int __glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap, int reqlen);
 
-#undef PURE
+#  undef PURE
 
-#endif                          /* !defined( _INDIRECT_REQSIZE_H_ ) */
+#endif /* !defined( _INDIRECT_REQSIZE_H_ ) */
diff --git a/xserver/glx/indirect_size.h b/vcxsrv-code/xorg-server/glx/indirect_size.h
index 6a3d14c..1bc9798 100644
--- a/xserver/glx/indirect_size.h
+++ b/vcxsrv-code/xorg-server/glx/indirect_size.h
@@ -26,7 +26,7 @@
  */
 
 #if !defined( _INDIRECT_SIZE_H_ )
-#define _INDIRECT_SIZE_H_
+#  define _INDIRECT_SIZE_H_
 
 /**
  * \file
@@ -38,48 +38,20 @@
 
 #include <X11/Xfuncproto.h>
 
-#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
-#define PURE __attribute__((pure))
-#else
-#define PURE
-#endif
+#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
 
-#if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
-#define FASTCALL __attribute__((fastcall))
-#else
-#define FASTCALL
-#endif
+#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#    define FASTCALL __attribute__((fastcall))
+#  else
+#    define FASTCALL
+#  endif
 
-extern _X_INTERNAL PURE FASTCALL GLint __glCallLists_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glFogfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glFogiv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glLightfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glLightiv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glLightModelfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glLightModeliv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMaterialfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMaterialiv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexParameteriv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexEnvfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexEnviv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexGendv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexGenfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glTexGeniv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMap1d_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMap1f_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMap2d_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glMap2f_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameteriv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glConvolutionParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glConvolutionParameteriv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glPointParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint __glPointParameteriv_size(GLenum);
 
-#undef PURE
-#undef FASTCALL
+#  undef PURE
+#  undef FASTCALL
 
 #endif /* !defined( _INDIRECT_SIZE_H_ ) */
diff --git a/xserver/glx/indirect_size_get.c b/vcxsrv-code/xorg-server/glx/indirect_size_get.c
index 7e81e62..fb61f8a 100644
--- a/xserver/glx/indirect_size_get.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_size_get.c
@@ -26,1195 +26,1231 @@
  */
 
 
-#include <X11/Xfuncproto.h>
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#else
+
+#include "glheader.h"
+
+#endif
+
 #include <GL/gl.h>
 #include "indirect_size_get.h"
 #include "glxserver.h"
 #include "indirect_util.h"
 #include "indirect_size.h"
 
-#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
-#define PURE __attribute__((pure))
-#else
-#define PURE
-#endif
+#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
 
-#if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
-#define FASTCALL __attribute__((fastcall))
-#else
-#define FASTCALL
-#endif
+#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#    define FASTCALL __attribute__((fastcall))
+#  else
+#    define FASTCALL
+#  endif
 
 
-#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(GLX_USE_APPLEGL)
-#undef HAVE_ALIAS
-#endif
-#ifdef HAVE_ALIAS
-#define ALIAS2(from,to) \
+#ifdef HAVE_FUNC_ATTRIBUTE_ALIAS
+#  define ALIAS2(from,to) \
     _X_INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \
         __attribute__ ((alias( # to )));
-#define ALIAS(from,to) ALIAS2( from, __gl ## to ## _size )
+#  define ALIAS(from,to) ALIAS2( from, __gl ## to ## _size )
 #else
-#define ALIAS(from,to) \
+#  define ALIAS(from,to) \
     _X_INTERNAL PURE FASTCALL GLint __gl ## from ## _size( GLenum e ) \
     { return __gl ## to ## _size( e ); }
 #endif
 
 
 _X_INTERNAL PURE FASTCALL GLint
-__glCallLists_size(GLenum e)
+__glCallLists_size( GLenum e )
 {
-    switch (e) {
-    case GL_BYTE:
-    case GL_UNSIGNED_BYTE:
-        return 1;
-    case GL_SHORT:
-    case GL_UNSIGNED_SHORT:
-    case GL_2_BYTES:
-    case GL_HALF_FLOAT:
-        return 2;
-    case GL_3_BYTES:
-        return 3;
-    case GL_INT:
-    case GL_UNSIGNED_INT:
-    case GL_FLOAT:
-    case GL_4_BYTES:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_BYTE:
+        case GL_UNSIGNED_BYTE:
+            return 1;
+        case GL_SHORT:
+        case GL_UNSIGNED_SHORT:
+        case GL_2_BYTES:
+        case GL_HALF_FLOAT:
+            return 2;
+        case GL_3_BYTES:
+            return 3;
+        case GL_INT:
+        case GL_UNSIGNED_INT:
+        case GL_FLOAT:
+        case GL_4_BYTES:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glFogfv_size(GLenum e)
+__glFogfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_FOG_INDEX:
-    case GL_FOG_DENSITY:
-    case GL_FOG_START:
-    case GL_FOG_END:
-    case GL_FOG_MODE:
-    case GL_FOG_OFFSET_VALUE_SGIX:
-    case GL_FOG_DISTANCE_MODE_NV:
-        return 1;
-    case GL_FOG_COLOR:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_FOG_INDEX:
+        case GL_FOG_DENSITY:
+        case GL_FOG_START:
+        case GL_FOG_END:
+        case GL_FOG_MODE:
+        case GL_FOG_OFFSET_VALUE_SGIX:
+        case GL_FOG_DISTANCE_MODE_NV:
+            return 1;
+        case GL_FOG_COLOR:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glLightfv_size(GLenum e)
+__glLightfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_SPOT_EXPONENT:
-    case GL_SPOT_CUTOFF:
-    case GL_CONSTANT_ATTENUATION:
-    case GL_LINEAR_ATTENUATION:
-    case GL_QUADRATIC_ATTENUATION:
-        return 1;
-    case GL_SPOT_DIRECTION:
-        return 3;
-    case GL_AMBIENT:
-    case GL_DIFFUSE:
-    case GL_SPECULAR:
-    case GL_POSITION:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_SPOT_EXPONENT:
+        case GL_SPOT_CUTOFF:
+        case GL_CONSTANT_ATTENUATION:
+        case GL_LINEAR_ATTENUATION:
+        case GL_QUADRATIC_ATTENUATION:
+            return 1;
+        case GL_SPOT_DIRECTION:
+            return 3;
+        case GL_AMBIENT:
+        case GL_DIFFUSE:
+        case GL_SPECULAR:
+        case GL_POSITION:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glLightModelfv_size(GLenum e)
+__glLightModelfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_LIGHT_MODEL_LOCAL_VIEWER:
-    case GL_LIGHT_MODEL_TWO_SIDE:
-    case GL_LIGHT_MODEL_COLOR_CONTROL:
+    switch( e ) {
+        case GL_LIGHT_MODEL_LOCAL_VIEWER:
+        case GL_LIGHT_MODEL_TWO_SIDE:
+        case GL_LIGHT_MODEL_COLOR_CONTROL:
 /*      case GL_LIGHT_MODEL_COLOR_CONTROL_EXT:*/
-        return 1;
-    case GL_LIGHT_MODEL_AMBIENT:
-        return 4;
-    default:
-        return 0;
+            return 1;
+        case GL_LIGHT_MODEL_AMBIENT:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glMaterialfv_size(GLenum e)
+__glMaterialfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_SHININESS:
-        return 1;
-    case GL_COLOR_INDEXES:
-        return 3;
-    case GL_AMBIENT:
-    case GL_DIFFUSE:
-    case GL_SPECULAR:
-    case GL_EMISSION:
-    case GL_AMBIENT_AND_DIFFUSE:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_SHININESS:
+            return 1;
+        case GL_COLOR_INDEXES:
+            return 3;
+        case GL_AMBIENT:
+        case GL_DIFFUSE:
+        case GL_SPECULAR:
+        case GL_EMISSION:
+        case GL_AMBIENT_AND_DIFFUSE:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glTexParameterfv_size(GLenum e)
+__glTexParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_TEXTURE_MAG_FILTER:
-    case GL_TEXTURE_MIN_FILTER:
-    case GL_TEXTURE_WRAP_S:
-    case GL_TEXTURE_WRAP_T:
-    case GL_TEXTURE_PRIORITY:
-    case GL_TEXTURE_WRAP_R:
-    case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
+    switch( e ) {
+        case GL_TEXTURE_MAG_FILTER:
+        case GL_TEXTURE_MIN_FILTER:
+        case GL_TEXTURE_WRAP_S:
+        case GL_TEXTURE_WRAP_T:
+        case GL_TEXTURE_PRIORITY:
+        case GL_TEXTURE_WRAP_R:
+        case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
 /*      case GL_SHADOW_AMBIENT_SGIX:*/
-    case GL_TEXTURE_MIN_LOD:
-    case GL_TEXTURE_MAX_LOD:
-    case GL_TEXTURE_BASE_LEVEL:
-    case GL_TEXTURE_MAX_LEVEL:
-    case GL_TEXTURE_CLIPMAP_FRAME_SGIX:
-    case GL_TEXTURE_LOD_BIAS_S_SGIX:
-    case GL_TEXTURE_LOD_BIAS_T_SGIX:
-    case GL_TEXTURE_LOD_BIAS_R_SGIX:
-    case GL_GENERATE_MIPMAP:
+        case GL_TEXTURE_MIN_LOD:
+        case GL_TEXTURE_MAX_LOD:
+        case GL_TEXTURE_BASE_LEVEL:
+        case GL_TEXTURE_MAX_LEVEL:
+        case GL_TEXTURE_CLIPMAP_FRAME_SGIX:
+        case GL_TEXTURE_LOD_BIAS_S_SGIX:
+        case GL_TEXTURE_LOD_BIAS_T_SGIX:
+        case GL_TEXTURE_LOD_BIAS_R_SGIX:
+        case GL_GENERATE_MIPMAP:
 /*      case GL_GENERATE_MIPMAP_SGIS:*/
-    case GL_TEXTURE_COMPARE_SGIX:
-    case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_S_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_T_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_R_SGIX:
-    case GL_TEXTURE_MAX_ANISOTROPY_EXT:
-    case GL_TEXTURE_LOD_BIAS:
+        case GL_TEXTURE_COMPARE_SGIX:
+        case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_S_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_T_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_R_SGIX:
+        case GL_TEXTURE_MAX_ANISOTROPY_EXT:
+        case GL_TEXTURE_LOD_BIAS:
 /*      case GL_TEXTURE_LOD_BIAS_EXT:*/
-    case GL_TEXTURE_STORAGE_HINT_APPLE:
-    case GL_STORAGE_PRIVATE_APPLE:
-    case GL_STORAGE_CACHED_APPLE:
-    case GL_STORAGE_SHARED_APPLE:
-    case GL_DEPTH_TEXTURE_MODE:
+        case GL_TEXTURE_STORAGE_HINT_APPLE:
+        case GL_STORAGE_PRIVATE_APPLE:
+        case GL_STORAGE_CACHED_APPLE:
+        case GL_STORAGE_SHARED_APPLE:
+        case GL_DEPTH_TEXTURE_MODE:
 /*      case GL_DEPTH_TEXTURE_MODE_ARB:*/
-    case GL_TEXTURE_COMPARE_MODE:
+        case GL_TEXTURE_COMPARE_MODE:
 /*      case GL_TEXTURE_COMPARE_MODE_ARB:*/
-    case GL_TEXTURE_COMPARE_FUNC:
+        case GL_TEXTURE_COMPARE_FUNC:
 /*      case GL_TEXTURE_COMPARE_FUNC_ARB:*/
-    case GL_TEXTURE_UNSIGNED_REMAP_MODE_NV:
-        return 1;
-    case GL_TEXTURE_CLIPMAP_CENTER_SGIX:
-    case GL_TEXTURE_CLIPMAP_OFFSET_SGIX:
-        return 2;
-    case GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:
-        return 3;
-    case GL_TEXTURE_BORDER_COLOR:
-    case GL_POST_TEXTURE_FILTER_BIAS_SGIX:
-    case GL_POST_TEXTURE_FILTER_SCALE_SGIX:
-        return 4;
-    default:
-        return 0;
+        case GL_TEXTURE_UNSIGNED_REMAP_MODE_NV:
+            return 1;
+        case GL_TEXTURE_CLIPMAP_CENTER_SGIX:
+        case GL_TEXTURE_CLIPMAP_OFFSET_SGIX:
+            return 2;
+        case GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:
+            return 3;
+        case GL_TEXTURE_BORDER_COLOR:
+        case GL_POST_TEXTURE_FILTER_BIAS_SGIX:
+        case GL_POST_TEXTURE_FILTER_SCALE_SGIX:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glTexEnvfv_size(GLenum e)
+__glTexEnvfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_ALPHA_SCALE:
-    case GL_TEXTURE_ENV_MODE:
-    case GL_TEXTURE_LOD_BIAS:
-    case GL_COMBINE_RGB:
-    case GL_COMBINE_ALPHA:
-    case GL_RGB_SCALE:
-    case GL_SOURCE0_RGB:
-    case GL_SOURCE1_RGB:
-    case GL_SOURCE2_RGB:
-    case GL_SOURCE3_RGB_NV:
-    case GL_SOURCE0_ALPHA:
-    case GL_SOURCE1_ALPHA:
-    case GL_SOURCE2_ALPHA:
-    case GL_SOURCE3_ALPHA_NV:
-    case GL_OPERAND0_RGB:
-    case GL_OPERAND1_RGB:
-    case GL_OPERAND2_RGB:
-    case GL_OPERAND3_RGB_NV:
-    case GL_OPERAND0_ALPHA:
-    case GL_OPERAND1_ALPHA:
-    case GL_OPERAND2_ALPHA:
-    case GL_OPERAND3_ALPHA_NV:
-    case GL_BUMP_TARGET_ATI:
-    case GL_COORD_REPLACE_ARB:
+    switch( e ) {
+        case GL_ALPHA_SCALE:
+        case GL_TEXTURE_ENV_MODE:
+        case GL_TEXTURE_LOD_BIAS:
+        case GL_COMBINE_RGB:
+        case GL_COMBINE_ALPHA:
+        case GL_RGB_SCALE:
+        case GL_SOURCE0_RGB:
+        case GL_SOURCE1_RGB:
+        case GL_SOURCE2_RGB:
+        case GL_SOURCE3_RGB_NV:
+        case GL_SOURCE0_ALPHA:
+        case GL_SOURCE1_ALPHA:
+        case GL_SOURCE2_ALPHA:
+        case GL_SOURCE3_ALPHA_NV:
+        case GL_OPERAND0_RGB:
+        case GL_OPERAND1_RGB:
+        case GL_OPERAND2_RGB:
+        case GL_OPERAND3_RGB_NV:
+        case GL_OPERAND0_ALPHA:
+        case GL_OPERAND1_ALPHA:
+        case GL_OPERAND2_ALPHA:
+        case GL_OPERAND3_ALPHA_NV:
+        case GL_BUMP_TARGET_ATI:
+        case GL_COORD_REPLACE_ARB:
 /*      case GL_COORD_REPLACE_NV:*/
-        return 1;
-    case GL_TEXTURE_ENV_COLOR:
-        return 4;
-    default:
-        return 0;
+            return 1;
+        case GL_TEXTURE_ENV_COLOR:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glTexGendv_size(GLenum e)
+__glTexGendv_size( GLenum e )
 {
-    switch (e) {
-    case GL_TEXTURE_GEN_MODE:
-        return 1;
-    case GL_OBJECT_PLANE:
-    case GL_EYE_PLANE:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_TEXTURE_GEN_MODE:
+            return 1;
+        case GL_OBJECT_PLANE:
+        case GL_EYE_PLANE:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glMap1d_size(GLenum e)
+__glMap1d_size( GLenum e )
 {
-    switch (e) {
-    case GL_MAP1_INDEX:
-    case GL_MAP1_TEXTURE_COORD_1:
-        return 1;
-    case GL_MAP1_TEXTURE_COORD_2:
-        return 2;
-    case GL_MAP1_NORMAL:
-    case GL_MAP1_TEXTURE_COORD_3:
-    case GL_MAP1_VERTEX_3:
-        return 3;
-    case GL_MAP1_COLOR_4:
-    case GL_MAP1_TEXTURE_COORD_4:
-    case GL_MAP1_VERTEX_4:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_MAP1_INDEX:
+        case GL_MAP1_TEXTURE_COORD_1:
+            return 1;
+        case GL_MAP1_TEXTURE_COORD_2:
+            return 2;
+        case GL_MAP1_NORMAL:
+        case GL_MAP1_TEXTURE_COORD_3:
+        case GL_MAP1_VERTEX_3:
+            return 3;
+        case GL_MAP1_COLOR_4:
+        case GL_MAP1_TEXTURE_COORD_4:
+        case GL_MAP1_VERTEX_4:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glMap2d_size(GLenum e)
+__glMap2d_size( GLenum e )
 {
-    switch (e) {
-    case GL_MAP2_INDEX:
-    case GL_MAP2_TEXTURE_COORD_1:
-        return 1;
-    case GL_MAP2_TEXTURE_COORD_2:
-        return 2;
-    case GL_MAP2_NORMAL:
-    case GL_MAP2_TEXTURE_COORD_3:
-    case GL_MAP2_VERTEX_3:
-        return 3;
-    case GL_MAP2_COLOR_4:
-    case GL_MAP2_TEXTURE_COORD_4:
-    case GL_MAP2_VERTEX_4:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_MAP2_INDEX:
+        case GL_MAP2_TEXTURE_COORD_1:
+            return 1;
+        case GL_MAP2_TEXTURE_COORD_2:
+            return 2;
+        case GL_MAP2_NORMAL:
+        case GL_MAP2_TEXTURE_COORD_3:
+        case GL_MAP2_VERTEX_3:
+            return 3;
+        case GL_MAP2_COLOR_4:
+        case GL_MAP2_TEXTURE_COORD_4:
+        case GL_MAP2_VERTEX_4:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetBooleanv_size(GLenum e)
+__glGetBooleanv_size( GLenum e )
 {
-    switch (e) {
-    case GL_CURRENT_INDEX:
-    case GL_CURRENT_RASTER_INDEX:
-    case GL_CURRENT_RASTER_POSITION_VALID:
-    case GL_CURRENT_RASTER_DISTANCE:
-    case GL_POINT_SMOOTH:
-    case GL_POINT_SIZE:
-    case GL_SMOOTH_POINT_SIZE_GRANULARITY:
-    case GL_LINE_SMOOTH:
-    case GL_LINE_WIDTH:
-    case GL_LINE_WIDTH_GRANULARITY:
-    case GL_LINE_STIPPLE:
-    case GL_LINE_STIPPLE_PATTERN:
-    case GL_LINE_STIPPLE_REPEAT:
-    case GL_LIST_MODE:
-    case GL_MAX_LIST_NESTING:
-    case GL_LIST_BASE:
-    case GL_LIST_INDEX:
-    case GL_POLYGON_SMOOTH:
-    case GL_POLYGON_STIPPLE:
-    case GL_EDGE_FLAG:
-    case GL_CULL_FACE:
-    case GL_CULL_FACE_MODE:
-    case GL_FRONT_FACE:
-    case GL_LIGHTING:
-    case GL_LIGHT_MODEL_LOCAL_VIEWER:
-    case GL_LIGHT_MODEL_TWO_SIDE:
-    case GL_SHADE_MODEL:
-    case GL_COLOR_MATERIAL_FACE:
-    case GL_COLOR_MATERIAL_PARAMETER:
-    case GL_COLOR_MATERIAL:
-    case GL_FOG:
-    case GL_FOG_INDEX:
-    case GL_FOG_DENSITY:
-    case GL_FOG_START:
-    case GL_FOG_END:
-    case GL_FOG_MODE:
-    case GL_DEPTH_TEST:
-    case GL_DEPTH_WRITEMASK:
-    case GL_DEPTH_CLEAR_VALUE:
-    case GL_DEPTH_FUNC:
-    case GL_STENCIL_TEST:
-    case GL_STENCIL_CLEAR_VALUE:
-    case GL_STENCIL_FUNC:
-    case GL_STENCIL_VALUE_MASK:
-    case GL_STENCIL_FAIL:
-    case GL_STENCIL_PASS_DEPTH_FAIL:
-    case GL_STENCIL_PASS_DEPTH_PASS:
-    case GL_STENCIL_REF:
-    case GL_STENCIL_WRITEMASK:
-    case GL_MATRIX_MODE:
-    case GL_NORMALIZE:
-    case GL_MODELVIEW_STACK_DEPTH:
-    case GL_PROJECTION_STACK_DEPTH:
-    case GL_TEXTURE_STACK_DEPTH:
-    case GL_ATTRIB_STACK_DEPTH:
-    case GL_CLIENT_ATTRIB_STACK_DEPTH:
-    case GL_ALPHA_TEST:
-    case GL_ALPHA_TEST_FUNC:
-    case GL_ALPHA_TEST_REF:
-    case GL_DITHER:
-    case GL_BLEND_DST:
-    case GL_BLEND_SRC:
-    case GL_BLEND:
-    case GL_LOGIC_OP_MODE:
-    case GL_LOGIC_OP:
-    case GL_AUX_BUFFERS:
-    case GL_DRAW_BUFFER:
-    case GL_READ_BUFFER:
-    case GL_SCISSOR_TEST:
-    case GL_INDEX_CLEAR_VALUE:
-    case GL_INDEX_WRITEMASK:
-    case GL_INDEX_MODE:
-    case GL_RGBA_MODE:
-    case GL_DOUBLEBUFFER:
-    case GL_STEREO:
-    case GL_RENDER_MODE:
-    case GL_PERSPECTIVE_CORRECTION_HINT:
-    case GL_POINT_SMOOTH_HINT:
-    case GL_LINE_SMOOTH_HINT:
-    case GL_POLYGON_SMOOTH_HINT:
-    case GL_FOG_HINT:
-    case GL_TEXTURE_GEN_S:
-    case GL_TEXTURE_GEN_T:
-    case GL_TEXTURE_GEN_R:
-    case GL_TEXTURE_GEN_Q:
-    case GL_PIXEL_MAP_I_TO_I:
-    case GL_PIXEL_MAP_I_TO_I_SIZE:
-    case GL_PIXEL_MAP_S_TO_S_SIZE:
-    case GL_PIXEL_MAP_I_TO_R_SIZE:
-    case GL_PIXEL_MAP_I_TO_G_SIZE:
-    case GL_PIXEL_MAP_I_TO_B_SIZE:
-    case GL_PIXEL_MAP_I_TO_A_SIZE:
-    case GL_PIXEL_MAP_R_TO_R_SIZE:
-    case GL_PIXEL_MAP_G_TO_G_SIZE:
-    case GL_PIXEL_MAP_B_TO_B_SIZE:
-    case GL_PIXEL_MAP_A_TO_A_SIZE:
-    case GL_UNPACK_SWAP_BYTES:
-    case GL_UNPACK_LSB_FIRST:
-    case GL_UNPACK_ROW_LENGTH:
-    case GL_UNPACK_SKIP_ROWS:
-    case GL_UNPACK_SKIP_PIXELS:
-    case GL_UNPACK_ALIGNMENT:
-    case GL_PACK_SWAP_BYTES:
-    case GL_PACK_LSB_FIRST:
-    case GL_PACK_ROW_LENGTH:
-    case GL_PACK_SKIP_ROWS:
-    case GL_PACK_SKIP_PIXELS:
-    case GL_PACK_ALIGNMENT:
-    case GL_MAP_COLOR:
-    case GL_MAP_STENCIL:
-    case GL_INDEX_SHIFT:
-    case GL_INDEX_OFFSET:
-    case GL_RED_SCALE:
-    case GL_RED_BIAS:
-    case GL_ZOOM_X:
-    case GL_ZOOM_Y:
-    case GL_GREEN_SCALE:
-    case GL_GREEN_BIAS:
-    case GL_BLUE_SCALE:
-    case GL_BLUE_BIAS:
-    case GL_ALPHA_SCALE:
-    case GL_ALPHA_BIAS:
-    case GL_DEPTH_SCALE:
-    case GL_DEPTH_BIAS:
-    case GL_MAX_EVAL_ORDER:
-    case GL_MAX_LIGHTS:
-    case GL_MAX_CLIP_PLANES:
-    case GL_MAX_TEXTURE_SIZE:
-    case GL_MAX_PIXEL_MAP_TABLE:
-    case GL_MAX_ATTRIB_STACK_DEPTH:
-    case GL_MAX_MODELVIEW_STACK_DEPTH:
-    case GL_MAX_NAME_STACK_DEPTH:
-    case GL_MAX_PROJECTION_STACK_DEPTH:
-    case GL_MAX_TEXTURE_STACK_DEPTH:
-    case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
-    case GL_SUBPIXEL_BITS:
-    case GL_INDEX_BITS:
-    case GL_RED_BITS:
-    case GL_GREEN_BITS:
-    case GL_BLUE_BITS:
-    case GL_ALPHA_BITS:
-    case GL_DEPTH_BITS:
-    case GL_STENCIL_BITS:
-    case GL_ACCUM_RED_BITS:
-    case GL_ACCUM_GREEN_BITS:
-    case GL_ACCUM_BLUE_BITS:
-    case GL_ACCUM_ALPHA_BITS:
-    case GL_NAME_STACK_DEPTH:
-    case GL_AUTO_NORMAL:
-    case GL_MAP1_COLOR_4:
-    case GL_MAP1_INDEX:
-    case GL_MAP1_NORMAL:
-    case GL_MAP1_TEXTURE_COORD_1:
-    case GL_MAP1_TEXTURE_COORD_2:
-    case GL_MAP1_TEXTURE_COORD_3:
-    case GL_MAP1_TEXTURE_COORD_4:
-    case GL_MAP1_VERTEX_3:
-    case GL_MAP1_VERTEX_4:
-    case GL_MAP2_COLOR_4:
-    case GL_MAP2_INDEX:
-    case GL_MAP2_NORMAL:
-    case GL_MAP2_TEXTURE_COORD_1:
-    case GL_MAP2_TEXTURE_COORD_2:
-    case GL_MAP2_TEXTURE_COORD_3:
-    case GL_MAP2_TEXTURE_COORD_4:
-    case GL_MAP2_VERTEX_3:
-    case GL_MAP2_VERTEX_4:
-    case GL_MAP1_GRID_SEGMENTS:
-    case GL_TEXTURE_1D:
-    case GL_TEXTURE_2D:
-    case GL_POLYGON_OFFSET_UNITS:
-    case GL_CLIP_PLANE0:
-    case GL_CLIP_PLANE1:
-    case GL_CLIP_PLANE2:
-    case GL_CLIP_PLANE3:
-    case GL_CLIP_PLANE4:
-    case GL_CLIP_PLANE5:
-    case GL_LIGHT0:
-    case GL_LIGHT1:
-    case GL_LIGHT2:
-    case GL_LIGHT3:
-    case GL_LIGHT4:
-    case GL_LIGHT5:
-    case GL_LIGHT6:
-    case GL_LIGHT7:
-    case GL_BLEND_EQUATION:
-/*      case GL_BLEND_EQUATION_EXT:*/
-    case GL_CONVOLUTION_1D:
-    case GL_CONVOLUTION_2D:
-    case GL_SEPARABLE_2D:
-    case GL_MAX_CONVOLUTION_WIDTH:
-/*      case GL_MAX_CONVOLUTION_WIDTH_EXT:*/
-    case GL_MAX_CONVOLUTION_HEIGHT:
-/*      case GL_MAX_CONVOLUTION_HEIGHT_EXT:*/
-    case GL_POST_CONVOLUTION_RED_SCALE:
-/*      case GL_POST_CONVOLUTION_RED_SCALE_EXT:*/
-    case GL_POST_CONVOLUTION_GREEN_SCALE:
-/*      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:*/
-    case GL_POST_CONVOLUTION_BLUE_SCALE:
-/*      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:*/
-    case GL_POST_CONVOLUTION_ALPHA_SCALE:
-/*      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:*/
-    case GL_POST_CONVOLUTION_RED_BIAS:
-/*      case GL_POST_CONVOLUTION_RED_BIAS_EXT:*/
-    case GL_POST_CONVOLUTION_GREEN_BIAS:
-/*      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:*/
-    case GL_POST_CONVOLUTION_BLUE_BIAS:
-/*      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:*/
-    case GL_POST_CONVOLUTION_ALPHA_BIAS:
-/*      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:*/
-    case GL_HISTOGRAM:
-    case GL_MINMAX:
-    case GL_POLYGON_OFFSET_FACTOR:
-    case GL_RESCALE_NORMAL:
+    switch( e ) {
+        case GL_COMPRESSED_TEXTURE_FORMATS:
+        case GL_MIN_PROGRAM_TEXEL_OFFSET:
+        case GL_MAX_PROGRAM_TEXEL_OFFSET:
+        case GL_RGBA_INTEGER_MODE_EXT:
+        case GL_POLYGON_OFFSET_CLAMP_EXT:
+        case GL_WINDOW_RECTANGLE_MODE_EXT:
+        case GL_MAX_WINDOW_RECTANGLES_EXT:
+        case GL_NUM_WINDOW_RECTANGLES_EXT:
+        case GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB:
+/*      case GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV:*/
+        case GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB:
+/*      case GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV:*/
+        case GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB:
+/*      case GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV:*/
+        case GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB:
+/*      case GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV:*/
+        case GL_CONSERVATIVE_RASTERIZATION_NV:
+        case GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV:
+        case GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV:
+        case GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV:
+        case GL_CONSERVATIVE_RASTER_DILATE_NV:
+        case GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV:
+        case GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV:
+        case GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB:
+        case GL_CONSERVATIVE_RASTER_MODE_NV:
+            return __glGetBooleanv_variable_size( e );
+        case GL_CURRENT_INDEX:
+        case GL_CURRENT_RASTER_INDEX:
+        case GL_CURRENT_RASTER_POSITION_VALID:
+        case GL_CURRENT_RASTER_DISTANCE:
+        case GL_POINT_SMOOTH:
+        case GL_POINT_SIZE:
+        case GL_SMOOTH_POINT_SIZE_GRANULARITY:
+        case GL_LINE_SMOOTH:
+        case GL_LINE_WIDTH:
+        case GL_SMOOTH_LINE_WIDTH_GRANULARITY:
+        case GL_LINE_STIPPLE:
+        case GL_LINE_STIPPLE_PATTERN:
+        case GL_LINE_STIPPLE_REPEAT:
+        case GL_LIST_MODE:
+        case GL_MAX_LIST_NESTING:
+        case GL_LIST_BASE:
+        case GL_LIST_INDEX:
+        case GL_POLYGON_SMOOTH:
+        case GL_POLYGON_STIPPLE:
+        case GL_EDGE_FLAG:
+        case GL_CULL_FACE:
+        case GL_CULL_FACE_MODE:
+        case GL_FRONT_FACE:
+        case GL_LIGHTING:
+        case GL_LIGHT_MODEL_LOCAL_VIEWER:
+        case GL_LIGHT_MODEL_TWO_SIDE:
+        case GL_SHADE_MODEL:
+        case GL_COLOR_MATERIAL_FACE:
+        case GL_COLOR_MATERIAL_PARAMETER:
+        case GL_COLOR_MATERIAL:
+        case GL_FOG:
+        case GL_FOG_INDEX:
+        case GL_FOG_DENSITY:
+        case GL_FOG_START:
+        case GL_FOG_END:
+        case GL_FOG_MODE:
+        case GL_DEPTH_TEST:
+        case GL_DEPTH_WRITEMASK:
+        case GL_DEPTH_CLEAR_VALUE:
+        case GL_DEPTH_FUNC:
+        case GL_STENCIL_TEST:
+        case GL_STENCIL_CLEAR_VALUE:
+        case GL_STENCIL_FUNC:
+        case GL_STENCIL_VALUE_MASK:
+        case GL_STENCIL_FAIL:
+        case GL_STENCIL_PASS_DEPTH_FAIL:
+        case GL_STENCIL_PASS_DEPTH_PASS:
+        case GL_STENCIL_REF:
+        case GL_STENCIL_WRITEMASK:
+        case GL_MATRIX_MODE:
+        case GL_NORMALIZE:
+        case GL_MODELVIEW_STACK_DEPTH:
+        case GL_PROJECTION_STACK_DEPTH:
+        case GL_TEXTURE_STACK_DEPTH:
+        case GL_ATTRIB_STACK_DEPTH:
+        case GL_CLIENT_ATTRIB_STACK_DEPTH:
+        case GL_ALPHA_TEST:
+        case GL_ALPHA_TEST_FUNC:
+        case GL_ALPHA_TEST_REF:
+        case GL_DITHER:
+        case GL_BLEND_DST:
+        case GL_BLEND_SRC:
+        case GL_BLEND:
+        case GL_LOGIC_OP_MODE:
+        case GL_LOGIC_OP:
+        case GL_AUX_BUFFERS:
+        case GL_DRAW_BUFFER:
+        case GL_READ_BUFFER:
+        case GL_SCISSOR_TEST:
+        case GL_INDEX_CLEAR_VALUE:
+        case GL_INDEX_WRITEMASK:
+        case GL_INDEX_MODE:
+        case GL_RGBA_MODE:
+        case GL_DOUBLEBUFFER:
+        case GL_STEREO:
+        case GL_RENDER_MODE:
+        case GL_PERSPECTIVE_CORRECTION_HINT:
+        case GL_POINT_SMOOTH_HINT:
+        case GL_LINE_SMOOTH_HINT:
+        case GL_POLYGON_SMOOTH_HINT:
+        case GL_FOG_HINT:
+        case GL_TEXTURE_GEN_S:
+        case GL_TEXTURE_GEN_T:
+        case GL_TEXTURE_GEN_R:
+        case GL_TEXTURE_GEN_Q:
+        case GL_PIXEL_MAP_I_TO_I:
+        case GL_PIXEL_MAP_I_TO_I_SIZE:
+        case GL_PIXEL_MAP_S_TO_S_SIZE:
+        case GL_PIXEL_MAP_I_TO_R_SIZE:
+        case GL_PIXEL_MAP_I_TO_G_SIZE:
+        case GL_PIXEL_MAP_I_TO_B_SIZE:
+        case GL_PIXEL_MAP_I_TO_A_SIZE:
+        case GL_PIXEL_MAP_R_TO_R_SIZE:
+        case GL_PIXEL_MAP_G_TO_G_SIZE:
+        case GL_PIXEL_MAP_B_TO_B_SIZE:
+        case GL_PIXEL_MAP_A_TO_A_SIZE:
+        case GL_UNPACK_SWAP_BYTES:
+        case GL_UNPACK_LSB_FIRST:
+        case GL_UNPACK_ROW_LENGTH:
+        case GL_UNPACK_SKIP_ROWS:
+        case GL_UNPACK_SKIP_PIXELS:
+        case GL_UNPACK_ALIGNMENT:
+        case GL_PACK_SWAP_BYTES:
+        case GL_PACK_LSB_FIRST:
+        case GL_PACK_ROW_LENGTH:
+        case GL_PACK_SKIP_ROWS:
+        case GL_PACK_SKIP_PIXELS:
+        case GL_PACK_ALIGNMENT:
+        case GL_MAP_COLOR:
+        case GL_MAP_STENCIL:
+        case GL_INDEX_SHIFT:
+        case GL_INDEX_OFFSET:
+        case GL_RED_SCALE:
+        case GL_RED_BIAS:
+        case GL_ZOOM_X:
+        case GL_ZOOM_Y:
+        case GL_GREEN_SCALE:
+        case GL_GREEN_BIAS:
+        case GL_BLUE_SCALE:
+        case GL_BLUE_BIAS:
+        case GL_ALPHA_SCALE:
+        case GL_ALPHA_BIAS:
+        case GL_DEPTH_SCALE:
+        case GL_DEPTH_BIAS:
+        case GL_MAX_EVAL_ORDER:
+        case GL_MAX_LIGHTS:
+        case GL_MAX_CLIP_PLANES:
+        case GL_MAX_TEXTURE_SIZE:
+        case GL_MAX_PIXEL_MAP_TABLE:
+        case GL_MAX_ATTRIB_STACK_DEPTH:
+        case GL_MAX_MODELVIEW_STACK_DEPTH:
+        case GL_MAX_NAME_STACK_DEPTH:
+        case GL_MAX_PROJECTION_STACK_DEPTH:
+        case GL_MAX_TEXTURE_STACK_DEPTH:
+        case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
+        case GL_SUBPIXEL_BITS:
+        case GL_INDEX_BITS:
+        case GL_RED_BITS:
+        case GL_GREEN_BITS:
+        case GL_BLUE_BITS:
+        case GL_ALPHA_BITS:
+        case GL_DEPTH_BITS:
+        case GL_STENCIL_BITS:
+        case GL_ACCUM_RED_BITS:
+        case GL_ACCUM_GREEN_BITS:
+        case GL_ACCUM_BLUE_BITS:
+        case GL_ACCUM_ALPHA_BITS:
+        case GL_NAME_STACK_DEPTH:
+        case GL_AUTO_NORMAL:
+        case GL_MAP1_COLOR_4:
+        case GL_MAP1_INDEX:
+        case GL_MAP1_NORMAL:
+        case GL_MAP1_TEXTURE_COORD_1:
+        case GL_MAP1_TEXTURE_COORD_2:
+        case GL_MAP1_TEXTURE_COORD_3:
+        case GL_MAP1_TEXTURE_COORD_4:
+        case GL_MAP1_VERTEX_3:
+        case GL_MAP1_VERTEX_4:
+        case GL_MAP2_COLOR_4:
+        case GL_MAP2_INDEX:
+        case GL_MAP2_NORMAL:
+        case GL_MAP2_TEXTURE_COORD_1:
+        case GL_MAP2_TEXTURE_COORD_2:
+        case GL_MAP2_TEXTURE_COORD_3:
+        case GL_MAP2_TEXTURE_COORD_4:
+        case GL_MAP2_VERTEX_3:
+        case GL_MAP2_VERTEX_4:
+        case GL_MAP1_GRID_SEGMENTS:
+        case GL_TEXTURE_1D:
+        case GL_TEXTURE_2D:
+        case GL_POLYGON_OFFSET_UNITS:
+        case GL_CLIP_PLANE0:
+        case GL_CLIP_PLANE1:
+        case GL_CLIP_PLANE2:
+        case GL_CLIP_PLANE3:
+        case GL_CLIP_PLANE4:
+        case GL_CLIP_PLANE5:
+        case GL_LIGHT0:
+        case GL_LIGHT1:
+        case GL_LIGHT2:
+        case GL_LIGHT3:
+        case GL_LIGHT4:
+        case GL_LIGHT5:
+        case GL_LIGHT6:
+        case GL_LIGHT7:
+        case GL_BLEND_EQUATION:
+/*      case GL_BLEND_EQUATION_RGB_EXT:*/
+        case GL_CONVOLUTION_1D:
+        case GL_CONVOLUTION_2D:
+        case GL_SEPARABLE_2D:
+        case GL_MAX_CONVOLUTION_WIDTH:
+        case GL_MAX_CONVOLUTION_HEIGHT:
+        case GL_POST_CONVOLUTION_RED_SCALE:
+        case GL_POST_CONVOLUTION_GREEN_SCALE:
+        case GL_POST_CONVOLUTION_BLUE_SCALE:
+        case GL_POST_CONVOLUTION_ALPHA_SCALE:
+        case GL_POST_CONVOLUTION_RED_BIAS:
+        case GL_POST_CONVOLUTION_GREEN_BIAS:
+        case GL_POST_CONVOLUTION_BLUE_BIAS:
+        case GL_POST_CONVOLUTION_ALPHA_BIAS:
+        case GL_HISTOGRAM:
+        case GL_MINMAX:
+        case GL_POLYGON_OFFSET_FACTOR:
+        case GL_RESCALE_NORMAL:
 /*      case GL_RESCALE_NORMAL_EXT:*/
-    case GL_TEXTURE_BINDING_1D:
-    case GL_TEXTURE_BINDING_2D:
-    case GL_TEXTURE_BINDING_3D:
-    case GL_PACK_SKIP_IMAGES:
-    case GL_PACK_IMAGE_HEIGHT:
-    case GL_UNPACK_SKIP_IMAGES:
-    case GL_UNPACK_IMAGE_HEIGHT:
-    case GL_TEXTURE_3D:
-    case GL_MAX_3D_TEXTURE_SIZE:
-    case GL_VERTEX_ARRAY:
-    case GL_NORMAL_ARRAY:
-    case GL_COLOR_ARRAY:
-    case GL_INDEX_ARRAY:
-    case GL_TEXTURE_COORD_ARRAY:
-    case GL_EDGE_FLAG_ARRAY:
-    case GL_VERTEX_ARRAY_SIZE:
-    case GL_VERTEX_ARRAY_TYPE:
-    case GL_VERTEX_ARRAY_STRIDE:
-    case GL_NORMAL_ARRAY_TYPE:
-    case GL_NORMAL_ARRAY_STRIDE:
-    case GL_COLOR_ARRAY_SIZE:
-    case GL_COLOR_ARRAY_TYPE:
-    case GL_COLOR_ARRAY_STRIDE:
-    case GL_INDEX_ARRAY_TYPE:
-    case GL_INDEX_ARRAY_STRIDE:
-    case GL_TEXTURE_COORD_ARRAY_SIZE:
-    case GL_TEXTURE_COORD_ARRAY_TYPE:
-    case GL_TEXTURE_COORD_ARRAY_STRIDE:
-    case GL_EDGE_FLAG_ARRAY_STRIDE:
-    case GL_MULTISAMPLE:
+        case GL_TEXTURE_BINDING_1D:
+        case GL_TEXTURE_BINDING_2D:
+        case GL_TEXTURE_BINDING_3D:
+        case GL_PACK_SKIP_IMAGES:
+        case GL_PACK_IMAGE_HEIGHT:
+        case GL_UNPACK_SKIP_IMAGES:
+        case GL_UNPACK_IMAGE_HEIGHT:
+        case GL_TEXTURE_3D:
+        case GL_MAX_3D_TEXTURE_SIZE:
+        case GL_VERTEX_ARRAY:
+        case GL_NORMAL_ARRAY:
+        case GL_COLOR_ARRAY:
+        case GL_INDEX_ARRAY:
+        case GL_TEXTURE_COORD_ARRAY:
+        case GL_EDGE_FLAG_ARRAY:
+        case GL_VERTEX_ARRAY_SIZE:
+        case GL_VERTEX_ARRAY_TYPE:
+        case GL_VERTEX_ARRAY_STRIDE:
+        case GL_NORMAL_ARRAY_TYPE:
+        case GL_NORMAL_ARRAY_STRIDE:
+        case GL_COLOR_ARRAY_SIZE:
+        case GL_COLOR_ARRAY_TYPE:
+        case GL_COLOR_ARRAY_STRIDE:
+        case GL_INDEX_ARRAY_TYPE:
+        case GL_INDEX_ARRAY_STRIDE:
+        case GL_TEXTURE_COORD_ARRAY_SIZE:
+        case GL_TEXTURE_COORD_ARRAY_TYPE:
+        case GL_TEXTURE_COORD_ARRAY_STRIDE:
+        case GL_EDGE_FLAG_ARRAY_STRIDE:
+        case GL_MULTISAMPLE:
 /*      case GL_MULTISAMPLE_ARB:*/
-    case GL_SAMPLE_ALPHA_TO_COVERAGE:
+        case GL_SAMPLE_ALPHA_TO_COVERAGE:
 /*      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:*/
-    case GL_SAMPLE_ALPHA_TO_ONE:
+        case GL_SAMPLE_ALPHA_TO_ONE:
 /*      case GL_SAMPLE_ALPHA_TO_ONE_ARB:*/
-    case GL_SAMPLE_COVERAGE:
+        case GL_SAMPLE_COVERAGE:
 /*      case GL_SAMPLE_COVERAGE_ARB:*/
-    case GL_SAMPLE_BUFFERS:
+        case GL_SAMPLE_BUFFERS:
 /*      case GL_SAMPLE_BUFFERS_ARB:*/
-    case GL_SAMPLES:
+        case GL_SAMPLES:
 /*      case GL_SAMPLES_ARB:*/
-    case GL_SAMPLE_COVERAGE_VALUE:
+        case GL_SAMPLE_COVERAGE_VALUE:
 /*      case GL_SAMPLE_COVERAGE_VALUE_ARB:*/
-    case GL_SAMPLE_COVERAGE_INVERT:
+        case GL_SAMPLE_COVERAGE_INVERT:
 /*      case GL_SAMPLE_COVERAGE_INVERT_ARB:*/
-    case GL_COLOR_MATRIX_STACK_DEPTH:
-    case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
-    case GL_POST_COLOR_MATRIX_RED_SCALE:
-    case GL_POST_COLOR_MATRIX_GREEN_SCALE:
-    case GL_POST_COLOR_MATRIX_BLUE_SCALE:
-    case GL_POST_COLOR_MATRIX_ALPHA_SCALE:
-    case GL_POST_COLOR_MATRIX_RED_BIAS:
-    case GL_POST_COLOR_MATRIX_GREEN_BIAS:
-    case GL_POST_COLOR_MATRIX_BLUE_BIAS:
-    case GL_POST_COLOR_MATRIX_ALPHA_BIAS:
-    case GL_BLEND_DST_RGB:
-    case GL_BLEND_SRC_RGB:
-    case GL_BLEND_DST_ALPHA:
-    case GL_BLEND_SRC_ALPHA:
-    case GL_COLOR_TABLE:
-    case GL_POST_CONVOLUTION_COLOR_TABLE:
-    case GL_POST_COLOR_MATRIX_COLOR_TABLE:
-    case GL_MAX_ELEMENTS_VERTICES:
-    case GL_MAX_ELEMENTS_INDICES:
-    case GL_CLIP_VOLUME_CLIPPING_HINT_EXT:
-    case GL_POINT_SIZE_MIN:
-    case GL_POINT_SIZE_MAX:
-    case GL_POINT_FADE_THRESHOLD_SIZE:
-    case GL_OCCLUSION_TEST_HP:
-    case GL_OCCLUSION_TEST_RESULT_HP:
-    case GL_LIGHT_MODEL_COLOR_CONTROL:
-    case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB:
-    case GL_RESET_NOTIFICATION_STRATEGY_ARB:
-    case GL_CURRENT_FOG_COORD:
-    case GL_FOG_COORDINATE_ARRAY_TYPE:
-    case GL_FOG_COORDINATE_ARRAY_STRIDE:
-    case GL_FOG_COORD_ARRAY:
-    case GL_COLOR_SUM_ARB:
-    case GL_SECONDARY_COLOR_ARRAY_SIZE:
-    case GL_SECONDARY_COLOR_ARRAY_TYPE:
-    case GL_SECONDARY_COLOR_ARRAY_STRIDE:
-    case GL_SECONDARY_COLOR_ARRAY:
-    case GL_ACTIVE_TEXTURE:
+        case GL_COLOR_MATRIX_STACK_DEPTH:
+        case GL_MAX_COLOR_MATRIX_STACK_DEPTH:
+        case GL_POST_COLOR_MATRIX_RED_SCALE:
+        case GL_POST_COLOR_MATRIX_GREEN_SCALE:
+        case GL_POST_COLOR_MATRIX_BLUE_SCALE:
+        case GL_POST_COLOR_MATRIX_ALPHA_SCALE:
+        case GL_POST_COLOR_MATRIX_RED_BIAS:
+        case GL_POST_COLOR_MATRIX_GREEN_BIAS:
+        case GL_POST_COLOR_MATRIX_BLUE_BIAS:
+        case GL_POST_COLOR_MATRIX_ALPHA_BIAS:
+        case GL_BLEND_DST_RGB:
+        case GL_BLEND_SRC_RGB:
+        case GL_BLEND_DST_ALPHA:
+        case GL_BLEND_SRC_ALPHA:
+        case GL_COLOR_TABLE:
+        case GL_POST_CONVOLUTION_COLOR_TABLE:
+        case GL_POST_COLOR_MATRIX_COLOR_TABLE:
+        case GL_MAX_ELEMENTS_VERTICES:
+        case GL_MAX_ELEMENTS_INDICES:
+        case GL_CLIP_VOLUME_CLIPPING_HINT_EXT:
+        case GL_POINT_SIZE_MIN:
+        case GL_POINT_SIZE_MAX:
+        case GL_POINT_FADE_THRESHOLD_SIZE:
+        case GL_OCCLUSION_TEST_HP:
+        case GL_OCCLUSION_TEST_RESULT_HP:
+        case GL_LIGHT_MODEL_COLOR_CONTROL:
+        case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB:
+/*      case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:*/
+        case GL_RESET_NOTIFICATION_STRATEGY_ARB:
+/*      case GL_RESET_NOTIFICATION_STRATEGY:*/
+        case GL_MAX_DEBUG_GROUP_STACK_DEPTH:
+        case GL_DEBUG_GROUP_STACK_DEPTH:
+        case GL_MAX_UNIFORM_LOCATIONS:
+        case GL_MAX_LABEL_LENGTH:
+        case GL_FOG_COORD_SRC:
+        case GL_CURRENT_FOG_COORD:
+        case GL_FOG_COORD_ARRAY_TYPE:
+        case GL_FOG_COORD_ARRAY_STRIDE:
+        case GL_FOG_COORD_ARRAY:
+        case GL_COLOR_SUM_ARB:
+        case GL_SECONDARY_COLOR_ARRAY_SIZE:
+        case GL_SECONDARY_COLOR_ARRAY_TYPE:
+        case GL_SECONDARY_COLOR_ARRAY_STRIDE:
+        case GL_SECONDARY_COLOR_ARRAY:
+        case GL_ACTIVE_TEXTURE:
 /*      case GL_ACTIVE_TEXTURE_ARB:*/
-    case GL_CLIENT_ACTIVE_TEXTURE:
+        case GL_CLIENT_ACTIVE_TEXTURE:
 /*      case GL_CLIENT_ACTIVE_TEXTURE_ARB:*/
-    case GL_MAX_TEXTURE_UNITS:
+        case GL_MAX_TEXTURE_UNITS:
 /*      case GL_MAX_TEXTURE_UNITS_ARB:*/
-    case GL_MAX_RENDERBUFFER_SIZE:
+        case GL_MAX_RENDERBUFFER_SIZE:
 /*      case GL_MAX_RENDERBUFFER_SIZE_EXT:*/
-    case GL_TEXTURE_COMPRESSION_HINT:
+        case GL_TEXTURE_COMPRESSION_HINT:
 /*      case GL_TEXTURE_COMPRESSION_HINT_ARB:*/
-    case GL_TEXTURE_RECTANGLE_ARB:
+        case GL_TEXTURE_RECTANGLE_ARB:
 /*      case GL_TEXTURE_RECTANGLE_NV:*/
-    case GL_TEXTURE_BINDING_RECTANGLE_ARB:
+        case GL_TEXTURE_BINDING_RECTANGLE_ARB:
 /*      case GL_TEXTURE_BINDING_RECTANGLE_NV:*/
-    case GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB:
+        case GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB:
 /*      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:*/
-    case GL_MAX_TEXTURE_LOD_BIAS:
-    case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
-    case GL_MAX_SHININESS_NV:
-    case GL_MAX_SPOT_EXPONENT_NV:
-    case GL_TEXTURE_CUBE_MAP:
+        case GL_MAX_TEXTURE_LOD_BIAS:
+        case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
+        case GL_MAX_SHININESS_NV:
+        case GL_MAX_SPOT_EXPONENT_NV:
+        case GL_TEXTURE_CUBE_MAP:
 /*      case GL_TEXTURE_CUBE_MAP_ARB:*/
-    case GL_TEXTURE_BINDING_CUBE_MAP:
+        case GL_TEXTURE_BINDING_CUBE_MAP:
 /*      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:*/
-    case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
+        case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
 /*      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:*/
-    case GL_MULTISAMPLE_FILTER_HINT_NV:
-    case GL_FOG_DISTANCE_MODE_NV:
-    case GL_VERTEX_PROGRAM_ARB:
-    case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
-    case GL_MAX_PROGRAM_MATRICES_ARB:
-    case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
-    case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
-    case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
-    case GL_PROGRAM_ERROR_POSITION_ARB:
-    case GL_DEPTH_CLAMP:
+        case GL_MULTISAMPLE_FILTER_HINT_NV:
+        case GL_FOG_DISTANCE_MODE_NV:
+        case GL_VERTEX_PROGRAM_ARB:
+        case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
+        case GL_MAX_PROGRAM_MATRICES_ARB:
+        case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
+        case GL_VERTEX_PROGRAM_POINT_SIZE_ARB:
+        case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
+        case GL_PROGRAM_ERROR_POSITION_ARB:
+        case GL_DEPTH_CLAMP:
 /*      case GL_DEPTH_CLAMP_NV:*/
-    case GL_NUM_COMPRESSED_TEXTURE_FORMATS:
+        case GL_NUM_COMPRESSED_TEXTURE_FORMATS:
 /*      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:*/
-    case GL_MAX_VERTEX_UNITS_ARB:
-    case GL_ACTIVE_VERTEX_UNITS_ARB:
-    case GL_WEIGHT_SUM_UNITY_ARB:
-    case GL_VERTEX_BLEND_ARB:
-    case GL_CURRENT_WEIGHT_ARB:
-    case GL_WEIGHT_ARRAY_TYPE_ARB:
-    case GL_WEIGHT_ARRAY_STRIDE_ARB:
-    case GL_WEIGHT_ARRAY_SIZE_ARB:
-    case GL_WEIGHT_ARRAY_ARB:
-    case GL_PACK_INVERT_MESA:
-    case GL_STENCIL_BACK_FUNC_ATI:
-    case GL_STENCIL_BACK_FAIL_ATI:
-    case GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI:
-    case GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI:
-    case GL_FRAGMENT_PROGRAM_ARB:
-    case GL_MAX_DRAW_BUFFERS_ARB:
+        case GL_MAX_VERTEX_UNITS_ARB:
+        case GL_ACTIVE_VERTEX_UNITS_ARB:
+        case GL_WEIGHT_SUM_UNITY_ARB:
+        case GL_VERTEX_BLEND_ARB:
+        case GL_CURRENT_WEIGHT_ARB:
+        case GL_WEIGHT_ARRAY_TYPE_ARB:
+        case GL_WEIGHT_ARRAY_STRIDE_ARB:
+        case GL_WEIGHT_ARRAY_SIZE_ARB:
+        case GL_WEIGHT_ARRAY_ARB:
+        case GL_PACK_INVERT_MESA:
+        case GL_STENCIL_BACK_FUNC_ATI:
+        case GL_STENCIL_BACK_FAIL_ATI:
+        case GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI:
+        case GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI:
+        case GL_FRAGMENT_PROGRAM_ARB:
+        case GL_MAX_DRAW_BUFFERS_ARB:
 /*      case GL_MAX_DRAW_BUFFERS_ATI:*/
-    case GL_DRAW_BUFFER0_ARB:
+        case GL_DRAW_BUFFER0_ARB:
 /*      case GL_DRAW_BUFFER0_ATI:*/
-    case GL_DRAW_BUFFER1_ARB:
+        case GL_DRAW_BUFFER1_ARB:
 /*      case GL_DRAW_BUFFER1_ATI:*/
-    case GL_DRAW_BUFFER2_ARB:
+        case GL_DRAW_BUFFER2_ARB:
 /*      case GL_DRAW_BUFFER2_ATI:*/
-    case GL_DRAW_BUFFER3_ARB:
+        case GL_DRAW_BUFFER3_ARB:
 /*      case GL_DRAW_BUFFER3_ATI:*/
-    case GL_DRAW_BUFFER4_ARB:
+        case GL_DRAW_BUFFER4_ARB:
 /*      case GL_DRAW_BUFFER4_ATI:*/
-    case GL_DRAW_BUFFER5_ARB:
+        case GL_DRAW_BUFFER5_ARB:
 /*      case GL_DRAW_BUFFER5_ATI:*/
-    case GL_DRAW_BUFFER6_ARB:
+        case GL_DRAW_BUFFER6_ARB:
 /*      case GL_DRAW_BUFFER6_ATI:*/
-    case GL_DRAW_BUFFER7_ARB:
+        case GL_DRAW_BUFFER7_ARB:
 /*      case GL_DRAW_BUFFER7_ATI:*/
-    case GL_DRAW_BUFFER8_ARB:
+        case GL_DRAW_BUFFER8_ARB:
 /*      case GL_DRAW_BUFFER8_ATI:*/
-    case GL_DRAW_BUFFER9_ARB:
+        case GL_DRAW_BUFFER9_ARB:
 /*      case GL_DRAW_BUFFER9_ATI:*/
-    case GL_DRAW_BUFFER10_ARB:
+        case GL_DRAW_BUFFER10_ARB:
 /*      case GL_DRAW_BUFFER10_ATI:*/
-    case GL_DRAW_BUFFER11_ARB:
+        case GL_DRAW_BUFFER11_ARB:
 /*      case GL_DRAW_BUFFER11_ATI:*/
-    case GL_DRAW_BUFFER12_ARB:
+        case GL_DRAW_BUFFER12_ARB:
 /*      case GL_DRAW_BUFFER12_ATI:*/
-    case GL_DRAW_BUFFER13_ARB:
+        case GL_DRAW_BUFFER13_ARB:
 /*      case GL_DRAW_BUFFER13_ATI:*/
-    case GL_DRAW_BUFFER14_ARB:
+        case GL_DRAW_BUFFER14_ARB:
 /*      case GL_DRAW_BUFFER14_ATI:*/
-    case GL_DRAW_BUFFER15_ARB:
+        case GL_DRAW_BUFFER15_ARB:
 /*      case GL_DRAW_BUFFER15_ATI:*/
-    case GL_BLEND_EQUATION_ALPHA_EXT:
-    case GL_MATRIX_PALETTE_ARB:
-    case GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB:
-    case GL_MAX_PALETTE_MATRICES_ARB:
-    case GL_CURRENT_PALETTE_MATRIX_ARB:
-    case GL_MATRIX_INDEX_ARRAY_ARB:
-    case GL_CURRENT_MATRIX_INDEX_ARB:
-    case GL_MATRIX_INDEX_ARRAY_SIZE_ARB:
-    case GL_MATRIX_INDEX_ARRAY_TYPE_ARB:
-    case GL_MATRIX_INDEX_ARRAY_STRIDE_ARB:
-    case GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT:
-    case GL_TEXTURE_CUBE_MAP_SEAMLESS:
-    case GL_POINT_SPRITE_ARB:
+        case GL_BLEND_EQUATION_ALPHA_EXT:
+        case GL_MATRIX_PALETTE_ARB:
+        case GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB:
+        case GL_MAX_PALETTE_MATRICES_ARB:
+        case GL_CURRENT_PALETTE_MATRIX_ARB:
+        case GL_MATRIX_INDEX_ARRAY_ARB:
+        case GL_CURRENT_MATRIX_INDEX_ARB:
+        case GL_MATRIX_INDEX_ARRAY_SIZE_ARB:
+        case GL_MATRIX_INDEX_ARRAY_TYPE_ARB:
+        case GL_MATRIX_INDEX_ARRAY_STRIDE_ARB:
+        case GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT:
+        case GL_TEXTURE_CUBE_MAP_SEAMLESS:
+        case GL_POINT_SPRITE_ARB:
 /*      case GL_POINT_SPRITE_NV:*/
-    case GL_POINT_SPRITE_R_MODE_NV:
-    case GL_MAX_VERTEX_ATTRIBS_ARB:
-    case GL_MAX_TEXTURE_COORDS_ARB:
-    case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
-    case GL_DEPTH_BOUNDS_TEST_EXT:
-    case GL_ARRAY_BUFFER_BINDING_ARB:
-    case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
-    case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
-    case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
-    case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
-    case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
-    case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
-    case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
-    case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
-    case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
-    case GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB:
-    case GL_MAX_ARRAY_TEXTURE_LAYERS_EXT:
-    case GL_STENCIL_TEST_TWO_SIDE_EXT:
-    case GL_ACTIVE_STENCIL_FACE_EXT:
-    case GL_SAMPLER_BINDING:
-    case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
-    case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
-    case GL_FRAMEBUFFER_BINDING:
+        case GL_POINT_SPRITE_R_MODE_NV:
+        case GL_MAX_VERTEX_ATTRIBS_ARB:
+        case GL_MAX_TEXTURE_COORDS_ARB:
+        case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
+        case GL_DEPTH_BOUNDS_TEST_EXT:
+        case GL_ARRAY_BUFFER_BINDING_ARB:
+        case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
+        case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
+        case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
+        case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
+        case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
+        case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
+        case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
+        case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
+        case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
+        case GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB:
+        case GL_MAX_ARRAY_TEXTURE_LAYERS_EXT:
+        case GL_STENCIL_TEST_TWO_SIDE_EXT:
+        case GL_ACTIVE_STENCIL_FACE_EXT:
+        case GL_SAMPLER_BINDING:
+        case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
+        case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
+        case GL_DRAW_FRAMEBUFFER_BINDING:
 /*      case GL_DRAW_FRAMEBUFFER_BINDING_EXT:*/
-    case GL_RENDERBUFFER_BINDING:
+        case GL_RENDERBUFFER_BINDING:
 /*      case GL_RENDERBUFFER_BINDING_EXT:*/
-    case GL_READ_FRAMEBUFFER_BINDING:
+        case GL_READ_FRAMEBUFFER_BINDING:
 /*      case GL_READ_FRAMEBUFFER_BINDING_EXT:*/
-    case GL_MAX_COLOR_ATTACHMENTS:
+        case GL_MAX_COLOR_ATTACHMENTS:
 /*      case GL_MAX_COLOR_ATTACHMENTS_EXT:*/
-    case GL_MAX_SAMPLES:
+        case GL_MAX_SAMPLES:
 /*      case GL_MAX_SAMPLES_EXT:*/
-    case GL_MAX_SERVER_WAIT_TIMEOUT:
-    case GL_MAX_DEBUG_MESSAGE_LENGTH_ARB:
-    case GL_MAX_DEBUG_LOGGED_MESSAGES_ARB:
-    case GL_DEBUG_LOGGED_MESSAGES_ARB:
-    case GL_RASTER_POSITION_UNCLIPPED_IBM:
-        return 1;
-    case GL_SMOOTH_POINT_SIZE_RANGE:
-    case GL_LINE_WIDTH_RANGE:
-    case GL_POLYGON_MODE:
-    case GL_DEPTH_RANGE:
-    case GL_MAX_VIEWPORT_DIMS:
-    case GL_MAP1_GRID_DOMAIN:
-    case GL_MAP2_GRID_SEGMENTS:
-    case GL_ALIASED_POINT_SIZE_RANGE:
-    case GL_ALIASED_LINE_WIDTH_RANGE:
-    case GL_DEPTH_BOUNDS_EXT:
-        return 2;
-    case GL_CURRENT_NORMAL:
-    case GL_POINT_DISTANCE_ATTENUATION:
-        return 3;
-    case GL_CURRENT_COLOR:
-    case GL_CURRENT_TEXTURE_COORDS:
-    case GL_CURRENT_RASTER_COLOR:
-    case GL_CURRENT_RASTER_TEXTURE_COORDS:
-    case GL_CURRENT_RASTER_POSITION:
-    case GL_LIGHT_MODEL_AMBIENT:
-    case GL_FOG_COLOR:
-    case GL_ACCUM_CLEAR_VALUE:
-    case GL_VIEWPORT:
-    case GL_SCISSOR_BOX:
-    case GL_COLOR_CLEAR_VALUE:
-    case GL_COLOR_WRITEMASK:
-    case GL_MAP2_GRID_DOMAIN:
-    case GL_BLEND_COLOR:
+        case GL_DEPTH_CLAMP_NEAR_AMD:
+        case GL_DEPTH_CLAMP_FAR_AMD:
+        case GL_CONTEXT_ROBUST_ACCESS:
+        case GL_MAX_SERVER_WAIT_TIMEOUT:
+        case GL_MAX_DEBUG_MESSAGE_LENGTH_ARB:
+/*      case GL_MAX_DEBUG_MESSAGE_LENGTH:*/
+        case GL_MAX_DEBUG_LOGGED_MESSAGES_ARB:
+/*      case GL_MAX_DEBUG_LOGGED_MESSAGES:*/
+        case GL_DEBUG_LOGGED_MESSAGES_ARB:
+/*      case GL_DEBUG_LOGGED_MESSAGES:*/
+        case GL_RASTER_POSITION_UNCLIPPED_IBM:
+            return 1;
+        case GL_SMOOTH_POINT_SIZE_RANGE:
+        case GL_SMOOTH_LINE_WIDTH_RANGE:
+        case GL_POLYGON_MODE:
+        case GL_DEPTH_RANGE:
+        case GL_MAX_VIEWPORT_DIMS:
+        case GL_MAP1_GRID_DOMAIN:
+        case GL_MAP2_GRID_SEGMENTS:
+        case GL_ALIASED_POINT_SIZE_RANGE:
+        case GL_ALIASED_LINE_WIDTH_RANGE:
+        case GL_DEPTH_BOUNDS_EXT:
+        case GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB:
+            return 2;
+        case GL_CURRENT_NORMAL:
+        case GL_POINT_DISTANCE_ATTENUATION:
+            return 3;
+        case GL_CURRENT_COLOR:
+        case GL_CURRENT_TEXTURE_COORDS:
+        case GL_CURRENT_RASTER_COLOR:
+        case GL_CURRENT_RASTER_TEXTURE_COORDS:
+        case GL_CURRENT_RASTER_POSITION:
+        case GL_LIGHT_MODEL_AMBIENT:
+        case GL_FOG_COLOR:
+        case GL_ACCUM_CLEAR_VALUE:
+        case GL_VIEWPORT:
+        case GL_SCISSOR_BOX:
+        case GL_COLOR_CLEAR_VALUE:
+        case GL_COLOR_WRITEMASK:
+        case GL_MAP2_GRID_DOMAIN:
+        case GL_BLEND_COLOR:
 /*      case GL_BLEND_COLOR_EXT:*/
-    case GL_CURRENT_SECONDARY_COLOR:
-        return 4;
-    case GL_MODELVIEW_MATRIX:
-    case GL_PROJECTION_MATRIX:
-    case GL_TEXTURE_MATRIX:
-    case GL_MODELVIEW0_ARB:
-    case GL_COLOR_MATRIX:
-    case GL_MODELVIEW1_ARB:
-    case GL_CURRENT_MATRIX_ARB:
-    case GL_MODELVIEW2_ARB:
-    case GL_MODELVIEW3_ARB:
-    case GL_MODELVIEW4_ARB:
-    case GL_MODELVIEW5_ARB:
-    case GL_MODELVIEW6_ARB:
-    case GL_MODELVIEW7_ARB:
-    case GL_MODELVIEW8_ARB:
-    case GL_MODELVIEW9_ARB:
-    case GL_MODELVIEW10_ARB:
-    case GL_MODELVIEW11_ARB:
-    case GL_MODELVIEW12_ARB:
-    case GL_MODELVIEW13_ARB:
-    case GL_MODELVIEW14_ARB:
-    case GL_MODELVIEW15_ARB:
-    case GL_MODELVIEW16_ARB:
-    case GL_MODELVIEW17_ARB:
-    case GL_MODELVIEW18_ARB:
-    case GL_MODELVIEW19_ARB:
-    case GL_MODELVIEW20_ARB:
-    case GL_MODELVIEW21_ARB:
-    case GL_MODELVIEW22_ARB:
-    case GL_MODELVIEW23_ARB:
-    case GL_MODELVIEW24_ARB:
-    case GL_MODELVIEW25_ARB:
-    case GL_MODELVIEW26_ARB:
-    case GL_MODELVIEW27_ARB:
-    case GL_MODELVIEW28_ARB:
-    case GL_MODELVIEW29_ARB:
-    case GL_MODELVIEW30_ARB:
-    case GL_MODELVIEW31_ARB:
-    case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
-        return 16;
-    case GL_FOG_COORDINATE_SOURCE:
-    case GL_COMPRESSED_TEXTURE_FORMATS:
-    case GL_RGBA_INTEGER_MODE_EXT:
-        return __glGetBooleanv_variable_size(e);
-    default:
-        return 0;
+        case GL_CURRENT_SECONDARY_COLOR:
+        case GL_WINDOW_RECTANGLE_EXT:
+            return 4;
+        case GL_PRIMITIVE_BOUNDING_BOX_ARB:
+            return 8;
+        case GL_MODELVIEW_MATRIX:
+        case GL_PROJECTION_MATRIX:
+        case GL_TEXTURE_MATRIX:
+        case GL_MODELVIEW0_ARB:
+        case GL_COLOR_MATRIX:
+        case GL_MODELVIEW1_ARB:
+        case GL_CURRENT_MATRIX_ARB:
+        case GL_MODELVIEW2_ARB:
+        case GL_MODELVIEW3_ARB:
+        case GL_MODELVIEW4_ARB:
+        case GL_MODELVIEW5_ARB:
+        case GL_MODELVIEW6_ARB:
+        case GL_MODELVIEW7_ARB:
+        case GL_MODELVIEW8_ARB:
+        case GL_MODELVIEW9_ARB:
+        case GL_MODELVIEW10_ARB:
+        case GL_MODELVIEW11_ARB:
+        case GL_MODELVIEW12_ARB:
+        case GL_MODELVIEW13_ARB:
+        case GL_MODELVIEW14_ARB:
+        case GL_MODELVIEW15_ARB:
+        case GL_MODELVIEW16_ARB:
+        case GL_MODELVIEW17_ARB:
+        case GL_MODELVIEW18_ARB:
+        case GL_MODELVIEW19_ARB:
+        case GL_MODELVIEW20_ARB:
+        case GL_MODELVIEW21_ARB:
+        case GL_MODELVIEW22_ARB:
+        case GL_MODELVIEW23_ARB:
+        case GL_MODELVIEW24_ARB:
+        case GL_MODELVIEW25_ARB:
+        case GL_MODELVIEW26_ARB:
+        case GL_MODELVIEW27_ARB:
+        case GL_MODELVIEW28_ARB:
+        case GL_MODELVIEW29_ARB:
+        case GL_MODELVIEW30_ARB:
+        case GL_MODELVIEW31_ARB:
+        case GL_TRANSPOSE_CURRENT_MATRIX_ARB:
+            return 16;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetTexParameterfv_size(GLenum e)
+__glGetTexParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_TEXTURE_MAG_FILTER:
-    case GL_TEXTURE_MIN_FILTER:
-    case GL_TEXTURE_WRAP_S:
-    case GL_TEXTURE_WRAP_T:
-    case GL_TEXTURE_PRIORITY:
-    case GL_TEXTURE_RESIDENT:
-    case GL_TEXTURE_WRAP_R:
-    case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
+    switch( e ) {
+        case GL_TEXTURE_MAG_FILTER:
+        case GL_TEXTURE_MIN_FILTER:
+        case GL_TEXTURE_WRAP_S:
+        case GL_TEXTURE_WRAP_T:
+        case GL_TEXTURE_PRIORITY:
+        case GL_TEXTURE_RESIDENT:
+        case GL_TEXTURE_WRAP_R:
+        case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
 /*      case GL_SHADOW_AMBIENT_SGIX:*/
-    case GL_TEXTURE_MIN_LOD:
-    case GL_TEXTURE_MAX_LOD:
-    case GL_TEXTURE_BASE_LEVEL:
-    case GL_TEXTURE_MAX_LEVEL:
-    case GL_TEXTURE_CLIPMAP_FRAME_SGIX:
-    case GL_TEXTURE_LOD_BIAS_S_SGIX:
-    case GL_TEXTURE_LOD_BIAS_T_SGIX:
-    case GL_TEXTURE_LOD_BIAS_R_SGIX:
-    case GL_GENERATE_MIPMAP:
+        case GL_TEXTURE_MIN_LOD:
+        case GL_TEXTURE_MAX_LOD:
+        case GL_TEXTURE_BASE_LEVEL:
+        case GL_TEXTURE_MAX_LEVEL:
+        case GL_TEXTURE_CLIPMAP_FRAME_SGIX:
+        case GL_TEXTURE_LOD_BIAS_S_SGIX:
+        case GL_TEXTURE_LOD_BIAS_T_SGIX:
+        case GL_TEXTURE_LOD_BIAS_R_SGIX:
+        case GL_GENERATE_MIPMAP:
 /*      case GL_GENERATE_MIPMAP_SGIS:*/
-    case GL_TEXTURE_COMPARE_SGIX:
-    case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_S_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_T_SGIX:
-    case GL_TEXTURE_MAX_CLAMP_R_SGIX:
-    case GL_TEXTURE_MAX_ANISOTROPY_EXT:
-    case GL_TEXTURE_LOD_BIAS:
+        case GL_TEXTURE_COMPARE_SGIX:
+        case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_S_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_T_SGIX:
+        case GL_TEXTURE_MAX_CLAMP_R_SGIX:
+        case GL_TEXTURE_MAX_ANISOTROPY_EXT:
+        case GL_TEXTURE_LOD_BIAS:
 /*      case GL_TEXTURE_LOD_BIAS_EXT:*/
-    case GL_TEXTURE_RANGE_LENGTH_APPLE:
-    case GL_TEXTURE_STORAGE_HINT_APPLE:
-    case GL_DEPTH_TEXTURE_MODE:
+        case GL_TEXTURE_RANGE_LENGTH_APPLE:
+        case GL_TEXTURE_STORAGE_HINT_APPLE:
+        case GL_DEPTH_TEXTURE_MODE:
 /*      case GL_DEPTH_TEXTURE_MODE_ARB:*/
-    case GL_TEXTURE_COMPARE_MODE:
+        case GL_TEXTURE_COMPARE_MODE:
 /*      case GL_TEXTURE_COMPARE_MODE_ARB:*/
-    case GL_TEXTURE_COMPARE_FUNC:
+        case GL_TEXTURE_COMPARE_FUNC:
 /*      case GL_TEXTURE_COMPARE_FUNC_ARB:*/
-    case GL_TEXTURE_UNSIGNED_REMAP_MODE_NV:
-        return 1;
-    case GL_TEXTURE_CLIPMAP_CENTER_SGIX:
-    case GL_TEXTURE_CLIPMAP_OFFSET_SGIX:
-        return 2;
-    case GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:
-        return 3;
-    case GL_TEXTURE_BORDER_COLOR:
-    case GL_POST_TEXTURE_FILTER_BIAS_SGIX:
-    case GL_POST_TEXTURE_FILTER_SCALE_SGIX:
-        return 4;
-    default:
-        return 0;
+        case GL_TEXTURE_UNSIGNED_REMAP_MODE_NV:
+            return 1;
+        case GL_TEXTURE_CLIPMAP_CENTER_SGIX:
+        case GL_TEXTURE_CLIPMAP_OFFSET_SGIX:
+            return 2;
+        case GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX:
+            return 3;
+        case GL_TEXTURE_BORDER_COLOR:
+        case GL_POST_TEXTURE_FILTER_BIAS_SGIX:
+        case GL_POST_TEXTURE_FILTER_SCALE_SGIX:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetTexLevelParameterfv_size(GLenum e)
+__glGetTexLevelParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_TEXTURE_WIDTH:
-    case GL_TEXTURE_HEIGHT:
-    case GL_TEXTURE_COMPONENTS:
-    case GL_TEXTURE_BORDER:
-    case GL_TEXTURE_RED_SIZE:
+    switch( e ) {
+        case GL_TEXTURE_WIDTH:
+        case GL_TEXTURE_HEIGHT:
+        case GL_TEXTURE_COMPONENTS:
+        case GL_TEXTURE_BORDER:
+        case GL_TEXTURE_RED_SIZE:
 /*      case GL_TEXTURE_RED_SIZE_EXT:*/
-    case GL_TEXTURE_GREEN_SIZE:
+        case GL_TEXTURE_GREEN_SIZE:
 /*      case GL_TEXTURE_GREEN_SIZE_EXT:*/
-    case GL_TEXTURE_BLUE_SIZE:
+        case GL_TEXTURE_BLUE_SIZE:
 /*      case GL_TEXTURE_BLUE_SIZE_EXT:*/
-    case GL_TEXTURE_ALPHA_SIZE:
+        case GL_TEXTURE_ALPHA_SIZE:
 /*      case GL_TEXTURE_ALPHA_SIZE_EXT:*/
-    case GL_TEXTURE_LUMINANCE_SIZE:
+        case GL_TEXTURE_LUMINANCE_SIZE:
 /*      case GL_TEXTURE_LUMINANCE_SIZE_EXT:*/
-    case GL_TEXTURE_INTENSITY_SIZE:
+        case GL_TEXTURE_INTENSITY_SIZE:
 /*      case GL_TEXTURE_INTENSITY_SIZE_EXT:*/
-    case GL_TEXTURE_DEPTH:
-    case GL_TEXTURE_INDEX_SIZE_EXT:
-    case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
+        case GL_TEXTURE_DEPTH:
+        case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
 /*      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB:*/
-    case GL_TEXTURE_COMPRESSED:
-/*      case GL_TEXTURE_COMPRESSED_ARB:*/
-    case GL_TEXTURE_DEPTH_SIZE:
+        case GL_TEXTURE_COMPRESSED_ARB:
+        case GL_TEXTURE_DEPTH_SIZE:
 /*      case GL_TEXTURE_DEPTH_SIZE_ARB:*/
-    case GL_TEXTURE_STENCIL_SIZE:
+        case GL_TEXTURE_STENCIL_SIZE:
 /*      case GL_TEXTURE_STENCIL_SIZE_EXT:*/
-        return 1;
-    default:
-        return 0;
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetPointerv_size(GLenum e)
+__glGetPointerv_size( GLenum e )
 {
-    switch (e) {
-    case GL_DEBUG_CALLBACK_FUNCTION_ARB:
-    case GL_DEBUG_CALLBACK_USER_PARAM_ARB:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_DEBUG_CALLBACK_FUNCTION_ARB:
+/*      case GL_DEBUG_CALLBACK_FUNCTION:*/
+        case GL_DEBUG_CALLBACK_USER_PARAM_ARB:
+/*      case GL_DEBUG_CALLBACK_USER_PARAM:*/
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glColorTableParameterfv_size(GLenum e)
+__glColorTableParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_COLOR_TABLE_SCALE:
-    case GL_COLOR_TABLE_BIAS:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_COLOR_TABLE_SCALE:
+        case GL_COLOR_TABLE_BIAS:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetColorTableParameterfv_size(GLenum e)
+__glGetColorTableParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_COLOR_TABLE_FORMAT:
-/*      case GL_COLOR_TABLE_FORMAT_EXT:*/
-    case GL_COLOR_TABLE_WIDTH:
-/*      case GL_COLOR_TABLE_WIDTH_EXT:*/
-    case GL_COLOR_TABLE_RED_SIZE:
-/*      case GL_COLOR_TABLE_RED_SIZE_EXT:*/
-    case GL_COLOR_TABLE_GREEN_SIZE:
-/*      case GL_COLOR_TABLE_GREEN_SIZE_EXT:*/
-    case GL_COLOR_TABLE_BLUE_SIZE:
-/*      case GL_COLOR_TABLE_BLUE_SIZE_EXT:*/
-    case GL_COLOR_TABLE_ALPHA_SIZE:
-/*      case GL_COLOR_TABLE_ALPHA_SIZE_EXT:*/
-    case GL_COLOR_TABLE_LUMINANCE_SIZE:
-/*      case GL_COLOR_TABLE_LUMINANCE_SIZE_EXT:*/
-    case GL_COLOR_TABLE_INTENSITY_SIZE:
-/*      case GL_COLOR_TABLE_INTENSITY_SIZE_EXT:*/
-        return 1;
-    case GL_COLOR_TABLE_SCALE:
-    case GL_COLOR_TABLE_BIAS:
-        return 4;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_COLOR_TABLE_FORMAT:
+        case GL_COLOR_TABLE_WIDTH:
+        case GL_COLOR_TABLE_RED_SIZE:
+        case GL_COLOR_TABLE_GREEN_SIZE:
+        case GL_COLOR_TABLE_BLUE_SIZE:
+        case GL_COLOR_TABLE_ALPHA_SIZE:
+        case GL_COLOR_TABLE_LUMINANCE_SIZE:
+        case GL_COLOR_TABLE_INTENSITY_SIZE:
+            return 1;
+        case GL_COLOR_TABLE_SCALE:
+        case GL_COLOR_TABLE_BIAS:
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glConvolutionParameterfv_size(GLenum e)
+__glConvolutionParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_CONVOLUTION_BORDER_MODE:
-/*      case GL_CONVOLUTION_BORDER_MODE_EXT:*/
-        return 1;
-    case GL_CONVOLUTION_FILTER_SCALE:
-/*      case GL_CONVOLUTION_FILTER_SCALE_EXT:*/
-    case GL_CONVOLUTION_FILTER_BIAS:
-/*      case GL_CONVOLUTION_FILTER_BIAS_EXT:*/
-    case GL_CONVOLUTION_BORDER_COLOR:
+    switch( e ) {
+        case GL_CONVOLUTION_BORDER_MODE:
+            return 1;
+        case GL_CONVOLUTION_FILTER_SCALE:
+        case GL_CONVOLUTION_FILTER_BIAS:
+        case GL_CONVOLUTION_BORDER_COLOR:
 /*      case GL_CONVOLUTION_BORDER_COLOR_HP:*/
-        return 4;
-    default:
-        return 0;
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetConvolutionParameterfv_size(GLenum e)
+__glGetConvolutionParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_CONVOLUTION_BORDER_MODE:
-/*      case GL_CONVOLUTION_BORDER_MODE_EXT:*/
-    case GL_CONVOLUTION_FORMAT:
-/*      case GL_CONVOLUTION_FORMAT_EXT:*/
-    case GL_CONVOLUTION_WIDTH:
-/*      case GL_CONVOLUTION_WIDTH_EXT:*/
-    case GL_CONVOLUTION_HEIGHT:
-/*      case GL_CONVOLUTION_HEIGHT_EXT:*/
-    case GL_MAX_CONVOLUTION_WIDTH:
-/*      case GL_MAX_CONVOLUTION_WIDTH_EXT:*/
-    case GL_MAX_CONVOLUTION_HEIGHT:
-/*      case GL_MAX_CONVOLUTION_HEIGHT_EXT:*/
-        return 1;
-    case GL_CONVOLUTION_FILTER_SCALE:
-/*      case GL_CONVOLUTION_FILTER_SCALE_EXT:*/
-    case GL_CONVOLUTION_FILTER_BIAS:
-/*      case GL_CONVOLUTION_FILTER_BIAS_EXT:*/
-    case GL_CONVOLUTION_BORDER_COLOR:
+    switch( e ) {
+        case GL_CONVOLUTION_BORDER_MODE:
+        case GL_CONVOLUTION_FORMAT:
+        case GL_CONVOLUTION_WIDTH:
+        case GL_CONVOLUTION_HEIGHT:
+        case GL_MAX_CONVOLUTION_WIDTH:
+        case GL_MAX_CONVOLUTION_HEIGHT:
+            return 1;
+        case GL_CONVOLUTION_FILTER_SCALE:
+        case GL_CONVOLUTION_FILTER_BIAS:
+        case GL_CONVOLUTION_BORDER_COLOR:
 /*      case GL_CONVOLUTION_BORDER_COLOR_HP:*/
-        return 4;
-    default:
-        return 0;
+            return 4;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetHistogramParameterfv_size(GLenum e)
+__glGetHistogramParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_HISTOGRAM_WIDTH:
-    case GL_HISTOGRAM_FORMAT:
-    case GL_HISTOGRAM_RED_SIZE:
-    case GL_HISTOGRAM_GREEN_SIZE:
-    case GL_HISTOGRAM_BLUE_SIZE:
-    case GL_HISTOGRAM_ALPHA_SIZE:
-    case GL_HISTOGRAM_LUMINANCE_SIZE:
-    case GL_HISTOGRAM_SINK:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_HISTOGRAM_WIDTH:
+        case GL_HISTOGRAM_FORMAT:
+        case GL_HISTOGRAM_RED_SIZE:
+        case GL_HISTOGRAM_GREEN_SIZE:
+        case GL_HISTOGRAM_BLUE_SIZE:
+        case GL_HISTOGRAM_ALPHA_SIZE:
+        case GL_HISTOGRAM_LUMINANCE_SIZE:
+        case GL_HISTOGRAM_SINK:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetMinmaxParameterfv_size(GLenum e)
+__glGetMinmaxParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_MINMAX_FORMAT:
-    case GL_MINMAX_SINK:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_MINMAX_FORMAT:
+        case GL_MINMAX_SINK:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glPointParameterfv_size(GLenum e)
+__glPointParameterfv_size( GLenum e )
 {
-    switch (e) {
-    case GL_POINT_SIZE_MIN:
+    switch( e ) {
+        case GL_POINT_SIZE_MIN:
 /*      case GL_POINT_SIZE_MIN_ARB:*/
 /*      case GL_POINT_SIZE_MIN_SGIS:*/
-    case GL_POINT_SIZE_MAX:
+        case GL_POINT_SIZE_MAX:
 /*      case GL_POINT_SIZE_MAX_ARB:*/
 /*      case GL_POINT_SIZE_MAX_SGIS:*/
-    case GL_POINT_FADE_THRESHOLD_SIZE:
+        case GL_POINT_FADE_THRESHOLD_SIZE:
 /*      case GL_POINT_FADE_THRESHOLD_SIZE_ARB:*/
 /*      case GL_POINT_FADE_THRESHOLD_SIZE_SGIS:*/
-    case GL_POINT_SPRITE_R_MODE_NV:
-    case GL_POINT_SPRITE_COORD_ORIGIN:
-        return 1;
-    case GL_POINT_DISTANCE_ATTENUATION:
+        case GL_POINT_SPRITE_R_MODE_NV:
+        case GL_POINT_SPRITE_COORD_ORIGIN:
+            return 1;
+        case GL_POINT_DISTANCE_ATTENUATION:
 /*      case GL_POINT_DISTANCE_ATTENUATION_ARB:*/
 /*      case GL_POINT_DISTANCE_ATTENUATION_SGIS:*/
-        return 3;
-    default:
-        return 0;
+            return 3;
+        default: return 0;
+    }
+}
+
+_X_INTERNAL PURE FASTCALL GLint
+__glGetQueryObjectiv_size( GLenum e )
+{
+    switch( e ) {
+        case GL_QUERY_RESULT_ARB:
+        case GL_QUERY_RESULT_AVAILABLE_ARB:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetQueryObjectiv_size(GLenum e)
+__glGetQueryiv_size( GLenum e )
 {
-    switch (e) {
-    case GL_QUERY_RESULT_ARB:
-    case GL_QUERY_RESULT_AVAILABLE_ARB:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_QUERY_COUNTER_BITS_ARB:
+        case GL_CURRENT_QUERY_ARB:
+        case GL_ANY_SAMPLES_PASSED:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetQueryiv_size(GLenum e)
+__glGetVertexAttribdv_size( GLenum e )
 {
-    switch (e) {
-    case GL_QUERY_COUNTER_BITS_ARB:
-    case GL_CURRENT_QUERY_ARB:
-    case GL_ANY_SAMPLES_PASSED:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_VERTEX_PROGRAM_ARB:
+        case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB:
+        case GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB:
+        case GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB:
+        case GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB:
+        case GL_CURRENT_VERTEX_ATTRIB_ARB:
+        case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetProgramivARB_size(GLenum e)
+__glGetProgramivARB_size( GLenum e )
 {
-    switch (e) {
-    case GL_PROGRAM_LENGTH_ARB:
-    case GL_PROGRAM_BINDING_ARB:
-    case GL_PROGRAM_ALU_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_TEX_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_TEX_INDIRECTIONS_ARB:
-    case GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB:
-    case GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB:
-    case GL_PROGRAM_FORMAT_ARB:
-    case GL_PROGRAM_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB:
-    case GL_PROGRAM_TEMPORARIES_ARB:
-    case GL_MAX_PROGRAM_TEMPORARIES_ARB:
-    case GL_PROGRAM_NATIVE_TEMPORARIES_ARB:
-    case GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB:
-    case GL_PROGRAM_PARAMETERS_ARB:
-    case GL_MAX_PROGRAM_PARAMETERS_ARB:
-    case GL_PROGRAM_NATIVE_PARAMETERS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB:
-    case GL_PROGRAM_ATTRIBS_ARB:
-    case GL_MAX_PROGRAM_ATTRIBS_ARB:
-    case GL_PROGRAM_NATIVE_ATTRIBS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB:
-    case GL_PROGRAM_ADDRESS_REGISTERS_ARB:
-    case GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB:
-    case GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB:
-    case GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB:
-    case GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB:
-    case GL_MAX_PROGRAM_ENV_PARAMETERS_ARB:
-    case GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB:
-    case GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV:
-    case GL_MAX_PROGRAM_CALL_DEPTH_NV:
-    case GL_MAX_PROGRAM_IF_DEPTH_NV:
-    case GL_MAX_PROGRAM_LOOP_DEPTH_NV:
-    case GL_MAX_PROGRAM_LOOP_COUNT_NV:
-        return 1;
-    default:
-        return 0;
+    switch( e ) {
+        case GL_PROGRAM_LENGTH_ARB:
+        case GL_PROGRAM_BINDING_ARB:
+        case GL_PROGRAM_ALU_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_TEX_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_TEX_INDIRECTIONS_ARB:
+        case GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB:
+        case GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB:
+        case GL_PROGRAM_FORMAT_ARB:
+        case GL_PROGRAM_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB:
+        case GL_PROGRAM_TEMPORARIES_ARB:
+        case GL_MAX_PROGRAM_TEMPORARIES_ARB:
+        case GL_PROGRAM_NATIVE_TEMPORARIES_ARB:
+        case GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB:
+        case GL_PROGRAM_PARAMETERS_ARB:
+        case GL_MAX_PROGRAM_PARAMETERS_ARB:
+        case GL_PROGRAM_NATIVE_PARAMETERS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB:
+        case GL_PROGRAM_ATTRIBS_ARB:
+        case GL_MAX_PROGRAM_ATTRIBS_ARB:
+        case GL_PROGRAM_NATIVE_ATTRIBS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB:
+        case GL_PROGRAM_ADDRESS_REGISTERS_ARB:
+        case GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB:
+        case GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB:
+        case GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB:
+        case GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB:
+        case GL_MAX_PROGRAM_ENV_PARAMETERS_ARB:
+        case GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB:
+        case GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV:
+        case GL_MAX_PROGRAM_CALL_DEPTH_NV:
+        case GL_MAX_PROGRAM_IF_DEPTH_NV:
+        case GL_MAX_PROGRAM_LOOP_DEPTH_NV:
+        case GL_MAX_PROGRAM_LOOP_COUNT_NV:
+            return 1;
+        default: return 0;
     }
 }
 
 _X_INTERNAL PURE FASTCALL GLint
-__glGetFramebufferAttachmentParameteriv_size(GLenum e)
+__glGetFramebufferAttachmentParameteriv_size( GLenum e )
 {
-    switch (e) {
-    case GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
-    case GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
-    case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
-    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
+    switch( e ) {
+        case GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
+        case GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
+        case GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
+        case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
 /*      case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT:*/
-    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
+        case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
 /*      case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT:*/
-    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
+        case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
 /*      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT:*/
-    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
+        case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
 /*      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT:*/
-    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT:
-        return 1;
-    default:
-        return 0;
+        case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:
+/*      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT:*/
+            return 1;
+        default: return 0;
+    }
+}
+
+_X_INTERNAL PURE FASTCALL GLint
+__glGetProgramivNV_size( GLenum e )
+{
+    switch( e ) {
+        case GL_PROGRAM_LENGTH_NV:
+        case GL_PROGRAM_TARGET_NV:
+        case GL_PROGRAM_RESIDENT_NV:
+            return 1;
+        default: return 0;
     }
 }
 
-ALIAS(Fogiv, Fogfv)
-    ALIAS(Lightiv, Lightfv)
-    ALIAS(LightModeliv, LightModelfv)
-    ALIAS(Materialiv, Materialfv)
-    ALIAS(TexParameteriv, TexParameterfv)
-    ALIAS(TexEnviv, TexEnvfv)
-    ALIAS(TexGenfv, TexGendv)
-    ALIAS(TexGeniv, TexGendv)
-    ALIAS(Map1f, Map1d)
-    ALIAS(Map2f, Map2d)
-    ALIAS(GetDoublev, GetBooleanv)
-    ALIAS(GetFloatv, GetBooleanv)
-    ALIAS(GetIntegerv, GetBooleanv)
-    ALIAS(GetLightfv, Lightfv)
-    ALIAS(GetLightiv, Lightfv)
-    ALIAS(GetMaterialfv, Materialfv)
-    ALIAS(GetMaterialiv, Materialfv)
-    ALIAS(GetTexEnvfv, TexEnvfv)
-    ALIAS(GetTexEnviv, TexEnvfv)
-    ALIAS(GetTexGendv, TexGendv)
-    ALIAS(GetTexGenfv, TexGendv)
-    ALIAS(GetTexGeniv, TexGendv)
-    ALIAS(GetTexParameteriv, GetTexParameterfv)
-    ALIAS(GetTexLevelParameteriv, GetTexLevelParameterfv)
-    ALIAS(ColorTableParameteriv, ColorTableParameterfv)
-    ALIAS(GetColorTableParameteriv, GetColorTableParameterfv)
-    ALIAS(ConvolutionParameteriv, ConvolutionParameterfv)
-    ALIAS(GetConvolutionParameteriv, GetConvolutionParameterfv)
-    ALIAS(GetHistogramParameteriv, GetHistogramParameterfv)
-    ALIAS(GetMinmaxParameteriv, GetMinmaxParameterfv)
-    ALIAS(PointParameteriv, PointParameterfv)
-    ALIAS(GetQueryObjectuiv, GetQueryObjectiv)
-#undef PURE
-#undef FASTCALL
+_X_INTERNAL PURE FASTCALL GLint
+__glGetVertexAttribdvNV_size( GLenum e )
+{
+    switch( e ) {
+        case GL_ATTRIB_ARRAY_SIZE_NV:
+        case GL_ATTRIB_ARRAY_STRIDE_NV:
+        case GL_ATTRIB_ARRAY_TYPE_NV:
+        case GL_CURRENT_ATTRIB_NV:
+            return 1;
+        default: return 0;
+    }
+}
+
+ALIAS( Fogiv, Fogfv )
+ALIAS( Lightiv, Lightfv )
+ALIAS( LightModeliv, LightModelfv )
+ALIAS( Materialiv, Materialfv )
+ALIAS( TexParameteriv, TexParameterfv )
+ALIAS( TexEnviv, TexEnvfv )
+ALIAS( TexGenfv, TexGendv )
+ALIAS( TexGeniv, TexGendv )
+ALIAS( Map1f, Map1d )
+ALIAS( Map2f, Map2d )
+ALIAS( GetDoublev, GetBooleanv )
+ALIAS( GetFloatv, GetBooleanv )
+ALIAS( GetIntegerv, GetBooleanv )
+ALIAS( GetLightfv, Lightfv )
+ALIAS( GetLightiv, Lightfv )
+ALIAS( GetMaterialfv, Materialfv )
+ALIAS( GetMaterialiv, Materialfv )
+ALIAS( GetTexEnvfv, TexEnvfv )
+ALIAS( GetTexEnviv, TexEnvfv )
+ALIAS( GetTexGendv, TexGendv )
+ALIAS( GetTexGenfv, TexGendv )
+ALIAS( GetTexGeniv, TexGendv )
+ALIAS( GetTexParameteriv, GetTexParameterfv )
+ALIAS( GetTexLevelParameteriv, GetTexLevelParameterfv )
+ALIAS( ColorTableParameteriv, ColorTableParameterfv )
+ALIAS( GetColorTableParameteriv, GetColorTableParameterfv )
+ALIAS( ConvolutionParameteriv, ConvolutionParameterfv )
+ALIAS( GetConvolutionParameteriv, GetConvolutionParameterfv )
+ALIAS( GetHistogramParameteriv, GetHistogramParameterfv )
+ALIAS( GetMinmaxParameteriv, GetMinmaxParameterfv )
+ALIAS( PointParameteriv, PointParameterfv )
+ALIAS( GetQueryObjectuiv, GetQueryObjectiv )
+ALIAS( GetVertexAttribfv, GetVertexAttribdv )
+ALIAS( GetVertexAttribiv, GetVertexAttribdv )
+ALIAS( GetVertexAttribfvNV, GetVertexAttribdvNV )
+ALIAS( GetVertexAttribivNV, GetVertexAttribdvNV )
+
+#  undef PURE
+#  undef FASTCALL
diff --git a/xserver/glx/indirect_size_get.h b/vcxsrv-code/xorg-server/glx/indirect_size_get.h
index 5af11d3..d23a7bb 100644
--- a/xserver/glx/indirect_size_get.h
+++ b/vcxsrv-code/xorg-server/glx/indirect_size_get.h
@@ -26,7 +26,7 @@
  */
 
 #if !defined( _INDIRECT_SIZE_GET_H_ )
-#define _INDIRECT_SIZE_GET_H_
+#  define _INDIRECT_SIZE_GET_H_
 
 /**
  * \file
@@ -38,18 +38,38 @@
 
 #include <X11/Xfuncproto.h>
 
-#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
-#define PURE __attribute__((pure))
-#else
-#define PURE
-#endif
+#  if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
 
-#if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
-#define FASTCALL __attribute__((fastcall))
-#else
-#define FASTCALL
-#endif
+#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#    define FASTCALL __attribute__((fastcall))
+#  else
+#    define FASTCALL
+#  endif
 
+extern _X_INTERNAL PURE FASTCALL GLint __glCallLists_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glFogfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glFogiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightModelfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightModeliv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMaterialfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMaterialiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexEnvfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexEnviv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGendv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGenfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGeniv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap1d_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap1f_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap2d_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap2f_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetBooleanv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetDoublev_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetFloatv_size(GLenum);
@@ -68,26 +88,34 @@ extern _X_INTERNAL PURE FASTCALL GLint __glGetTexParameteriv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetTexLevelParameterfv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetTexLevelParameteriv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetPointerv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glGetColorTableParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glGetColorTableParameteriv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glGetConvolutionParameterfv_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glGetConvolutionParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetColorTableParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetColorTableParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glConvolutionParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glConvolutionParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetConvolutionParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetConvolutionParameteriv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetHistogramParameterfv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetHistogramParameteriv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetMinmaxParameterfv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetMinmaxParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glPointParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glPointParameteriv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryObjectiv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryObjectuiv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribdv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribiv_size(GLenum);
 extern _X_INTERNAL PURE FASTCALL GLint __glGetProgramivARB_size(GLenum);
-extern _X_INTERNAL PURE FASTCALL GLint
-__glGetFramebufferAttachmentParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetFramebufferAttachmentParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetProgramivNV_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribdvNV_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribfvNV_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetVertexAttribivNV_size(GLenum);
 
-#undef PURE
-#undef FASTCALL
+#  undef PURE
+#  undef FASTCALL
 
-#endif                          /* !defined( _INDIRECT_SIZE_GET_H_ ) */
+#endif /* !defined( _INDIRECT_SIZE_GET_H_ ) */
diff --git a/xserver/glx/indirect_table.c b/vcxsrv-code/xorg-server/glx/indirect_table.c
index f0f0b83..c5ac69b 100644
--- a/xserver/glx/indirect_table.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_table.c
@@ -25,6 +25,10 @@
  * SOFTWARE.
  */
 
+#ifndef HAVE_DIX_CONFIG_H
+#include "glheader.h"
+#endif
+
 #include <inttypes.h>
 #include "glxserver.h"
 #include "glxext.h"
@@ -78,8 +82,7 @@ static const void *Single_function_table[112][2] = {
     /* [  1] =     1 */ {__glXDisp_Render, __glXDispSwap_Render},
     /* [  2] =     2 */ {__glXDisp_RenderLarge, __glXDispSwap_RenderLarge},
     /* [  3] =     3 */ {__glXDisp_CreateContext, __glXDispSwap_CreateContext},
-    /* [  4] =     4 */ {__glXDisp_DestroyContext,
-                         __glXDispSwap_DestroyContext},
+    /* [  4] =     4 */ {__glXDisp_DestroyContext, __glXDispSwap_DestroyContext},
     /* [  5] =     5 */ {__glXDisp_MakeCurrent, __glXDispSwap_MakeCurrent},
     /* [  6] =     6 */ {__glXDisp_IsDirect, __glXDispSwap_IsDirect},
     /* [  7] =     7 */ {__glXDisp_QueryVersion, __glXDispSwap_QueryVersion},
@@ -88,43 +91,29 @@ static const void *Single_function_table[112][2] = {
     /* [ 10] =    10 */ {__glXDisp_CopyContext, __glXDispSwap_CopyContext},
     /* [ 11] =    11 */ {__glXDisp_SwapBuffers, __glXDispSwap_SwapBuffers},
     /* [ 12] =    12 */ {__glXDisp_UseXFont, __glXDispSwap_UseXFont},
-    /* [ 13] =    13 */ {__glXDisp_CreateGLXPixmap,
-                         __glXDispSwap_CreateGLXPixmap},
-    /* [ 14] =    14 */ {__glXDisp_GetVisualConfigs,
-                         __glXDispSwap_GetVisualConfigs},
-    /* [ 15] =    15 */ {__glXDisp_DestroyGLXPixmap,
-                         __glXDispSwap_DestroyGLXPixmap},
+    /* [ 13] =    13 */ {__glXDisp_CreateGLXPixmap, __glXDispSwap_CreateGLXPixmap},
+    /* [ 14] =    14 */ {__glXDisp_GetVisualConfigs, __glXDispSwap_GetVisualConfigs},
+    /* [ 15] =    15 */ {__glXDisp_DestroyGLXPixmap, __glXDispSwap_DestroyGLXPixmap},
     /* [ 16] =    16 */ {__glXDisp_VendorPrivate, __glXDispSwap_VendorPrivate},
-    /* [ 17] =    17 */ {__glXDisp_VendorPrivateWithReply,
-                         __glXDispSwap_VendorPrivateWithReply},
-    /* [ 18] =    18 */ {__glXDisp_QueryExtensionsString,
-                         __glXDispSwap_QueryExtensionsString},
-    /* [ 19] =    19 */ {__glXDisp_QueryServerString,
-                         __glXDispSwap_QueryServerString},
+    /* [ 17] =    17 */ {__glXDisp_VendorPrivateWithReply, __glXDispSwap_VendorPrivateWithReply},
+    /* [ 18] =    18 */ {__glXDisp_QueryExtensionsString, __glXDispSwap_QueryExtensionsString},
+    /* [ 19] =    19 */ {__glXDisp_QueryServerString, __glXDispSwap_QueryServerString},
     /* [ 20] =    20 */ {__glXDisp_ClientInfo, __glXDispSwap_ClientInfo},
     /* [ 21] =    21 */ {__glXDisp_GetFBConfigs, __glXDispSwap_GetFBConfigs},
     /* [ 22] =    22 */ {__glXDisp_CreatePixmap, __glXDispSwap_CreatePixmap},
     /* [ 23] =    23 */ {__glXDisp_DestroyPixmap, __glXDispSwap_DestroyPixmap},
-    /* [ 24] =    24 */ {__glXDisp_CreateNewContext,
-                         __glXDispSwap_CreateNewContext},
+    /* [ 24] =    24 */ {__glXDisp_CreateNewContext, __glXDispSwap_CreateNewContext},
     /* [ 25] =    25 */ {__glXDisp_QueryContext, __glXDispSwap_QueryContext},
-    /* [ 26] =    26 */ {__glXDisp_MakeContextCurrent,
-                         __glXDispSwap_MakeContextCurrent},
+    /* [ 26] =    26 */ {__glXDisp_MakeContextCurrent, __glXDispSwap_MakeContextCurrent},
     /* [ 27] =    27 */ {__glXDisp_CreatePbuffer, __glXDispSwap_CreatePbuffer},
-    /* [ 28] =    28 */ {__glXDisp_DestroyPbuffer,
-                         __glXDispSwap_DestroyPbuffer},
-    /* [ 29] =    29 */ {__glXDisp_GetDrawableAttributes,
-                         __glXDispSwap_GetDrawableAttributes},
-    /* [ 30] =    30 */ {__glXDisp_ChangeDrawableAttributes,
-                         __glXDispSwap_ChangeDrawableAttributes},
+    /* [ 28] =    28 */ {__glXDisp_DestroyPbuffer, __glXDispSwap_DestroyPbuffer},
+    /* [ 29] =    29 */ {__glXDisp_GetDrawableAttributes, __glXDispSwap_GetDrawableAttributes},
+    /* [ 30] =    30 */ {__glXDisp_ChangeDrawableAttributes, __glXDispSwap_ChangeDrawableAttributes},
     /* [ 31] =    31 */ {__glXDisp_CreateWindow, __glXDispSwap_CreateWindow},
     /* [ 32] =    32 */ {__glXDisp_DestroyWindow, __glXDispSwap_DestroyWindow},
-    /* [ 33] =    33 */ {__glXDisp_SetClientInfoARB,
-                         __glXDispSwap_SetClientInfoARB},
-    /* [ 34] =    34 */ {__glXDisp_CreateContextAttribsARB,
-                         __glXDispSwap_CreateContextAttribsARB},
-    /* [ 35] =    35 */ {__glXDisp_SetClientInfo2ARB,
-                         __glXDispSwap_SetClientInfo2ARB},
+    /* [ 33] =    33 */ {__glXDisp_SetClientInfoARB, __glXDispSwap_SetClientInfoARB},
+    /* [ 34] =    34 */ {__glXDisp_CreateContextAttribsARB, __glXDispSwap_CreateContextAttribsARB},
+    /* [ 35] =    35 */ {__glXDisp_SetClientInfo2ARB, __glXDispSwap_SetClientInfo2ARB},
     /* [ 36] =    36 */ {NULL, NULL},
     /* [ 37] =    37 */ {NULL, NULL},
     /* [ 38] =    38 */ {NULL, NULL},
@@ -138,8 +127,7 @@ static const void *Single_function_table[112][2] = {
     /* [ 46] =   102 */ {__glXDisp_EndList, __glXDispSwap_EndList},
     /* [ 47] =   103 */ {__glXDisp_DeleteLists, __glXDispSwap_DeleteLists},
     /* [ 48] =   104 */ {__glXDisp_GenLists, __glXDispSwap_GenLists},
-    /* [ 49] =   105 */ {__glXDisp_FeedbackBuffer,
-                         __glXDispSwap_FeedbackBuffer},
+    /* [ 49] =   105 */ {__glXDisp_FeedbackBuffer, __glXDispSwap_FeedbackBuffer},
     /* [ 50] =   106 */ {__glXDisp_SelectBuffer, __glXDispSwap_SelectBuffer},
     /* [ 51] =   107 */ {__glXDisp_RenderMode, __glXDispSwap_RenderMode},
     /* [ 52] =   108 */ {__glXDisp_Finish, __glXDispSwap_Finish},
@@ -160,12 +148,9 @@ static const void *Single_function_table[112][2] = {
     /* [ 67] =   123 */ {__glXDisp_GetMaterialfv, __glXDispSwap_GetMaterialfv},
     /* [ 68] =   124 */ {__glXDisp_GetMaterialiv, __glXDispSwap_GetMaterialiv},
     /* [ 69] =   125 */ {__glXDisp_GetPixelMapfv, __glXDispSwap_GetPixelMapfv},
-    /* [ 70] =   126 */ {__glXDisp_GetPixelMapuiv,
-                         __glXDispSwap_GetPixelMapuiv},
-    /* [ 71] =   127 */ {__glXDisp_GetPixelMapusv,
-                         __glXDispSwap_GetPixelMapusv},
-    /* [ 72] =   128 */ {__glXDisp_GetPolygonStipple,
-                         __glXDispSwap_GetPolygonStipple},
+    /* [ 70] =   126 */ {__glXDisp_GetPixelMapuiv, __glXDispSwap_GetPixelMapuiv},
+    /* [ 71] =   127 */ {__glXDisp_GetPixelMapusv, __glXDispSwap_GetPixelMapusv},
+    /* [ 72] =   128 */ {__glXDisp_GetPolygonStipple, __glXDispSwap_GetPolygonStipple},
     /* [ 73] =   129 */ {__glXDisp_GetString, __glXDispSwap_GetString},
     /* [ 74] =   130 */ {__glXDisp_GetTexEnvfv, __glXDispSwap_GetTexEnvfv},
     /* [ 75] =   131 */ {__glXDisp_GetTexEnviv, __glXDispSwap_GetTexEnviv},
@@ -173,56 +158,37 @@ static const void *Single_function_table[112][2] = {
     /* [ 77] =   133 */ {__glXDisp_GetTexGenfv, __glXDispSwap_GetTexGenfv},
     /* [ 78] =   134 */ {__glXDisp_GetTexGeniv, __glXDispSwap_GetTexGeniv},
     /* [ 79] =   135 */ {__glXDisp_GetTexImage, __glXDispSwap_GetTexImage},
-    /* [ 80] =   136 */ {__glXDisp_GetTexParameterfv,
-                         __glXDispSwap_GetTexParameterfv},
-    /* [ 81] =   137 */ {__glXDisp_GetTexParameteriv,
-                         __glXDispSwap_GetTexParameteriv},
-    /* [ 82] =   138 */ {__glXDisp_GetTexLevelParameterfv,
-                         __glXDispSwap_GetTexLevelParameterfv},
-    /* [ 83] =   139 */ {__glXDisp_GetTexLevelParameteriv,
-                         __glXDispSwap_GetTexLevelParameteriv},
+    /* [ 80] =   136 */ {__glXDisp_GetTexParameterfv, __glXDispSwap_GetTexParameterfv},
+    /* [ 81] =   137 */ {__glXDisp_GetTexParameteriv, __glXDispSwap_GetTexParameteriv},
+    /* [ 82] =   138 */ {__glXDisp_GetTexLevelParameterfv, __glXDispSwap_GetTexLevelParameterfv},
+    /* [ 83] =   139 */ {__glXDisp_GetTexLevelParameteriv, __glXDispSwap_GetTexLevelParameteriv},
     /* [ 84] =   140 */ {__glXDisp_IsEnabled, __glXDispSwap_IsEnabled},
     /* [ 85] =   141 */ {__glXDisp_IsList, __glXDispSwap_IsList},
     /* [ 86] =   142 */ {__glXDisp_Flush, __glXDispSwap_Flush},
-    /* [ 87] =   143 */ {__glXDisp_AreTexturesResident,
-                         __glXDispSwap_AreTexturesResident},
-    /* [ 88] =   144 */ {__glXDisp_DeleteTextures,
-                         __glXDispSwap_DeleteTextures},
+    /* [ 87] =   143 */ {__glXDisp_AreTexturesResident, __glXDispSwap_AreTexturesResident},
+    /* [ 88] =   144 */ {__glXDisp_DeleteTextures, __glXDispSwap_DeleteTextures},
     /* [ 89] =   145 */ {__glXDisp_GenTextures, __glXDispSwap_GenTextures},
     /* [ 90] =   146 */ {__glXDisp_IsTexture, __glXDispSwap_IsTexture},
     /* [ 91] =   147 */ {__glXDisp_GetColorTable, __glXDispSwap_GetColorTable},
-    /* [ 92] =   148 */ {__glXDisp_GetColorTableParameterfv,
-                         __glXDispSwap_GetColorTableParameterfv},
-    /* [ 93] =   149 */ {__glXDisp_GetColorTableParameteriv,
-                         __glXDispSwap_GetColorTableParameteriv},
-    /* [ 94] =   150 */ {__glXDisp_GetConvolutionFilter,
-                         __glXDispSwap_GetConvolutionFilter},
-    /* [ 95] =   151 */ {__glXDisp_GetConvolutionParameterfv,
-                         __glXDispSwap_GetConvolutionParameterfv},
-    /* [ 96] =   152 */ {__glXDisp_GetConvolutionParameteriv,
-                         __glXDispSwap_GetConvolutionParameteriv},
-    /* [ 97] =   153 */ {__glXDisp_GetSeparableFilter,
-                         __glXDispSwap_GetSeparableFilter},
+    /* [ 92] =   148 */ {__glXDisp_GetColorTableParameterfv, __glXDispSwap_GetColorTableParameterfv},
+    /* [ 93] =   149 */ {__glXDisp_GetColorTableParameteriv, __glXDispSwap_GetColorTableParameteriv},
+    /* [ 94] =   150 */ {__glXDisp_GetConvolutionFilter, __glXDispSwap_GetConvolutionFilter},
+    /* [ 95] =   151 */ {__glXDisp_GetConvolutionParameterfv, __glXDispSwap_GetConvolutionParameterfv},
+    /* [ 96] =   152 */ {__glXDisp_GetConvolutionParameteriv, __glXDispSwap_GetConvolutionParameteriv},
+    /* [ 97] =   153 */ {__glXDisp_GetSeparableFilter, __glXDispSwap_GetSeparableFilter},
     /* [ 98] =   154 */ {__glXDisp_GetHistogram, __glXDispSwap_GetHistogram},
-    /* [ 99] =   155 */ {__glXDisp_GetHistogramParameterfv,
-                         __glXDispSwap_GetHistogramParameterfv},
-    /* [ 100] =   156 */ {__glXDisp_GetHistogramParameteriv,
-                          __glXDispSwap_GetHistogramParameteriv},
+    /* [ 99] =   155 */ {__glXDisp_GetHistogramParameterfv, __glXDispSwap_GetHistogramParameterfv},
+    /* [ 100] =   156 */ {__glXDisp_GetHistogramParameteriv, __glXDispSwap_GetHistogramParameteriv},
     /* [ 101] =   157 */ {__glXDisp_GetMinmax, __glXDispSwap_GetMinmax},
-    /* [ 102] =   158 */ {__glXDisp_GetMinmaxParameterfv,
-                          __glXDispSwap_GetMinmaxParameterfv},
-    /* [ 103] =   159 */ {__glXDisp_GetMinmaxParameteriv,
-                          __glXDispSwap_GetMinmaxParameteriv},
-    /* [ 104] =   160 */ {__glXDisp_GetCompressedTexImage,
-                          __glXDispSwap_GetCompressedTexImage},
+    /* [ 102] =   158 */ {__glXDisp_GetMinmaxParameterfv, __glXDispSwap_GetMinmaxParameterfv},
+    /* [ 103] =   159 */ {__glXDisp_GetMinmaxParameteriv, __glXDispSwap_GetMinmaxParameteriv},
+    /* [ 104] =   160 */ {__glXDisp_GetCompressedTexImage, __glXDispSwap_GetCompressedTexImage},
     /* [ 105] =   161 */ {__glXDisp_DeleteQueries, __glXDispSwap_DeleteQueries},
     /* [ 106] =   162 */ {__glXDisp_GenQueries, __glXDispSwap_GenQueries},
     /* [ 107] =   163 */ {__glXDisp_IsQuery, __glXDispSwap_IsQuery},
     /* [ 108] =   164 */ {__glXDisp_GetQueryiv, __glXDispSwap_GetQueryiv},
-    /* [ 109] =   165 */ {__glXDisp_GetQueryObjectiv,
-                          __glXDispSwap_GetQueryObjectiv},
-    /* [ 110] =   166 */ {__glXDisp_GetQueryObjectuiv,
-                          __glXDispSwap_GetQueryObjectuiv},
+    /* [ 109] =   165 */ {__glXDisp_GetQueryObjectiv, __glXDispSwap_GetQueryObjectiv},
+    /* [ 110] =   166 */ {__glXDisp_GetQueryObjectuiv, __glXDispSwap_GetQueryObjectuiv},
     /* [ 111] =   167 */ {NULL, NULL},
 };
 
@@ -474,16 +440,13 @@ static const void *Render_function_table[408][2] = {
     /* [ 99] =    99 */ {__glXDisp_Materialiv, __glXDispSwap_Materialiv},
     /* [ 100] =   100 */ {__glXDisp_PointSize, __glXDispSwap_PointSize},
     /* [ 101] =   101 */ {__glXDisp_PolygonMode, __glXDispSwap_PolygonMode},
-    /* [ 102] =   102 */ {__glXDisp_PolygonStipple,
-                          __glXDispSwap_PolygonStipple},
+    /* [ 102] =   102 */ {__glXDisp_PolygonStipple, __glXDispSwap_PolygonStipple},
     /* [ 103] =   103 */ {__glXDisp_Scissor, __glXDispSwap_Scissor},
     /* [ 104] =   104 */ {__glXDisp_ShadeModel, __glXDispSwap_ShadeModel},
     /* [ 105] =   105 */ {__glXDisp_TexParameterf, __glXDispSwap_TexParameterf},
-    /* [ 106] =   106 */ {__glXDisp_TexParameterfv,
-                          __glXDispSwap_TexParameterfv},
+    /* [ 106] =   106 */ {__glXDisp_TexParameterfv, __glXDispSwap_TexParameterfv},
     /* [ 107] =   107 */ {__glXDisp_TexParameteri, __glXDispSwap_TexParameteri},
-    /* [ 108] =   108 */ {__glXDisp_TexParameteriv,
-                          __glXDispSwap_TexParameteriv},
+    /* [ 108] =   108 */ {__glXDisp_TexParameteriv, __glXDispSwap_TexParameteriv},
     /* [ 109] =   109 */ {__glXDisp_TexImage1D, __glXDispSwap_TexImage1D},
     /* [ 110] =   110 */ {__glXDisp_TexImage2D, __glXDispSwap_TexImage2D},
     /* [ 111] =   111 */ {__glXDisp_TexEnvf, __glXDispSwap_TexEnvf},
@@ -541,10 +504,8 @@ static const void *Render_function_table[408][2] = {
     /* [ 163] =   163 */ {__glXDisp_StencilOp, __glXDispSwap_StencilOp},
     /* [ 164] =   164 */ {__glXDisp_DepthFunc, __glXDispSwap_DepthFunc},
     /* [ 165] =   165 */ {__glXDisp_PixelZoom, __glXDispSwap_PixelZoom},
-    /* [ 166] =   166 */ {__glXDisp_PixelTransferf,
-                          __glXDispSwap_PixelTransferf},
-    /* [ 167] =   167 */ {__glXDisp_PixelTransferi,
-                          __glXDispSwap_PixelTransferi},
+    /* [ 166] =   166 */ {__glXDisp_PixelTransferf, __glXDispSwap_PixelTransferf},
+    /* [ 167] =   167 */ {__glXDisp_PixelTransferi, __glXDispSwap_PixelTransferi},
     /* [ 168] =   168 */ {__glXDisp_PixelMapfv, __glXDispSwap_PixelMapfv},
     /* [ 169] =   169 */ {__glXDisp_PixelMapuiv, __glXDispSwap_PixelMapuiv},
     /* [ 170] =   170 */ {__glXDisp_PixelMapusv, __glXDispSwap_PixelMapusv},
@@ -573,53 +534,30 @@ static const void *Render_function_table[408][2] = {
     /* [ 193] =   193 */ {__glXDisp_DrawArrays, __glXDispSwap_DrawArrays},
     /* [ 194] =   194 */ {__glXDisp_Indexubv, __glXDispSwap_Indexubv},
     /* [ 195] =   195 */ {__glXDisp_ColorSubTable, __glXDispSwap_ColorSubTable},
-    /* [ 196] =   196 */ {__glXDisp_CopyColorSubTable,
-                          __glXDispSwap_CopyColorSubTable},
+    /* [ 196] =   196 */ {__glXDisp_CopyColorSubTable, __glXDispSwap_CopyColorSubTable},
     /* [ 197] =   197 */ {__glXDisp_ActiveTexture, __glXDispSwap_ActiveTexture},
-    /* [ 198] =   198 */ {__glXDisp_MultiTexCoord1dv,
-                          __glXDispSwap_MultiTexCoord1dv},
-    /* [ 199] =   199 */ {__glXDisp_MultiTexCoord1fvARB,
-                          __glXDispSwap_MultiTexCoord1fvARB},
-    /* [ 200] =   200 */ {__glXDisp_MultiTexCoord1iv,
-                          __glXDispSwap_MultiTexCoord1iv},
-    /* [ 201] =   201 */ {__glXDisp_MultiTexCoord1sv,
-                          __glXDispSwap_MultiTexCoord1sv},
-    /* [ 202] =   202 */ {__glXDisp_MultiTexCoord2dv,
-                          __glXDispSwap_MultiTexCoord2dv},
-    /* [ 203] =   203 */ {__glXDisp_MultiTexCoord2fvARB,
-                          __glXDispSwap_MultiTexCoord2fvARB},
-    /* [ 204] =   204 */ {__glXDisp_MultiTexCoord2iv,
-                          __glXDispSwap_MultiTexCoord2iv},
-    /* [ 205] =   205 */ {__glXDisp_MultiTexCoord2sv,
-                          __glXDispSwap_MultiTexCoord2sv},
-    /* [ 206] =   206 */ {__glXDisp_MultiTexCoord3dv,
-                          __glXDispSwap_MultiTexCoord3dv},
-    /* [ 207] =   207 */ {__glXDisp_MultiTexCoord3fvARB,
-                          __glXDispSwap_MultiTexCoord3fvARB},
-    /* [ 208] =   208 */ {__glXDisp_MultiTexCoord3iv,
-                          __glXDispSwap_MultiTexCoord3iv},
-    /* [ 209] =   209 */ {__glXDisp_MultiTexCoord3sv,
-                          __glXDispSwap_MultiTexCoord3sv},
-    /* [ 210] =   210 */ {__glXDisp_MultiTexCoord4dv,
-                          __glXDispSwap_MultiTexCoord4dv},
-    /* [ 211] =   211 */ {__glXDisp_MultiTexCoord4fvARB,
-                          __glXDispSwap_MultiTexCoord4fvARB},
-    /* [ 212] =   212 */ {__glXDisp_MultiTexCoord4iv,
-                          __glXDispSwap_MultiTexCoord4iv},
-    /* [ 213] =   213 */ {__glXDisp_MultiTexCoord4sv,
-                          __glXDispSwap_MultiTexCoord4sv},
-    /* [ 214] =   214 */ {__glXDisp_CompressedTexImage1D,
-                          __glXDispSwap_CompressedTexImage1D},
-    /* [ 215] =   215 */ {__glXDisp_CompressedTexImage2D,
-                          __glXDispSwap_CompressedTexImage2D},
-    /* [ 216] =   216 */ {__glXDisp_CompressedTexImage3D,
-                          __glXDispSwap_CompressedTexImage3D},
-    /* [ 217] =   217 */ {__glXDisp_CompressedTexSubImage1D,
-                          __glXDispSwap_CompressedTexSubImage1D},
-    /* [ 218] =   218 */ {__glXDisp_CompressedTexSubImage2D,
-                          __glXDispSwap_CompressedTexSubImage2D},
-    /* [ 219] =   219 */ {__glXDisp_CompressedTexSubImage3D,
-                          __glXDispSwap_CompressedTexSubImage3D},
+    /* [ 198] =   198 */ {__glXDisp_MultiTexCoord1dv, __glXDispSwap_MultiTexCoord1dv},
+    /* [ 199] =   199 */ {__glXDisp_MultiTexCoord1fvARB, __glXDispSwap_MultiTexCoord1fvARB},
+    /* [ 200] =   200 */ {__glXDisp_MultiTexCoord1iv, __glXDispSwap_MultiTexCoord1iv},
+    /* [ 201] =   201 */ {__glXDisp_MultiTexCoord1sv, __glXDispSwap_MultiTexCoord1sv},
+    /* [ 202] =   202 */ {__glXDisp_MultiTexCoord2dv, __glXDispSwap_MultiTexCoord2dv},
+    /* [ 203] =   203 */ {__glXDisp_MultiTexCoord2fvARB, __glXDispSwap_MultiTexCoord2fvARB},
+    /* [ 204] =   204 */ {__glXDisp_MultiTexCoord2iv, __glXDispSwap_MultiTexCoord2iv},
+    /* [ 205] =   205 */ {__glXDisp_MultiTexCoord2sv, __glXDispSwap_MultiTexCoord2sv},
+    /* [ 206] =   206 */ {__glXDisp_MultiTexCoord3dv, __glXDispSwap_MultiTexCoord3dv},
+    /* [ 207] =   207 */ {__glXDisp_MultiTexCoord3fvARB, __glXDispSwap_MultiTexCoord3fvARB},
+    /* [ 208] =   208 */ {__glXDisp_MultiTexCoord3iv, __glXDispSwap_MultiTexCoord3iv},
+    /* [ 209] =   209 */ {__glXDisp_MultiTexCoord3sv, __glXDispSwap_MultiTexCoord3sv},
+    /* [ 210] =   210 */ {__glXDisp_MultiTexCoord4dv, __glXDispSwap_MultiTexCoord4dv},
+    /* [ 211] =   211 */ {__glXDisp_MultiTexCoord4fvARB, __glXDispSwap_MultiTexCoord4fvARB},
+    /* [ 212] =   212 */ {__glXDisp_MultiTexCoord4iv, __glXDispSwap_MultiTexCoord4iv},
+    /* [ 213] =   213 */ {__glXDisp_MultiTexCoord4sv, __glXDispSwap_MultiTexCoord4sv},
+    /* [ 214] =   214 */ {__glXDisp_CompressedTexImage1D, __glXDispSwap_CompressedTexImage1D},
+    /* [ 215] =   215 */ {__glXDisp_CompressedTexImage2D, __glXDispSwap_CompressedTexImage2D},
+    /* [ 216] =   216 */ {__glXDisp_CompressedTexImage3D, __glXDispSwap_CompressedTexImage3D},
+    /* [ 217] =   217 */ {__glXDisp_CompressedTexSubImage1D, __glXDispSwap_CompressedTexSubImage1D},
+    /* [ 218] =   218 */ {__glXDisp_CompressedTexSubImage2D, __glXDispSwap_CompressedTexSubImage2D},
+    /* [ 219] =   219 */ {__glXDisp_CompressedTexSubImage3D, __glXDispSwap_CompressedTexSubImage3D},
     /* [ 220] =   220 */ {NULL, NULL},
     /* [ 221] =   221 */ {NULL, NULL},
     /* [ 222] =   222 */ {NULL, NULL},
@@ -629,31 +567,26 @@ static const void *Render_function_table[408][2] = {
     /* [ 226] =   226 */ {NULL, NULL},
     /* [ 227] =   227 */ {NULL, NULL},
     /* [ 228] =   228 */ {NULL, NULL},
-    /* [ 229] =   229 */ {__glXDisp_SampleCoverage,
-                          __glXDispSwap_SampleCoverage},
+    /* [ 229] =   229 */ {__glXDisp_SampleCoverage, __glXDispSwap_SampleCoverage},
     /* [ 230] =   230 */ {__glXDisp_WindowPos3fv, __glXDispSwap_WindowPos3fv},
     /* [ 231] =   231 */ {__glXDisp_BeginQuery, __glXDispSwap_BeginQuery},
     /* [ 232] =   232 */ {__glXDisp_EndQuery, __glXDispSwap_EndQuery},
     /* [ 233] =   233 */ {__glXDisp_DrawBuffers, __glXDispSwap_DrawBuffers},
     /* [ 234] =   234 */ {__glXDisp_ClampColor, __glXDispSwap_ClampColor},
-    /* [ 235] =   235 */ {NULL, NULL},
-    /* [ 236] =   236 */ {NULL, NULL},
-    /* [ 237] =   237 */ {__glXDisp_FramebufferTextureLayer,
-                          __glXDispSwap_FramebufferTextureLayer},
+    /* [ 235] =   235 */ {__glXDisp_BindRenderbuffer, __glXDispSwap_BindRenderbuffer},
+    /* [ 236] =   236 */ {__glXDisp_BindFramebuffer, __glXDispSwap_BindFramebuffer},
+    /* [ 237] =   237 */ {__glXDisp_FramebufferTextureLayer, __glXDispSwap_FramebufferTextureLayer},
     /* [ 238] =   238 */ {NULL, NULL},
     /* [ 239] =   239 */ {NULL, NULL},
-    /* [ 240] =  2048 */ {NULL, NULL},
-    /* [ 241] =  2049 */ {NULL, NULL},
+    /* [ 240] =  2048 */ {__glXDisp_SampleMaskSGIS, __glXDispSwap_SampleMaskSGIS},
+    /* [ 241] =  2049 */ {__glXDisp_SamplePatternSGIS, __glXDispSwap_SamplePatternSGIS},
     /* [ 242] =  2050 */ {NULL, NULL},
     /* [ 243] =  2051 */ {NULL, NULL},
     /* [ 244] =  2052 */ {NULL, NULL},
     /* [ 245] =  2053 */ {__glXDisp_ColorTable, __glXDispSwap_ColorTable},
-    /* [ 246] =  2054 */ {__glXDisp_ColorTableParameterfv,
-                          __glXDispSwap_ColorTableParameterfv},
-    /* [ 247] =  2055 */ {__glXDisp_ColorTableParameteriv,
-                          __glXDispSwap_ColorTableParameteriv},
-    /* [ 248] =  2056 */ {__glXDisp_CopyColorTable,
-                          __glXDispSwap_CopyColorTable},
+    /* [ 246] =  2054 */ {__glXDisp_ColorTableParameterfv, __glXDispSwap_ColorTableParameterfv},
+    /* [ 247] =  2055 */ {__glXDisp_ColorTableParameteriv, __glXDispSwap_ColorTableParameteriv},
+    /* [ 248] =  2056 */ {__glXDisp_CopyColorTable, __glXDispSwap_CopyColorTable},
     /* [ 249] =  2057 */ {NULL, NULL},
     /* [ 250] =  2058 */ {NULL, NULL},
     /* [ 251] =  2059 */ {NULL, NULL},
@@ -662,10 +595,8 @@ static const void *Render_function_table[408][2] = {
     /* [ 254] =  2062 */ {NULL, NULL},
     /* [ 255] =  2063 */ {NULL, NULL},
     /* [ 256] =  2064 */ {NULL, NULL},
-    /* [ 257] =  2065 */ {__glXDisp_PointParameterf,
-                          __glXDispSwap_PointParameterf},
-    /* [ 258] =  2066 */ {__glXDisp_PointParameterfv,
-                          __glXDispSwap_PointParameterfv},
+    /* [ 257] =  2065 */ {__glXDisp_PointParameterf, __glXDispSwap_PointParameterf},
+    /* [ 258] =  2066 */ {__glXDisp_PointParameterfv, __glXDispSwap_PointParameterfv},
     /* [ 259] =  2067 */ {NULL, NULL},
     /* [ 260] =  2068 */ {NULL, NULL},
     /* [ 261] =  2069 */ {NULL, NULL},
@@ -676,723 +607,633 @@ static const void *Render_function_table[408][2] = {
     /* [ 266] =  4098 */ {NULL, NULL},
     /* [ 267] =  4099 */ {__glXDisp_TexSubImage1D, __glXDispSwap_TexSubImage1D},
     /* [ 268] =  4100 */ {__glXDisp_TexSubImage2D, __glXDispSwap_TexSubImage2D},
-    /* [ 269] =  4101 */ {__glXDisp_ConvolutionFilter1D,
-                          __glXDispSwap_ConvolutionFilter1D},
-    /* [ 270] =  4102 */ {__glXDisp_ConvolutionFilter2D,
-                          __glXDispSwap_ConvolutionFilter2D},
-    /* [ 271] =  4103 */ {__glXDisp_ConvolutionParameterf,
-                          __glXDispSwap_ConvolutionParameterf},
-    /* [ 272] =  4104 */ {__glXDisp_ConvolutionParameterfv,
-                          __glXDispSwap_ConvolutionParameterfv},
-    /* [ 273] =  4105 */ {__glXDisp_ConvolutionParameteri,
-                          __glXDispSwap_ConvolutionParameteri},
-    /* [ 274] =  4106 */ {__glXDisp_ConvolutionParameteriv,
-                          __glXDispSwap_ConvolutionParameteriv},
-    /* [ 275] =  4107 */ {__glXDisp_CopyConvolutionFilter1D,
-                          __glXDispSwap_CopyConvolutionFilter1D},
-    /* [ 276] =  4108 */ {__glXDisp_CopyConvolutionFilter2D,
-                          __glXDispSwap_CopyConvolutionFilter2D},
-    /* [ 277] =  4109 */ {__glXDisp_SeparableFilter2D,
-                          __glXDispSwap_SeparableFilter2D},
+    /* [ 269] =  4101 */ {__glXDisp_ConvolutionFilter1D, __glXDispSwap_ConvolutionFilter1D},
+    /* [ 270] =  4102 */ {__glXDisp_ConvolutionFilter2D, __glXDispSwap_ConvolutionFilter2D},
+    /* [ 271] =  4103 */ {__glXDisp_ConvolutionParameterf, __glXDispSwap_ConvolutionParameterf},
+    /* [ 272] =  4104 */ {__glXDisp_ConvolutionParameterfv, __glXDispSwap_ConvolutionParameterfv},
+    /* [ 273] =  4105 */ {__glXDisp_ConvolutionParameteri, __glXDispSwap_ConvolutionParameteri},
+    /* [ 274] =  4106 */ {__glXDisp_ConvolutionParameteriv, __glXDispSwap_ConvolutionParameteriv},
+    /* [ 275] =  4107 */ {__glXDisp_CopyConvolutionFilter1D, __glXDispSwap_CopyConvolutionFilter1D},
+    /* [ 276] =  4108 */ {__glXDisp_CopyConvolutionFilter2D, __glXDispSwap_CopyConvolutionFilter2D},
+    /* [ 277] =  4109 */ {__glXDisp_SeparableFilter2D, __glXDispSwap_SeparableFilter2D},
     /* [ 278] =  4110 */ {__glXDisp_Histogram, __glXDispSwap_Histogram},
     /* [ 279] =  4111 */ {__glXDisp_Minmax, __glXDispSwap_Minmax},
-    /* [ 280] =  4112 */ {__glXDisp_ResetHistogram,
-                          __glXDispSwap_ResetHistogram},
+    /* [ 280] =  4112 */ {__glXDisp_ResetHistogram, __glXDispSwap_ResetHistogram},
     /* [ 281] =  4113 */ {__glXDisp_ResetMinmax, __glXDispSwap_ResetMinmax},
     /* [ 282] =  4114 */ {__glXDisp_TexImage3D, __glXDispSwap_TexImage3D},
     /* [ 283] =  4115 */ {__glXDisp_TexSubImage3D, __glXDispSwap_TexSubImage3D},
     /* [ 284] =  4116 */ {NULL, NULL},
     /* [ 285] =  4117 */ {__glXDisp_BindTexture, __glXDispSwap_BindTexture},
-    /* [ 286] =  4118 */ {__glXDisp_PrioritizeTextures,
-                          __glXDispSwap_PrioritizeTextures},
-    /* [ 287] =  4119 */ {__glXDisp_CopyTexImage1D,
-                          __glXDispSwap_CopyTexImage1D},
-    /* [ 288] =  4120 */ {__glXDisp_CopyTexImage2D,
-                          __glXDispSwap_CopyTexImage2D},
-    /* [ 289] =  4121 */ {__glXDisp_CopyTexSubImage1D,
-                          __glXDispSwap_CopyTexSubImage1D},
-    /* [ 290] =  4122 */ {__glXDisp_CopyTexSubImage2D,
-                          __glXDispSwap_CopyTexSubImage2D},
-    /* [ 291] =  4123 */ {__glXDisp_CopyTexSubImage3D,
-                          __glXDispSwap_CopyTexSubImage3D},
+    /* [ 286] =  4118 */ {__glXDisp_PrioritizeTextures, __glXDispSwap_PrioritizeTextures},
+    /* [ 287] =  4119 */ {__glXDisp_CopyTexImage1D, __glXDispSwap_CopyTexImage1D},
+    /* [ 288] =  4120 */ {__glXDisp_CopyTexImage2D, __glXDispSwap_CopyTexImage2D},
+    /* [ 289] =  4121 */ {__glXDisp_CopyTexSubImage1D, __glXDispSwap_CopyTexSubImage1D},
+    /* [ 290] =  4122 */ {__glXDisp_CopyTexSubImage2D, __glXDispSwap_CopyTexSubImage2D},
+    /* [ 291] =  4123 */ {__glXDisp_CopyTexSubImage3D, __glXDispSwap_CopyTexSubImage3D},
     /* [ 292] =  4124 */ {__glXDisp_FogCoordfvEXT, __glXDispSwap_FogCoordfvEXT},
     /* [ 293] =  4125 */ {__glXDisp_FogCoorddv, __glXDispSwap_FogCoorddv},
-    /* [ 294] =  4126 */ {__glXDisp_SecondaryColor3bv,
-                          __glXDispSwap_SecondaryColor3bv},
-    /* [ 295] =  4127 */ {__glXDisp_SecondaryColor3sv,
-                          __glXDispSwap_SecondaryColor3sv},
+    /* [ 294] =  4126 */ {__glXDisp_SecondaryColor3bv, __glXDispSwap_SecondaryColor3bv},
+    /* [ 295] =  4127 */ {__glXDisp_SecondaryColor3sv, __glXDispSwap_SecondaryColor3sv},
     /* [ 296] =  4176 */ {NULL, NULL},
     /* [ 297] =  4177 */ {NULL, NULL},
     /* [ 298] =  4178 */ {NULL, NULL},
     /* [ 299] =  4179 */ {NULL, NULL},
-    /* [ 300] =  4180 */ {__glXDisp_BindProgramARB,
-                          __glXDispSwap_BindProgramARB},
-    /* [ 301] =  4181 */ {NULL, NULL},
-    /* [ 302] =  4182 */ {NULL, NULL},
-    /* [ 303] =  4183 */ {NULL, NULL},
-    /* [ 304] =  4184 */ {__glXDisp_ProgramEnvParameter4fvARB,
-                          __glXDispSwap_ProgramEnvParameter4fvARB},
-    /* [ 305] =  4185 */ {__glXDisp_ProgramEnvParameter4dvARB,
-                          __glXDispSwap_ProgramEnvParameter4dvARB},
-    /* [ 306] =  4186 */ {NULL, NULL},
-    /* [ 307] =  4187 */ {NULL, NULL},
-    /* [ 308] =  4188 */ {NULL, NULL},
-    /* [ 309] =  4189 */ {__glXDisp_VertexAttrib1sv,
-                          __glXDispSwap_VertexAttrib1sv},
-    /* [ 310] =  4190 */ {__glXDisp_VertexAttrib2sv,
-                          __glXDispSwap_VertexAttrib2sv},
-    /* [ 311] =  4191 */ {__glXDisp_VertexAttrib3sv,
-                          __glXDispSwap_VertexAttrib3sv},
-    /* [ 312] =  4192 */ {__glXDisp_VertexAttrib4sv,
-                          __glXDispSwap_VertexAttrib4sv},
-    /* [ 313] =  4193 */ {__glXDisp_VertexAttrib1fvARB,
-                          __glXDispSwap_VertexAttrib1fvARB},
-    /* [ 314] =  4194 */ {__glXDisp_VertexAttrib2fvARB,
-                          __glXDispSwap_VertexAttrib2fvARB},
-    /* [ 315] =  4195 */ {__glXDisp_VertexAttrib3fvARB,
-                          __glXDispSwap_VertexAttrib3fvARB},
-    /* [ 316] =  4196 */ {__glXDisp_VertexAttrib4fvARB,
-                          __glXDispSwap_VertexAttrib4fvARB},
-    /* [ 317] =  4197 */ {__glXDisp_VertexAttrib1dv,
-                          __glXDispSwap_VertexAttrib1dv},
-    /* [ 318] =  4198 */ {__glXDisp_VertexAttrib2dv,
-                          __glXDispSwap_VertexAttrib2dv},
-    /* [ 319] =  4199 */ {__glXDisp_VertexAttrib3dv,
-                          __glXDispSwap_VertexAttrib3dv},
-    /* [ 320] =  4200 */ {__glXDisp_VertexAttrib4dv,
-                          __glXDispSwap_VertexAttrib4dv},
-    /* [ 321] =  4201 */ {__glXDisp_VertexAttrib4Nubv,
-                          __glXDispSwap_VertexAttrib4Nubv},
-    /* [ 322] =  4202 */ {__glXDisp_VertexAttribs1svNV,
-                          __glXDispSwap_VertexAttribs1svNV},
-    /* [ 323] =  4203 */ {__glXDisp_VertexAttribs2svNV,
-                          __glXDispSwap_VertexAttribs2svNV},
-    /* [ 324] =  4204 */ {__glXDisp_VertexAttribs3svNV,
-                          __glXDispSwap_VertexAttribs3svNV},
-    /* [ 325] =  4205 */ {__glXDisp_VertexAttribs4svNV,
-                          __glXDispSwap_VertexAttribs4svNV},
-    /* [ 326] =  4206 */ {__glXDisp_VertexAttribs1fvNV,
-                          __glXDispSwap_VertexAttribs1fvNV},
-    /* [ 327] =  4207 */ {__glXDisp_VertexAttribs2fvNV,
-                          __glXDispSwap_VertexAttribs2fvNV},
-    /* [ 328] =  4208 */ {__glXDisp_VertexAttribs3fvNV,
-                          __glXDispSwap_VertexAttribs3fvNV},
-    /* [ 329] =  4209 */ {__glXDisp_VertexAttribs4fvNV,
-                          __glXDispSwap_VertexAttribs4fvNV},
-    /* [ 330] =  4210 */ {__glXDisp_VertexAttribs1dvNV,
-                          __glXDispSwap_VertexAttribs1dvNV},
-    /* [ 331] =  4211 */ {__glXDisp_VertexAttribs2dvNV,
-                          __glXDispSwap_VertexAttribs2dvNV},
-    /* [ 332] =  4212 */ {__glXDisp_VertexAttribs3dvNV,
-                          __glXDispSwap_VertexAttribs3dvNV},
-    /* [ 333] =  4213 */ {__glXDisp_VertexAttribs4dvNV,
-                          __glXDispSwap_VertexAttribs4dvNV},
-    /* [ 334] =  4214 */ {__glXDisp_VertexAttribs4ubvNV,
-                          __glXDispSwap_VertexAttribs4ubvNV},
-    /* [ 335] =  4215 */ {__glXDisp_ProgramLocalParameter4fvARB,
-                          __glXDispSwap_ProgramLocalParameter4fvARB},
-    /* [ 336] =  4216 */ {__glXDisp_ProgramLocalParameter4dvARB,
-                          __glXDispSwap_ProgramLocalParameter4dvARB},
-    /* [ 337] =  4217 */ {__glXDisp_ProgramStringARB,
-                          __glXDispSwap_ProgramStringARB},
-    /* [ 338] =  4218 */ {NULL, NULL},
-    /* [ 339] =  4219 */ {NULL, NULL},
-    /* [ 340] =  4220 */ {__glXDisp_ActiveStencilFaceEXT,
-                          __glXDispSwap_ActiveStencilFaceEXT},
-    /* [ 341] =  4221 */ {__glXDisp_PointParameteri,
-                          __glXDispSwap_PointParameteri},
-    /* [ 342] =  4222 */ {__glXDisp_PointParameteriv,
-                          __glXDispSwap_PointParameteriv},
+    /* [ 300] =  4180 */ {__glXDisp_BindProgramARB, __glXDispSwap_BindProgramARB},
+    /* [ 301] =  4181 */ {__glXDisp_ExecuteProgramNV, __glXDispSwap_ExecuteProgramNV},
+    /* [ 302] =  4182 */ {__glXDisp_RequestResidentProgramsNV, __glXDispSwap_RequestResidentProgramsNV},
+    /* [ 303] =  4183 */ {__glXDisp_LoadProgramNV, __glXDispSwap_LoadProgramNV},
+    /* [ 304] =  4184 */ {__glXDisp_ProgramEnvParameter4fvARB, __glXDispSwap_ProgramEnvParameter4fvARB},
+    /* [ 305] =  4185 */ {__glXDisp_ProgramEnvParameter4dvARB, __glXDispSwap_ProgramEnvParameter4dvARB},
+    /* [ 306] =  4186 */ {__glXDisp_ProgramParameters4fvNV, __glXDispSwap_ProgramParameters4fvNV},
+    /* [ 307] =  4187 */ {__glXDisp_ProgramParameters4dvNV, __glXDispSwap_ProgramParameters4dvNV},
+    /* [ 308] =  4188 */ {__glXDisp_TrackMatrixNV, __glXDispSwap_TrackMatrixNV},
+    /* [ 309] =  4189 */ {__glXDisp_VertexAttrib1sv, __glXDispSwap_VertexAttrib1sv},
+    /* [ 310] =  4190 */ {__glXDisp_VertexAttrib2sv, __glXDispSwap_VertexAttrib2sv},
+    /* [ 311] =  4191 */ {__glXDisp_VertexAttrib3sv, __glXDispSwap_VertexAttrib3sv},
+    /* [ 312] =  4192 */ {__glXDisp_VertexAttrib4sv, __glXDispSwap_VertexAttrib4sv},
+    /* [ 313] =  4193 */ {__glXDisp_VertexAttrib1fvARB, __glXDispSwap_VertexAttrib1fvARB},
+    /* [ 314] =  4194 */ {__glXDisp_VertexAttrib2fvARB, __glXDispSwap_VertexAttrib2fvARB},
+    /* [ 315] =  4195 */ {__glXDisp_VertexAttrib3fvARB, __glXDispSwap_VertexAttrib3fvARB},
+    /* [ 316] =  4196 */ {__glXDisp_VertexAttrib4fvARB, __glXDispSwap_VertexAttrib4fvARB},
+    /* [ 317] =  4197 */ {__glXDisp_VertexAttrib1dv, __glXDispSwap_VertexAttrib1dv},
+    /* [ 318] =  4198 */ {__glXDisp_VertexAttrib2dv, __glXDispSwap_VertexAttrib2dv},
+    /* [ 319] =  4199 */ {__glXDisp_VertexAttrib3dv, __glXDispSwap_VertexAttrib3dv},
+    /* [ 320] =  4200 */ {__glXDisp_VertexAttrib4dv, __glXDispSwap_VertexAttrib4dv},
+    /* [ 321] =  4201 */ {__glXDisp_VertexAttrib4Nubv, __glXDispSwap_VertexAttrib4Nubv},
+    /* [ 322] =  4202 */ {__glXDisp_VertexAttribs1svNV, __glXDispSwap_VertexAttribs1svNV},
+    /* [ 323] =  4203 */ {__glXDisp_VertexAttribs2svNV, __glXDispSwap_VertexAttribs2svNV},
+    /* [ 324] =  4204 */ {__glXDisp_VertexAttribs3svNV, __glXDispSwap_VertexAttribs3svNV},
+    /* [ 325] =  4205 */ {__glXDisp_VertexAttribs4svNV, __glXDispSwap_VertexAttribs4svNV},
+    /* [ 326] =  4206 */ {__glXDisp_VertexAttribs1fvNV, __glXDispSwap_VertexAttribs1fvNV},
+    /* [ 327] =  4207 */ {__glXDisp_VertexAttribs2fvNV, __glXDispSwap_VertexAttribs2fvNV},
+    /* [ 328] =  4208 */ {__glXDisp_VertexAttribs3fvNV, __glXDispSwap_VertexAttribs3fvNV},
+    /* [ 329] =  4209 */ {__glXDisp_VertexAttribs4fvNV, __glXDispSwap_VertexAttribs4fvNV},
+    /* [ 330] =  4210 */ {__glXDisp_VertexAttribs1dvNV, __glXDispSwap_VertexAttribs1dvNV},
+    /* [ 331] =  4211 */ {__glXDisp_VertexAttribs2dvNV, __glXDispSwap_VertexAttribs2dvNV},
+    /* [ 332] =  4212 */ {__glXDisp_VertexAttribs3dvNV, __glXDispSwap_VertexAttribs3dvNV},
+    /* [ 333] =  4213 */ {__glXDisp_VertexAttribs4dvNV, __glXDispSwap_VertexAttribs4dvNV},
+    /* [ 334] =  4214 */ {__glXDisp_VertexAttribs4ubvNV, __glXDispSwap_VertexAttribs4ubvNV},
+    /* [ 335] =  4215 */ {__glXDisp_ProgramLocalParameter4fvARB, __glXDispSwap_ProgramLocalParameter4fvARB},
+    /* [ 336] =  4216 */ {__glXDisp_ProgramLocalParameter4dvARB, __glXDispSwap_ProgramLocalParameter4dvARB},
+    /* [ 337] =  4217 */ {__glXDisp_ProgramStringARB, __glXDispSwap_ProgramStringARB},
+    /* [ 338] =  4218 */ {__glXDisp_ProgramNamedParameter4fvNV, __glXDispSwap_ProgramNamedParameter4fvNV},
+    /* [ 339] =  4219 */ {__glXDisp_ProgramNamedParameter4dvNV, __glXDispSwap_ProgramNamedParameter4dvNV},
+    /* [ 340] =  4220 */ {__glXDisp_ActiveStencilFaceEXT, __glXDispSwap_ActiveStencilFaceEXT},
+    /* [ 341] =  4221 */ {__glXDisp_PointParameteri, __glXDispSwap_PointParameteri},
+    /* [ 342] =  4222 */ {__glXDisp_PointParameteriv, __glXDispSwap_PointParameteriv},
     /* [ 343] =  4223 */ {NULL, NULL},
     /* [ 344] =  4224 */ {NULL, NULL},
     /* [ 345] =  4225 */ {NULL, NULL},
     /* [ 346] =  4226 */ {NULL, NULL},
     /* [ 347] =  4227 */ {NULL, NULL},
-    /* [ 348] =  4228 */ {__glXDisp_BlendEquationSeparate,
-                          __glXDispSwap_BlendEquationSeparate},
+    /* [ 348] =  4228 */ {__glXDisp_BlendEquationSeparate, __glXDispSwap_BlendEquationSeparate},
     /* [ 349] =  4229 */ {NULL, NULL},
-    /* [ 350] =  4230 */ {__glXDisp_VertexAttrib4bv,
-                          __glXDispSwap_VertexAttrib4bv},
-    /* [ 351] =  4231 */ {__glXDisp_VertexAttrib4iv,
-                          __glXDispSwap_VertexAttrib4iv},
-    /* [ 352] =  4232 */ {__glXDisp_VertexAttrib4ubv,
-                          __glXDispSwap_VertexAttrib4ubv},
-    /* [ 353] =  4233 */ {__glXDisp_VertexAttrib4usv,
-                          __glXDispSwap_VertexAttrib4usv},
-    /* [ 354] =  4234 */ {__glXDisp_VertexAttrib4uiv,
-                          __glXDispSwap_VertexAttrib4uiv},
-    /* [ 355] =  4235 */ {__glXDisp_VertexAttrib4Nbv,
-                          __glXDispSwap_VertexAttrib4Nbv},
-    /* [ 356] =  4236 */ {__glXDisp_VertexAttrib4Nsv,
-                          __glXDispSwap_VertexAttrib4Nsv},
-    /* [ 357] =  4237 */ {__glXDisp_VertexAttrib4Niv,
-                          __glXDispSwap_VertexAttrib4Niv},
-    /* [ 358] =  4238 */ {__glXDisp_VertexAttrib4Nusv,
-                          __glXDispSwap_VertexAttrib4Nusv},
-    /* [ 359] =  4239 */ {__glXDisp_VertexAttrib4Nuiv,
-                          __glXDispSwap_VertexAttrib4Nuiv},
-    /* [ 360] =  4320 */ {__glXDisp_DeleteFramebuffers,
-                          __glXDispSwap_DeleteFramebuffers},
-    /* [ 361] =  4321 */ {__glXDisp_FramebufferTexture1D,
-                          __glXDispSwap_FramebufferTexture1D},
-    /* [ 362] =  4322 */ {__glXDisp_FramebufferTexture2D,
-                          __glXDispSwap_FramebufferTexture2D},
-    /* [ 363] =  4323 */ {__glXDisp_FramebufferTexture3D,
-                          __glXDispSwap_FramebufferTexture3D},
-    /* [ 364] =  4324 */ {__glXDisp_FramebufferRenderbuffer,
-                          __glXDispSwap_FramebufferRenderbuffer},
-    /* [ 365] =  4325 */ {__glXDisp_GenerateMipmap,
-                          __glXDispSwap_GenerateMipmap},
+    /* [ 350] =  4230 */ {__glXDisp_VertexAttrib4bv, __glXDispSwap_VertexAttrib4bv},
+    /* [ 351] =  4231 */ {__glXDisp_VertexAttrib4iv, __glXDispSwap_VertexAttrib4iv},
+    /* [ 352] =  4232 */ {__glXDisp_VertexAttrib4ubv, __glXDispSwap_VertexAttrib4ubv},
+    /* [ 353] =  4233 */ {__glXDisp_VertexAttrib4usv, __glXDispSwap_VertexAttrib4usv},
+    /* [ 354] =  4234 */ {__glXDisp_VertexAttrib4uiv, __glXDispSwap_VertexAttrib4uiv},
+    /* [ 355] =  4235 */ {__glXDisp_VertexAttrib4Nbv, __glXDispSwap_VertexAttrib4Nbv},
+    /* [ 356] =  4236 */ {__glXDisp_VertexAttrib4Nsv, __glXDispSwap_VertexAttrib4Nsv},
+    /* [ 357] =  4237 */ {__glXDisp_VertexAttrib4Niv, __glXDispSwap_VertexAttrib4Niv},
+    /* [ 358] =  4238 */ {__glXDisp_VertexAttrib4Nusv, __glXDispSwap_VertexAttrib4Nusv},
+    /* [ 359] =  4239 */ {__glXDisp_VertexAttrib4Nuiv, __glXDispSwap_VertexAttrib4Nuiv},
+    /* [ 360] =  4320 */ {__glXDisp_DeleteFramebuffers, __glXDispSwap_DeleteFramebuffers},
+    /* [ 361] =  4321 */ {__glXDisp_FramebufferTexture1D, __glXDispSwap_FramebufferTexture1D},
+    /* [ 362] =  4322 */ {__glXDisp_FramebufferTexture2D, __glXDispSwap_FramebufferTexture2D},
+    /* [ 363] =  4323 */ {__glXDisp_FramebufferTexture3D, __glXDispSwap_FramebufferTexture3D},
+    /* [ 364] =  4324 */ {__glXDisp_FramebufferRenderbuffer, __glXDispSwap_FramebufferRenderbuffer},
+    /* [ 365] =  4325 */ {__glXDisp_GenerateMipmap, __glXDispSwap_GenerateMipmap},
     /* [ 366] =  4326 */ {NULL, NULL},
     /* [ 367] =  4327 */ {NULL, NULL},
     /* [ 368] =  4328 */ {NULL, NULL},
     /* [ 369] =  4329 */ {NULL, NULL},
-    /* [ 370] =  4330 */ {__glXDisp_BlitFramebuffer,
-                          __glXDispSwap_BlitFramebuffer},
-    /* [ 371] =  4331 */ {__glXDisp_RenderbufferStorageMultisample,
-                          __glXDispSwap_RenderbufferStorageMultisample},
+    /* [ 370] =  4330 */ {__glXDisp_BlitFramebuffer, __glXDispSwap_BlitFramebuffer},
+    /* [ 371] =  4331 */ {__glXDisp_RenderbufferStorageMultisample, __glXDispSwap_RenderbufferStorageMultisample},
     /* [ 372] =  4332 */ {NULL, NULL},
     /* [ 373] =  4333 */ {NULL, NULL},
     /* [ 374] =  4334 */ {NULL, NULL},
     /* [ 375] =  4335 */ {NULL, NULL},
-    /* [ 376] =  4128 */ {__glXDisp_SecondaryColor3iv,
-                          __glXDispSwap_SecondaryColor3iv},
-    /* [ 377] =  4129 */ {__glXDisp_SecondaryColor3fvEXT,
-                          __glXDispSwap_SecondaryColor3fvEXT},
-    /* [ 378] =  4130 */ {__glXDisp_SecondaryColor3dv,
-                          __glXDispSwap_SecondaryColor3dv},
-    /* [ 379] =  4131 */ {__glXDisp_SecondaryColor3ubv,
-                          __glXDispSwap_SecondaryColor3ubv},
-    /* [ 380] =  4132 */ {__glXDisp_SecondaryColor3usv,
-                          __glXDispSwap_SecondaryColor3usv},
-    /* [ 381] =  4133 */ {__glXDisp_SecondaryColor3uiv,
-                          __glXDispSwap_SecondaryColor3uiv},
-    /* [ 382] =  4134 */ {__glXDisp_BlendFuncSeparate,
-                          __glXDispSwap_BlendFuncSeparate},
+    /* [ 376] =  4128 */ {__glXDisp_SecondaryColor3iv, __glXDispSwap_SecondaryColor3iv},
+    /* [ 377] =  4129 */ {__glXDisp_SecondaryColor3fvEXT, __glXDispSwap_SecondaryColor3fvEXT},
+    /* [ 378] =  4130 */ {__glXDisp_SecondaryColor3dv, __glXDispSwap_SecondaryColor3dv},
+    /* [ 379] =  4131 */ {__glXDisp_SecondaryColor3ubv, __glXDispSwap_SecondaryColor3ubv},
+    /* [ 380] =  4132 */ {__glXDisp_SecondaryColor3usv, __glXDispSwap_SecondaryColor3usv},
+    /* [ 381] =  4133 */ {__glXDisp_SecondaryColor3uiv, __glXDispSwap_SecondaryColor3uiv},
+    /* [ 382] =  4134 */ {__glXDisp_BlendFuncSeparate, __glXDispSwap_BlendFuncSeparate},
     /* [ 383] =  4135 */ {NULL, NULL},
     /* [ 384] =  4264 */ {NULL, NULL},
-    /* [ 385] =  4265 */ {__glXDisp_VertexAttrib1svNV,
-                          __glXDispSwap_VertexAttrib1svNV},
-    /* [ 386] =  4266 */ {__glXDisp_VertexAttrib2svNV,
-                          __glXDispSwap_VertexAttrib2svNV},
-    /* [ 387] =  4267 */ {__glXDisp_VertexAttrib3svNV,
-                          __glXDispSwap_VertexAttrib3svNV},
-    /* [ 388] =  4268 */ {__glXDisp_VertexAttrib4svNV,
-                          __glXDispSwap_VertexAttrib4svNV},
-    /* [ 389] =  4269 */ {__glXDisp_VertexAttrib1fvNV,
-                          __glXDispSwap_VertexAttrib1fvNV},
-    /* [ 390] =  4270 */ {__glXDisp_VertexAttrib2fvNV,
-                          __glXDispSwap_VertexAttrib2fvNV},
-    /* [ 391] =  4271 */ {__glXDisp_VertexAttrib3fvNV,
-                          __glXDispSwap_VertexAttrib3fvNV},
-    /* [ 392] =  4272 */ {__glXDisp_VertexAttrib4fvNV,
-                          __glXDispSwap_VertexAttrib4fvNV},
-    /* [ 393] =  4273 */ {__glXDisp_VertexAttrib1dvNV,
-                          __glXDispSwap_VertexAttrib1dvNV},
-    /* [ 394] =  4274 */ {__glXDisp_VertexAttrib2dvNV,
-                          __glXDispSwap_VertexAttrib2dvNV},
-    /* [ 395] =  4275 */ {__glXDisp_VertexAttrib3dvNV,
-                          __glXDispSwap_VertexAttrib3dvNV},
-    /* [ 396] =  4276 */ {__glXDisp_VertexAttrib4dvNV,
-                          __glXDispSwap_VertexAttrib4dvNV},
-    /* [ 397] =  4277 */ {__glXDisp_VertexAttrib4ubvNV,
-                          __glXDispSwap_VertexAttrib4ubvNV},
+    /* [ 385] =  4265 */ {__glXDisp_VertexAttrib1svNV, __glXDispSwap_VertexAttrib1svNV},
+    /* [ 386] =  4266 */ {__glXDisp_VertexAttrib2svNV, __glXDispSwap_VertexAttrib2svNV},
+    /* [ 387] =  4267 */ {__glXDisp_VertexAttrib3svNV, __glXDispSwap_VertexAttrib3svNV},
+    /* [ 388] =  4268 */ {__glXDisp_VertexAttrib4svNV, __glXDispSwap_VertexAttrib4svNV},
+    /* [ 389] =  4269 */ {__glXDisp_VertexAttrib1fvNV, __glXDispSwap_VertexAttrib1fvNV},
+    /* [ 390] =  4270 */ {__glXDisp_VertexAttrib2fvNV, __glXDispSwap_VertexAttrib2fvNV},
+    /* [ 391] =  4271 */ {__glXDisp_VertexAttrib3fvNV, __glXDispSwap_VertexAttrib3fvNV},
+    /* [ 392] =  4272 */ {__glXDisp_VertexAttrib4fvNV, __glXDispSwap_VertexAttrib4fvNV},
+    /* [ 393] =  4273 */ {__glXDisp_VertexAttrib1dvNV, __glXDispSwap_VertexAttrib1dvNV},
+    /* [ 394] =  4274 */ {__glXDisp_VertexAttrib2dvNV, __glXDispSwap_VertexAttrib2dvNV},
+    /* [ 395] =  4275 */ {__glXDisp_VertexAttrib3dvNV, __glXDispSwap_VertexAttrib3dvNV},
+    /* [ 396] =  4276 */ {__glXDisp_VertexAttrib4dvNV, __glXDispSwap_VertexAttrib4dvNV},
+    /* [ 397] =  4277 */ {__glXDisp_VertexAttrib4ubvNV, __glXDispSwap_VertexAttrib4ubvNV},
     /* [ 398] =  4278 */ {NULL, NULL},
     /* [ 399] =  4279 */ {NULL, NULL},
     /* [ 400] =  4312 */ {NULL, NULL},
     /* [ 401] =  4313 */ {NULL, NULL},
     /* [ 402] =  4314 */ {NULL, NULL},
     /* [ 403] =  4315 */ {NULL, NULL},
-    /* [ 404] =  4316 */ {__glXDisp_BindRenderbuffer,
-                          __glXDispSwap_BindRenderbuffer},
-    /* [ 405] =  4317 */ {__glXDisp_DeleteRenderbuffers,
-                          __glXDispSwap_DeleteRenderbuffers},
-    /* [ 406] =  4318 */ {__glXDisp_RenderbufferStorage,
-                          __glXDispSwap_RenderbufferStorage},
-    /* [ 407] =  4319 */ {__glXDisp_BindFramebuffer,
-                          __glXDispSwap_BindFramebuffer},
+    /* [ 404] =  4316 */ {__glXDisp_BindRenderbufferEXT, __glXDispSwap_BindRenderbufferEXT},
+    /* [ 405] =  4317 */ {__glXDisp_DeleteRenderbuffers, __glXDispSwap_DeleteRenderbuffers},
+    /* [ 406] =  4318 */ {__glXDisp_RenderbufferStorage, __glXDispSwap_RenderbufferStorage},
+    /* [ 407] =  4319 */ {__glXDisp_BindFramebufferEXT, __glXDispSwap_BindFramebufferEXT},
 };
 
 static const int_fast16_t Render_size_table[408][2] = {
-    /* [  0] =     0 */ {0, ~0},
-    /* [  1] =     1 */ {8, ~0},
-    /* [  2] =     2 */ {12, 0},
-    /* [  3] =     3 */ {8, ~0},
-    /* [  4] =     4 */ {8, ~0},
-    /* [  5] =     5 */ {48, 1},
-    /* [  6] =     6 */ {8, ~0},
-    /* [  7] =     7 */ {28, ~0},
-    /* [  8] =     8 */ {16, ~0},
-    /* [  9] =     9 */ {16, ~0},
-    /* [ 10] =    10 */ {12, ~0},
-    /* [ 11] =    11 */ {8, ~0},
-    /* [ 12] =    12 */ {16, ~0},
-    /* [ 13] =    13 */ {12, ~0},
-    /* [ 14] =    14 */ {8, ~0},
-    /* [ 15] =    15 */ {36, ~0},
-    /* [ 16] =    16 */ {20, ~0},
-    /* [ 17] =    17 */ {20, ~0},
-    /* [ 18] =    18 */ {12, ~0},
-    /* [ 19] =    19 */ {8, ~0},
-    /* [ 20] =    20 */ {20, ~0},
-    /* [ 21] =    21 */ {12, ~0},
-    /* [ 22] =    22 */ {8, ~0},
-    /* [ 23] =    23 */ {4, ~0},
-    /* [ 24] =    24 */ {12, ~0},
-    /* [ 25] =    25 */ {8, ~0},
-    /* [ 26] =    26 */ {8, ~0},
-    /* [ 27] =    27 */ {8, ~0},
-    /* [ 28] =    28 */ {8, ~0},
-    /* [ 29] =    29 */ {28, ~0},
-    /* [ 30] =    30 */ {16, ~0},
-    /* [ 31] =    31 */ {16, ~0},
-    /* [ 32] =    32 */ {12, ~0},
-    /* [ 33] =    33 */ {20, ~0},
-    /* [ 34] =    34 */ {12, ~0},
-    /* [ 35] =    35 */ {12, ~0},
-    /* [ 36] =    36 */ {8, ~0},
-    /* [ 37] =    37 */ {28, ~0},
-    /* [ 38] =    38 */ {16, ~0},
-    /* [ 39] =    39 */ {16, ~0},
-    /* [ 40] =    40 */ {12, ~0},
-    /* [ 41] =    41 */ {36, ~0},
-    /* [ 42] =    42 */ {20, ~0},
-    /* [ 43] =    43 */ {20, ~0},
-    /* [ 44] =    44 */ {12, ~0},
-    /* [ 45] =    45 */ {36, ~0},
-    /* [ 46] =    46 */ {20, ~0},
-    /* [ 47] =    47 */ {20, ~0},
-    /* [ 48] =    48 */ {12, ~0},
-    /* [ 49] =    49 */ {12, ~0},
-    /* [ 50] =    50 */ {8, ~0},
-    /* [ 51] =    51 */ {8, ~0},
-    /* [ 52] =    52 */ {8, ~0},
-    /* [ 53] =    53 */ {20, ~0},
-    /* [ 54] =    54 */ {12, ~0},
-    /* [ 55] =    55 */ {12, ~0},
-    /* [ 56] =    56 */ {8, ~0},
-    /* [ 57] =    57 */ {28, ~0},
-    /* [ 58] =    58 */ {16, ~0},
-    /* [ 59] =    59 */ {16, ~0},
-    /* [ 60] =    60 */ {12, ~0},
-    /* [ 61] =    61 */ {36, ~0},
-    /* [ 62] =    62 */ {20, ~0},
-    /* [ 63] =    63 */ {20, ~0},
-    /* [ 64] =    64 */ {12, ~0},
-    /* [ 65] =    65 */ {20, ~0},
-    /* [ 66] =    66 */ {12, ~0},
-    /* [ 67] =    67 */ {12, ~0},
-    /* [ 68] =    68 */ {8, ~0},
-    /* [ 69] =    69 */ {28, ~0},
-    /* [ 70] =    70 */ {16, ~0},
-    /* [ 71] =    71 */ {16, ~0},
-    /* [ 72] =    72 */ {12, ~0},
-    /* [ 73] =    73 */ {36, ~0},
-    /* [ 74] =    74 */ {20, ~0},
-    /* [ 75] =    75 */ {20, ~0},
-    /* [ 76] =    76 */ {12, ~0},
-    /* [ 77] =    77 */ {40, ~0},
-    /* [ 78] =    78 */ {12, ~0},
-    /* [ 79] =    79 */ {8, ~0},
-    /* [ 80] =    80 */ {12, ~0},
-    /* [ 81] =    81 */ {8, 2},
-    /* [ 82] =    82 */ {12, ~0},
-    /* [ 83] =    83 */ {8, 3},
-    /* [ 84] =    84 */ {8, ~0},
-    /* [ 85] =    85 */ {12, ~0},
-    /* [ 86] =    86 */ {16, ~0},
-    /* [ 87] =    87 */ {12, 4},
-    /* [ 88] =    88 */ {16, ~0},
-    /* [ 89] =    89 */ {12, 5},
-    /* [ 90] =    90 */ {12, ~0},
-    /* [ 91] =    91 */ {8, 6},
-    /* [ 92] =    92 */ {12, ~0},
-    /* [ 93] =    93 */ {8, 7},
-    /* [ 94] =    94 */ {12, ~0},
-    /* [ 95] =    95 */ {8, ~0},
-    /* [ 96] =    96 */ {16, ~0},
-    /* [ 97] =    97 */ {12, 8},
-    /* [ 98] =    98 */ {16, ~0},
-    /* [ 99] =    99 */ {12, 9},
-    /* [100] =   100 */ {8, ~0},
-    /* [101] =   101 */ {12, ~0},
-    /* [102] =   102 */ {24, 10},
-    /* [103] =   103 */ {20, ~0},
-    /* [104] =   104 */ {8, ~0},
-    /* [105] =   105 */ {16, ~0},
-    /* [106] =   106 */ {12, 11},
-    /* [107] =   107 */ {16, ~0},
-    /* [108] =   108 */ {12, 12},
-    /* [109] =   109 */ {56, 13},
-    /* [110] =   110 */ {56, 14},
-    /* [111] =   111 */ {16, ~0},
-    /* [112] =   112 */ {12, 15},
-    /* [113] =   113 */ {16, ~0},
-    /* [114] =   114 */ {12, 16},
-    /* [115] =   115 */ {20, ~0},
-    /* [116] =   116 */ {12, 17},
-    /* [117] =   117 */ {16, ~0},
-    /* [118] =   118 */ {12, 18},
-    /* [119] =   119 */ {16, ~0},
-    /* [120] =   120 */ {12, 19},
-    /* [121] =   121 */ {4, ~0},
-    /* [122] =   122 */ {8, ~0},
-    /* [123] =   123 */ {8, ~0},
-    /* [124] =   124 */ {4, ~0},
-    /* [125] =   125 */ {8, ~0},
-    /* [126] =   126 */ {8, ~0},
-    /* [127] =   127 */ {8, ~0},
-    /* [128] =   128 */ {20, ~0},
-    /* [129] =   129 */ {8, ~0},
-    /* [130] =   130 */ {20, ~0},
-    /* [131] =   131 */ {8, ~0},
-    /* [132] =   132 */ {12, ~0},
-    /* [133] =   133 */ {8, ~0},
-    /* [134] =   134 */ {8, ~0},
-    /* [135] =   135 */ {8, ~0},
-    /* [136] =   136 */ {8, ~0},
-    /* [137] =   137 */ {12, ~0},
-    /* [138] =   138 */ {8, ~0},
-    /* [139] =   139 */ {8, ~0},
-    /* [140] =   140 */ {0, ~0},
-    /* [141] =   141 */ {4, ~0},
-    /* [142] =   142 */ {8, ~0},
-    /* [143] =   143 */ {28, 20},
-    /* [144] =   144 */ {20, 21},
-    /* [145] =   145 */ {48, 22},
-    /* [146] =   146 */ {32, 23},
-    /* [147] =   147 */ {24, ~0},
-    /* [148] =   148 */ {16, ~0},
-    /* [149] =   149 */ {44, ~0},
-    /* [150] =   150 */ {28, ~0},
-    /* [151] =   151 */ {12, ~0},
-    /* [152] =   152 */ {8, ~0},
-    /* [153] =   153 */ {20, ~0},
-    /* [154] =   154 */ {12, ~0},
-    /* [155] =   155 */ {16, ~0},
-    /* [156] =   156 */ {8, ~0},
-    /* [157] =   157 */ {24, ~0},
-    /* [158] =   158 */ {12, ~0},
-    /* [159] =   159 */ {12, ~0},
-    /* [160] =   160 */ {12, ~0},
-    /* [161] =   161 */ {8, ~0},
-    /* [162] =   162 */ {16, ~0},
-    /* [163] =   163 */ {16, ~0},
-    /* [164] =   164 */ {8, ~0},
-    /* [165] =   165 */ {12, ~0},
-    /* [166] =   166 */ {12, ~0},
-    /* [167] =   167 */ {12, ~0},
-    /* [168] =   168 */ {12, 24},
-    /* [169] =   169 */ {12, 25},
-    /* [170] =   170 */ {12, 26},
-    /* [171] =   171 */ {8, ~0},
-    /* [172] =   172 */ {24, ~0},
-    /* [173] =   173 */ {40, 27},
-    /* [174] =   174 */ {20, ~0},
-    /* [175] =   175 */ {52, ~0},
-    /* [176] =   176 */ {4, ~0},
-    /* [177] =   177 */ {68, ~0},
+    /* [  0] =     0 */ {  0, ~0},
+    /* [  1] =     1 */ {  8, ~0},
+    /* [  2] =     2 */ { 12,  0},
+    /* [  3] =     3 */ {  8, ~0},
+    /* [  4] =     4 */ {  8, ~0},
+    /* [  5] =     5 */ { 48,  1},
+    /* [  6] =     6 */ {  8, ~0},
+    /* [  7] =     7 */ { 28, ~0},
+    /* [  8] =     8 */ { 16, ~0},
+    /* [  9] =     9 */ { 16, ~0},
+    /* [ 10] =    10 */ { 12, ~0},
+    /* [ 11] =    11 */ {  8, ~0},
+    /* [ 12] =    12 */ { 16, ~0},
+    /* [ 13] =    13 */ { 12, ~0},
+    /* [ 14] =    14 */ {  8, ~0},
+    /* [ 15] =    15 */ { 36, ~0},
+    /* [ 16] =    16 */ { 20, ~0},
+    /* [ 17] =    17 */ { 20, ~0},
+    /* [ 18] =    18 */ { 12, ~0},
+    /* [ 19] =    19 */ {  8, ~0},
+    /* [ 20] =    20 */ { 20, ~0},
+    /* [ 21] =    21 */ { 12, ~0},
+    /* [ 22] =    22 */ {  8, ~0},
+    /* [ 23] =    23 */ {  4, ~0},
+    /* [ 24] =    24 */ { 12, ~0},
+    /* [ 25] =    25 */ {  8, ~0},
+    /* [ 26] =    26 */ {  8, ~0},
+    /* [ 27] =    27 */ {  8, ~0},
+    /* [ 28] =    28 */ {  8, ~0},
+    /* [ 29] =    29 */ { 28, ~0},
+    /* [ 30] =    30 */ { 16, ~0},
+    /* [ 31] =    31 */ { 16, ~0},
+    /* [ 32] =    32 */ { 12, ~0},
+    /* [ 33] =    33 */ { 20, ~0},
+    /* [ 34] =    34 */ { 12, ~0},
+    /* [ 35] =    35 */ { 12, ~0},
+    /* [ 36] =    36 */ {  8, ~0},
+    /* [ 37] =    37 */ { 28, ~0},
+    /* [ 38] =    38 */ { 16, ~0},
+    /* [ 39] =    39 */ { 16, ~0},
+    /* [ 40] =    40 */ { 12, ~0},
+    /* [ 41] =    41 */ { 36, ~0},
+    /* [ 42] =    42 */ { 20, ~0},
+    /* [ 43] =    43 */ { 20, ~0},
+    /* [ 44] =    44 */ { 12, ~0},
+    /* [ 45] =    45 */ { 36, ~0},
+    /* [ 46] =    46 */ { 20, ~0},
+    /* [ 47] =    47 */ { 20, ~0},
+    /* [ 48] =    48 */ { 12, ~0},
+    /* [ 49] =    49 */ { 12, ~0},
+    /* [ 50] =    50 */ {  8, ~0},
+    /* [ 51] =    51 */ {  8, ~0},
+    /* [ 52] =    52 */ {  8, ~0},
+    /* [ 53] =    53 */ { 20, ~0},
+    /* [ 54] =    54 */ { 12, ~0},
+    /* [ 55] =    55 */ { 12, ~0},
+    /* [ 56] =    56 */ {  8, ~0},
+    /* [ 57] =    57 */ { 28, ~0},
+    /* [ 58] =    58 */ { 16, ~0},
+    /* [ 59] =    59 */ { 16, ~0},
+    /* [ 60] =    60 */ { 12, ~0},
+    /* [ 61] =    61 */ { 36, ~0},
+    /* [ 62] =    62 */ { 20, ~0},
+    /* [ 63] =    63 */ { 20, ~0},
+    /* [ 64] =    64 */ { 12, ~0},
+    /* [ 65] =    65 */ { 20, ~0},
+    /* [ 66] =    66 */ { 12, ~0},
+    /* [ 67] =    67 */ { 12, ~0},
+    /* [ 68] =    68 */ {  8, ~0},
+    /* [ 69] =    69 */ { 28, ~0},
+    /* [ 70] =    70 */ { 16, ~0},
+    /* [ 71] =    71 */ { 16, ~0},
+    /* [ 72] =    72 */ { 12, ~0},
+    /* [ 73] =    73 */ { 36, ~0},
+    /* [ 74] =    74 */ { 20, ~0},
+    /* [ 75] =    75 */ { 20, ~0},
+    /* [ 76] =    76 */ { 12, ~0},
+    /* [ 77] =    77 */ { 40, ~0},
+    /* [ 78] =    78 */ { 12, ~0},
+    /* [ 79] =    79 */ {  8, ~0},
+    /* [ 80] =    80 */ { 12, ~0},
+    /* [ 81] =    81 */ {  8,  2},
+    /* [ 82] =    82 */ { 12, ~0},
+    /* [ 83] =    83 */ {  8,  3},
+    /* [ 84] =    84 */ {  8, ~0},
+    /* [ 85] =    85 */ { 12, ~0},
+    /* [ 86] =    86 */ { 16, ~0},
+    /* [ 87] =    87 */ { 12,  4},
+    /* [ 88] =    88 */ { 16, ~0},
+    /* [ 89] =    89 */ { 12,  5},
+    /* [ 90] =    90 */ { 12, ~0},
+    /* [ 91] =    91 */ {  8,  6},
+    /* [ 92] =    92 */ { 12, ~0},
+    /* [ 93] =    93 */ {  8,  7},
+    /* [ 94] =    94 */ { 12, ~0},
+    /* [ 95] =    95 */ {  8, ~0},
+    /* [ 96] =    96 */ { 16, ~0},
+    /* [ 97] =    97 */ { 12,  8},
+    /* [ 98] =    98 */ { 16, ~0},
+    /* [ 99] =    99 */ { 12,  9},
+    /* [100] =   100 */ {  8, ~0},
+    /* [101] =   101 */ { 12, ~0},
+    /* [102] =   102 */ { 24, 10},
+    /* [103] =   103 */ { 20, ~0},
+    /* [104] =   104 */ {  8, ~0},
+    /* [105] =   105 */ { 16, ~0},
+    /* [106] =   106 */ { 12, 11},
+    /* [107] =   107 */ { 16, ~0},
+    /* [108] =   108 */ { 12, 12},
+    /* [109] =   109 */ { 56, 13},
+    /* [110] =   110 */ { 56, 14},
+    /* [111] =   111 */ { 16, ~0},
+    /* [112] =   112 */ { 12, 15},
+    /* [113] =   113 */ { 16, ~0},
+    /* [114] =   114 */ { 12, 16},
+    /* [115] =   115 */ { 20, ~0},
+    /* [116] =   116 */ { 12, 17},
+    /* [117] =   117 */ { 16, ~0},
+    /* [118] =   118 */ { 12, 18},
+    /* [119] =   119 */ { 16, ~0},
+    /* [120] =   120 */ { 12, 19},
+    /* [121] =   121 */ {  4, ~0},
+    /* [122] =   122 */ {  8, ~0},
+    /* [123] =   123 */ {  8, ~0},
+    /* [124] =   124 */ {  4, ~0},
+    /* [125] =   125 */ {  8, ~0},
+    /* [126] =   126 */ {  8, ~0},
+    /* [127] =   127 */ {  8, ~0},
+    /* [128] =   128 */ { 20, ~0},
+    /* [129] =   129 */ {  8, ~0},
+    /* [130] =   130 */ { 20, ~0},
+    /* [131] =   131 */ {  8, ~0},
+    /* [132] =   132 */ { 12, ~0},
+    /* [133] =   133 */ {  8, ~0},
+    /* [134] =   134 */ {  8, ~0},
+    /* [135] =   135 */ {  8, ~0},
+    /* [136] =   136 */ {  8, ~0},
+    /* [137] =   137 */ { 12, ~0},
+    /* [138] =   138 */ {  8, ~0},
+    /* [139] =   139 */ {  8, ~0},
+    /* [140] =   140 */ {  0, ~0},
+    /* [141] =   141 */ {  4, ~0},
+    /* [142] =   142 */ {  8, ~0},
+    /* [143] =   143 */ { 28, 20},
+    /* [144] =   144 */ { 20, 21},
+    /* [145] =   145 */ { 48, 22},
+    /* [146] =   146 */ { 32, 23},
+    /* [147] =   147 */ { 24, ~0},
+    /* [148] =   148 */ { 16, ~0},
+    /* [149] =   149 */ { 44, ~0},
+    /* [150] =   150 */ { 28, ~0},
+    /* [151] =   151 */ { 12, ~0},
+    /* [152] =   152 */ {  8, ~0},
+    /* [153] =   153 */ { 20, ~0},
+    /* [154] =   154 */ { 12, ~0},
+    /* [155] =   155 */ { 16, ~0},
+    /* [156] =   156 */ {  8, ~0},
+    /* [157] =   157 */ { 24, ~0},
+    /* [158] =   158 */ { 12, ~0},
+    /* [159] =   159 */ { 12, ~0},
+    /* [160] =   160 */ { 12, ~0},
+    /* [161] =   161 */ {  8, ~0},
+    /* [162] =   162 */ { 16, ~0},
+    /* [163] =   163 */ { 16, ~0},
+    /* [164] =   164 */ {  8, ~0},
+    /* [165] =   165 */ { 12, ~0},
+    /* [166] =   166 */ { 12, ~0},
+    /* [167] =   167 */ { 12, ~0},
+    /* [168] =   168 */ { 12, 24},
+    /* [169] =   169 */ { 12, 25},
+    /* [170] =   170 */ { 12, 26},
+    /* [171] =   171 */ {  8, ~0},
+    /* [172] =   172 */ { 24, ~0},
+    /* [173] =   173 */ { 40, 27},
+    /* [174] =   174 */ { 20, ~0},
+    /* [175] =   175 */ { 52, ~0},
+    /* [176] =   176 */ {  4, ~0},
+    /* [177] =   177 */ { 68, ~0},
     /* [178] =   178 */ {132, ~0},
-    /* [179] =   179 */ {8, ~0},
-    /* [180] =   180 */ {68, ~0},
+    /* [179] =   179 */ {  8, ~0},
+    /* [180] =   180 */ { 68, ~0},
     /* [181] =   181 */ {132, ~0},
-    /* [182] =   182 */ {52, ~0},
-    /* [183] =   183 */ {4, ~0},
-    /* [184] =   184 */ {4, ~0},
-    /* [185] =   185 */ {36, ~0},
-    /* [186] =   186 */ {20, ~0},
-    /* [187] =   187 */ {28, ~0},
-    /* [188] =   188 */ {16, ~0},
-    /* [189] =   189 */ {28, ~0},
-    /* [190] =   190 */ {16, ~0},
-    /* [191] =   191 */ {20, ~0},
-    /* [192] =   192 */ {12, ~0},
-    /* [193] =   193 */ {16, 28},
-    /* [194] =   194 */ {8, ~0},
-    /* [195] =   195 */ {44, 29},
-    /* [196] =   196 */ {24, ~0},
-    /* [197] =   197 */ {8, ~0},
-    /* [198] =   198 */ {16, ~0},
-    /* [199] =   199 */ {12, ~0},
-    /* [200] =   200 */ {12, ~0},
-    /* [201] =   201 */ {12, ~0},
-    /* [202] =   202 */ {24, ~0},
-    /* [203] =   203 */ {16, ~0},
-    /* [204] =   204 */ {16, ~0},
-    /* [205] =   205 */ {12, ~0},
-    /* [206] =   206 */ {32, ~0},
-    /* [207] =   207 */ {20, ~0},
-    /* [208] =   208 */ {20, ~0},
-    /* [209] =   209 */ {16, ~0},
-    /* [210] =   210 */ {40, ~0},
-    /* [211] =   211 */ {24, ~0},
-    /* [212] =   212 */ {24, ~0},
-    /* [213] =   213 */ {16, ~0},
-    /* [214] =   214 */ {28, 30},
-    /* [215] =   215 */ {32, 31},
-    /* [216] =   216 */ {36, 32},
-    /* [217] =   217 */ {28, 33},
-    /* [218] =   218 */ {36, 34},
-    /* [219] =   219 */ {44, 35},
-    /* [220] =   220 */ {0, ~0},
-    /* [221] =   221 */ {0, ~0},
-    /* [222] =   222 */ {0, ~0},
-    /* [223] =   223 */ {0, ~0},
-    /* [224] =   224 */ {0, ~0},
-    /* [225] =   225 */ {0, ~0},
-    /* [226] =   226 */ {0, ~0},
-    /* [227] =   227 */ {0, ~0},
-    /* [228] =   228 */ {0, ~0},
-    /* [229] =   229 */ {12, ~0},
-    /* [230] =   230 */ {16, ~0},
-    /* [231] =   231 */ {12, ~0},
-    /* [232] =   232 */ {8, ~0},
-    /* [233] =   233 */ {8, 36},
-    /* [234] =   234 */ {12, ~0},
-    /* [235] =   235 */ {0, ~0},
-    /* [236] =   236 */ {0, ~0},
-    /* [237] =   237 */ {24, ~0},
-    /* [238] =   238 */ {0, ~0},
-    /* [239] =   239 */ {0, ~0},
-    /* [240] =  2048 */ {0, ~0},
-    /* [241] =  2049 */ {0, ~0},
-    /* [242] =  2050 */ {0, ~0},
-    /* [243] =  2051 */ {0, ~0},
-    /* [244] =  2052 */ {0, ~0},
-    /* [245] =  2053 */ {44, 37},
-    /* [246] =  2054 */ {12, 38},
-    /* [247] =  2055 */ {12, 39},
-    /* [248] =  2056 */ {24, ~0},
-    /* [249] =  2057 */ {0, ~0},
-    /* [250] =  2058 */ {0, ~0},
-    /* [251] =  2059 */ {0, ~0},
-    /* [252] =  2060 */ {0, ~0},
-    /* [253] =  2061 */ {0, ~0},
-    /* [254] =  2062 */ {0, ~0},
-    /* [255] =  2063 */ {0, ~0},
-    /* [256] =  2064 */ {0, ~0},
-    /* [257] =  2065 */ {12, ~0},
-    /* [258] =  2066 */ {8, 40},
-    /* [259] =  2067 */ {0, ~0},
-    /* [260] =  2068 */ {0, ~0},
-    /* [261] =  2069 */ {0, ~0},
-    /* [262] =  2070 */ {0, ~0},
-    /* [263] =  2071 */ {0, ~0},
-    /* [264] =  4096 */ {20, ~0},
-    /* [265] =  4097 */ {8, ~0},
-    /* [266] =  4098 */ {0, ~0},
-    /* [267] =  4099 */ {60, 41},
-    /* [268] =  4100 */ {60, 42},
-    /* [269] =  4101 */ {48, 43},
-    /* [270] =  4102 */ {48, 44},
-    /* [271] =  4103 */ {16, ~0},
-    /* [272] =  4104 */ {12, 45},
-    /* [273] =  4105 */ {16, ~0},
-    /* [274] =  4106 */ {12, 46},
-    /* [275] =  4107 */ {24, ~0},
-    /* [276] =  4108 */ {28, ~0},
-    /* [277] =  4109 */ {32, 47},
-    /* [278] =  4110 */ {20, ~0},
-    /* [279] =  4111 */ {16, ~0},
-    /* [280] =  4112 */ {8, ~0},
-    /* [281] =  4113 */ {8, ~0},
-    /* [282] =  4114 */ {84, 48},
-    /* [283] =  4115 */ {92, 49},
-    /* [284] =  4116 */ {0, ~0},
-    /* [285] =  4117 */ {12, ~0},
-    /* [286] =  4118 */ {8, 50},
-    /* [287] =  4119 */ {32, ~0},
-    /* [288] =  4120 */ {36, ~0},
-    /* [289] =  4121 */ {28, ~0},
-    /* [290] =  4122 */ {36, ~0},
-    /* [291] =  4123 */ {40, ~0},
-    /* [292] =  4124 */ {8, ~0},
-    /* [293] =  4125 */ {12, ~0},
-    /* [294] =  4126 */ {8, ~0},
-    /* [295] =  4127 */ {12, ~0},
-    /* [296] =  4176 */ {0, ~0},
-    /* [297] =  4177 */ {0, ~0},
-    /* [298] =  4178 */ {0, ~0},
-    /* [299] =  4179 */ {0, ~0},
-    /* [300] =  4180 */ {12, ~0},
-    /* [301] =  4181 */ {0, ~0},
-    /* [302] =  4182 */ {0, ~0},
-    /* [303] =  4183 */ {0, ~0},
-    /* [304] =  4184 */ {28, ~0},
-    /* [305] =  4185 */ {44, ~0},
-    /* [306] =  4186 */ {0, ~0},
-    /* [307] =  4187 */ {0, ~0},
-    /* [308] =  4188 */ {0, ~0},
-    /* [309] =  4189 */ {12, ~0},
-    /* [310] =  4190 */ {12, ~0},
-    /* [311] =  4191 */ {16, ~0},
-    /* [312] =  4192 */ {16, ~0},
-    /* [313] =  4193 */ {12, ~0},
-    /* [314] =  4194 */ {16, ~0},
-    /* [315] =  4195 */ {20, ~0},
-    /* [316] =  4196 */ {24, ~0},
-    /* [317] =  4197 */ {16, ~0},
-    /* [318] =  4198 */ {24, ~0},
-    /* [319] =  4199 */ {32, ~0},
-    /* [320] =  4200 */ {40, ~0},
-    /* [321] =  4201 */ {12, ~0},
-    /* [322] =  4202 */ {12, 51},
-    /* [323] =  4203 */ {12, 52},
-    /* [324] =  4204 */ {12, 53},
-    /* [325] =  4205 */ {12, 54},
-    /* [326] =  4206 */ {12, 55},
-    /* [327] =  4207 */ {12, 56},
-    /* [328] =  4208 */ {12, 57},
-    /* [329] =  4209 */ {12, 58},
-    /* [330] =  4210 */ {12, 59},
-    /* [331] =  4211 */ {12, 60},
-    /* [332] =  4212 */ {12, 61},
-    /* [333] =  4213 */ {12, 62},
-    /* [334] =  4214 */ {12, 63},
-    /* [335] =  4215 */ {28, ~0},
-    /* [336] =  4216 */ {44, ~0},
-    /* [337] =  4217 */ {16, 64},
-    /* [338] =  4218 */ {0, ~0},
-    /* [339] =  4219 */ {0, ~0},
-    /* [340] =  4220 */ {8, ~0},
-    /* [341] =  4221 */ {12, ~0},
-    /* [342] =  4222 */ {8, 65},
-    /* [343] =  4223 */ {0, ~0},
-    /* [344] =  4224 */ {0, ~0},
-    /* [345] =  4225 */ {0, ~0},
-    /* [346] =  4226 */ {0, ~0},
-    /* [347] =  4227 */ {0, ~0},
-    /* [348] =  4228 */ {12, ~0},
-    /* [349] =  4229 */ {0, ~0},
-    /* [350] =  4230 */ {12, ~0},
-    /* [351] =  4231 */ {24, ~0},
-    /* [352] =  4232 */ {12, ~0},
-    /* [353] =  4233 */ {16, ~0},
-    /* [354] =  4234 */ {24, ~0},
-    /* [355] =  4235 */ {12, ~0},
-    /* [356] =  4236 */ {16, ~0},
-    /* [357] =  4237 */ {24, ~0},
-    /* [358] =  4238 */ {16, ~0},
-    /* [359] =  4239 */ {24, ~0},
-    /* [360] =  4320 */ {8, 66},
-    /* [361] =  4321 */ {24, ~0},
-    /* [362] =  4322 */ {24, ~0},
-    /* [363] =  4323 */ {28, ~0},
-    /* [364] =  4324 */ {20, ~0},
-    /* [365] =  4325 */ {8, ~0},
-    /* [366] =  4326 */ {0, ~0},
-    /* [367] =  4327 */ {0, ~0},
-    /* [368] =  4328 */ {0, ~0},
-    /* [369] =  4329 */ {0, ~0},
-    /* [370] =  4330 */ {44, ~0},
-    /* [371] =  4331 */ {24, ~0},
-    /* [372] =  4332 */ {0, ~0},
-    /* [373] =  4333 */ {0, ~0},
-    /* [374] =  4334 */ {0, ~0},
-    /* [375] =  4335 */ {0, ~0},
-    /* [376] =  4128 */ {16, ~0},
-    /* [377] =  4129 */ {16, ~0},
-    /* [378] =  4130 */ {28, ~0},
-    /* [379] =  4131 */ {8, ~0},
-    /* [380] =  4132 */ {12, ~0},
-    /* [381] =  4133 */ {16, ~0},
-    /* [382] =  4134 */ {20, ~0},
-    /* [383] =  4135 */ {0, ~0},
-    /* [384] =  4264 */ {0, ~0},
-    /* [385] =  4265 */ {12, ~0},
-    /* [386] =  4266 */ {12, ~0},
-    /* [387] =  4267 */ {16, ~0},
-    /* [388] =  4268 */ {16, ~0},
-    /* [389] =  4269 */ {12, ~0},
-    /* [390] =  4270 */ {16, ~0},
-    /* [391] =  4271 */ {20, ~0},
-    /* [392] =  4272 */ {24, ~0},
-    /* [393] =  4273 */ {16, ~0},
-    /* [394] =  4274 */ {24, ~0},
-    /* [395] =  4275 */ {32, ~0},
-    /* [396] =  4276 */ {40, ~0},
-    /* [397] =  4277 */ {12, ~0},
-    /* [398] =  4278 */ {0, ~0},
-    /* [399] =  4279 */ {0, ~0},
-    /* [400] =  4312 */ {0, ~0},
-    /* [401] =  4313 */ {0, ~0},
-    /* [402] =  4314 */ {0, ~0},
-    /* [403] =  4315 */ {0, ~0},
-    /* [404] =  4316 */ {12, ~0},
-    /* [405] =  4317 */ {8, 67},
-    /* [406] =  4318 */ {20, ~0},
-    /* [407] =  4319 */ {12, ~0},
+    /* [182] =   182 */ { 52, ~0},
+    /* [183] =   183 */ {  4, ~0},
+    /* [184] =   184 */ {  4, ~0},
+    /* [185] =   185 */ { 36, ~0},
+    /* [186] =   186 */ { 20, ~0},
+    /* [187] =   187 */ { 28, ~0},
+    /* [188] =   188 */ { 16, ~0},
+    /* [189] =   189 */ { 28, ~0},
+    /* [190] =   190 */ { 16, ~0},
+    /* [191] =   191 */ { 20, ~0},
+    /* [192] =   192 */ { 12, ~0},
+    /* [193] =   193 */ { 16, 28},
+    /* [194] =   194 */ {  8, ~0},
+    /* [195] =   195 */ { 44, 29},
+    /* [196] =   196 */ { 24, ~0},
+    /* [197] =   197 */ {  8, ~0},
+    /* [198] =   198 */ { 16, ~0},
+    /* [199] =   199 */ { 12, ~0},
+    /* [200] =   200 */ { 12, ~0},
+    /* [201] =   201 */ { 12, ~0},
+    /* [202] =   202 */ { 24, ~0},
+    /* [203] =   203 */ { 16, ~0},
+    /* [204] =   204 */ { 16, ~0},
+    /* [205] =   205 */ { 12, ~0},
+    /* [206] =   206 */ { 32, ~0},
+    /* [207] =   207 */ { 20, ~0},
+    /* [208] =   208 */ { 20, ~0},
+    /* [209] =   209 */ { 16, ~0},
+    /* [210] =   210 */ { 40, ~0},
+    /* [211] =   211 */ { 24, ~0},
+    /* [212] =   212 */ { 24, ~0},
+    /* [213] =   213 */ { 16, ~0},
+    /* [214] =   214 */ { 28, 30},
+    /* [215] =   215 */ { 32, 31},
+    /* [216] =   216 */ { 36, 32},
+    /* [217] =   217 */ { 28, 33},
+    /* [218] =   218 */ { 36, 34},
+    /* [219] =   219 */ { 44, 35},
+    /* [220] =   220 */ {  0, ~0},
+    /* [221] =   221 */ {  0, ~0},
+    /* [222] =   222 */ {  0, ~0},
+    /* [223] =   223 */ {  0, ~0},
+    /* [224] =   224 */ {  0, ~0},
+    /* [225] =   225 */ {  0, ~0},
+    /* [226] =   226 */ {  0, ~0},
+    /* [227] =   227 */ {  0, ~0},
+    /* [228] =   228 */ {  0, ~0},
+    /* [229] =   229 */ { 12, ~0},
+    /* [230] =   230 */ { 16, ~0},
+    /* [231] =   231 */ { 12, ~0},
+    /* [232] =   232 */ {  8, ~0},
+    /* [233] =   233 */ {  8, 36},
+    /* [234] =   234 */ { 12, ~0},
+    /* [235] =   235 */ { 12, ~0},
+    /* [236] =   236 */ { 12, ~0},
+    /* [237] =   237 */ { 24, ~0},
+    /* [238] =   238 */ {  0, ~0},
+    /* [239] =   239 */ {  0, ~0},
+    /* [240] =  2048 */ { 12, ~0},
+    /* [241] =  2049 */ {  8, ~0},
+    /* [242] =  2050 */ {  0, ~0},
+    /* [243] =  2051 */ {  0, ~0},
+    /* [244] =  2052 */ {  0, ~0},
+    /* [245] =  2053 */ { 44, 37},
+    /* [246] =  2054 */ { 12, 38},
+    /* [247] =  2055 */ { 12, 39},
+    /* [248] =  2056 */ { 24, ~0},
+    /* [249] =  2057 */ {  0, ~0},
+    /* [250] =  2058 */ {  0, ~0},
+    /* [251] =  2059 */ {  0, ~0},
+    /* [252] =  2060 */ {  0, ~0},
+    /* [253] =  2061 */ {  0, ~0},
+    /* [254] =  2062 */ {  0, ~0},
+    /* [255] =  2063 */ {  0, ~0},
+    /* [256] =  2064 */ {  0, ~0},
+    /* [257] =  2065 */ { 12, ~0},
+    /* [258] =  2066 */ {  8, 40},
+    /* [259] =  2067 */ {  0, ~0},
+    /* [260] =  2068 */ {  0, ~0},
+    /* [261] =  2069 */ {  0, ~0},
+    /* [262] =  2070 */ {  0, ~0},
+    /* [263] =  2071 */ {  0, ~0},
+    /* [264] =  4096 */ { 20, ~0},
+    /* [265] =  4097 */ {  8, ~0},
+    /* [266] =  4098 */ {  0, ~0},
+    /* [267] =  4099 */ { 60, 41},
+    /* [268] =  4100 */ { 60, 42},
+    /* [269] =  4101 */ { 48, 43},
+    /* [270] =  4102 */ { 48, 44},
+    /* [271] =  4103 */ { 16, ~0},
+    /* [272] =  4104 */ { 12, 45},
+    /* [273] =  4105 */ { 16, ~0},
+    /* [274] =  4106 */ { 12, 46},
+    /* [275] =  4107 */ { 24, ~0},
+    /* [276] =  4108 */ { 28, ~0},
+    /* [277] =  4109 */ { 32, 47},
+    /* [278] =  4110 */ { 20, ~0},
+    /* [279] =  4111 */ { 16, ~0},
+    /* [280] =  4112 */ {  8, ~0},
+    /* [281] =  4113 */ {  8, ~0},
+    /* [282] =  4114 */ { 84, 48},
+    /* [283] =  4115 */ { 92, 49},
+    /* [284] =  4116 */ {  0, ~0},
+    /* [285] =  4117 */ { 12, ~0},
+    /* [286] =  4118 */ {  8, 50},
+    /* [287] =  4119 */ { 32, ~0},
+    /* [288] =  4120 */ { 36, ~0},
+    /* [289] =  4121 */ { 28, ~0},
+    /* [290] =  4122 */ { 36, ~0},
+    /* [291] =  4123 */ { 40, ~0},
+    /* [292] =  4124 */ {  8, ~0},
+    /* [293] =  4125 */ { 12, ~0},
+    /* [294] =  4126 */ {  8, ~0},
+    /* [295] =  4127 */ { 12, ~0},
+    /* [296] =  4176 */ {  0, ~0},
+    /* [297] =  4177 */ {  0, ~0},
+    /* [298] =  4178 */ {  0, ~0},
+    /* [299] =  4179 */ {  0, ~0},
+    /* [300] =  4180 */ { 12, ~0},
+    /* [301] =  4181 */ { 28, ~0},
+    /* [302] =  4182 */ {  8, 51},
+    /* [303] =  4183 */ { 16, 52},
+    /* [304] =  4184 */ { 28, ~0},
+    /* [305] =  4185 */ { 44, ~0},
+    /* [306] =  4186 */ { 16, 53},
+    /* [307] =  4187 */ { 16, 54},
+    /* [308] =  4188 */ { 20, ~0},
+    /* [309] =  4189 */ { 12, ~0},
+    /* [310] =  4190 */ { 12, ~0},
+    /* [311] =  4191 */ { 16, ~0},
+    /* [312] =  4192 */ { 16, ~0},
+    /* [313] =  4193 */ { 12, ~0},
+    /* [314] =  4194 */ { 16, ~0},
+    /* [315] =  4195 */ { 20, ~0},
+    /* [316] =  4196 */ { 24, ~0},
+    /* [317] =  4197 */ { 16, ~0},
+    /* [318] =  4198 */ { 24, ~0},
+    /* [319] =  4199 */ { 32, ~0},
+    /* [320] =  4200 */ { 40, ~0},
+    /* [321] =  4201 */ { 12, ~0},
+    /* [322] =  4202 */ { 12, 55},
+    /* [323] =  4203 */ { 12, 56},
+    /* [324] =  4204 */ { 12, 57},
+    /* [325] =  4205 */ { 12, 58},
+    /* [326] =  4206 */ { 12, 59},
+    /* [327] =  4207 */ { 12, 60},
+    /* [328] =  4208 */ { 12, 61},
+    /* [329] =  4209 */ { 12, 62},
+    /* [330] =  4210 */ { 12, 63},
+    /* [331] =  4211 */ { 12, 64},
+    /* [332] =  4212 */ { 12, 65},
+    /* [333] =  4213 */ { 12, 66},
+    /* [334] =  4214 */ { 12, 67},
+    /* [335] =  4215 */ { 28, ~0},
+    /* [336] =  4216 */ { 44, ~0},
+    /* [337] =  4217 */ { 16, 68},
+    /* [338] =  4218 */ { 28, 69},
+    /* [339] =  4219 */ { 44, 70},
+    /* [340] =  4220 */ {  8, ~0},
+    /* [341] =  4221 */ { 12, ~0},
+    /* [342] =  4222 */ {  8, 71},
+    /* [343] =  4223 */ {  0, ~0},
+    /* [344] =  4224 */ {  0, ~0},
+    /* [345] =  4225 */ {  0, ~0},
+    /* [346] =  4226 */ {  0, ~0},
+    /* [347] =  4227 */ {  0, ~0},
+    /* [348] =  4228 */ { 12, ~0},
+    /* [349] =  4229 */ {  0, ~0},
+    /* [350] =  4230 */ { 12, ~0},
+    /* [351] =  4231 */ { 24, ~0},
+    /* [352] =  4232 */ { 12, ~0},
+    /* [353] =  4233 */ { 16, ~0},
+    /* [354] =  4234 */ { 24, ~0},
+    /* [355] =  4235 */ { 12, ~0},
+    /* [356] =  4236 */ { 16, ~0},
+    /* [357] =  4237 */ { 24, ~0},
+    /* [358] =  4238 */ { 16, ~0},
+    /* [359] =  4239 */ { 24, ~0},
+    /* [360] =  4320 */ {  8, 72},
+    /* [361] =  4321 */ { 24, ~0},
+    /* [362] =  4322 */ { 24, ~0},
+    /* [363] =  4323 */ { 28, ~0},
+    /* [364] =  4324 */ { 20, ~0},
+    /* [365] =  4325 */ {  8, ~0},
+    /* [366] =  4326 */ {  0, ~0},
+    /* [367] =  4327 */ {  0, ~0},
+    /* [368] =  4328 */ {  0, ~0},
+    /* [369] =  4329 */ {  0, ~0},
+    /* [370] =  4330 */ { 44, ~0},
+    /* [371] =  4331 */ { 24, ~0},
+    /* [372] =  4332 */ {  0, ~0},
+    /* [373] =  4333 */ {  0, ~0},
+    /* [374] =  4334 */ {  0, ~0},
+    /* [375] =  4335 */ {  0, ~0},
+    /* [376] =  4128 */ { 16, ~0},
+    /* [377] =  4129 */ { 16, ~0},
+    /* [378] =  4130 */ { 28, ~0},
+    /* [379] =  4131 */ {  8, ~0},
+    /* [380] =  4132 */ { 12, ~0},
+    /* [381] =  4133 */ { 16, ~0},
+    /* [382] =  4134 */ { 20, ~0},
+    /* [383] =  4135 */ {  0, ~0},
+    /* [384] =  4264 */ {  0, ~0},
+    /* [385] =  4265 */ { 12, ~0},
+    /* [386] =  4266 */ { 12, ~0},
+    /* [387] =  4267 */ { 16, ~0},
+    /* [388] =  4268 */ { 16, ~0},
+    /* [389] =  4269 */ { 12, ~0},
+    /* [390] =  4270 */ { 16, ~0},
+    /* [391] =  4271 */ { 20, ~0},
+    /* [392] =  4272 */ { 24, ~0},
+    /* [393] =  4273 */ { 16, ~0},
+    /* [394] =  4274 */ { 24, ~0},
+    /* [395] =  4275 */ { 32, ~0},
+    /* [396] =  4276 */ { 40, ~0},
+    /* [397] =  4277 */ { 12, ~0},
+    /* [398] =  4278 */ {  0, ~0},
+    /* [399] =  4279 */ {  0, ~0},
+    /* [400] =  4312 */ {  0, ~0},
+    /* [401] =  4313 */ {  0, ~0},
+    /* [402] =  4314 */ {  0, ~0},
+    /* [403] =  4315 */ {  0, ~0},
+    /* [404] =  4316 */ { 12, ~0},
+    /* [405] =  4317 */ {  8, 73},
+    /* [406] =  4318 */ { 20, ~0},
+    /* [407] =  4319 */ { 12, ~0},
 };
 
-static const gl_proto_size_func Render_size_func_table[68] = {
-    __glXCallListsReqSize,
-    __glXBitmapReqSize,
-    __glXFogfvReqSize,
-    __glXFogivReqSize,
-    __glXLightfvReqSize,
-    __glXLightivReqSize,
-    __glXLightModelfvReqSize,
-    __glXLightModelivReqSize,
-    __glXMaterialfvReqSize,
-    __glXMaterialivReqSize,
-    __glXPolygonStippleReqSize,
-    __glXTexParameterfvReqSize,
-    __glXTexParameterivReqSize,
-    __glXTexImage1DReqSize,
-    __glXTexImage2DReqSize,
-    __glXTexEnvfvReqSize,
-    __glXTexEnvivReqSize,
-    __glXTexGendvReqSize,
-    __glXTexGenfvReqSize,
-    __glXTexGenivReqSize,
-    __glXMap1dReqSize,
-    __glXMap1fReqSize,
-    __glXMap2dReqSize,
-    __glXMap2fReqSize,
-    __glXPixelMapfvReqSize,
-    __glXPixelMapuivReqSize,
-    __glXPixelMapusvReqSize,
-    __glXDrawPixelsReqSize,
-    __glXDrawArraysReqSize,
-    __glXColorSubTableReqSize,
-    __glXCompressedTexImage1DReqSize,
-    __glXCompressedTexImage2DReqSize,
-    __glXCompressedTexImage3DReqSize,
-    __glXCompressedTexSubImage1DReqSize,
-    __glXCompressedTexSubImage2DReqSize,
-    __glXCompressedTexSubImage3DReqSize,
-    __glXDrawBuffersReqSize,
-    __glXColorTableReqSize,
-    __glXColorTableParameterfvReqSize,
-    __glXColorTableParameterivReqSize,
-    __glXPointParameterfvReqSize,
-    __glXTexSubImage1DReqSize,
-    __glXTexSubImage2DReqSize,
-    __glXConvolutionFilter1DReqSize,
-    __glXConvolutionFilter2DReqSize,
-    __glXConvolutionParameterfvReqSize,
-    __glXConvolutionParameterivReqSize,
-    __glXSeparableFilter2DReqSize,
-    __glXTexImage3DReqSize,
-    __glXTexSubImage3DReqSize,
-    __glXPrioritizeTexturesReqSize,
-    __glXVertexAttribs1svNVReqSize,
-    __glXVertexAttribs2svNVReqSize,
-    __glXVertexAttribs3svNVReqSize,
-    __glXVertexAttribs4svNVReqSize,
-    __glXVertexAttribs1fvNVReqSize,
-    __glXVertexAttribs2fvNVReqSize,
-    __glXVertexAttribs3fvNVReqSize,
-    __glXVertexAttribs4fvNVReqSize,
-    __glXVertexAttribs1dvNVReqSize,
-    __glXVertexAttribs2dvNVReqSize,
-    __glXVertexAttribs3dvNVReqSize,
-    __glXVertexAttribs4dvNVReqSize,
-    __glXVertexAttribs4ubvNVReqSize,
-    __glXProgramStringARBReqSize,
-    __glXPointParameterivReqSize,
-    __glXDeleteFramebuffersReqSize,
-    __glXDeleteRenderbuffersReqSize,
+static const gl_proto_size_func Render_size_func_table[74] = {
+   __glXCallListsReqSize,
+   __glXBitmapReqSize,
+   __glXFogfvReqSize,
+   __glXFogivReqSize,
+   __glXLightfvReqSize,
+   __glXLightivReqSize,
+   __glXLightModelfvReqSize,
+   __glXLightModelivReqSize,
+   __glXMaterialfvReqSize,
+   __glXMaterialivReqSize,
+   __glXPolygonStippleReqSize,
+   __glXTexParameterfvReqSize,
+   __glXTexParameterivReqSize,
+   __glXTexImage1DReqSize,
+   __glXTexImage2DReqSize,
+   __glXTexEnvfvReqSize,
+   __glXTexEnvivReqSize,
+   __glXTexGendvReqSize,
+   __glXTexGenfvReqSize,
+   __glXTexGenivReqSize,
+   __glXMap1dReqSize,
+   __glXMap1fReqSize,
+   __glXMap2dReqSize,
+   __glXMap2fReqSize,
+   __glXPixelMapfvReqSize,
+   __glXPixelMapuivReqSize,
+   __glXPixelMapusvReqSize,
+   __glXDrawPixelsReqSize,
+   __glXDrawArraysReqSize,
+   __glXColorSubTableReqSize,
+   __glXCompressedTexImage1DReqSize,
+   __glXCompressedTexImage2DReqSize,
+   __glXCompressedTexImage3DReqSize,
+   __glXCompressedTexSubImage1DReqSize,
+   __glXCompressedTexSubImage2DReqSize,
+   __glXCompressedTexSubImage3DReqSize,
+   __glXDrawBuffersReqSize,
+   __glXColorTableReqSize,
+   __glXColorTableParameterfvReqSize,
+   __glXColorTableParameterivReqSize,
+   __glXPointParameterfvReqSize,
+   __glXTexSubImage1DReqSize,
+   __glXTexSubImage2DReqSize,
+   __glXConvolutionFilter1DReqSize,
+   __glXConvolutionFilter2DReqSize,
+   __glXConvolutionParameterfvReqSize,
+   __glXConvolutionParameterivReqSize,
+   __glXSeparableFilter2DReqSize,
+   __glXTexImage3DReqSize,
+   __glXTexSubImage3DReqSize,
+   __glXPrioritizeTexturesReqSize,
+   __glXRequestResidentProgramsNVReqSize,
+   __glXLoadProgramNVReqSize,
+   __glXProgramParameters4fvNVReqSize,
+   __glXProgramParameters4dvNVReqSize,
+   __glXVertexAttribs1svNVReqSize,
+   __glXVertexAttribs2svNVReqSize,
+   __glXVertexAttribs3svNVReqSize,
+   __glXVertexAttribs4svNVReqSize,
+   __glXVertexAttribs1fvNVReqSize,
+   __glXVertexAttribs2fvNVReqSize,
+   __glXVertexAttribs3fvNVReqSize,
+   __glXVertexAttribs4fvNVReqSize,
+   __glXVertexAttribs1dvNVReqSize,
+   __glXVertexAttribs2dvNVReqSize,
+   __glXVertexAttribs3dvNVReqSize,
+   __glXVertexAttribs4dvNVReqSize,
+   __glXVertexAttribs4ubvNVReqSize,
+   __glXProgramStringARBReqSize,
+   __glXProgramNamedParameter4fvNVReqSize,
+   __glXProgramNamedParameter4dvNVReqSize,
+   __glXPointParameterivReqSize,
+   __glXDeleteFramebuffersReqSize,
+   __glXDeleteRenderbuffersReqSize,
 };
 
 const struct __glXDispatchInfo Render_dispatch_info = {
@@ -1405,12 +1246,12 @@ const struct __glXDispatchInfo Render_dispatch_info = {
 
 /*****************************************************************/
 /* tree depth = 12 */
-static const int_fast16_t VendorPriv_dispatch_tree[152] = {
+static const int_fast16_t VendorPriv_dispatch_tree[138] = {
     /* [0] -> opcode range [0, 131072], node depth 1 */
     2,
     5,
     EMPTY_LEAF,
-    119,
+    105,
     EMPTY_LEAF,
 
     /* [5] -> opcode range [0, 32768], node depth 2 */
@@ -1427,14 +1268,14 @@ static const int_fast16_t VendorPriv_dispatch_tree[152] = {
     2,
     16,
     EMPTY_LEAF,
-    78,
+    81,
     EMPTY_LEAF,
 
     /* [16] -> opcode range [0, 2048], node depth 5 */
     2,
     21,
     EMPTY_LEAF,
-    36,
+    39,
     EMPTY_LEAF,
 
     /* [21] -> opcode range [0, 512], node depth 6 */
@@ -1459,346 +1300,266 @@ static const int_fast16_t VendorPriv_dispatch_tree[152] = {
 
     /* [33] -> opcode range [0, 32], node depth 10 */
     1,
-    LEAF(0),
+    36,
     EMPTY_LEAF,
 
-    /* [36] -> opcode range [1024, 1536], node depth 6 */
-    2,
-    41,
+    /* [36] -> opcode range [0, 16], node depth 11 */
+    1,
     EMPTY_LEAF,
-    53,
-    67,
+    LEAF(0),
 
-    /* [41] -> opcode range [1024, 1152], node depth 7 */
-    1,
+    /* [39] -> opcode range [1024, 1536], node depth 6 */
+    2,
     44,
     EMPTY_LEAF,
+    56,
+    70,
 
-    /* [44] -> opcode range [1024, 1088], node depth 8 */
+    /* [44] -> opcode range [1024, 1152], node depth 7 */
     1,
     47,
     EMPTY_LEAF,
 
-    /* [47] -> opcode range [1024, 1056], node depth 9 */
+    /* [47] -> opcode range [1024, 1088], node depth 8 */
     1,
     50,
     EMPTY_LEAF,
 
-    /* [50] -> opcode range [1024, 1040], node depth 10 */
+    /* [50] -> opcode range [1024, 1056], node depth 9 */
     1,
-    LEAF(16),
+    53,
     EMPTY_LEAF,
 
-    /* [53] -> opcode range [1280, 1408], node depth 7 */
+    /* [53] -> opcode range [1024, 1040], node depth 10 */
     1,
-    56,
+    LEAF(8),
     EMPTY_LEAF,
 
-    /* [56] -> opcode range [1280, 1344], node depth 8 */
-    2,
-    61,
-    LEAF(24),
-    EMPTY_LEAF,
-    64,
-
-    /* [61] -> opcode range [1280, 1296], node depth 9 */
+    /* [56] -> opcode range [1280, 1408], node depth 7 */
     1,
+    59,
     EMPTY_LEAF,
-    LEAF(40),
 
-    /* [64] -> opcode range [1328, 1344], node depth 9 */
-    1,
-    LEAF(48),
+    /* [59] -> opcode range [1280, 1344], node depth 8 */
+    2,
+    64,
+    LEAF(16),
     EMPTY_LEAF,
+    67,
 
-    /* [67] -> opcode range [1408, 1536], node depth 7 */
+    /* [64] -> opcode range [1280, 1296], node depth 9 */
     1,
-    70,
     EMPTY_LEAF,
+    LEAF(32),
 
-    /* [70] -> opcode range [1408, 1472], node depth 8 */
+    /* [67] -> opcode range [1328, 1344], node depth 9 */
     1,
-    73,
-    EMPTY_LEAF,
-
-    /* [73] -> opcode range [1408, 1440], node depth 9 */
-    2,
-    EMPTY_LEAF,
-    LEAF(56),
-    LEAF(64),
-    EMPTY_LEAF,
-
-    /* [78] -> opcode range [4096, 6144], node depth 5 */
-    2,
-    83,
-    EMPTY_LEAF,
-    101,
+    LEAF(40),
     EMPTY_LEAF,
 
-    /* [83] -> opcode range [4096, 4608], node depth 6 */
+    /* [70] -> opcode range [1408, 1536], node depth 7 */
     1,
-    86,
+    73,
     EMPTY_LEAF,
 
-    /* [86] -> opcode range [4096, 4352], node depth 7 */
+    /* [73] -> opcode range [1408, 1472], node depth 8 */
     1,
-    89,
+    76,
     EMPTY_LEAF,
 
-    /* [89] -> opcode range [4096, 4224], node depth 8 */
-    1,
-    92,
+    /* [76] -> opcode range [1408, 1440], node depth 9 */
+    2,
     EMPTY_LEAF,
-
-    /* [92] -> opcode range [4096, 4160], node depth 9 */
-    1,
-    95,
+    LEAF(48),
+    LEAF(56),
     EMPTY_LEAF,
 
-    /* [95] -> opcode range [4096, 4128], node depth 10 */
+    /* [81] -> opcode range [4096, 6144], node depth 5 */
     1,
-    98,
     EMPTY_LEAF,
+    84,
 
-    /* [98] -> opcode range [4096, 4112], node depth 11 */
+    /* [84] -> opcode range [5120, 6144], node depth 6 */
     1,
-    LEAF(72),
+    87,
     EMPTY_LEAF,
 
-    /* [101] -> opcode range [5120, 5632], node depth 6 */
+    /* [87] -> opcode range [5120, 5632], node depth 7 */
     1,
-    104,
+    90,
     EMPTY_LEAF,
 
-    /* [104] -> opcode range [5120, 5376], node depth 7 */
+    /* [90] -> opcode range [5120, 5376], node depth 8 */
     1,
-    107,
+    93,
     EMPTY_LEAF,
 
-    /* [107] -> opcode range [5120, 5248], node depth 8 */
+    /* [93] -> opcode range [5120, 5248], node depth 9 */
     1,
-    110,
+    96,
     EMPTY_LEAF,
 
-    /* [110] -> opcode range [5120, 5184], node depth 9 */
+    /* [96] -> opcode range [5120, 5184], node depth 10 */
     1,
     EMPTY_LEAF,
-    113,
+    99,
 
-    /* [113] -> opcode range [5152, 5184], node depth 10 */
+    /* [99] -> opcode range [5152, 5184], node depth 11 */
     1,
-    116,
+    102,
     EMPTY_LEAF,
 
-    /* [116] -> opcode range [5152, 5168], node depth 11 */
+    /* [102] -> opcode range [5152, 5168], node depth 12 */
     1,
-    LEAF(80),
+    LEAF(64),
     EMPTY_LEAF,
 
-    /* [119] -> opcode range [65536, 98304], node depth 2 */
+    /* [105] -> opcode range [65536, 98304], node depth 2 */
     1,
-    122,
+    108,
     EMPTY_LEAF,
 
-    /* [122] -> opcode range [65536, 81920], node depth 3 */
+    /* [108] -> opcode range [65536, 81920], node depth 3 */
     1,
-    125,
+    111,
     EMPTY_LEAF,
 
-    /* [125] -> opcode range [65536, 73728], node depth 4 */
+    /* [111] -> opcode range [65536, 73728], node depth 4 */
     1,
-    128,
+    114,
     EMPTY_LEAF,
 
-    /* [128] -> opcode range [65536, 69632], node depth 5 */
+    /* [114] -> opcode range [65536, 69632], node depth 5 */
     1,
-    131,
+    117,
     EMPTY_LEAF,
 
-    /* [131] -> opcode range [65536, 67584], node depth 6 */
+    /* [117] -> opcode range [65536, 67584], node depth 6 */
     1,
-    134,
+    120,
     EMPTY_LEAF,
 
-    /* [134] -> opcode range [65536, 66560], node depth 7 */
+    /* [120] -> opcode range [65536, 66560], node depth 7 */
     1,
-    137,
+    123,
     EMPTY_LEAF,
 
-    /* [137] -> opcode range [65536, 66048], node depth 8 */
+    /* [123] -> opcode range [65536, 66048], node depth 8 */
     1,
-    140,
+    126,
     EMPTY_LEAF,
 
-    /* [140] -> opcode range [65536, 65792], node depth 9 */
+    /* [126] -> opcode range [65536, 65792], node depth 9 */
     1,
-    143,
+    129,
     EMPTY_LEAF,
 
-    /* [143] -> opcode range [65536, 65664], node depth 10 */
+    /* [129] -> opcode range [65536, 65664], node depth 10 */
     1,
-    146,
+    132,
     EMPTY_LEAF,
 
-    /* [146] -> opcode range [65536, 65600], node depth 11 */
+    /* [132] -> opcode range [65536, 65600], node depth 11 */
     1,
-    149,
+    135,
     EMPTY_LEAF,
 
-    /* [149] -> opcode range [65536, 65568], node depth 12 */
+    /* [135] -> opcode range [65536, 65568], node depth 12 */
     1,
-    LEAF(88),
+    LEAF(72),
     EMPTY_LEAF,
 
 };
 
-static const void *VendorPriv_function_table[104][2] = {
-    /* [  0] =     0 */ {NULL, NULL},
-    /* [  1] =     1 */ {__glXDisp_GetConvolutionFilterEXT,
-                         __glXDispSwap_GetConvolutionFilterEXT},
-    /* [  2] =     2 */ {__glXDisp_GetConvolutionParameterfvEXT,
-                         __glXDispSwap_GetConvolutionParameterfvEXT},
-    /* [  3] =     3 */ {__glXDisp_GetConvolutionParameterivEXT,
-                         __glXDispSwap_GetConvolutionParameterivEXT},
-    /* [  4] =     4 */ {__glXDisp_GetSeparableFilterEXT,
-                         __glXDispSwap_GetSeparableFilterEXT},
-    /* [  5] =     5 */ {__glXDisp_GetHistogramEXT,
-                         __glXDispSwap_GetHistogramEXT},
-    /* [  6] =     6 */ {__glXDisp_GetHistogramParameterfvEXT,
-                         __glXDispSwap_GetHistogramParameterfvEXT},
-    /* [  7] =     7 */ {__glXDisp_GetHistogramParameterivEXT,
-                         __glXDispSwap_GetHistogramParameterivEXT},
-    /* [  8] =     8 */ {__glXDisp_GetMinmaxEXT, __glXDispSwap_GetMinmaxEXT},
-    /* [  9] =     9 */ {__glXDisp_GetMinmaxParameterfvEXT,
-                         __glXDispSwap_GetMinmaxParameterfvEXT},
-    /* [ 10] =    10 */ {__glXDisp_GetMinmaxParameterivEXT,
-                         __glXDispSwap_GetMinmaxParameterivEXT},
-    /* [ 11] =    11 */ {__glXDisp_AreTexturesResidentEXT,
-                         __glXDispSwap_AreTexturesResidentEXT},
-    /* [ 12] =    12 */ {__glXDisp_DeleteTexturesEXT,
-                         __glXDispSwap_DeleteTexturesEXT},
-    /* [ 13] =    13 */ {__glXDisp_GenTexturesEXT,
-                         __glXDispSwap_GenTexturesEXT},
-    /* [ 14] =    14 */ {__glXDisp_IsTextureEXT, __glXDispSwap_IsTextureEXT},
-    /* [ 15] =    15 */ {NULL, NULL},
-    /* [ 16] =  1024 */ {__glXDisp_QueryContextInfoEXT,
-                         __glXDispSwap_QueryContextInfoEXT},
-    /* [ 17] =  1025 */ {NULL, NULL},
-    /* [ 18] =  1026 */ {NULL, NULL},
-    /* [ 19] =  1027 */ {NULL, NULL},
-    /* [ 20] =  1028 */ {NULL, NULL},
-    /* [ 21] =  1029 */ {NULL, NULL},
-    /* [ 22] =  1030 */ {NULL, NULL},
-    /* [ 23] =  1031 */ {NULL, NULL},
-    /* [ 24] =  1296 */ {__glXDisp_GetProgramEnvParameterfvARB,
-                         __glXDispSwap_GetProgramEnvParameterfvARB},
-    /* [ 25] =  1297 */ {__glXDisp_GetProgramEnvParameterdvARB,
-                         __glXDispSwap_GetProgramEnvParameterdvARB},
-    /* [ 26] =  1298 */ {NULL, NULL},
-    /* [ 27] =  1299 */ {NULL, NULL},
-    /* [ 28] =  1300 */ {NULL, NULL},
-    /* [ 29] =  1301 */ {NULL, NULL},
-    /* [ 30] =  1302 */ {NULL, NULL},
-    /* [ 31] =  1303 */ {NULL, NULL},
-    /* [ 32] =  1304 */ {__glXDisp_IsProgramARB, __glXDispSwap_IsProgramARB},
-    /* [ 33] =  1305 */ {__glXDisp_GetProgramLocalParameterfvARB,
-                         __glXDispSwap_GetProgramLocalParameterfvARB},
-    /* [ 34] =  1306 */ {__glXDisp_GetProgramLocalParameterdvARB,
-                         __glXDispSwap_GetProgramLocalParameterdvARB},
-    /* [ 35] =  1307 */ {__glXDisp_GetProgramivARB,
-                         __glXDispSwap_GetProgramivARB},
-    /* [ 36] =  1308 */ {__glXDisp_GetProgramStringARB,
-                         __glXDispSwap_GetProgramStringARB},
-    /* [ 37] =  1309 */ {NULL, NULL},
-    /* [ 38] =  1310 */ {NULL, NULL},
-    /* [ 39] =  1311 */ {NULL, NULL},
-    /* [ 40] =  1288 */ {NULL, NULL},
-    /* [ 41] =  1289 */ {NULL, NULL},
-    /* [ 42] =  1290 */ {NULL, NULL},
-    /* [ 43] =  1291 */ {NULL, NULL},
-    /* [ 44] =  1292 */ {NULL, NULL},
-    /* [ 45] =  1293 */ {NULL, NULL},
-    /* [ 46] =  1294 */ {__glXDisp_DeleteProgramsARB,
-                         __glXDispSwap_DeleteProgramsARB},
-    /* [ 47] =  1295 */ {__glXDisp_GenProgramsARB,
-                         __glXDispSwap_GenProgramsARB},
-    /* [ 48] =  1328 */ {NULL, NULL},
-    /* [ 49] =  1329 */ {NULL, NULL},
-    /* [ 50] =  1330 */ {__glXDisp_BindTexImageEXT,
-                         __glXDispSwap_BindTexImageEXT},
-    /* [ 51] =  1331 */ {__glXDisp_ReleaseTexImageEXT,
-                         __glXDispSwap_ReleaseTexImageEXT},
-    /* [ 52] =  1332 */ {NULL, NULL},
-    /* [ 53] =  1333 */ {NULL, NULL},
-    /* [ 54] =  1334 */ {NULL, NULL},
-    /* [ 55] =  1335 */ {NULL, NULL},
-    /* [ 56] =  1416 */ {NULL, NULL},
-    /* [ 57] =  1417 */ {NULL, NULL},
-    /* [ 58] =  1418 */ {NULL, NULL},
-    /* [ 59] =  1419 */ {NULL, NULL},
-    /* [ 60] =  1420 */ {NULL, NULL},
-    /* [ 61] =  1421 */ {NULL, NULL},
-    /* [ 62] =  1422 */ {__glXDisp_IsRenderbuffer,
-                         __glXDispSwap_IsRenderbuffer},
-    /* [ 63] =  1423 */ {__glXDisp_GenRenderbuffers,
-                         __glXDispSwap_GenRenderbuffers},
-    /* [ 64] =  1424 */ {__glXDisp_GetRenderbufferParameteriv,
-                         __glXDispSwap_GetRenderbufferParameteriv},
-    /* [ 65] =  1425 */ {__glXDisp_IsFramebuffer, __glXDispSwap_IsFramebuffer},
-    /* [ 66] =  1426 */ {__glXDisp_GenFramebuffers,
-                         __glXDispSwap_GenFramebuffers},
-    /* [ 67] =  1427 */ {__glXDisp_CheckFramebufferStatus,
-                         __glXDispSwap_CheckFramebufferStatus},
-    /* [ 68] =  1428 */ {__glXDisp_GetFramebufferAttachmentParameteriv,
-                         __glXDispSwap_GetFramebufferAttachmentParameteriv},
-    /* [ 69] =  1429 */ {NULL, NULL},
-    /* [ 70] =  1430 */ {NULL, NULL},
-    /* [ 71] =  1431 */ {NULL, NULL},
-    /* [ 72] =  4096 */ {NULL, NULL},
-    /* [ 73] =  4097 */ {NULL, NULL},
-    /* [ 74] =  4098 */ {__glXDisp_GetColorTableSGI,
-                         __glXDispSwap_GetColorTableSGI},
-    /* [ 75] =  4099 */ {__glXDisp_GetColorTableParameterfvSGI,
-                         __glXDispSwap_GetColorTableParameterfvSGI},
-    /* [ 76] =  4100 */ {__glXDisp_GetColorTableParameterivSGI,
-                         __glXDispSwap_GetColorTableParameterivSGI},
-    /* [ 77] =  4101 */ {NULL, NULL},
-    /* [ 78] =  4102 */ {NULL, NULL},
-    /* [ 79] =  4103 */ {NULL, NULL},
-    /* [ 80] =  5152 */ {NULL, NULL},
-    /* [ 81] =  5153 */ {NULL, NULL},
-    /* [ 82] =  5154 */ {__glXDisp_CopySubBufferMESA,
-                         __glXDispSwap_CopySubBufferMESA},
-    /* [ 83] =  5155 */ {NULL, NULL},
-    /* [ 84] =  5156 */ {NULL, NULL},
-    /* [ 85] =  5157 */ {NULL, NULL},
-    /* [ 86] =  5158 */ {NULL, NULL},
-    /* [ 87] =  5159 */ {NULL, NULL},
-    /* [ 88] = 65536 */ {__glXDisp_SwapIntervalSGI,
-                         __glXDispSwap_SwapIntervalSGI},
-    /* [ 89] = 65537 */ {__glXDisp_MakeCurrentReadSGI,
-                         __glXDispSwap_MakeCurrentReadSGI},
-    /* [ 90] = 65538 */ {NULL, NULL},
-    /* [ 91] = 65539 */ {NULL, NULL},
-    /* [ 92] = 65540 */ {__glXDisp_GetFBConfigsSGIX,
-                         __glXDispSwap_GetFBConfigsSGIX},
-    /* [ 93] = 65541 */ {__glXDisp_CreateContextWithConfigSGIX,
-                         __glXDispSwap_CreateContextWithConfigSGIX},
-    /* [ 94] = 65542 */ {__glXDisp_CreateGLXPixmapWithConfigSGIX,
-                         __glXDispSwap_CreateGLXPixmapWithConfigSGIX},
-    /* [ 95] = 65543 */ {__glXDisp_CreateGLXPbufferSGIX,
-                         __glXDispSwap_CreateGLXPbufferSGIX},
-    /* [ 96] = 65544 */ {__glXDisp_DestroyGLXPbufferSGIX,
-                         __glXDispSwap_DestroyGLXPbufferSGIX},
-    /* [ 97] = 65545 */ {__glXDisp_ChangeDrawableAttributesSGIX,
-                         __glXDispSwap_ChangeDrawableAttributesSGIX},
-    /* [ 98] = 65546 */ {__glXDisp_GetDrawableAttributesSGIX,
-                         __glXDispSwap_GetDrawableAttributesSGIX},
-    /* [ 99] = 65547 */ {NULL, NULL},
-    /* [ 100] = 65548 */ {NULL, NULL},
-    /* [ 101] = 65549 */ {NULL, NULL},
-    /* [ 102] = 65550 */ {NULL, NULL},
-    /* [ 103] = 65551 */ {NULL, NULL},
+static const void *VendorPriv_function_table[88][2] = {
+    /* [  0] =     8 */ {NULL, NULL},
+    /* [  1] =     9 */ {NULL, NULL},
+    /* [  2] =    10 */ {NULL, NULL},
+    /* [  3] =    11 */ {__glXDisp_AreTexturesResidentEXT, __glXDispSwap_AreTexturesResidentEXT},
+    /* [  4] =    12 */ {__glXDisp_DeleteTexturesEXT, __glXDispSwap_DeleteTexturesEXT},
+    /* [  5] =    13 */ {__glXDisp_GenTexturesEXT, __glXDispSwap_GenTexturesEXT},
+    /* [  6] =    14 */ {__glXDisp_IsTextureEXT, __glXDispSwap_IsTextureEXT},
+    /* [  7] =    15 */ {NULL, NULL},
+    /* [  8] =  1024 */ {__glXDisp_QueryContextInfoEXT, __glXDispSwap_QueryContextInfoEXT},
+    /* [  9] =  1025 */ {NULL, NULL},
+    /* [ 10] =  1026 */ {NULL, NULL},
+    /* [ 11] =  1027 */ {NULL, NULL},
+    /* [ 12] =  1028 */ {NULL, NULL},
+    /* [ 13] =  1029 */ {NULL, NULL},
+    /* [ 14] =  1030 */ {NULL, NULL},
+    /* [ 15] =  1031 */ {NULL, NULL},
+    /* [ 16] =  1296 */ {__glXDisp_GetProgramParameterfvNV, __glXDispSwap_GetProgramParameterfvNV},
+    /* [ 17] =  1297 */ {__glXDisp_GetProgramParameterdvNV, __glXDispSwap_GetProgramParameterdvNV},
+    /* [ 18] =  1298 */ {__glXDisp_GetProgramivNV, __glXDispSwap_GetProgramivNV},
+    /* [ 19] =  1299 */ {__glXDisp_GetProgramStringNV, __glXDispSwap_GetProgramStringNV},
+    /* [ 20] =  1300 */ {__glXDisp_GetTrackMatrixivNV, __glXDispSwap_GetTrackMatrixivNV},
+    /* [ 21] =  1301 */ {__glXDisp_GetVertexAttribdvNV, __glXDispSwap_GetVertexAttribdvNV},
+    /* [ 22] =  1302 */ {__glXDisp_GetVertexAttribfvNV, __glXDispSwap_GetVertexAttribfvNV},
+    /* [ 23] =  1303 */ {__glXDisp_GetVertexAttribivNV, __glXDispSwap_GetVertexAttribivNV},
+    /* [ 24] =  1304 */ {__glXDisp_IsProgramARB, __glXDispSwap_IsProgramARB},
+    /* [ 25] =  1305 */ {__glXDisp_GetProgramLocalParameterfvARB, __glXDispSwap_GetProgramLocalParameterfvARB},
+    /* [ 26] =  1306 */ {__glXDisp_GetProgramLocalParameterdvARB, __glXDispSwap_GetProgramLocalParameterdvARB},
+    /* [ 27] =  1307 */ {__glXDisp_GetProgramivARB, __glXDispSwap_GetProgramivARB},
+    /* [ 28] =  1308 */ {__glXDisp_GetProgramStringARB, __glXDispSwap_GetProgramStringARB},
+    /* [ 29] =  1309 */ {NULL, NULL},
+    /* [ 30] =  1310 */ {__glXDisp_GetProgramNamedParameterfvNV, __glXDispSwap_GetProgramNamedParameterfvNV},
+    /* [ 31] =  1311 */ {__glXDisp_GetProgramNamedParameterdvNV, __glXDispSwap_GetProgramNamedParameterdvNV},
+    /* [ 32] =  1288 */ {NULL, NULL},
+    /* [ 33] =  1289 */ {NULL, NULL},
+    /* [ 34] =  1290 */ {NULL, NULL},
+    /* [ 35] =  1291 */ {NULL, NULL},
+    /* [ 36] =  1292 */ {NULL, NULL},
+    /* [ 37] =  1293 */ {__glXDisp_AreProgramsResidentNV, __glXDispSwap_AreProgramsResidentNV},
+    /* [ 38] =  1294 */ {__glXDisp_DeleteProgramsARB, __glXDispSwap_DeleteProgramsARB},
+    /* [ 39] =  1295 */ {__glXDisp_GenProgramsARB, __glXDispSwap_GenProgramsARB},
+    /* [ 40] =  1328 */ {NULL, NULL},
+    /* [ 41] =  1329 */ {NULL, NULL},
+    /* [ 42] =  1330 */ {__glXDisp_BindTexImageEXT, __glXDispSwap_BindTexImageEXT},
+    /* [ 43] =  1331 */ {__glXDisp_ReleaseTexImageEXT, __glXDispSwap_ReleaseTexImageEXT},
+    /* [ 44] =  1332 */ {NULL, NULL},
+    /* [ 45] =  1333 */ {NULL, NULL},
+    /* [ 46] =  1334 */ {NULL, NULL},
+    /* [ 47] =  1335 */ {NULL, NULL},
+    /* [ 48] =  1416 */ {NULL, NULL},
+    /* [ 49] =  1417 */ {NULL, NULL},
+    /* [ 50] =  1418 */ {NULL, NULL},
+    /* [ 51] =  1419 */ {NULL, NULL},
+    /* [ 52] =  1420 */ {NULL, NULL},
+    /* [ 53] =  1421 */ {NULL, NULL},
+    /* [ 54] =  1422 */ {__glXDisp_IsRenderbuffer, __glXDispSwap_IsRenderbuffer},
+    /* [ 55] =  1423 */ {__glXDisp_GenRenderbuffers, __glXDispSwap_GenRenderbuffers},
+    /* [ 56] =  1424 */ {__glXDisp_GetRenderbufferParameteriv, __glXDispSwap_GetRenderbufferParameteriv},
+    /* [ 57] =  1425 */ {__glXDisp_IsFramebuffer, __glXDispSwap_IsFramebuffer},
+    /* [ 58] =  1426 */ {__glXDisp_GenFramebuffers, __glXDispSwap_GenFramebuffers},
+    /* [ 59] =  1427 */ {__glXDisp_CheckFramebufferStatus, __glXDispSwap_CheckFramebufferStatus},
+    /* [ 60] =  1428 */ {__glXDisp_GetFramebufferAttachmentParameteriv, __glXDispSwap_GetFramebufferAttachmentParameteriv},
+    /* [ 61] =  1429 */ {NULL, NULL},
+    /* [ 62] =  1430 */ {NULL, NULL},
+    /* [ 63] =  1431 */ {NULL, NULL},
+    /* [ 64] =  5152 */ {NULL, NULL},
+    /* [ 65] =  5153 */ {NULL, NULL},
+    /* [ 66] =  5154 */ {__glXDisp_CopySubBufferMESA, __glXDispSwap_CopySubBufferMESA},
+    /* [ 67] =  5155 */ {NULL, NULL},
+    /* [ 68] =  5156 */ {NULL, NULL},
+    /* [ 69] =  5157 */ {NULL, NULL},
+    /* [ 70] =  5158 */ {NULL, NULL},
+    /* [ 71] =  5159 */ {NULL, NULL},
+    /* [ 72] = 65536 */ {__glXDisp_SwapIntervalSGI, __glXDispSwap_SwapIntervalSGI},
+    /* [ 73] = 65537 */ {__glXDisp_MakeCurrentReadSGI, __glXDispSwap_MakeCurrentReadSGI},
+    /* [ 74] = 65538 */ {NULL, NULL},
+    /* [ 75] = 65539 */ {NULL, NULL},
+    /* [ 76] = 65540 */ {__glXDisp_GetFBConfigsSGIX, __glXDispSwap_GetFBConfigsSGIX},
+    /* [ 77] = 65541 */ {__glXDisp_CreateContextWithConfigSGIX, __glXDispSwap_CreateContextWithConfigSGIX},
+    /* [ 78] = 65542 */ {__glXDisp_CreateGLXPixmapWithConfigSGIX, __glXDispSwap_CreateGLXPixmapWithConfigSGIX},
+    /* [ 79] = 65543 */ {__glXDisp_CreateGLXPbufferSGIX, __glXDispSwap_CreateGLXPbufferSGIX},
+    /* [ 80] = 65544 */ {__glXDisp_DestroyGLXPbufferSGIX, __glXDispSwap_DestroyGLXPbufferSGIX},
+    /* [ 81] = 65545 */ {__glXDisp_ChangeDrawableAttributesSGIX, __glXDispSwap_ChangeDrawableAttributesSGIX},
+    /* [ 82] = 65546 */ {__glXDisp_GetDrawableAttributesSGIX, __glXDispSwap_GetDrawableAttributesSGIX},
+    /* [ 83] = 65547 */ {NULL, NULL},
+    /* [ 84] = 65548 */ {NULL, NULL},
+    /* [ 85] = 65549 */ {NULL, NULL},
+    /* [ 86] = 65550 */ {NULL, NULL},
+    /* [ 87] = 65551 */ {NULL, NULL},
 };
 
 const struct __glXDispatchInfo VendorPriv_dispatch_info = {
@@ -1808,3 +1569,4 @@ const struct __glXDispatchInfo VendorPriv_dispatch_info = {
     NULL,
     NULL
 };
+
diff --git a/xserver/glx/indirect_texture_compression.c b/vcxsrv-code/xorg-server/glx/indirect_texture_compression.c
index 6d25bcd..a4b6d42 100644
--- a/xserver/glx/indirect_texture_compression.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_texture_compression.c
@@ -26,6 +26,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxbyteorder.h"
@@ -35,6 +36,7 @@
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
 int
 __glXDisp_GetCompressedTexImage(struct __GLXclientStateRec *cl, GLbyte * pc)
 {
@@ -57,11 +59,11 @@ __glXDisp_GetCompressedTexImage(struct __GLXclientStateRec *cl, GLbyte * pc)
                                  &compsize);
 
         if (compsize != 0) {
-            PFNGLGETCOMPRESSEDTEXIMAGEARBPROC GetCompressedTexImageARB =
-                __glGetProcAddress("glGetCompressedTexImageARB");
+            PFNGLGETCOMPRESSEDTEXIMAGEPROC GetCompressedTexImage =
+                __glGetProcAddress("glGetCompressedTexImage");
             __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
             __glXClearErrorOccured();
-            GetCompressedTexImageARB(target, level, answer);
+            GetCompressedTexImage(target, level, answer);
         }
 
         if (__glXErrorOccured()) {
@@ -104,11 +106,11 @@ __glXDispSwap_GetCompressedTexImage(struct __GLXclientStateRec *cl, GLbyte * pc)
                                  &compsize);
 
         if (compsize != 0) {
-            PFNGLGETCOMPRESSEDTEXIMAGEARBPROC GetCompressedTexImageARB =
-                __glGetProcAddress("glGetCompressedTexImageARB");
+            PFNGLGETCOMPRESSEDTEXIMAGEPROC GetCompressedTexImage =
+                __glGetProcAddress("glGetCompressedTexImage");
             __GLX_GET_ANSWER_BUFFER(answer, cl, compsize, 1);
             __glXClearErrorOccured();
-            GetCompressedTexImageARB(target, level, answer);
+            GetCompressedTexImage(target, level, answer);
         }
 
         if (__glXErrorOccured()) {
diff --git a/xserver/glx/indirect_util.c b/vcxsrv-code/xorg-server/glx/indirect_util.c
index ba180b0..2d8b55f 100644
--- a/xserver/glx/indirect_util.c
+++ b/vcxsrv-code/xorg-server/glx/indirect_util.c
@@ -26,6 +26,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <string.h>
 
@@ -43,6 +44,8 @@
 #include "indirect_table.h"
 #include "indirect_util.h"
 
+#include "glfunctions.h"
+
 #define __GLX_PAD(a) (((a)+3)&~3)
 
 GLint
diff --git a/xserver/glx/render2.c b/vcxsrv-code/xorg-server/glx/render2.c
index 8d9b5f4..bdd6341 100644
--- a/xserver/glx/render2.c
+++ b/vcxsrv-code/xorg-server/glx/render2.c
@@ -31,12 +31,15 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <glxserver.h>
 #include "unpack.h"
 #include "indirect_size.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
+
 void
 __glXDisp_Map1f(GLbyte * pc)
 {
@@ -232,18 +235,18 @@ __glXDisp_DrawArrays(GLbyte * pc)
             break;
         case GL_SECONDARY_COLOR_ARRAY:
         {
-            PFNGLSECONDARYCOLORPOINTERPROC SecondaryColorPointerEXT =
-                __glGetProcAddress("glSecondaryColorPointerEXT");
+            PFNGLSECONDARYCOLORPOINTERPROC SecondaryColorPointer =
+                __glGetProcAddress("glSecondaryColorPointer");
             glEnableClientState(GL_SECONDARY_COLOR_ARRAY);
-            SecondaryColorPointerEXT(numVals, datatype, stride, pc);
+            SecondaryColorPointer(numVals, datatype, stride, pc);
             break;
         }
         case GL_FOG_COORD_ARRAY:
         {
-            PFNGLFOGCOORDPOINTERPROC FogCoordPointerEXT =
-                __glGetProcAddress("glFogCoordPointerEXT");
+            PFNGLFOGCOORDPOINTERPROC FogCoordPointer =
+                __glGetProcAddress("glFogCoordPointer");
             glEnableClientState(GL_FOG_COORD_ARRAY);
-            FogCoordPointerEXT(datatype, stride, pc);
+            FogCoordPointer(datatype, stride, pc);
             break;
         }
         default:
diff --git a/xserver/glx/render2swap.c b/vcxsrv-code/xorg-server/glx/render2swap.c
index 6ed364f..3d77988 100644
--- a/xserver/glx/render2swap.c
+++ b/vcxsrv-code/xorg-server/glx/render2swap.c
@@ -31,12 +31,15 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "unpack.h"
 #include "indirect_size.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
+
 void
 __glXDispSwap_Map1f(GLbyte * pc)
 {
@@ -354,18 +357,18 @@ __glXDispSwap_DrawArrays(GLbyte * pc)
             break;
         case GL_SECONDARY_COLOR_ARRAY:
         {
-            PFNGLSECONDARYCOLORPOINTERPROC SecondaryColorPointerEXT =
-                __glGetProcAddress("glSecondaryColorPointerEXT");
+            PFNGLSECONDARYCOLORPOINTERPROC SecondaryColorPointer =
+                __glGetProcAddress("glSecondaryColorPointer");
             glEnableClientState(GL_SECONDARY_COLOR_ARRAY);
-            SecondaryColorPointerEXT(numVals, datatype, stride, pc);
+            SecondaryColorPointer(numVals, datatype, stride, pc);
             break;
         }
         case GL_FOG_COORD_ARRAY:
         {
-            PFNGLFOGCOORDPOINTERPROC FogCoordPointerEXT =
-                __glGetProcAddress("glFogCoordPointerEXT");
+            PFNGLFOGCOORDPOINTERPROC FogCoordPointer =
+                __glGetProcAddress("glFogCoordPointer");
             glEnableClientState(GL_FOG_COORD_ARRAY);
-            FogCoordPointerEXT(datatype, stride, pc);
+            FogCoordPointer(datatype, stride, pc);
             break;
         }
         default:
diff --git a/xserver/glx/renderpix.c b/vcxsrv-code/xorg-server/glx/renderpix.c
index 91ba911..2a387b2 100644
--- a/xserver/glx/renderpix.c
+++ b/vcxsrv-code/xorg-server/glx/renderpix.c
@@ -31,11 +31,14 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "unpack.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
+
 void
 __glXDisp_SeparableFilter2D(GLbyte * pc)
 {
diff --git a/xserver/glx/renderpixswap.c b/vcxsrv-code/xorg-server/glx/renderpixswap.c
index a4cb246..3fa1151 100644
--- a/xserver/glx/renderpixswap.c
+++ b/vcxsrv-code/xorg-server/glx/renderpixswap.c
@@ -31,11 +31,14 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "unpack.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
+
 void
 __glXDispSwap_SeparableFilter2D(GLbyte * pc)
 {
diff --git a/xserver/glx/rensize.c b/vcxsrv-code/xorg-server/glx/rensize.c
index 55ad4a2..6fbf712 100644
--- a/xserver/glx/rensize.c
+++ b/vcxsrv-code/xorg-server/glx/rensize.c
@@ -30,6 +30,10 @@
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+
+#include "glheader.h"
+
 #endif
 
 #include <GL/gl.h>
diff --git a/xserver/glx/single2.c b/vcxsrv-code/xorg-server/glx/single2.c
index 36a01f0..a7e2d1d 100644
--- a/xserver/glx/single2.c
+++ b/vcxsrv-code/xorg-server/glx/single2.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -42,6 +43,8 @@
 #include "indirect_dispatch.h"
 #include "unpack.h"
 
+#include "glfunctions.h"
+
 int
 __glXDisp_FeedbackBuffer(__GLXclientState * cl, GLbyte * pc)
 {
diff --git a/xserver/glx/single2swap.c b/vcxsrv-code/xorg-server/glx/single2swap.c
index b140946..571c3e4 100644
--- a/xserver/glx/single2swap.c
+++ b/vcxsrv-code/xorg-server/glx/single2swap.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxutil.h"
@@ -38,6 +39,8 @@
 #include "indirect_dispatch.h"
 #include "unpack.h"
 
+#include "glfunctions.h"
+
 int
 __glXDispSwap_FeedbackBuffer(__GLXclientState * cl, GLbyte * pc)
 {
diff --git a/xserver/glx/singlepix.c b/vcxsrv-code/xorg-server/glx/singlepix.c
index e1bed19..d4f6993 100644
--- a/xserver/glx/singlepix.c
+++ b/vcxsrv-code/xorg-server/glx/singlepix.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxext.h"
@@ -39,6 +40,8 @@
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
 
+#include "glfunctions.h"
+
 int
 __glXDisp_ReadPixels(__GLXclientState * cl, GLbyte * pc)
 {
diff --git a/xserver/glx/singlepixswap.c b/vcxsrv-code/xorg-server/glx/singlepixswap.c
index 8e4d9bd..79e0bb9 100644
--- a/xserver/glx/singlepixswap.c
+++ b/vcxsrv-code/xorg-server/glx/singlepixswap.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxext.h"
@@ -39,6 +40,8 @@
 #include "indirect_dispatch.h"
 #include "indirect_size_get.h"
 
+#include "glfunctions.h"
+
 int
 __glXDispSwap_ReadPixels(__GLXclientState * cl, GLbyte * pc)
 {
diff --git a/xserver/glx/singlesize.c b/vcxsrv-code/xorg-server/glx/singlesize.c
index 4c60b69..3c4c6fa 100644
--- a/xserver/glx/singlesize.c
+++ b/vcxsrv-code/xorg-server/glx/singlesize.c
@@ -31,12 +31,15 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include <GL/gl.h>
 #include "glxserver.h"
 #include "singlesize.h"
 #include "indirect_size_get.h"
 
+#include "glfunctions.h"
+
 /*
 ** These routines compute the size of variable-size returned parameters.
 ** Unlike the similar routines that do the same thing for variable-size
diff --git a/xserver/glx/swap_interval.c b/vcxsrv-code/xorg-server/glx/swap_interval.c
index 2320550..d82e63f 100644
--- a/xserver/glx/swap_interval.c
+++ b/vcxsrv-code/xorg-server/glx/swap_interval.c
@@ -25,6 +25,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxutil.h"
diff --git a/xserver/glx/unpack.h b/vcxsrv-code/xorg-server/glx/unpack.h
index 9676e64..51cc4ff 100644
--- a/xserver/glx/unpack.h
+++ b/vcxsrv-code/xorg-server/glx/unpack.h
@@ -88,7 +88,7 @@
 	    (cl)->returnBufSize = (size)+(align);			 \
 	}								 \
 	res = (char*)cl->returnBuf;					 \
-	bump = (long)(res) % (align);					 \
+	bump = (long)(uintptr_t)(res) % (align);					 \
 	if (bump) res += (align) - (bump);				 \
     } else {								 \
 	res = (char *)answerBuffer;					 \
diff --git a/xserver/glx/vndcmds.c b/vcxsrv-code/xorg-server/glx/vndcmds.c
index d6d8719..f42e70f 100644
--- a/xserver/glx/vndcmds.c
+++ b/vcxsrv-code/xorg-server/glx/vndcmds.c
@@ -28,6 +28,7 @@
  */
 
 #include <dix-config.h>
+#include <protocol-versions.h>
 
 #include "hashtable.h"
 #include "vndserver.h"
@@ -47,7 +48,7 @@ typedef struct GlxVendorPrivDispatchRec {
     HashTable hh;
 } GlxVendorPrivDispatch;
 
-static GlxServerDispatchProc dispatchFuncs[OPCODE_ARRAY_LEN] = {};
+static GlxServerDispatchProc dispatchFuncs[OPCODE_ARRAY_LEN];
 static HashTable vendorPrivHash = NULL;
 static HtGenericHashSetupRec vendorPrivSetup = {
     .keySize = sizeof(CARD32)
@@ -107,8 +108,8 @@ static int dispatch_GLXQueryVersion(ClientPtr client)
     REQUEST_SIZE_MATCH(xGLXQueryVersionReq);
 
     SetReplyHeader(client, &reply);
-    reply.majorVersion = GlxCheckSwap(client, 1);
-    reply.minorVersion = GlxCheckSwap(client, 4);
+    reply.majorVersion = GlxCheckSwap(client, SERVER_GLX_MAJOR_VERSION);
+    reply.minorVersion = GlxCheckSwap(client, SERVER_GLX_MINOR_VERSION);
 
     WriteToClient(client, sz_xGLXQueryVersionReply, &reply);
     return Success;
@@ -208,7 +209,7 @@ static int CommonMakeCurrent(ClientPtr client,
         GLXDrawable readdrawable,
         GLXContextID context)
 {
-    xGLXMakeCurrentReply reply = {};
+    xGLXMakeCurrentReply reply;
     GlxContextTagInfo *oldTag = NULL;
     GlxServerVendor *newVendor = NULL;
 
diff --git a/xserver/glx/xfont.c b/vcxsrv-code/xorg-server/glx/xfont.c
index bd2fdae..a6da247 100644
--- a/xserver/glx/xfont.c
+++ b/vcxsrv-code/xorg-server/glx/xfont.c
@@ -31,6 +31,7 @@
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
+#include "glheader.h"
 
 #include "glxserver.h"
 #include "glxutil.h"
@@ -41,6 +42,8 @@
 #include <windowstr.h>
 #include <dixfontstr.h>
 
+#include "glfunctions.h"
+
 /*
 ** Make a single GL bitmap from a single X glyph
 */
diff --git a/xserver/hw/kdrive/ephyr/ephyr.c b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyr.c
index 9236252..fa59796 100644
--- a/xserver/hw/kdrive/ephyr/ephyr.c
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyr.c
@@ -64,8 +64,11 @@ Bool EphyrWantNoHostGrab = 0;
 Bool
 ephyrInitialize(KdCardInfo * card, EphyrPriv * priv)
 {
+#ifdef _MSC_VER
+  __asm int 3;
+#else
     OsSignal(SIGUSR1, hostx_handle_signal);
-
+#endif  
     priv->base = 0;
     priv->bytes_per_line = 0;
     return TRUE;
@@ -807,6 +810,14 @@ ephyrUpdateModifierState(unsigned int state)
     }
 }
 
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
 static Bool
 ephyrCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
 {
diff --git a/xserver/hw/kdrive/ephyr/ephyr.h b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyr.h
index 8833de8..11b0949 100644
--- a/xserver/hw/kdrive/ephyr/ephyr.h
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyr.h
@@ -26,8 +26,11 @@
 #ifndef _EPHYR_H_
 #define _EPHYR_H_
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
 #include <libgen.h>
+#endif
+#include <signal.h>
 #include <xcb/xcb_image.h>
 
 #include "os.h"                 /* for OsSignal() */
@@ -194,6 +197,8 @@ extern Bool ephyrCursorInit(ScreenPtr pScreen);
 
 extern int ephyrBufferHeight(KdScreenInfo * screen);
 
+extern int ephyrBufferHeight(KdScreenInfo *screen);
+
 /* ephyr_draw.c */
 
 Bool
diff --git a/xserver/hw/kdrive/ephyr/ephyrinit.c b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyrinit.c
index 020461d..236c65f 100644
--- a/xserver/hw/kdrive/ephyr/ephyrinit.c
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyrinit.c
@@ -58,6 +58,7 @@ InitCard(char *name)
     KdCardInfoAdd(&ephyrFuncs, 0);
 }
 
+#ifndef _MSC_VER
 void
 InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
 {
@@ -143,6 +144,7 @@ ddxUseMsg(void)
     ErrorF("-no-host-grab        Disable grabbing the keyboard and mouse.\n");
     ErrorF("\n");
 }
+#endif
 
 void
 processScreenOrOutputArg(const char *screen_size, const char *output, char *parent_id)
@@ -188,6 +190,7 @@ processOutputArg(const char *output, char *parent_id)
     processScreenOrOutputArg("100x100+0+0", output, parent_id);
 }
 
+#ifndef _MSC_VER
 int
 ddxProcessArgument(int argc, char **argv, int i)
 {
@@ -375,6 +378,15 @@ OsVendorInit(void)
     }
 }
 
+#ifdef DDXOSFATALERROR
+void
+OsVendorFatalError(void)
+{
+}
+#endif
+
+#endif
+
 KdCardFuncs ephyrFuncs = {
     ephyrCardInit,              /* cardinit */
     ephyrScreenInitialize,      /* scrinit */
diff --git a/xserver/hw/kdrive/ephyr/ephyrlog.h b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyrlog.h
index 744da74..0d48012 100644
--- a/xserver/hw/kdrive/ephyr/ephyrlog.h
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/ephyrlog.h
@@ -43,14 +43,14 @@
 #ifndef EPHYR_LOG
 #define EPHYR_LOG(...) \
 LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, "in %s:%d:%s: ",\
-                      __FILE__, __LINE__, __func__) ; \
+                      __FILE__, __LINE__, __FUNCTION__) ; \
 LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, __VA_ARGS__)
 #endif                          /*nomadik_log */
 
 #ifndef EPHYR_LOG_ERROR
 #define EPHYR_LOG_ERROR(...) \
 LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, "Error:in %s:%d:%s: ",\
-                      __FILE__, __LINE__, __func__) ; \
+                      __FILE__, __LINE__, __FUNCTION__) ; \
 LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, __VA_ARGS__)
 #endif                          /*EPHYR_LOG_ERROR */
 
diff --git a/xserver/hw/kdrive/ephyr/hostx.c b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/hostx.c
index f9cb698..7e7e39a 100644
--- a/xserver/hw/kdrive/ephyr/hostx.c
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/hostx.c
@@ -38,10 +38,12 @@
 #include <time.h>
 #include <err.h>
 
+#ifndef _MSC_VER
 #include <sys/ipc.h>
 #include <sys/shm.h>
 #include <sys/time.h>
 #include <sys/mman.h>
+#endif
 
 #include <X11/keysym.h>
 #include <xcb/xcb.h>
@@ -152,7 +154,11 @@ hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num, Boo
 void
 hostx_set_display_name(char *name)
 {
+#ifdef _MSC_VER
+  __asm int 3;
+#else
     HostX.server_dpy_name = strdup(name);
+#endif
 }
 
 void
@@ -722,6 +728,9 @@ hostx_init(void)
         }
     }
 
+#ifdef _MSC_VER
+  __asm int 3;
+#else
     hostx_init_shm();
     if (HostX.have_shm) {
         /* Really really check we have shm - better way ?*/
@@ -735,6 +744,7 @@ hostx_init(void)
     } else {
         fprintf(stderr, "\nXephyr unable to use SHM XImages\n");
     }
+#endif
 
     xcb_flush(HostX.conn);
 
@@ -865,7 +875,7 @@ hostx_screen_init(KdScreenInfo *screen,
     Bool shm_success = FALSE;
 
     if (!scrpriv) {
-        fprintf(stderr, "%s: Error in accessing hostx data\n", __func__);
+        fprintf(stderr, "%s: Error in accessing hostx data\n", __FUNCTION__);
         exit(1);
     }
 
@@ -878,8 +888,12 @@ hostx_screen_init(KdScreenInfo *screen,
          */
 
         if (HostX.have_shm) {
+#ifdef _MSC_VER
+	  __asm int 3;
+#else
             xcb_image_destroy(scrpriv->ximg);
             hostx_destroy_shm_segment(&scrpriv->shminfo, scrpriv->shmsize);
+#endif
         }
         else {
             free(scrpriv->ximg->data);
@@ -890,6 +904,9 @@ hostx_screen_init(KdScreenInfo *screen,
     }
 
     if (!ephyr_glamor && HostX.have_shm) {
+#ifdef _MSC_VER
+__asm int 3;
+#else
         scrpriv->ximg = xcb_image_create_native(HostX.conn,
                                                 width,
                                                 buffer_height,
@@ -912,6 +929,7 @@ hostx_screen_init(KdScreenInfo *screen,
             scrpriv->ximg->data = scrpriv->shminfo.shmaddr;
             shm_success = TRUE;
         }
+#endif
     }
 
     if (!ephyr_glamor && !shm_success) {
@@ -1096,10 +1114,14 @@ hostx_paint_rect(KdScreenInfo *screen,
     }
 
     if (HostX.have_shm) {
+#ifdef _MSC_VER
+      __asm int 3;
+#else
         xcb_image_shm_put(HostX.conn, scrpriv->win,
                           HostX.gc, scrpriv->ximg,
                           scrpriv->shminfo,
                           sx, sy, dx, dy, width, height, FALSE);
+#endif
     }
     else {
         xcb_image_t *subimg = xcb_image_subimage(scrpriv->ximg, sx, sy,
@@ -1118,6 +1140,9 @@ static void
 hostx_paint_debug_rect(KdScreenInfo *screen,
                        int x, int y, int width, int height)
 {
+#ifdef _MSC_VER
+  __asm int 3;
+#else
     EphyrScrPriv *scrpriv = screen->driver;
     struct timespec tspec;
     xcb_rectangle_t rect = { .x = x, .y = y, .width = width, .height = height };
@@ -1139,6 +1164,7 @@ hostx_paint_debug_rect(KdScreenInfo *screen,
 
     /* nanosleep seems to work better than usleep for me... */
     nanosleep(&tspec, NULL);
+#endif
 }
 
 Bool
diff --git a/xserver/hw/kdrive/ephyr/hostx.h b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/hostx.h
index 4b2678e..2d03747 100644
--- a/xserver/hw/kdrive/ephyr/hostx.h
+++ b/vcxsrv-code/xorg-server/hw/kdrive/ephyr/hostx.h
@@ -38,8 +38,12 @@
 #define EPHYR_DBG(x, a...) \
  fprintf(stderr, __FILE__ ":%d,%s() " x "\n", __LINE__, __func__, ##a)
 #else
+#ifdef _MSC_VER
+#define EPHYR_DBG()
+#else
 #define EPHYR_DBG(x, a...) do {} while (0)
 #endif
+#endif
 
 typedef struct EphyrHostXVars EphyrHostXVars;
 
diff --git a/xserver/hw/kdrive/src/kdrive.c b/vcxsrv-code/xorg-server/hw/kdrive/src/kdrive.c
index 8de01cc..2a746bd 100644
--- a/xserver/hw/kdrive/src/kdrive.c
+++ b/vcxsrv-code/xorg-server/hw/kdrive/src/kdrive.c
@@ -164,10 +164,12 @@ KdEnableScreen(ScreenPtr pScreen)
 }
 
 void
+#ifndef _MSC_VER
 ddxGiveUp(enum ExitCode error)
 {
     KdDisableScreens();
 }
+#endif
 
 static Bool kdDumbDriver;
 static Bool kdSoftCursor;
@@ -976,11 +978,13 @@ KdInitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
 #endif
 }
 
+#ifndef _MSC_VER
 void
 OsVendorFatalError(const char *f, va_list args)
 {
 }
 
+#endif
 /* These stubs can be safely removed once we can
  * split input and GPU parts in hotplug.h et al. */
 #ifdef CONFIG_UDEV_KMS
diff --git a/xserver/hw/kdrive/src/kdrive.h b/vcxsrv-code/xorg-server/hw/kdrive/src/kdrive.h
index 432f891..ada9576 100644
--- a/xserver/hw/kdrive/src/kdrive.h
+++ b/vcxsrv-code/xorg-server/hw/kdrive/src/kdrive.h
@@ -52,7 +52,7 @@
 #define KD_DPMS_POWERDOWN   3
 #define KD_DPMS_MAX	    KD_DPMS_POWERDOWN
 
-#define Status int
+typedef int Status;
 
 typedef struct _KdCardInfo {
     struct _KdCardFuncs *cfuncs;
diff --git a/xserver/hw/kdrive/src/kinput.c b/vcxsrv-code/xorg-server/hw/kdrive/src/kinput.c
index 185a9a3..ffbf01f 100644
--- a/xserver/hw/kdrive/src/kinput.c
+++ b/vcxsrv-code/xorg-server/hw/kdrive/src/kinput.c
@@ -88,6 +88,14 @@ extern const char *kdGlobalXkbLayout;
 extern const char *kdGlobalXkbVariant;
 extern const char *kdGlobalXkbOptions;
 
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
 #ifdef FNONBLOCK
 #define NOBLOCK FNONBLOCK
 #else
@@ -105,6 +113,18 @@ KdResetInputMachine(void)
     }
 }
 
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
+#ifdef _MSC_VER
+    __asm int 3;
+#else
+#endif
 void
 KdDisableInput(void)
 {
@@ -354,6 +374,8 @@ KdPointerProc(DeviceIntPtr pDevice, int onoff)
     return BadImplementation;
 }
 
+#ifndef _MSC_VER
+#endif
 static void
 KdRingBell(KdKeyboardInfo * ki, int volume, int pitch, int duration)
 {
@@ -381,6 +403,7 @@ KdBell(int volume, DeviceIntPtr pDev, void *arg, int something)
     KdRingBell(ki, volume, ctrl->bell_pitch, ctrl->bell_duration);
 }
 
+#ifndef _MSC_VER
 void
 DDXRingBell(int volume, int pitch, int duration)
 {
@@ -391,6 +414,7 @@ DDXRingBell(int volume, int pitch, int duration)
             KdRingBell(ki, volume, pitch, duration);
     }
 }
+#endif
 
 static void
 KdSetLeds(KdKeyboardInfo * ki, int leds)
@@ -1881,12 +1905,14 @@ miPointerScreenFuncRec kdPointerScreenFuncs = {
     KdWarpCursor
 };
 
+#ifndef _MSC_VER
 void
 ProcessInputEvents(void)
 {
     mieqProcessInputEvents();
     KdCheckLock();
 }
+#endif
 
 /* At the moment, absolute/relative is up to the client. */
 int
diff --git a/xserver/hw/xfree86/common/compiler.h b/vcxsrv-code/xorg-server/hw/xfree86/common/compiler.h
index eb788d3..19749c5 100644
--- a/xserver/hw/xfree86/common/compiler.h
+++ b/vcxsrv-code/xorg-server/hw/xfree86/common/compiler.h
@@ -84,7 +84,7 @@
 #endif
 #endif                          /* __inline__ */
 #ifndef __inline
-#if defined(__GNUC__)
+#if defined(__GNUC__) || defined(_MSC_VER)
     /* gcc has __inline */
 #else
 #define __inline /**/
@@ -941,7 +941,7 @@ inl(unsigned PORT_SIZE port)
 #define asm __asm
 #endif
 #endif
-#if !defined(__SUNPRO_C)
+#if !defined(__SUNPRO_C) && !defined(_MSC_VER)
 #include <sys/inline.h>
 #endif
 #endif                          /* __GNUC__ */
diff --git a/xserver/hw/xwayland/xwayland-present.c b/vcxsrv-code/xorg-server/hw/xwayland/xwayland-present.c
index ed49783..69c02dc 100644
--- a/xserver/hw/xwayland/xwayland-present.c
+++ b/vcxsrv-code/xorg-server/hw/xwayland/xwayland-present.c
@@ -93,7 +93,6 @@ xwl_present_free_timer(struct xwl_present_window *xwl_present_window)
 {
     TimerFree(xwl_present_window->frame_timer);
     xwl_present_window->frame_timer = NULL;
-    xwl_present_window->timer_armed = 0;
 }
 
 static CARD32
@@ -131,7 +130,6 @@ static void
 xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 {
     if (xwl_present_has_pending_events(xwl_present_window)) {
-        CARD32 now = GetTimeInMillis();
         CARD32 timeout;
 
         if (!xorg_list_is_empty(&xwl_present_window->frame_callback_list))
@@ -139,21 +137,6 @@ xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
         else
             timeout = TIMER_LEN_COPY;
 
-        /* Make sure the timer callback runs if at least a second has passed
-         * since we first armed the timer. This can happen e.g. if the Wayland
-         * compositor doesn't send a pending frame event, e.g. because the
-         * Wayland surface isn't visible anywhere.
-         */
-        if (xwl_present_window->timer_armed) {
-            if ((int)(now - xwl_present_window->timer_armed) > 1000) {
-                xwl_present_timer_callback(xwl_present_window->frame_timer, now,
-                                           xwl_present_window);
-                return;
-            }
-        } else {
-            xwl_present_window->timer_armed = now;
-        }
-
         xwl_present_window->frame_timer = TimerSet(xwl_present_window->frame_timer,
                                                    0, timeout,
                                                    &xwl_present_timer_callback,
@@ -403,8 +386,6 @@ xwl_present_msc_bump(struct xwl_present_window *xwl_present_window)
 
     xwl_present_window->ust = GetTimeInMicros();
 
-    xwl_present_window->timer_armed = 0;
-
     if (flip_pending && flip_pending->sync_flip)
         xwl_present_flip_notify_vblank(flip_pending, xwl_present_window->ust, msc);
 
@@ -820,14 +801,14 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
         present_execute_copy(vblank, crtc_msc);
         assert(!vblank->queued);
 
-        /* Clear the pixmap field, so this will fall through to present_execute_post next time */
-        dixDestroyPixmap(vblank->pixmap, vblank->pixmap->drawable.id);
-        vblank->pixmap = NULL;
-
         if (xwl_present_queue_vblank(screen, window, vblank->crtc,
                                      vblank->event_id, crtc_msc + 1)
-            == Success)
+            == Success) {
+            /* Clear the pixmap field, so this will fall through to present_execute_post next time */
+            dixDestroyPixmap(vblank->pixmap, vblank->pixmap->drawable.id);
+            vblank->pixmap = NULL;
             return;
+        }
     }
 
     present_execute_post(vblank, ust, crtc_msc);
diff --git a/xserver/hw/xwayland/xwayland-present.h b/vcxsrv-code/xorg-server/hw/xwayland/xwayland-present.h
index 5d880e8..d3eff73 100644
--- a/xserver/hw/xwayland/xwayland-present.h
+++ b/vcxsrv-code/xorg-server/hw/xwayland/xwayland-present.h
@@ -41,8 +41,6 @@ struct xwl_present_window {
     uint64_t ust;
 
     OsTimerPtr frame_timer;
-    /* Timestamp when the current timer was first armed */
-    CARD32 timer_armed;
 
     struct wl_callback *sync_callback;
 
diff --git a/xserver/hw/xwin/InitInput.c b/vcxsrv-code/xorg-server/hw/xwin/InitInput.c
index 04cd514..ff40ae3 100644
--- a/xserver/hw/xwin/InitInput.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/InitInput.c
@@ -32,7 +32,7 @@
 #include "win.h"
 #include "dixstruct.h"
 #include "inputstr.h"
-
+#include <unistd.h>
 /*
  * Local function prototypes
  */
@@ -54,15 +54,7 @@ DeviceIntPtr g_pwinKeyboard;
 void
 ProcessInputEvents(void)
 {
-#if 0
-    ErrorF("ProcessInputEvents\n");
-#endif
-
     mieqProcessInputEvents();
-
-#if 0
-    ErrorF("ProcessInputEvents - returning\n");
-#endif
 }
 
 void
@@ -88,9 +80,8 @@ xwinDevWindowsHandlerNotify(int fd, int ready, void *data)
 void
 InitInput(int argc, char *argv[])
 {
-#if CYGDEBUG
+  int rc;
     winDebug("InitInput\n");
-#endif
 
     /*
      * Wrap some functions at every generation of the server.
@@ -108,8 +99,8 @@ InitInput(int argc, char *argv[])
 
     mieqInit();
 
-    /* Initialize the mode key states */
-    winInitializeModeKeyStates();
+    /* Do not nitialize the mode key states here yet since the keyboard device is not started yet
+    winInitializeModeKeyStates (); */
 
 #ifdef HAS_DEVWINDOWS
     /* Only open the windows message queue device once */
@@ -126,13 +117,13 @@ InitInput(int argc, char *argv[])
     }
 #endif
 
-#if CYGDEBUG
     winDebug("InitInput - returning\n");
-#endif
 }
 
 void
 CloseInput(void)
 {
     mieqFini();
+    g_pwinPointer=NULL;
+    g_pwinKeyboard=NULL;
 }
diff --git a/xserver/hw/xwin/InitOutput.c b/vcxsrv-code/xorg-server/hw/xwin/InitOutput.c
index 7a03bfb..65c3641 100644
--- a/xserver/hw/xwin/InitOutput.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/InitOutput.c
@@ -38,6 +38,7 @@ from The Open Group.
 #ifdef DPMSExtension
 #include "dpmsproc.h"
 #endif
+#include <locale.h>
 #ifdef __CYGWIN__
 #include <mntent.h>
 #endif
@@ -45,15 +46,12 @@ from The Open Group.
 #include "xkbsrv.h"
 #endif
 #ifdef RELOCATE_PROJECTROOT
-#pragma push_macro("Status")
 #undef Status
-#define Status wStatus
 #include <shlobj.h>
-#pragma pop_macro("Status")
-typedef WINAPI HRESULT(*SHGETFOLDERPATHPROC) (HWND hwndOwner,
-                                              int nFolder,
-                                              HANDLE hToken,
-                                              DWORD dwFlags, LPTSTR pszPath);
+typedef HRESULT  (__stdcall *  SHGETFOLDERPATHPROC)(HWND hwndOwner,
+                                                    int nFolder,
+                                                    HANDLE hToken,
+                                                    DWORD dwFlags, LPTSTR pszPath);
 #endif
 
 #include "winmonitors.h"
@@ -71,10 +69,15 @@ typedef WINAPI HRESULT(*SHGETFOLDERPATHPROC) (HWND hwndOwner,
  * References to external symbols
  */
 
+extern int xserver_resetting;
+
 /*
  * Function prototypes
  */
 
+static Bool
+ winCheckDisplayNumber(void);
+
 void
  winLogCommandLine(int argc, char *argv[]);
 
@@ -84,10 +87,6 @@ void
 Bool
  winValidateArgs(void);
 
-#ifdef RELOCATE_PROJECTROOT
-const char *winGetBaseDir(void);
-#endif
-
 /*
  * For the depth 24 pixmap we default to 32 bits per pixel, but
  * we change this pixmap format later if we detect that the display
@@ -111,15 +110,13 @@ static PixmapFormatRec g_PixmapFormats[] = {
     {32, 32, BITMAP_SCANLINE_PAD}
 };
 
+#if defined(GLXEXT) && defined(XWIN_WINDOWS_DRI)
 static Bool noDriExtension;
 
 static const ExtensionModule xwinExtensions[] = {
-#ifdef GLXEXT
-#ifdef XWIN_WINDOWS_DRI
   { WindowsDRIExtensionInit, "Windows-DRI", &noDriExtension },
-#endif
-#endif
 };
+#endif
 
 /*
  * XwinExtensionInit
@@ -135,7 +132,11 @@ void XwinExtensionInit(void)
     }
 #endif
 
+#if defined(GLXEXT) && defined(XWIN_WINDOWS_DRI)
     LoadExtensionList(xwinExtensions, ARRAY_SIZE(xwinExtensions), TRUE);
+#else
+    LoadExtensionList(NULL, 0, TRUE);
+#endif
 }
 
 #if defined(DDXBEFORERESET)
@@ -147,6 +148,7 @@ void XwinExtensionInit(void)
 void
 ddxBeforeReset(void)
 {
+    xserver_resetting = 1;
     winDebug("ddxBeforeReset - Hello\n");
 
     winClipboardShutdown();
@@ -187,14 +189,12 @@ ddxGiveUp(enum ExitCode error)
 {
     int i;
 
-#if CYGDEBUG
     winDebug("ddxGiveUp\n");
-#endif
 
     /* Perform per-screen deinitialization */
     for (i = 0; i < g_iNumScreens; ++i) {
         /* Delete the tray icon */
-        if (!g_ScreenInfo[i].fNoTrayIcon && g_ScreenInfo[i].pScreen)
+        if (!g_ScreenInfo[i].fNoTrayIcon && g_ScreenInfo[i].pScreen && !pref.fNoTrayIcon)
             winDeleteNotifyIcon(winGetScreenPriv(g_ScreenInfo[i].pScreen));
     }
 
@@ -330,8 +330,10 @@ winCheckMount(void)
         return;
     }
 
+#ifdef WINDBG
     if (!binary)
-        winMsg(X_WARNING, "/tmp mounted in textmode\n");
+        winDebug("/tmp mounted in textmode\n");
+#endif
 }
 #else
 static void
@@ -358,7 +360,7 @@ winGetBaseDir(void)
         fendptr = buffer + size;
         while (fendptr > buffer) {
             if (*fendptr == '\\' || *fendptr == '/') {
-                *fendptr = 0;
+                fendptr[1] = 0; // Include ending slash
                 break;
             }
             fendptr--;
@@ -383,8 +385,17 @@ winFixupPaths(void)
 #ifdef READ_FONTDIRS
     {
         /* Open fontpath configuration file */
+#if defined WIN32 && defined __MINGW32__
+        static Bool once = FALSE;
+        char buffer[MAX_PATH];
+        snprintf(buffer, sizeof(buffer), "%sfont-dirs", basedir);
+        buffer[sizeof(buffer)-1] = 0;
+        FILE *fontdirs = fopen(buffer, "rt");
+        if (once) fontdirs = NULL;
+        else once = TRUE;
+#else
         FILE *fontdirs = fopen(ETCX11DIR "/font-dirs", "rt");
-
+#endif
         if (fontdirs != NULL) {
             char buffer[256];
             int needs_sep = TRUE;
@@ -482,7 +493,7 @@ winFixupPaths(void)
 #endif                          /* READ_FONTDIRS */
 #ifdef RELOCATE_PROJECTROOT
     {
-        const char *libx11dir = PROJECTROOT "/lib/X11";
+        const char *libx11dir = PROJECTROOT "/";
         size_t libx11dir_len = strlen(libx11dir);
         char *newfp = NULL;
         size_t newfp_len = 0;
@@ -548,30 +559,37 @@ winFixupPaths(void)
     }
 #endif                          /* RELOCATE_PROJECTROOT */
     if (changed_fontpath)
-        winMsg(font_from, "FontPath set to \"%s\"\n", defaultFontPath);
+        winDebug ("FontPath set to \"%s\"\n", defaultFontPath);
 
 #ifdef RELOCATE_PROJECTROOT
     if (getenv("XKEYSYMDB") == NULL) {
         char buffer[MAX_PATH];
 
-        snprintf(buffer, sizeof(buffer), "XKEYSYMDB=%s\\XKeysymDB", basedir);
+        snprintf(buffer, sizeof(buffer), "XKEYSYMDB=%sXKeysymDB", basedir);
         buffer[sizeof(buffer) - 1] = 0;
         putenv(buffer);
     }
     if (getenv("XERRORDB") == NULL) {
         char buffer[MAX_PATH];
 
-        snprintf(buffer, sizeof(buffer), "XERRORDB=%s\\XErrorDB", basedir);
+        snprintf(buffer, sizeof(buffer), "XERRORDB=%sXErrorDB", basedir);
         buffer[sizeof(buffer) - 1] = 0;
         putenv(buffer);
     }
     if (getenv("XLOCALEDIR") == NULL) {
         char buffer[MAX_PATH];
 
-        snprintf(buffer, sizeof(buffer), "XLOCALEDIR=%s\\locale", basedir);
+        snprintf(buffer, sizeof(buffer), "XLOCALEDIR=%slocale", basedir);
         buffer[sizeof(buffer) - 1] = 0;
         putenv(buffer);
     }
+    if (getenv("XHOSTPREFIX") == NULL) {
+        char buffer[MAX_PATH];
+        snprintf(buffer, sizeof(buffer), "XHOSTPREFIX=%sX",
+                basedir);
+        buffer[sizeof(buffer)-1] = 0;
+        putenv(buffer);
+    }
     if (getenv("HOME") == NULL) {
         char buffer[MAX_PATH + 5];
 
@@ -584,7 +602,7 @@ winFixupPaths(void)
             putenv(buffer);
         }
         else {
-            winMsg(X_ERROR, "Can not determine HOME directory\n");
+            ErrorF ("Can not determine HOME directory\n");
         }
     }
     if (!g_fLogFileChanged) {
@@ -593,16 +611,17 @@ winFixupPaths(void)
 
         if (size && size < sizeof(buffer)) {
             snprintf(buffer + size, sizeof(buffer) - size,
-                     "XWin.%s.log", display);
+                    "VCXSrv.%s.log", display); 
             buffer[sizeof(buffer) - 1] = 0;
             g_pszLogFile = buffer;
-            winMsg(X_DEFAULT, "Logfile set to \"%s\"\n", g_pszLogFile);
+            GetLongPathName(buffer, buffer, MAX_PATH);
+            winDebug ("Logfile set to \"%s\"\n", g_pszLogFile);
         }
     }
     {
         static char xkbbasedir[MAX_PATH];
 
-        snprintf(xkbbasedir, sizeof(xkbbasedir), "%s\\xkb", basedir);
+        snprintf(xkbbasedir, sizeof(xkbbasedir), "%sxkbdata", basedir);
         if (sizeof(xkbbasedir) > 0)
             xkbbasedir[sizeof(xkbbasedir) - 1] = 0;
         XkbBaseDirectory = xkbbasedir;
@@ -612,11 +631,8 @@ winFixupPaths(void)
 }
 
 void
-OsVendorInit(void)
+OsVendorPreInit(int argc, char *argv[])
 {
-    /* Re-initialize global variables on server reset */
-    winInitializeGlobals();
-
     winFixupPaths();
 
 #ifdef DDXOSVERRORF
@@ -638,6 +654,17 @@ OsVendorInit(void)
     LogSetParameter(XLOG_VERBOSITY, g_iLogVerbose);
     LogSetParameter(XLOG_FILE_VERBOSITY, g_iLogVerbose);
 
+    /* Log the command line */
+    winLogCommandLine(argc, argv);
+
+}
+
+void
+OsVendorInit(void)
+{
+    /* Re-initialize global variables on server reset */
+    winInitializeGlobals();
+
     /* Log the version information */
     if (serverGeneration == 1)
         winLogVersionInfo();
@@ -675,8 +702,7 @@ OsVendorInit(void)
                     g_ScreenInfo[j].iE3BTimeout = WIN_DEFAULT_E3B_TIME;
                     if (reportOnce) {
                         reportOnce = FALSE;
-                        winMsg(X_PROBED,
-                               "Windows reports only %d mouse buttons, defaulting to -emulate3buttons\n",
+                        winDebug("Windows reports only %d mouse buttons, defaulting to -emulate3buttons\n",
                                mouseButtons);
                     }
                 }
@@ -712,11 +738,25 @@ winUseMsg(void)
 
     ErrorF("-[no]clipboard\n"
            "\tEnable [disable] the clipboard integration. Default is enabled.\n");
+    ErrorF ("-noprimary\n"
+	        "\tDo not map the PRIMARY selection to the windows clipboard.\n"
+          "\tThe CLIPBOARD selection is always mapped if -clipboard is enabled.\n"
+          "\tDefault is mapped.\n");
 
     ErrorF("-clipupdates num_boxes\n"
            "\tUse a clipping region to constrain shadow update blits to\n"
            "\tthe updated region when num_boxes, or more, are in the\n"
-           "\tupdated region.\n");
+           "\tupdated region.  Diminished effect on current Windows\n"
+           "\tversions because they already group GDI operations together\n"
+           "\tin a batch, which has a similar effect.\n");
+
+    ErrorF("-[no]compositewm\n"
+           "\tEnable [Disable] Composite extension. Default is enabled.\n"
+           "\tUsed in -multiwindow mode.\n"
+           "\tUse Composite extension redirection to maintain a bitmap\n"
+           "\timage of each top-level X window, so window contents which\n"
+           "\tare occluded show correctly in Taskbar and Task Switcher\n"
+           "\tpreviews.\n");
 
     ErrorF("-[no]compositealpha\n"
            "\tX windows with per-pixel alpha are composited into the Windows desktop.\n");
@@ -792,11 +832,13 @@ winUseMsg(void)
            "\tUse the entire virtual screen if multiple\n"
            "\tmonitors are present.\n");
 
-    ErrorF("-multiwindow\n" "\tRun the server in multi-window mode.\n");
+    ErrorF("-multiwindow\n"
+           "\tRun the server in multiwindow mode.  Not to be used\n"
+           "\ttogether with -rootless or -fullscreen.\n");
 
     ErrorF("-nodecoration\n"
            "\tDo not draw a window border, title bar, etc.  Windowed\n"
-           "\tmode only.\n");
+           "\tmode only i.e. ignored when -fullscreen specified.\n");
 
     ErrorF("-[no]primary\n"
            "\tWhen clipboard integration is enabled, map the X11 PRIMARY selection\n"
@@ -811,7 +853,10 @@ winUseMsg(void)
            "\tmode gives the window scrollbars as needed, 'randr' mode uses the RANR\n"
            "\textension to resize the X screen.  'randr' is the default.\n");
 
-    ErrorF("-rootless\n" "\tRun the server in rootless mode.\n");
+    ErrorF("-rootless\n"
+           "\tUse a transparent root window with an external window\n"
+           "\tmanager (such as openbox).  Not to be used with\n"
+           "\t-multiwindow or with -fullscreen.\n");
 
     ErrorF("-screen scr_num [width height [x y] | [[WxH[+X+Y]][@m]] ]\n"
            "\tEnable screen scr_num and optionally specify a width and\n"
@@ -828,35 +873,40 @@ winUseMsg(void)
            "\tcursor instead.\n");
 
     ErrorF("-[no]trayicon\n"
-           "\tDo not create a tray icon.  Default is to create one\n"
-           "\ticon per screen.  You can globally disable tray icons with\n"
-           "\t-notrayicon, then enable it for specific screens with\n"
-           "\t-trayicon for those screens.\n");
+           "\tDo not create a notification area icon.  Default is to create\n"
+           "\tone icon per screen.  You can globally disable notification area\n"
+           "\ticons with -notrayicon, then enable them for specific screens\n"
+           "\twith -trayicon for those screens.\n");
 
-    ErrorF("-[no]unixkill\n" "\tCtrl+Alt+Backspace exits the X Server.\n");
+    ErrorF("-[no]unixkill\n"
+           "\tCtrl-Alt-Backspace exits the X Server. The Ctrl-Alt-Backspace\n"
+           "\tkey combo is disabled by default.\n");
 
-#ifdef XWIN_GLX_WINDOWS
     ErrorF("-[no]wgl\n"
            "\tEnable the GLX extension to use the native Windows WGL interface for hardware-accelerated OpenGL\n");
-#endif
+
+    ErrorF("-swrastwgl\n"
+           "\tEnable the GLX extension to use the native Windows WGL interface based on the swrast interface for accelerated OpenGL\n");
 
     ErrorF("-[no]winkill\n" "\tAlt+F4 exits the X Server.\n");
 
     ErrorF("-xkblayout XKBLayout\n"
-           "\tEquivalent to XKBLayout in XF86Config files.\n"
+           "\tSet the layout to use for XKB.  This defaults to a layout\n"
+           "\tmatching your current layout from Windows or us (i.e. USA)\n"
+           "\tif no matching layout was found.\n"
            "\tFor example: -xkblayout de\n");
 
     ErrorF("-xkbmodel XKBModel\n"
-           "\tEquivalent to XKBModel in XF86Config files.\n");
+           "\tSet the model to use for XKB.  This defaults to pc105.\n");
 
     ErrorF("-xkboptions XKBOptions\n"
-           "\tEquivalent to XKBOptions in XF86Config files.\n");
+           "\tSet the options to use for XKB.  This defaults to not set.\n");
 
     ErrorF("-xkbrules XKBRules\n"
-           "\tEquivalent to XKBRules in XF86Config files.\n");
+           "\tSet the rules to use for XKB.  This defaults to xorg.\n");
 
     ErrorF("-xkbvariant XKBVariant\n"
-           "\tEquivalent to XKBVariant in XF86Config files.\n"
+           "\tSet the variant to use for XKB.  This defaults to not set.\n"
            "\tFor example: -xkbvariant nodeadkeys\n");
 }
 
@@ -895,16 +945,12 @@ void
 InitOutput(ScreenInfo * pScreenInfo, int argc, char *argv[])
 {
     int i;
+    xserver_resetting = 0;
 
     if (serverGeneration == 1)
         XwinExtensionInit();
 
-    /* Log the command line */
-    winLogCommandLine(argc, argv);
-
-#if CYGDEBUG
     winDebug("InitOutput\n");
-#endif
 
     /* Validate command-line arguments */
     if (serverGeneration == 1 && !winValidateArgs()) {
@@ -912,14 +958,17 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char *argv[])
                    "Exiting.\n");
     }
 
+    /* Check for duplicate invocation on same display number. */
+    if (serverGeneration == 1 && !winCheckDisplayNumber()) {
+        FatalError("InitOutput - Another X server is already running display-"
+                   "number :%d\n", atoi(display));
+    }
+
 #ifdef XWIN_XF86CONFIG
     /* Try to read the xorg.conf-style configuration file */
     if (!winReadConfigfile())
-        winErrorFVerb(1, "InitOutput - Error reading config file\n");
+        ErrorF ("InitOutput - Error reading config file\n");
 #else
-    winMsg(X_INFO, "xorg.conf is not supported\n");
-    winMsg(X_INFO, "See http://x.cygwin.com/docs/faq/cygwin-x-faq.html "
-           "for more information\n");
     winConfigFiles();
 #endif
 
@@ -1020,7 +1069,73 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char *argv[])
         winGenerateAuthorization();
 
 
-#if CYGDEBUG || YES
     winDebug("InitOutput - Returning.\n");
-#endif
+}
+
+/*
+ * winCheckDisplayNumber - Check if another instance of Cygwin/X is
+ * already running on the same display number.  If no one exists,
+ * make a mutex to prevent new instances from running on the same display.
+ *
+ * return FALSE if the display number is already used.
+ */
+
+static Bool
+winCheckDisplayNumber(void)
+{
+    int nDisp;
+    HANDLE mutex;
+    char name[MAX_PATH];
+    const char *pszPrefix = 0;
+    OSVERSIONINFO osvi = { 0 };
+
+    /* Check display range */
+    nDisp = atoi(display);
+    if (nDisp < 0 || nDisp > 65535 - X_TCP_PORT) {
+        ErrorF("winCheckDisplayNumber - Bad display number: %d\n", nDisp);
+        return FALSE;
+    }
+
+    /* Set first character of mutex name to null */
+    name[0] = '\0';
+
+    /* Get operating system version information */
+    osvi.dwOSVersionInfoSize = sizeof(osvi);
+    GetVersionEx(&osvi);
+
+    /* Want a mutex shared among all terminals on NT > 4.0 */
+    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.dwMajorVersion >= 5) {
+        pszPrefix = "Global\\";
+    }
+
+    /* Setup Cygwin/X specific part of name */
+    snprintf(name, sizeof(name), "%sCYGWINX_DISPLAY:%d", pszPrefix, nDisp);
+
+    /* Windows automatically releases the mutex when this process exits */
+    mutex = CreateMutex(NULL, FALSE, name);
+    if (!mutex) {
+        LPVOID lpMsgBuf;
+
+        /* Display a fancy error message */
+        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
+                      FORMAT_MESSAGE_FROM_SYSTEM |
+                      FORMAT_MESSAGE_IGNORE_INSERTS,
+                      NULL,
+                      GetLastError(),
+                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+                      (LPTSTR) &lpMsgBuf, 0, NULL);
+        ErrorF("winCheckDisplayNumber - CreateMutex failed: %s\n",
+               (LPSTR) lpMsgBuf);
+        LocalFree(lpMsgBuf);
+
+        return FALSE;
+    }
+    if (GetLastError() == ERROR_ALREADY_EXISTS) {
+        ErrorF("winCheckDisplayNumber - "
+               "Xming or Cygwin/X is already running display-number :%d\n",
+               nDisp);
+        return FALSE;
+    }
+
+    return TRUE;
 }
diff --git a/xserver/hw/xwin/XWin.rc b/vcxsrv-code/xorg-server/hw/xwin/XWin.rc
index a54e0fd..7367ce6 100644
--- a/xserver/hw/xwin/XWin.rc
+++ b/vcxsrv-code/xorg-server/hw/xwin/XWin.rc
@@ -32,32 +32,66 @@
 #include <windows.h>
 #include "winresource.h"
 #include "xwin-config.h"
-#include "version-config.h"
+
+#define VER_FILEVERSION             1,20,14,0
+#define VER_FILEVERSION_STR         "1.20.14.0"
+
+#define VER_PRODUCTVERSION          1,20,14,0
+#define VER_PRODUCTVERSION_STR      "1.20.14.0"
+
+VS_VERSION_INFO VERSIONINFO
+FILEVERSION    VER_FILEVERSION
+PRODUCTVERSION VER_PRODUCTVERSION
+FILETYPE       VFT_APP
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904E4"
+        BEGIN
+            VALUE "FileDescription",  "VcXsrv windows xserver\0"
+            VALUE "FileVersion",      VER_FILEVERSION_STR"\0"
+            VALUE "InternalName",     "VcXsrv\0"
+            VALUE "LegalCopyright",   "marha@users.sourceforge.net\0"
+            VALUE "OriginalFilename", "vcxsrv.exe\0"
+            VALUE "ProductName",      "VcXsrv\0"
+            VALUE "ProductVersion",   VER_PRODUCTVERSION_STR"\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        /* The following line should only be modified for localized versions.     */
+        /* It consists of any number of WORD,WORD pairs, with each pair           */
+        /* describing a language,codepage combination supported by the file.      */
+        /*                                                                        */
+        /* For example, a file might have values "0x409,1252" indicating that it  */
+        /* supports English language (0x409) in the Windows ANSI codepage (1252). */
+
+        VALUE "Translation", 0x409, 1252
+    END
+END
 
 /*
  * Dialogs
  */
 
 /* About */
-ABOUT_BOX DIALOGEX 32, 32, 260, 105
+ABOUT_BOX DIALOGEX 32, 32, 260, 95
 STYLE WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_TABSTOP  | DS_CENTERMOUSE
-CAPTION "About " XVENDORNAMESHORT
+CAPTION "About "XVENDORNAMESHORT
 FONT 8, "MS Shell Dlg 2"
 BEGIN
-  CONTROL				IDI_XWIN, IDC_STATIC, "Static", SS_ICON, 8, 8, 32, 32
-  LTEXT			XVENDORNAMESHORT " X Server ", IDC_STATIC, 36, 8, 220, 8
-  LTEXT			VENDOR_MAN_VERSION, IDC_STATIC, 36, 18, 220, 8
-  LTEXT			BUILDERSTRING, IDC_STATIC, 36, 28, 220, 8
-  LTEXT			"This software is licensed under the terms of the MIT/X11 License.", IDC_STATIC, 36, 48, 220, 20
-  CONTROL               __VENDORDWEBSUPPORT__, ID_ABOUT_WEBSITE, "Button",
-                        BS_OWNERDRAW | WS_TABSTOP, 36, 68, 220, 8
-  DEFPUSHBUTTON		"&OK", IDOK, 105, 85, 50, 15
+  CONTROL			IDI_XWIN, IDC_STATIC, "Static", SS_ICON, 8, 8, 32, 32
+  LTEXT			"VcXsrv X Server ", IDC_STATIC, 36, 8, 220, 8
+  LTEXT			"http://vcxsrv.sourceforge.net", IDC_STATIC, 36, 18, 220, 8
+  LTEXT			"marha@users.sourceforge.net", IDC_STATIC, 36, 28, 220, 8
+  LTEXT			"Version "VER_PRODUCTVERSION_STR" (31 Dec 2021)", IDC_STATIC, 36, 38, 220, 8
+  DEFPUSHBUTTON		"OK", IDOK, 105, 75, 50, 15
 END
 
 
 /* Depth change */
 
-DEPTH_CHANGE_BOX DIALOGEX 32, 32, 180, 100
+DEPTH_CHANGE_BOX DIALOGEX	32, 32, 180, 100
 STYLE WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | DS_CENTERMOUSE
 FONT 8, "MS Shell Dlg 2"
 CAPTION XVENDORNAMESHORT
@@ -65,16 +99,16 @@ BEGIN
   DEFPUSHBUTTON		"Dismiss", IDOK, 66, 80, 50, 14
   CTEXT			XVENDORNAMESHORT, IDC_STATIC, 40, 12, 100, 8
   CTEXT			"Disruptive screen configuration change.", IDC_STATIC, 7, 40, 166, 8
-  CTEXT			"Restore previous resolution to use " XVENDORNAMESHORT ".", IDC_STATIC, 7, 52, 166, 8
+  CTEXT			"Restore previous resolution to use "XVENDORNAMESHORT".", IDC_STATIC, 7, 52, 166, 8
 END
 
 
 /* Exit */
 
-EXIT_DIALOG DIALOGEX 32, 32, 180, 78
+EXIT_DIALOG DIALOGEX	32, 32, 180, 78
 STYLE WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_TABSTOP | DS_CENTERMOUSE
 FONT 8, "MS Shell Dlg 2"
-CAPTION "Exit " XVENDORNAMESHORT "?"
+CAPTION "Exit "XVENDORNAMESHORT"?"
 BEGIN
   PUSHBUTTON "E&xit", IDOK, 55, 56, 30, 14
   DEFPUSHBUTTON "&Cancel", IDCANCEL, 95, 56, 30, 14
@@ -83,6 +117,17 @@ BEGIN
   CTEXT "Proceed with shutdown of this display/server?", IDC_STATIC, 7, 36, 166, 8
 END
 
+/* Xdmcp host selection dialog  */
+XDMCP_HOSTS DIALOGEX 32, 32, 260, 156
+STYLE DS_SETFONT | DS_CENTERMOUSE | WS_POPUP | WS_VISIBLE | WS_CAPTION
+EXSTYLE WS_EX_NOPARENTNOTIFY
+CAPTION "Select host to connect to"
+FONT 8, "MS Shell Dlg 2", 0, 0, 0x1
+BEGIN
+    DEFPUSHBUTTON   "Connect",IDOK,61,132,50,15
+    LISTBOX         IDC_HOSTLIST,7,7,245,113,LBS_SORT | LBS_NOINTEGRALHEIGHT | LBS_NOTIFY | WS_VSCROLL | WS_TABSTOP
+    PUSHBUTTON      "Cancel",IDCANCEL,147,134,50,14
+END
 
 /*
  * Menus
@@ -94,6 +139,7 @@ BEGIN
 	BEGIN
 		MENUITEM "&Hide Root Window", ID_APP_HIDE_ROOT
 		MENUITEM "Clipboard may use &PRIMARY selection", ID_APP_MONITOR_PRIMARY
+		MENUITEM "Gather &Windows", ID_APP_GATHER_WINDOWS
 		MENUITEM "&About...", ID_APP_ABOUT
 		MENUITEM SEPARATOR
 		MENUITEM "E&xit...", ID_APP_EXIT
@@ -106,4 +152,4 @@ END
  */
 
 IDI_XWIN		ICON	"X.ico"
-CREATEPROCESS_MANIFEST_RESOURCE_ID	RT_MANIFEST	"XWin.exe.manifest"
+/* CREATEPROCESS_MANIFEST_RESOURCE_ID	RT_MANIFEST	"XWin.exe.manifest"*/
diff --git a/xserver/hw/xwin/glx/.gitignore b/vcxsrv-code/xorg-server/hw/xwin/glx/.gitignore
index 9684410..70c5283 100644
--- a/xserver/hw/xwin/glx/.gitignore
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/.gitignore
@@ -1,6 +1,3 @@
 # ignore generated files
 diag.txt
-generated_gl_shim.c
-generated_gl_thunks.c
-generated_gl_thunks.def
-generated_wgl_wrappers.c
+
diff --git a/xserver/hw/xwin/glx/gen_gl_wrappers.py b/vcxsrv-code/xorg-server/hw/xwin/glx/gen_gl_wrappers.py
index b9e8dda..1d9aeab 100644
--- a/xserver/hw/xwin/glx/gen_gl_wrappers.py
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/gen_gl_wrappers.py
@@ -1,8 +1,5 @@
 #!/usr/bin/python3
 #
-# python script to generate cdecl to stdcall wrappers for GL functions
-# adapted from genheaders.py
-#
 # Copyright (c) 2013 The Khronos Group Inc.
 #
 # Permission is hereby granted, free of charge, to any person obtaining a
@@ -27,21 +24,29 @@
 import sys, time, pdb, string, cProfile
 from reg import *
 
+# debug - start header generation in debugger
+# dump - dump registry after loading
+# profile - enable Python profiling
+# protect - whether to use #ifndef protections
+# registry <filename> - use specified XML registry instead of gl.xml
+# timeit - time length of registry loading & header generation
+# validate - validate return & parameter group tags against <group>
+debug   = False
+dump    = False
+profile = False
+protect = True
+timeit  = False
+validate= False
 # Default input / log files
 errFilename = None
 diagFilename = 'diag.txt'
 regFilename = 'gl.xml'
 outFilename = 'gen_gl_wrappers.c'
-
-protect=True
+dispatchheader=None
 prefix="gl"
 preresolve=False
-wrapper=False
-shim=False
-thunk=False
-thunkdefs=False
 staticwrappers=False
-nodebug=False
+nodebugcallcounting=False
 
 # list of WGL extension functions we use
 used_wgl_ext_fns = {key: 1 for key in [
@@ -62,58 +67,127 @@ if __name__ == '__main__':
     while (i < len(sys.argv)):
         arg = sys.argv[i]
         i = i + 1
-        if (arg == '-noprotect'):
+        if (arg == '-debug'):
+            print('Enabling debug (-debug)', file=sys.stderr)
+            debug = True
+        elif (arg == '-dump'):
+            print('Enabling dump (-dump)', file=sys.stderr)
+            dump = True
+        elif (arg == '-noprotect'):
             print('Disabling inclusion protection in output headers', file=sys.stderr)
             protect = False
+        elif (arg == '-profile'):
+            print('Enabling profiling (-profile)', file=sys.stderr)
+            profile = True
         elif (arg == '-registry'):
             regFilename = sys.argv[i]
             i = i+1
-            print('Using registry', regFilename, file=sys.stderr)
+            print('Using registry ', regFilename, file=sys.stderr)
+        elif (arg == '-time'):
+            print('Enabling timing (-time)', file=sys.stderr)
+            timeit = True
+        elif (arg == '-validate'):
+            print('Enabling group validation (-validate)', file=sys.stderr)
+            validate = True
         elif (arg == '-outfile'):
             outFilename = sys.argv[i]
             i = i+1
         elif (arg == '-preresolve'):
             preresolve=True
-        elif (arg == '-wrapper'):
-            wrapper=True
-        elif (arg == '-shim'):
-            shim=True
-        elif (arg == '-thunk'):
-            thunk=True
-        elif (arg == '-thunkdefs'):
-            thunkdefs=True
         elif (arg == '-staticwrappers'):
             staticwrappers=True
+        elif (arg == '-dispatchheader'):
+            dispatchheader = sys.argv[i]
+            i = i+1
         elif (arg == '-prefix'):
             prefix = sys.argv[i]
             i = i+1
-        elif (arg == '-nodebug'):
-            nodebug = True
+        elif (arg == '-nodbgcount'):
+            nodebugcallcounting = True
         elif (arg[0:1] == '-'):
             print('Unrecognized argument:', arg, file=sys.stderr)
             exit(1)
-
-print('Generating', outFilename, file=sys.stderr)
+print('Generating ', outFilename, file=sys.stderr)
+
+# Simple timer functions
+startTime = None
+def startTimer():
+    global startTime
+    startTime = time.time()
+def endTimer(msg):
+    global startTime
+    endTime = time.time()
+    if (timeit):
+        print(msg, endTime - startTime)
+        startTime = None
 
 # Load & parse registry
 reg = Registry()
+
+startTimer()
 tree = etree.parse(regFilename)
-reg.loadElementTree(tree)
+endTimer('Time to make ElementTree =')
 
-if shim:
-    versions = '1\.[012]'
-else:
-    versions = '.*'
+startTimer()
+reg.loadElementTree(tree)
+endTimer('Time to parse ElementTree =')
+
+if (validate):
+    reg.validateGroups()
+
+if (dump):
+    print('***************************************')
+    print('Performing Registry dump to regdump.txt')
+    print('***************************************')
+    reg.dumpReg(filehandle = open('regdump.txt','w'))
+
+# Turn a list of strings into a regexp string matching exactly those strings
+def makeREstring(list):
+    return '^(' + '|'.join(list) + ')$'
+
+# These are "mandatory" OpenGL ES 1 extensions, to
+# be included in the core GLES/gl.h header.
+es1CoreList = [
+    'GL_OES_read_format',
+    'GL_OES_compressed_paletted_texture',
+    'GL_OES_point_size_array',
+    'GL_OES_point_sprite'
+]
+
+# Descriptive names for various regexp patterns used to select
+# versions and extensions
+
+allVersions     = allExtensions = '.*'
+noVersions      = noExtensions = None
+gl12andLaterPat = '1\.[2-9]|[234]\.[0-9]'
+gles2onlyPat    = '2\.[0-9]'
+gles2and3Pat    = '[23]\.[0-9]'
+es1CorePat      = makeREstring(es1CoreList)
+# Extensions in old glcorearb.h but not yet tagged accordingly in gl.xml
+glCoreARBPat    = None
+glx13andLaterPat = '1\.[3-9]'
+
+# Defaults for generating re-inclusion protection wrappers (or not)
+protectFile = protect
+protectFeature = protect
+protectProto = protect
 
 genOpts = CGeneratorOptions(
         apiname           = prefix,
         profile           = 'compatibility',
-        versions          = versions,
-        emitversions      = versions,
+        versions          = allVersions,
+        emitversions      = allVersions,
         defaultExtensions = prefix,                   # Default extensions for GL
-        protectFile       = protect,
-        protectFeature    = protect,
-        protectProto      = protect,
+#        addExtensions     = None,
+#        removeExtensions  = None,
+#        prefixText        = prefixStrings + glExtPlatformStrings + glextVersionStrings,
+#        genFuncPointers   = True,
+#        protectFile       = protectFile,
+#        protectFeature    = protectFeature,
+#        protectProto      = protectProto,
+#        apicall           = 'GLAPI ',
+#        apientry          = 'APIENTRY ',
+#        apientryp         = 'APIENTRYP '),
         )
 
 # create error/warning & diagnostic files
@@ -123,6 +197,28 @@ else:
     errWarn = sys.stderr
 diag = open(diagFilename, 'w')
 
+#
+# look for all the SET_ macros in dispatch.h, this is the set of functions
+# we need to generate
+#
+
+dispatch = {}
+
+if dispatchheader :
+    fh = open(dispatchheader)
+    dispatchh = fh.readlines()
+
+    dispatch_regex = re.compile(r'(?:#define|static\s+INLINE\s+void)\s+SET_([^\()]+)\(')
+
+    for line in dispatchh :
+        line = line.strip()
+        m1 = dispatch_regex.search(line)
+
+        if m1 :
+            dispatch[prefix+m1.group(1)] = 1
+
+    del dispatch['glby_offset']
+
 def ParseCmdRettype(cmd):
     proto=noneStr(cmd.elem.find('proto'))
     rettype=noneStr(proto.text)
@@ -161,7 +257,7 @@ class PreResolveOutputGenerator(OutputGenerator):
         OutputGenerator.__init__(self, errFile, warnFile, diagFile)
         self.wrappers={}
     def beginFile(self, genOpts):
-        self.outFile.write('/* Automatically generated from %s - DO NOT EDIT */\n\n'%regFilename)
+        pass
     def endFile(self):
         self.outFile.write('\nvoid ' + prefix + 'ResolveExtensionProcs(void)\n{\n')
         for funcname in self.wrappers.keys():
@@ -169,6 +265,7 @@ class PreResolveOutputGenerator(OutputGenerator):
         self.outFile.write('}\n\n')
     def beginFeature(self, interface, emit):
         OutputGenerator.beginFeature(self, interface, emit)
+        self.OldVersion = self.featureName.startswith('GL_VERSION_1_0') or self.featureName.startswith('GL_VERSION_1_1')
     def endFeature(self):
         OutputGenerator.endFeature(self)
     def genType(self, typeinfo, name):
@@ -177,21 +274,21 @@ class PreResolveOutputGenerator(OutputGenerator):
         OutputGenerator.genEnum(self, enuminfo, name)
     def genCmd(self, cmd, name):
         OutputGenerator.genCmd(self, cmd, name)
-
         if prefix == 'wgl' and not name in used_wgl_ext_fns:
             return
 
         self.outFile.write('RESOLVE_DECL(PFN' + name.upper() + 'PROC);\n')
         self.wrappers[name]=1
 
-class WrapperOutputGenerator(OutputGenerator):
+class MyOutputGenerator(OutputGenerator):
     def __init__(self,
                  errFile = sys.stderr,
                  warnFile = sys.stderr,
                  diagFile = sys.stdout):
         OutputGenerator.__init__(self, errFile, warnFile, diagFile)
+        self.wrappers={}
     def beginFile(self, genOpts):
-        self.outFile.write('/* Automatically generated from %s - DO NOT EDIT */\n\n'%regFilename)
+        pass
     def endFile(self):
         pass
     def beginFeature(self, interface, emit):
@@ -205,14 +302,19 @@ class WrapperOutputGenerator(OutputGenerator):
         OutputGenerator.genEnum(self, enuminfo, name)
     def genCmd(self, cmd, name):
         OutputGenerator.genCmd(self, cmd, name)
+        # Avoid generating wrappers which aren't referenced by the dispatch table
+        if dispatchheader and not name in dispatch :
+            self.outFile.write('/* No wrapper for ' + name + ', not in dispatch table */\n')
+            return
 
         if prefix == 'wgl' and not name in used_wgl_ext_fns:
             return
 
+        self.wrappers[name]=1
         rettype=ParseCmdRettype(cmd)
 
         if staticwrappers: self.outFile.write("static ")
-        self.outFile.write("%s %sWrapper("%(rettype, name))
+        self.outFile.write("%s __stdcall %sWrapper("%(rettype, name))
         plist=ParseCmdParams(cmd)
         Comma=""
         if len(plist):
@@ -221,210 +323,55 @@ class WrapperOutputGenerator(OutputGenerator):
                 Comma=", "
         else:
             self.outFile.write("void")
-
-        self.outFile.write(")\n{\n")
-
-        # for GL 1.0 and 1.1 functions, generate stdcall wrappers which call the function directly
         if self.OldVersion:
-            if not nodebug:
-                self.outFile.write('  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");\n'%(prefix.upper(), name))
-                self.outFile.write("  glWinDirectProcCalls++;\n")
-                self.outFile.write("\n")
-
-            if rettype.lower()=="void":
-                self.outFile.write("  %s( "%(name))
+            if nodebugcallcounting:
+                self.outFile.write(")\n{\n")
             else:
-                self.outFile.write("  return %s( "%(name))
-
-            Comma=""
-            for ptype, pname in plist:
-                self.outFile.write("%s%s"%(Comma, pname))
-                Comma=", "
-
-        # for GL 1.2+ functions, generate stdcall wrappers which use wglGetProcAddress()
-        else:
-            if rettype.lower()=="void":
-                self.outFile.write('  RESOLVE(PFN%sPROC, "%s");\n'%(name.upper(), name))
-
-                if not nodebug:
-                    self.outFile.write("\n")
-                    self.outFile.write('  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");\n'%(prefix.upper(), name))
-                    self.outFile.write("\n")
-
-                self.outFile.write("  RESOLVED_PROC(PFN%sPROC)( """%(name.upper()))
-            else:
-                self.outFile.write('  RESOLVE_RET(PFN%sPROC, "%s", FALSE);\n'%(name.upper(), name))
-
-                if not nodebug:
-                    self.outFile.write("\n")
-                    self.outFile.write('  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");\n'%(prefix.upper(), name))
-                    self.outFile.write("\n")
-
-                self.outFile.write("  return RESOLVED_PROC(PFN%sPROC)("%(name.upper()))
-
-            Comma=""
-            for ptype, pname in plist:
-                self.outFile.write("%s%s"%(Comma, pname))
-                Comma=", "
-        self.outFile.write(" );\n}\n\n")
-
-class ThunkOutputGenerator(OutputGenerator):
-    def __init__(self,
-                 errFile = sys.stderr,
-                 warnFile = sys.stderr,
-                 diagFile = sys.stdout):
-        OutputGenerator.__init__(self, errFile, warnFile, diagFile)
-    def beginFile(self, genOpts):
-        self.outFile.write('/* Automatically generated from %s - DO NOT EDIT */\n\n'%regFilename)
-    def endFile(self):
-        pass
-    def beginFeature(self, interface, emit):
-        OutputGenerator.beginFeature(self, interface, emit)
-        self.OldVersion = (self.featureName in ['GL_VERSION_1_0', 'GL_VERSION_1_1'])
-    def endFeature(self):
-        OutputGenerator.endFeature(self)
-    def genType(self, typeinfo, name):
-        OutputGenerator.genType(self, typeinfo, name)
-    def genEnum(self, enuminfo, name):
-        OutputGenerator.genEnum(self, enuminfo, name)
-    def genCmd(self, cmd, name):
-        OutputGenerator.genCmd(self, cmd, name)
-
-        rettype=ParseCmdRettype(cmd)
-        self.outFile.write("%s %sWrapper("%(rettype, name))
-        plist=ParseCmdParams(cmd)
-
-        Comma=""
-        if len(plist):
-            for ptype, pname in plist:
-                self.outFile.write("%s%s"%(Comma, ptype))
-                Comma=", "
-        else:
-            self.outFile.write("void")
-
-        self.outFile.write(")\n{\n")
-
-        # for GL 1.0 and 1.1 functions, generate stdcall thunk wrappers which call the function directly
-        if self.OldVersion:
+                self.outFile.write( """)
+{
+#ifdef _DEBUG
+  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");
+  glWinDirectProcCalls++;
+#endif
+"""%(prefix.upper(), name))
             if rettype.lower()=="void":
                 self.outFile.write("  %s( "%(name))
             else:
                 self.outFile.write("  return %s( "%(name))
-
             Comma=""
             for ptype, pname in plist:
                 self.outFile.write("%s%s"%(Comma, pname))
                 Comma=", "
-
-        # for GL 1.2+ functions, generate wrappers which use wglGetProcAddress()
         else:
             if rettype.lower()=="void":
-                self.outFile.write('  RESOLVE(PFN%sPROC, "%s");\n'%(name.upper(), name))
-                self.outFile.write("  RESOLVED_PROC(PFN%sPROC)( """%(name.upper()))
+                self.outFile.write(""")
+{
+  RESOLVE(PFN%sPROC, "%s");"""%(name.upper(), name))
+                if not nodebugcallcounting: self.outFile.write("""
+#ifdef _DEBUG
+  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");
+#endif"""%(prefix.upper(), name))
+                self.outFile.write("""
+  RESOLVED_PROC(PFN%sPROC)( """%(name.upper()))
             else:
-                self.outFile.write('  RESOLVE_RET(PFN%sPROC, "%s", FALSE);\n'%(name.upper(), name))
-                self.outFile.write("  return RESOLVED_PROC(PFN%sPROC)("%(name.upper()))
-
+                self.outFile.write(""")
+{
+  RESOLVE_RET(PFN%sPROC, "%s", FALSE);"""%(name.upper(), name))
+                if not nodebugcallcounting: self.outFile.write("""
+#ifdef _DEBUG
+  if (glxWinDebugSettings.enable%scallTrace) ErrorF("%s\\n");
+#endif"""%(prefix.upper(), name))
+                self.outFile.write("""
+  return RESOLVED_PROC(PFN%sPROC)( """%(name.upper()))
             Comma=""
             for ptype, pname in plist:
                 self.outFile.write("%s%s"%(Comma, pname))
                 Comma=", "
         self.outFile.write(" );\n}\n\n")
 
-class ThunkDefsOutputGenerator(OutputGenerator):
-    def __init__(self,
-                 errFile = sys.stderr,
-                 warnFile = sys.stderr,
-                 diagFile = sys.stdout):
-        OutputGenerator.__init__(self, errFile, warnFile, diagFile)
-    def beginFile(self, genOpts):
-        self.outFile.write("EXPORTS\n"); # this must be the first line for libtool to realize this is a .def file
-        self.outFile.write('; Automatically generated from %s - DO NOT EDIT\n\n'%regFilename)
-    def endFile(self):
-        pass
-    def beginFeature(self, interface, emit):
-        OutputGenerator.beginFeature(self, interface, emit)
-    def endFeature(self):
-        OutputGenerator.endFeature(self)
-    def genType(self, typeinfo, name):
-        OutputGenerator.genType(self, typeinfo, name)
-    def genEnum(self, enuminfo, name):
-        OutputGenerator.genEnum(self, enuminfo, name)
-    def genCmd(self, cmd, name):
-        OutputGenerator.genCmd(self, cmd, name)
-
-        # export the wrapper function with the name of the function it wraps
-        self.outFile.write("%s = %sWrapper\n"%(name, name))
-
-class ShimOutputGenerator(OutputGenerator):
-    def __init__(self,
-                 errFile = sys.stderr,
-                 warnFile = sys.stderr,
-                 diagFile = sys.stdout):
-        OutputGenerator.__init__(self, errFile, warnFile, diagFile)
-    def beginFile(self, genOpts):
-        self.outFile.write('/* Automatically generated from %s - DO NOT EDIT */\n\n'%regFilename)
-    def endFile(self):
-        pass
-    def beginFeature(self, interface, emit):
-        OutputGenerator.beginFeature(self, interface, emit)
-        self.OldVersion = (self.featureName in ['GL_VERSION_1_0', 'GL_VERSION_1_1', 'GL_VERSION_1_2', 'GL_ARB_imaging', 'GL_ARB_multitexture', 'GL_ARB_texture_compression'])
-    def endFeature(self):
-        OutputGenerator.endFeature(self)
-    def genType(self, typeinfo, name):
-        OutputGenerator.genType(self, typeinfo, name)
-    def genEnum(self, enuminfo, name):
-        OutputGenerator.genEnum(self, enuminfo, name)
-    def genCmd(self, cmd, name):
-        OutputGenerator.genCmd(self, cmd, name)
-
-        if not self.OldVersion:
-            return
-
-        # for GL functions which are in the ABI, generate a shim which calls the function via GetProcAddress
-        rettype=ParseCmdRettype(cmd)
-        self.outFile.write("%s %s("%(rettype, name))
-        plist=ParseCmdParams(cmd)
-
-        Comma=""
-        if len(plist):
-            for ptype, pname in plist:
-                self.outFile.write("%s%s"%(Comma, ptype))
-                Comma=", "
-        else:
-            self.outFile.write("void")
-
-        self.outFile.write(")\n{\n")
-
-        self.outFile.write('  typedef %s (* PFN%sPROC)(' % (rettype, name.upper()))
-
-        if len(plist):
-            Comma=""
-            for ptype, pname in plist:
-                self.outFile.write("%s %s"%(Comma, ptype))
-                Comma=", "
-        else:
-            self.outFile.write("void")
-
-        self.outFile.write(');\n')
-
-        if rettype.lower()=="void":
-            self.outFile.write('  RESOLVE(PFN%sPROC, "%s");\n'%(name.upper(), name))
-            self.outFile.write('  RESOLVED_PROC(')
-        else:
-            self.outFile.write('  RESOLVE_RET(PFN%sPROC, "%s", 0);\n'%(name.upper(), name))
-            self.outFile.write('  return RESOLVED_PROC(')
-
-        Comma=""
-        for ptype, pname in plist:
-            self.outFile.write("%s%s"%(Comma, pname))
-            Comma=", "
-
-        self.outFile.write(" );\n}\n\n")
-
 def genHeaders():
+    startTimer()
     outFile = open(outFilename,"w")
-
     if preresolve:
         gen = PreResolveOutputGenerator(errFile=errWarn,
                                         warnFile=errWarn,
@@ -432,40 +379,40 @@ def genHeaders():
         gen.outFile=outFile
         reg.setGenerator(gen)
         reg.apiGen(genOpts)
+    gen = MyOutputGenerator(errFile=errWarn,
+                            warnFile=errWarn,
+                            diagFile=diag)
+    gen.outFile=outFile
+    reg.setGenerator(gen)
+    reg.apiGen(genOpts)
 
-    if wrapper:
-        gen = WrapperOutputGenerator(errFile=errWarn,
-                                     warnFile=errWarn,
-                                     diagFile=diag)
-        gen.outFile=outFile
-        reg.setGenerator(gen)
-        reg.apiGen(genOpts)
+    # generate function to setup the dispatch table, which sets each
+    # dispatch table entry to point to it's wrapper function
+    # (assuming we were able to make one)
 
-    if shim:
-        gen = ShimOutputGenerator(errFile=errWarn,
-                                  warnFile=errWarn,
-                                  diagFile=diag)
-        gen.outFile=outFile
-        reg.setGenerator(gen)
-        reg.apiGen(genOpts)
+    if dispatchheader :
+        outFile.write( 'void glWinSetupDispatchTable(void)\n')
+        outFile.write( '{\n')
+        outFile.write( '  struct _glapi_table *disp = _glapi_get_dispatch();\n')
 
-    if thunk:
-        gen = ThunkOutputGenerator(errFile=errWarn,
-                                   warnFile=errWarn,
-                                   diagFile=diag)
-        gen.outFile=outFile
-        reg.setGenerator(gen)
-        reg.apiGen(genOpts)
+        for d in sorted(dispatch.keys()) :
+                if d in gen.wrappers :
+                        outFile.write('  SET_'+ d[len(prefix):] + '(disp, (void *)' + d + 'Wrapper);\n')
+#enable this if you want to see this warning messages                else :
+#                        outFile.write('#pragma message("No wrapper for ' + d + ' !")\n')
+
+        outFile.write('}\n')
 
 
-    if thunkdefs:
-        gen = ThunkDefsOutputGenerator(errFile=errWarn,
-                                       warnFile=errWarn,
-                                       diagFile=diag)
-        gen.outFile=outFile
-        reg.setGenerator(gen)
-        reg.apiGen(genOpts)
 
     outFile.close()
 
-genHeaders()
+if (debug):
+    pdb.run('genHeaders()')
+elif (profile):
+    import cProfile, pstats
+    cProfile.run('genHeaders()', 'profile.txt')
+    p = pstats.Stats('profile.txt')
+    p.strip_dirs().sort_stats('time').print_stats(50)
+else:
+    genHeaders()
diff --git a/xserver/hw/xwin/glx/glwindows.h b/vcxsrv-code/xorg-server/hw/xwin/glx/glwindows.h
index 34ff24c..1430bef 100644
--- a/xserver/hw/xwin/glx/glwindows.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/glwindows.h
@@ -45,13 +45,22 @@ typedef struct {
 
 extern glxWinDebugSettingsRec glxWinDebugSettings;
 
+void glWinCallDelta(void);
 void glxWinPushNativeProvider(void);
-void glAddSwapHintRectWINWrapper(GLint x, GLint y, GLsizei width, GLsizei height);
-int glWinSelectImplementation(int native);
+const GLubyte *glGetStringWrapperNonstatic(GLenum name);
+void glAddSwapHintRectWINWrapperNonstatic(GLint x, GLint y, GLsizei width,
+                                          GLsizei height);
+void glWinSetupDispatchTable(void);
 
-#if 1
+#ifdef _DEBUG
+#ifdef _MSC_VER
+#define GLWIN_TRACE_MSG(msg, ...) if (glxWinDebugSettings.enableTrace) ErrorF(msg " [%s:%d]\n" , __VA_ARGS__ , __FUNCTION__, __LINE__ )
+#define GLWIN_DEBUG_MSG(msg, ...) if (glxWinDebugSettings.enableDebug) ErrorF(msg " [%s:%d]\n" , __VA_ARGS__ , __FUNCTION__, __LINE__ )
+#else
 #define GLWIN_TRACE_MSG(msg, args...) if (glxWinDebugSettings.enableTrace) ErrorF(msg " [%s:%d]\n" , ##args , __FUNCTION__, __LINE__ )
 #define GLWIN_DEBUG_MSG(msg, args...) if (glxWinDebugSettings.enableDebug) ErrorF(msg " [%s:%d]\n" , ##args , __FUNCTION__, __LINE__ )
+#endif
+
 #else
 #define GLWIN_TRACE_MSG(a, ...)
 #define GLWIN_DEBUG_MSG(a, ...)
diff --git a/xserver/hw/xwin/glx/indirect.c b/vcxsrv-code/xorg-server/hw/xwin/glx/indirect.c
index ff015f7..ff25944 100644
--- a/xserver/hw/xwin/glx/indirect.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/indirect.c
@@ -79,12 +79,18 @@
 #endif
 
 #include "glwindows.h"
+#include <glx/glheader.h>
 #include <glx/glxserver.h>
 #include <glx/glxutil.h>
+#include <glx/glxext.h>
 #include <GL/glxtokens.h>
+#include <glx/glapitable.h>
+#include <glx/glapi.h>
 
 #include <winpriv.h>
 #include <wgl_ext_api.h>
+#include "win.h"
+#include <winmsg.h>
 #include <winglobals.h>
 #include <indirect.h>
 
@@ -111,12 +117,33 @@ typedef struct  {
  * Various debug helpers
  */
 
-#define GLWIN_DEBUG_HWND(hwnd)  \
-    if (glxWinDebugSettings.dumpHWND) { \
-        char buffer[1024]; \
-        if (GetWindowText(hwnd, buffer, sizeof(buffer))==0) *buffer=0; \
-        GLWIN_DEBUG_MSG("Got HWND %p for window '%s'", hwnd, buffer); \
+#ifdef _DEBUG
+void GLWIN_DEBUG_HWND(HWND hwnd)
+{
+    if (glxWinDebugSettings.dumpHWND) {
+        char buffer[1024];
+        RECT Rect;
+        HDC hDc=GetDC(hwnd);
+
+        if (GetWindowText(hwnd, buffer, sizeof(buffer))==0) *buffer=0;
+        GetWindowRect(hwnd,&Rect);
+
+        GLWIN_DEBUG_MSG("Got HWND %p (hdc %p) for window '%s' (%d,%d,%d,%d)", hwnd, hDc, buffer, Rect.left, Rect.top, Rect.right, Rect.bottom);
+        ReleaseDC(hwnd,hDc);
     }
+}
+
+void GLWIN_HDC_DEBUG_MSG(const char *Message, HDC hDc, HWND hwnd)
+{
+    char buffer[1024];
+    RECT Rect;
+
+    if (GetWindowText(hwnd, buffer, sizeof(buffer))==0) *buffer=0;
+    GetWindowRect(hwnd,&Rect);
+
+    GLWIN_DEBUG_MSG("Got HDC %p (hwnd %p) for window '%s' (%d,%d,%d,%d)", hDc, hwnd, buffer, Rect.left, Rect.top, Rect.right, Rect.bottom);
+
+}
 
 glxWinDebugSettingsRec glxWinDebugSettings = { 0, 0, 0, 0, 0, 0 };
 
@@ -164,6 +191,7 @@ glxWinInitDebugSettings(void)
         glxWinDebugSettings.enableWGLcallTrace = 1;
     }
 }
+#endif
 
 static
 const char *
@@ -190,6 +218,8 @@ glxWinErrorMessage(void)
 
 static void pfdOut(const PIXELFORMATDESCRIPTOR * pfd);
 
+#ifdef _DEBUG
+
 #define DUMP_PFD_FLAG(flag) \
     if (pfd->dwFlags & flag) { \
         ErrorF("%s%s", pipesym, #flag); \
@@ -306,7 +336,6 @@ fbConfigsDump(unsigned int n, __GLXconfig * c, PixelFormatRejectStats *rejects)
         ("idx  ID  ID VisualType Depth Lvl RGB CI DB Swap reo  R  G  B  A   Z  S  buf AR AG AB AA  bufs num  W P Pb  Float Trans Caveat cap \n");
     ErrorF
         ("----------------------------------------------------------------------------------------------------------------------------------\n");
-
     while (c != NULL) {
         unsigned int i = ((GLXWinConfig *) c)->pixelFormatIndex;
 
@@ -354,6 +383,7 @@ fbConfigsDump(unsigned int n, __GLXconfig * c, PixelFormatRejectStats *rejects)
         c = c->next;
     }
 }
+#endif
 
 /* ---------------------------------------------------------------------- */
 /*
@@ -375,12 +405,14 @@ static __GLXdrawable *glxWinCreateDrawable(ClientPtr client,
 
 static Bool glxWinRealizeWindow(WindowPtr pWin);
 static Bool glxWinUnrealizeWindow(WindowPtr pWin);
+static Bool glxWinDestroyWindow(WindowPtr pWin);
 static void glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
                              RegionPtr prgnSrc);
-static Bool glxWinSetPixelFormat(HDC hdc, int bppOverride, int drawableTypeOverride,
-                                 __GLXscreen *screen, __GLXconfig *config);
+static Bool glxWinPositionWindow(WindowPtr pWindow, int x, int y);
+static Bool glxWinSetPixelFormat(__GLXWinContext * gc, HDC hdc, int bppOverride,
+                                 int drawableTypeOverride);
 static HDC glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw,
-                        HDC * hdc, HWND * hwnd);
+                        HWND * hwnd);
 static void glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable * draw);
 
 static void glxWinCreateConfigs(HDC dc, glxWinScreen * screen);
@@ -407,7 +439,8 @@ __GLXprovider __glXWGLProvider = {
 void
 glxWinPushNativeProvider(void)
 {
-    GlxPushProvider(&__glXWGLProvider);
+    if (g_fNativeGl)
+        GlxPushProvider(&__glXWGLProvider);
 }
 
 /* ---------------------------------------------------------------------- */
@@ -415,6 +448,16 @@ glxWinPushNativeProvider(void)
  * Screen functions
  */
 
+static LRESULT CALLBACK
+GlxWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    if (uMsg == WM_NCHITTEST) {
+        return HTTRANSPARENT;
+    }
+    else
+        return DefWindowProc(hwnd, uMsg, wParam, lParam);
+}
+
 static void
 glxWinScreenDestroy(__GLXscreen * screen)
 {
@@ -453,7 +496,7 @@ glxLogExtensions(const char *prefix, const char *extensions)
     strl = strtok(str, " ");
     if (strl == NULL)
         strl = "";
-    ErrorF("%s%s", prefix, strl);
+    winDebug("%s%s", prefix, strl);
     length = strlen(prefix) + strlen(strl);
 
     while (1) {
@@ -462,20 +505,20 @@ glxLogExtensions(const char *prefix, const char *extensions)
             break;
 
         if (length + strlen(strl) + 1 > 120) {
-            ErrorF("\n");
-            ErrorF("%s", prefix);
+            winDebug("\n");
+            winDebug("%s", prefix);
             length = strlen(prefix);
         }
         else {
-            ErrorF(" ");
+            winDebug(" ");
             length++;
         }
 
-        ErrorF("%s", strl);
+        winDebug("%s", strl);
         length = length + strlen(strl);
     }
 
-    ErrorF("\n");
+    winDebug("\n");
 
     free(str);
 }
@@ -495,7 +538,9 @@ glxWinScreenProbe(ScreenPtr pScreen)
 
     GLWIN_DEBUG_MSG("glxWinScreenProbe");
 
+#ifdef _DEBUG
     glxWinInitDebugSettings();
+#endif
 
     if (pScreen == NULL)
         return NULL;
@@ -511,14 +556,7 @@ glxWinScreenProbe(ScreenPtr pScreen)
     if (NULL == screen)
         return NULL;
 
-    // Select the native GL implementation (WGL)
-    if (glWinSelectImplementation(1)) {
-        free(screen);
-        return NULL;
-    }
-
     // create window class
-#define WIN_GL_TEST_WINDOW_CLASS "XWinGLTest"
     {
         static wATOM glTestWndClass = 0;
 
@@ -526,59 +564,103 @@ glxWinScreenProbe(ScreenPtr pScreen)
             WNDCLASSEX wc;
 
             wc.cbSize = sizeof(WNDCLASSEX);
-            wc.style = CS_HREDRAW | CS_VREDRAW;
-            wc.lpfnWndProc = DefWindowProc;
+            wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
+            wc.lpfnWndProc = GlxWindowProc;
             wc.cbClsExtra = 0;
             wc.cbWndExtra = 0;
-            wc.hInstance = GetModuleHandle(NULL);
+            wc.hInstance = g_hInstance;
             wc.hIcon = 0;
             wc.hCursor = 0;
-            wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
+            wc.hbrBackground = NULL;
             wc.lpszMenuName = NULL;
-            wc.lpszClassName = WIN_GL_TEST_WINDOW_CLASS;
+            wc.lpszClassName = WIN_GL_WINDOW_CLASS;
             wc.hIconSm = 0;
-            RegisterClassEx(&wc);
+            glTestWndClass = RegisterClassEx(&wc);
         }
     }
 
     // create an invisible window for a scratch DC
     hwnd = CreateWindowExA(0,
-                           WIN_GL_TEST_WINDOW_CLASS,
+                           WIN_GL_WINDOW_CLASS,
                            "XWin GL Renderer Capabilities Test Window",
-                           0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL),
+                           0, 0, 0, 0, 0, NULL, NULL, g_hInstance,
                            NULL);
-    if (hwnd == NULL)
+    if (hwnd == NULL) {
         LogMessage(X_ERROR,
                    "AIGLX: Couldn't create a window for render capabilities testing\n");
+        goto error;
+    }
 
     hdc = GetDC(hwnd);
+    if (!hdc) {
+        LogMessage(X_ERROR, "AIGLX: Couldn't create a DC for render capabilities testing\n");
+        goto error;
+    }
+
+    // we must set a pixel format before we can create a context
+    {
+        PIXELFORMATDESCRIPTOR pfd = {
+            sizeof(PIXELFORMATDESCRIPTOR),
+            1,
+            PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DEPTH_DONTCARE | PFD_DOUBLEBUFFER_DONTCARE | PFD_STEREO_DONTCARE,
+            PFD_TYPE_RGBA,
+            24,
+            0, 0, 0, 0, 0, 0,
+            0,
+            0,
+            0,
+            0, 0, 0, 0,
+            0,
+            0,
+            0,
+            PFD_MAIN_PLANE,
+            0,
+            0, 0, 0
+        };
+        int iPixelFormat = ChoosePixelFormat(hdc, &pfd);
+        if (iPixelFormat == 0) {
+            LogMessage(X_ERROR, "AIGLX: ChoosePixelFormat failed\n");
+            goto error;
+        }
+
+        if (!SetPixelFormat(hdc, iPixelFormat, NULL)) {
+            LogMessage(X_ERROR, "AIGLX: SetPixelFormat %d failed\n", iPixelFormat);
+            goto error;
+        }
+        LogMessage(X_INFO, "AIGLX: Testing pixelFormatIndex %d\n", iPixelFormat);
+    }
 
-    // we must set a pixel format before we can create a context, just use the first one...
-    SetPixelFormat(hdc, 1, NULL);
     hglrc = wglCreateContext(hdc);
-    wglMakeCurrent(hdc, hglrc);
+    if (!wglMakeCurrent(hdc, hglrc)) {
+        DWORD ErrorCode=GetLastError();
+        ErrorF("wglMakeCurrent error: %x dc %p ctx %p\n", ErrorCode,hdc,hglrc);
+    }
 
     // initialize wgl extension proc pointers (don't call them before here...)
     // (but we need to have a current context for them to be resolvable)
     wglResolveExtensionProcs();
 
-    /* Dump out some useful information about the native renderer */
-    ErrorF("GL_VERSION:     %s\n", glGetString(GL_VERSION));
-    ErrorF("GL_VENDOR:      %s\n", glGetString(GL_VENDOR));
-    gl_renderer = (const char *) glGetString(GL_RENDERER);
-    ErrorF("GL_RENDERER:    %s\n", gl_renderer);
-    gl_extensions = (const char *) glGetString(GL_EXTENSIONS);
+    winDebug("GL_VERSION:     %s\n", glGetStringWrapperNonstatic(GL_VERSION));
+    winDebug("GL_VENDOR:      %s\n", glGetStringWrapperNonstatic(GL_VENDOR));
+    gl_renderer = (const char *) glGetStringWrapperNonstatic(GL_RENDERER);
+    winDebug("GL_RENDERER:    %s\n", gl_renderer);
+    gl_extensions = (const char *) glGetStringWrapperNonstatic(GL_EXTENSIONS);
     wgl_extensions = wglGetExtensionsStringARBWrapper(hdc);
     if (!wgl_extensions)
-        wgl_extensions = "";
+        wgl_extensions = "None";
 
     if (g_iLogVerbose >= 3) {
         glxLogExtensions("GL_EXTENSIONS:  ", gl_extensions);
         glxLogExtensions("WGL_EXTENSIONS: ", wgl_extensions);
     }
 
+    if (!gl_renderer) {
+        LogMessage(X_ERROR,
+                   "AIGLX: Native renderer not identified\n");
+        goto error;
+    }
+
     if (strcasecmp(gl_renderer, "GDI Generic") == 0) {
-        free(screen);
         LogMessage(X_ERROR,
                    "AIGLX: Won't use generic native renderer as it is not accelerated\n");
         goto error;
@@ -589,7 +671,6 @@ glxWinScreenProbe(ScreenPtr pScreen)
     // might have completely different capabilities.  Of course, good luck getting
     // those screens to be accelerated in XP and earlier...
 
-
     {
         int i;
 
@@ -621,6 +702,12 @@ glxWinScreenProbe(ScreenPtr pScreen)
         //
         __glXInitExtensionEnableBits(screen->base.glx_enable_bits);
 
+        __glXEnableExtension(screen->base.glx_enable_bits, "GLX_EXT_visual_info");
+        __glXEnableExtension(screen->base.glx_enable_bits, "GLX_EXT_visual_rating");
+        __glXEnableExtension(screen->base.glx_enable_bits, "GLX_EXT_import_context");
+        __glXEnableExtension(screen->base.glx_enable_bits, "GLX_OML_swap_method");
+        __glXEnableExtension(screen->base.glx_enable_bits, "GLX_SGIX_fbconfig");
+
         for (i = 0; i < sizeof(extensionMap)/sizeof(extensionMap[0]); i++) {
             if (strstr(wgl_extensions, extensionMap[i].wglext)) {
                 __glXEnableExtension(screen->base.glx_enable_bits, extensionMap[i].glxext);
@@ -683,7 +770,6 @@ glxWinScreenProbe(ScreenPtr pScreen)
            If we still didn't get any fbConfigs, we can't provide GLX for this screen
          */
         if (screen->base.numFBConfigs <= 0) {
-            free(screen);
             LogMessage(X_ERROR,
                        "AIGLX: No fbConfigs could be made from native OpenGL pixel formats\n");
             goto error;
@@ -701,8 +787,10 @@ glxWinScreenProbe(ScreenPtr pScreen)
     ReleaseDC(hwnd, hdc);
     DestroyWindow(hwnd);
 
+#ifdef _DEBUG
     // dump out fbConfigs now fbConfigIds and visualIDs have been assigned
     fbConfigsDump(screen->base.numFBConfigs, screen->base.fbconfigs, &rejects);
+#endif
 
     /* Wrap RealizeWindow, UnrealizeWindow and CopyWindow on this screen */
     screen->RealizeWindow = pScreen->RealizeWindow;
@@ -711,6 +799,10 @@ glxWinScreenProbe(ScreenPtr pScreen)
     pScreen->UnrealizeWindow = glxWinUnrealizeWindow;
     screen->CopyWindow = pScreen->CopyWindow;
     pScreen->CopyWindow = glxWinCopyWindow;
+    screen->PositionWindow = pScreen->PositionWindow;
+    pScreen->PositionWindow = glxWinPositionWindow;
+    screen->DestroyWindow = pScreen->DestroyWindow;
+    pScreen->DestroyWindow = glxWinDestroyWindow;
 
     // Note that WGL is active on this screen
     winSetScreenAiglxIsActive(pScreen);
@@ -718,10 +810,7 @@ glxWinScreenProbe(ScreenPtr pScreen)
     return &screen->base;
 
  error:
-    // Something went wrong and we can't use the native GL implementation
-    // so make sure the mesa GL implementation is selected instead
-    glWinSelectImplementation(0);
-
+    free(screen);
     return NULL;
 }
 
@@ -736,6 +825,7 @@ glxWinRealizeWindow(WindowPtr pWin)
     Bool result;
     ScreenPtr pScreen = pWin->drawable.pScreen;
     glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);
+    winWindowPriv(pWin);
 
     GLWIN_DEBUG_MSG("glxWinRealizeWindow");
 
@@ -744,6 +834,10 @@ glxWinRealizeWindow(WindowPtr pWin)
     result = pScreen->RealizeWindow(pWin);
     pScreen->RealizeWindow = glxWinRealizeWindow;
 
+    /* Check if we need to move the window */
+    if (pWinPriv->fWglUsed && pWinPriv->hWnd)
+        ShowWindow(pWinPriv->hWnd,SW_SHOWNOACTIVATE);
+
     return result;
 }
 
@@ -778,18 +872,88 @@ glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
     pScreen->CopyWindow = glxWinCopyWindow;
 }
 
+static Bool
+glxWinPositionWindow(WindowPtr pWin, int x, int y)
+{
+    Bool result;
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);
+    winWindowPriv(pWin);
+
+    pScreen->PositionWindow = screenPriv->PositionWindow;
+    result = pScreen->PositionWindow(pWin, x, y);
+    pScreen->PositionWindow = glxWinPositionWindow;
+
+    if (pWinPriv->fWglUsed && pWinPriv->hWnd)
+    {
+        MoveWindow(pWinPriv->hWnd,
+                   pWin->drawable.x,
+                   pWin->drawable.y,
+                   pWin->drawable.width,
+                   pWin->drawable.height,
+                   FALSE);
+        winDebug("Move window %x,  %x, %d, %d, %d, %d\n",pWinPriv->hWnd,GetParent(pWinPriv->hWnd), pWin->drawable.x, pWin->drawable.y, pWin->drawable.width, pWin->drawable.height);
+    }
+    return result;
+}
+
 static Bool
 glxWinUnrealizeWindow(WindowPtr pWin)
 {
     Bool result;
     ScreenPtr pScreen = pWin->drawable.pScreen;
     glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);
+    winWindowPriv(pWin);
 
     GLWIN_DEBUG_MSG("glxWinUnrealizeWindow");
 
-    pScreen->UnrealizeWindow = screenPriv->UnrealizeWindow;
-    result = pScreen->UnrealizeWindow(pWin);
-    pScreen->UnrealizeWindow = glxWinUnrealizeWindow;
+    if (pWinPriv->fWglUsed && pWinPriv->hWnd)
+    {
+      ShowWindow(pWinPriv->hWnd,SW_HIDE);
+      result = TRUE;
+    }
+    else
+    {
+      pScreen->UnrealizeWindow = screenPriv->UnrealizeWindow;
+      result = pScreen->UnrealizeWindow(pWin);
+      pScreen->UnrealizeWindow = glxWinUnrealizeWindow;
+    }
+
+
+    return result;
+}
+
+static Bool
+glxWinDestroyWindow(WindowPtr pWin)
+{
+    Bool result;
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    glxWinScreen *screenPriv = (glxWinScreen *)glxGetScreen(pScreen);
+    __GLXWinDrawable *pGlxDraw;
+    winWindowPriv(pWin);
+
+    GLWIN_DEBUG_MSG("glxWinDestroyWindow");
+
+    dixLookupResourceByType((pointer) &pGlxDraw, pWin->drawable.id, __glXDrawableRes, NullClient, DixUnknownAccess);
+
+    if (pGlxDraw && pGlxDraw->drawContext)
+    {
+      if (pGlxDraw->drawContext->hwnd!=pWinPriv->hWnd)
+        ErrorF("Wrong assumption\n");
+      glxWinReleaseDC(pGlxDraw->drawContext->hwnd, pGlxDraw->drawContext->hDC, pGlxDraw);
+      pGlxDraw->drawContext->hDC=NULL;
+      pGlxDraw->drawContext->hwnd=NULL;
+    }
+    if (pWinPriv->fWglUsed && pWinPriv->hWnd)
+    {
+      DestroyWindow(pWinPriv->hWnd);
+      pWinPriv->hWnd=NULL;
+      pWinPriv->fWglUsed=0;
+    }
+
+    pScreen->DestroyWindow = screenPriv->DestroyWindow;
+    result = pScreen->DestroyWindow(pWin);
+    pScreen->DestroyWindow = glxWinDestroyWindow;
 
     return result;
 }
@@ -802,8 +966,6 @@ glxWinUnrealizeWindow(WindowPtr pWin)
 static GLboolean
 glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable * base)
 {
-    HDC dc;
-    HWND hwnd;
     BOOL ret;
     __GLXWinDrawable *draw = (__GLXWinDrawable *) base;
 
@@ -817,16 +979,10 @@ glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable * base)
         ("glxWinSwapBuffers on drawable %p, last context %p (native ctx %p)",
          base, draw->drawContext, draw->drawContext->ctx);
 
-    dc = glxWinMakeDC(draw->drawContext, draw, &dc, &hwnd);
-    if (dc == NULL)
-        return GL_FALSE;
-
-    ret = wglSwapLayerBuffers(dc, WGL_SWAP_MAIN_PLANE);
-
-    glxWinReleaseDC(hwnd, dc, draw);
+    ret = SwapBuffers(draw->drawContext->hDC);
 
     if (!ret) {
-        ErrorF("wglSwapBuffers failed: %s\n", glxWinErrorMessage());
+        ErrorF("SwapBuffers failed: %s\n", glxWinErrorMessage());
         return GL_FALSE;
     }
 
@@ -837,7 +993,7 @@ static void
 glxWinDrawableCopySubBuffer(__GLXdrawable * drawable,
                             int x, int y, int w, int h)
 {
-    glAddSwapHintRectWINWrapper(x, y, w, h);
+    glAddSwapHintRectWINWrapperNonstatic(x, y, w, h);
     glxWinDrawableSwapBuffers(NULL, drawable);
 }
 
@@ -870,6 +1026,7 @@ glxWinDrawableDestroy(__GLXdrawable * base)
         }
 
         ((PixmapPtr) glxPriv->base.pDraw)->devPrivate.ptr = glxPriv->pOldBits;
+        glxPriv->base.pDraw->pScreen->DestroyPixmap((PixmapPtr)glxPriv->base.pDraw); /* Decrement reference count since we do not use it any more */
     }
 
     GLWIN_DEBUG_MSG("glxWinDestroyDrawable");
@@ -884,13 +1041,11 @@ glxWinCreateDrawable(ClientPtr client,
 {
     __GLXWinDrawable *glxPriv;
 
-    glxPriv = malloc(sizeof *glxPriv);
+    glxPriv = calloc(1, sizeof(*glxPriv));
 
     if (glxPriv == NULL)
         return NULL;
 
-    memset(glxPriv, 0, sizeof *glxPriv);
-
     if (!__glXDrawableInit
         (&glxPriv->base, screen, pDraw, type, glxDrawId, conf)) {
         free(glxPriv);
@@ -909,8 +1064,10 @@ glxWinCreateDrawable(ClientPtr client,
 }
 
 void
-glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config)
+glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXWinContext * gc)
 {
+    __GLXconfig *config=gc->base.config;
+
     switch (draw->base.type) {
     case GLX_DRAWABLE_WINDOW:
     {
@@ -941,9 +1098,12 @@ glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config)
             __GLXscreen *screen;
             glxWinScreen *winScreen;
             int pixelFormat;
+            WindowPtr pWin = (WindowPtr) draw->base.pDraw;
 
             // XXX: which DC are we supposed to use???
-            HDC screenDC = GetDC(NULL);
+            ScreenPtr pScreen = pWin->drawable.pScreen;
+            winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
+            HDC screenDC=pWinScreen->hdcScreen;
 
             if (!(config->drawableType & GLX_PBUFFER_BIT)) {
                 ErrorF
@@ -964,7 +1124,6 @@ glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config)
                 wglCreatePbufferARBWrapper(screenDC, pixelFormat,
                                            draw->base.pDraw->width,
                                            draw->base.pDraw->height, NULL);
-            ReleaseDC(NULL, screenDC);
 
             if (draw->hPbuffer == NULL) {
                 ErrorF("wglCreatePbufferARBWrapper error: %s\n",
@@ -1015,7 +1174,7 @@ glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config)
             //
             // XXX: not quite unique as potentially this name could be used in
             // another server instance.  Not sure how to deal with that.
-            snprintf(name, sizeof(name), "Local\\CYGWINX_WINDOWSDRI_%08x", (unsigned int)draw->base.pDraw->id);
+            snprintf(name, sizeof(name), "Local\\VCXSRV_WINDOWSDRI_%08x", (unsigned int)draw->base.pDraw->id);
             GLWIN_DEBUG_MSG("shared memory region name %s\n", name);
 
             // Create a file mapping backed by the pagefile
@@ -1058,11 +1217,10 @@ glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config)
             screen = glxGetScreen(screenInfo.screens[draw->base.pDraw->pScreen->myNum]);
 
             // Set the pixel format of the bitmap
-            glxWinSetPixelFormat(draw->dibDC,
+            glxWinSetPixelFormat(gc,
+                                 draw->dibDC,
                                  draw->base.pDraw->bitsPerPixel,
-                                 GLX_PIXMAP_BIT,
-                                 screen,
-                                 config);
+                                 GLX_PIXMAP_BIT);
 
             GLWIN_DEBUG_MSG
                 ("glxWinDeferredCreateDrawable: DIB bitmap %p created for drawable %p",
@@ -1124,33 +1282,33 @@ glxWinReleaseTexImage(__GLXcontext * baseContext,
  */
 
 static Bool
-glxWinSetPixelFormat(HDC hdc, int bppOverride, int drawableTypeOverride,
-                     __GLXscreen *screen, __GLXconfig *config)
+glxWinSetPixelFormat(__GLXWinContext * gc, HDC hdc, int bppOverride,
+                     int drawableTypeOverride)
 {
+    __GLXscreen *screen = gc->base.pGlxScreen;
     glxWinScreen *winScreen = (glxWinScreen *) screen;
-    GLXWinConfig *winConfig = (GLXWinConfig *) config;
 
-    GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d",
-                    winConfig->pixelFormatIndex);
+    __GLXconfig *config = gc->base.config;
+    GLXWinConfig *winConfig = (GLXWinConfig *) config;
 
-    /*
-       Normally, we can just use the the pixelFormatIndex corresponding
-       to the fbconfig which has been specified by the client
-     */
 
-    if (!
-        ((bppOverride &&
-          (bppOverride !=
-           (config->redBits + config->greenBits + config->blueBits)))
-         || ((config->drawableType & drawableTypeOverride) == 0))) {
-        if (!SetPixelFormat(hdc, winConfig->pixelFormatIndex, NULL)) {
-            ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
-            return FALSE;
+    WindowPtr pWin;
+    __GLXWinDrawable *drawPriv = (__GLXWinDrawable *)gc->base.drawPriv;
+    pWin = (WindowPtr) drawPriv->base.pDraw;
+    {
+        winWindowPriv(pWin);
+        if (pWinPriv->OpenGlWindow)
+        {
+            ErrorF("Not Setting pixel format to  %d on hdc %x for window %x (not allowed on windows)\n",winConfig->pixelFormatIndex,hdc,pWinPriv->hWnd);
+            return TRUE; /* Pixel format is already set on this window so it cannot be changed anymore */
         }
-
-        return TRUE;
     }
+    GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d", winConfig->pixelFormatIndex);
 
+    /*
+    Normally, we can just use the the pixelFormatIndex corresponding
+    to the fbconfig which has been specified by the client
+    */
     /*
        However, in certain special cases this pixel format will be incompatible with the
        use we are going to put it to, so we need to re-evaluate the pixel format to use:
@@ -1206,8 +1364,10 @@ glxWinSetPixelFormat(HDC hdc, int bppOverride, int drawableTypeOverride,
             return FALSE;
         }
 
+#ifdef _DEBUG
         if (glxWinDebugSettings.dumpPFD)
             pfdOut(&pfd);
+#endif
 
         if (bppOverride) {
             GLWIN_DEBUG_MSG("glxWinSetPixelFormat: Forcing bpp from %d to %d\n",
@@ -1237,10 +1397,9 @@ glxWinSetPixelFormat(HDC hdc, int bppOverride, int drawableTypeOverride,
 }
 
 static HDC
-glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw, HDC * hdc,
-             HWND * hwnd)
+glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HWND *hwnd)
 {
-    *hdc = NULL;
+    HDC hdc = NULL;
     *hwnd = NULL;
 
     if (draw == NULL) {
@@ -1267,45 +1426,52 @@ glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw, HDC * hdc,
             return NULL;
         }
 
-        *hdc = GetDC(*hwnd);
-
-        if (*hdc == NULL)
-            ErrorF("GetDC error: %s\n", glxWinErrorMessage());
+        if (!gc->hDC) {
+            winWindowPriv(pWin);
 
-        /* Check if the hwnd has changed... */
-        if (*hwnd != gc->hwnd) {
-            if (glxWinDebugSettings.enableTrace)
-                GLWIN_DEBUG_HWND(*hwnd);
+            hdc = GetDC(*hwnd);
 
-            GLWIN_TRACE_MSG
-                ("for context %p (native ctx %p), hWnd changed from %p to %p",
-                 gc, gc->ctx, gc->hwnd, *hwnd);
-            gc->hwnd = *hwnd;
+            if (hdc == NULL)
+                ErrorF("GetDC error: %s: hwnd %x, gc %p, gc->ctx %p ,gc->hwnd %p\n", glxWinErrorMessage(), *hwnd, gc, gc->ctx, gc->hwnd);
 
-            /* We must select a pixelformat, but SetPixelFormat can only be called once for a window... */
-            if (!glxWinSetPixelFormat(*hdc, 0, GLX_WINDOW_BIT, gc->base.pGlxScreen, gc->base.config)) {
-                ErrorF("glxWinSetPixelFormat error: %s\n",
-                       glxWinErrorMessage());
-                ReleaseDC(*hwnd, *hdc);
-                *hdc = NULL;
-                return NULL;
-            }
+            glxWinSetPixelFormat(gc, hdc, 0, GLX_WINDOW_BIT);
+            pWinPriv->OpenGlWindow=TRUE; /* Identify it as an opengl window, also used to check if the pixel format is already set */
+            gc->ctx = wglCreateContext(hdc);
         }
+
+#ifdef _DEBUG
+        if (glxWinDebugSettings.enableTrace)
+            GLWIN_DEBUG_HWND(*hwnd);
+
+        GLWIN_TRACE_MSG
+            ("for context %p (native ctx %p), hWnd changed from %p to %p",
+             gc, gc->ctx, gc->hwnd, *hwnd);
+#endif
+        if (gc->hwnd!=*hwnd)
+            ErrorF("Window changed handle from %x to %x\n", gc->hwnd, *hwnd);
+
+        gc->hwnd = *hwnd;
     }
         break;
 
     case GLX_DRAWABLE_PBUFFER:
     {
-        *hdc = wglGetPbufferDCARBWrapper(draw->hPbuffer);
+        hdc = wglGetPbufferDCARBWrapper(draw->hPbuffer);
 
-        if (*hdc == NULL)
+        if (hdc == NULL)
             ErrorF("GetDC (pbuffer) error: %s\n", glxWinErrorMessage());
+
+        gc->ctx = wglCreateContext(hdc);
     }
         break;
 
     case GLX_DRAWABLE_PIXMAP:
     {
-        *hdc = draw->dibDC;
+        hdc = draw->dibDC;
+#ifdef _DEBUG
+        if (glxWinDebugSettings.dumpDC)
+            GLWIN_DEBUG_MSG("Got PIXMAP HDC %p for window %p", hdc, *hwnd);
+#endif
     }
         break;
 
@@ -1316,10 +1482,12 @@ glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw, HDC * hdc,
     }
     }
 
+#ifdef _DEBUG
     if (glxWinDebugSettings.dumpDC)
-        GLWIN_DEBUG_MSG("Got HDC %p", *hdc);
+        GLWIN_HDC_DEBUG_MSG("Got HDC %p for window %p", hdc, *hwnd);
+#endif
 
-    return *hdc;
+    return hdc;
 }
 
 static void
@@ -1362,20 +1530,20 @@ glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable * draw)
 static void
 glxWinDeferredCreateContext(__GLXWinContext * gc, __GLXWinDrawable * draw)
 {
-    HDC dc;
     HWND hwnd;
 
     GLWIN_DEBUG_MSG
         ("glxWinDeferredCreateContext: attach context %p to drawable %p", gc,
          draw);
 
-    glxWinDeferredCreateDrawable(draw, gc->base.config);
+    glxWinDeferredCreateDrawable(draw, gc);
 
-    dc = glxWinMakeDC(gc, draw, &dc, &hwnd);
-    gc->ctx = wglCreateContext(dc);
-    glxWinReleaseDC(hwnd, dc, draw);
+    gc->hDC = glxWinMakeDC(gc, draw, &hwnd);
 
     if (gc->ctx == NULL) {
+        glxWinReleaseDC(hwnd, gc->hDC, draw);
+        gc->hDC=0;
+      
         ErrorF("wglCreateContext error: %s\n", glxWinErrorMessage());
         return;
     }
@@ -1385,7 +1553,7 @@ glxWinDeferredCreateContext(__GLXWinContext * gc, __GLXWinDrawable * draw)
          gc, gc->ctx, draw);
 
     // if the native context was created successfully, shareLists if needed
-    if (gc->ctx && gc->shareContext) {
+    if (gc->ctx && gc->shareContext && gc->shareContext->ctx) {
         GLWIN_DEBUG_MSG
             ("glxWinCreateContextReal shareLists with context %p (native ctx %p)",
              gc->shareContext, gc->shareContext->ctx);
@@ -1408,33 +1576,25 @@ glxWinContextMakeCurrent(__GLXcontext * base)
     __GLXWinContext *gc = (__GLXWinContext *) base;
     glxWinScreen *scr = (glxWinScreen *)base->pGlxScreen;
     BOOL ret;
-    HDC drawDC;
-    HDC readDC = NULL;
-    __GLXdrawable *drawPriv;
-    __GLXdrawable *readPriv = NULL;
-    HWND hDrawWnd;
-    HWND hReadWnd;
+    __GLXWinDrawable *drawPriv;
 
-    GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc,
-                    gc->ctx);
+#ifdef _DEBUG
+    GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc, gc->ctx);
+    glWinCallDelta();
+#endif
 
     /* Keep a note of the last active context in the drawable */
-    drawPriv = gc->base.drawPriv;
-    ((__GLXWinDrawable *) drawPriv)->drawContext = gc;
+    drawPriv = (__GLXWinDrawable *)gc->base.drawPriv;
+    drawPriv->drawContext = gc;
 
     if (gc->ctx == NULL) {
-        glxWinDeferredCreateContext(gc, (__GLXWinDrawable *) drawPriv);
+        glxWinDeferredCreateContext(gc, drawPriv);
     }
+    _glapi_set_dispatch(gc->Dispatch);
 
     if (gc->ctx == NULL) {
         ErrorF("glxWinContextMakeCurrent: Native context is NULL\n");
-        return FALSE;
-    }
-
-    drawDC =
-        glxWinMakeDC(gc, (__GLXWinDrawable *) drawPriv, &drawDC, &hDrawWnd);
-    if (drawDC == NULL) {
-        ErrorF("glxWinMakeDC failed for drawDC\n");
+        drawPriv->drawContext = NULL; /* clear last active context because we return error */
         return FALSE;
     }
 
@@ -1452,16 +1612,14 @@ glxWinContextMakeCurrent(__GLXcontext * base)
            use the wglMakeContextCurrent extension to make the context current drawing
            to one DC and reading from the other
          */
-        readPriv = gc->base.readPriv;
-        readDC =
-            glxWinMakeDC(gc, (__GLXWinDrawable *) readPriv, &readDC, &hReadWnd);
-        if (readDC == NULL) {
+        gc->hreadDC = glxWinMakeDC(gc, (__GLXWinDrawable *)gc->base.readPriv, &gc->hreadwnd);
+        if (gc->hreadDC == NULL) {
             ErrorF("glxWinMakeDC failed for readDC\n");
-            glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *) drawPriv);
+            drawPriv->drawContext = NULL; /* clear last active context because we return error */
             return FALSE;
         }
 
-        ret = wglMakeContextCurrentARBWrapper(drawDC, readDC, gc->ctx);
+        ret = wglMakeContextCurrentARBWrapper(gc->hDC, gc->hreadDC, gc->ctx);
         if (!ret) {
             ErrorF("wglMakeContextCurrentARBWrapper error: %s\n",
                    glxWinErrorMessage());
@@ -1469,18 +1627,25 @@ glxWinContextMakeCurrent(__GLXcontext * base)
     }
     else {
         /* Otherwise, just use wglMakeCurrent */
-        ret = wglMakeCurrent(drawDC, gc->ctx);
+        if (!gc->hDC) {
+            /* It probably has been release by loseCurrent, so create it again */
+            gc->hDC = glxWinMakeDC(gc, drawPriv, &gc->hwnd);
+        }
+        ret = wglMakeCurrent(gc->hDC, gc->ctx);
         if (!ret) {
-            ErrorF("wglMakeCurrent error: %s\n", glxWinErrorMessage());
+            DWORD ErrorCode=GetLastError();
+            ErrorF("wglMakeCurrent error: %x dc %p ctx %p\n", ErrorCode,gc->hDC,gc->ctx);
+            if (!ErrorCode) {
+                ErrorF("Error code was 0, assuming no error.\n");
+                ret=TRUE;
+            }
         }
     }
 
     // apparently make current could fail if the context is current in a different thread,
     // but that shouldn't be able to happen in the current server...
-
-    glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *) drawPriv);
-    if (readDC)
-        glxWinReleaseDC(hReadWnd, readDC, (__GLXWinDrawable *) readPriv);
+    if (!ret)
+      drawPriv->drawContext = NULL; /* clear last active context because we return error */
 
     return ret;
 }
@@ -1488,24 +1653,34 @@ glxWinContextMakeCurrent(__GLXcontext * base)
 static int
 glxWinContextLoseCurrent(__GLXcontext * base)
 {
-    BOOL ret;
+    BOOL ret=TRUE;
     __GLXWinContext *gc = (__GLXWinContext *) base;
+    __GLXWinDrawable *drawPriv = (__GLXWinDrawable *)gc->base.drawPriv;
 
-    GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc,
-                    gc->ctx);
+#ifdef _DEBUG
+    GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc, gc->ctx);
+    glWinCallDelta();
+#endif
 
-    /*
-       An error seems to be reported if we try to make no context current
-       if there is already no current context, so avoid doing that...
-     */
-    if (wglGetCurrentContext() != NULL) {
-        ret = wglMakeCurrent(NULL, NULL);       /* We don't need a DC when setting no current context */
-        if (!ret)
-            ErrorF("glxWinContextLoseCurrent error: %s\n",
-                   glxWinErrorMessage());
+     /* Clear the last active context in the drawable */
+    if (drawPriv) drawPriv->drawContext = NULL;
+
+    if (wglGetCurrentContext()==gc->ctx)
+    {
+      /* Only do this when we are sure we are currently the active, otherwise we are deactivating the wrong one (this is happening!!!) */
+      ret = wglMakeCurrent(NULL, NULL);
+      if (!ret)
+        ErrorF("glxWinContextLoseCurrent error: %s\n", glxWinErrorMessage());
+    }
+    else
+    {
+      return FALSE;
     }
 
-    return TRUE;
+    base->currentClient=NULL;  /* It looks like glx is not doing this */
+    _glapi_set_dispatch(NULL);
+
+    return ret;
 }
 
 static int
@@ -1532,27 +1707,35 @@ glxWinContextDestroy(__GLXcontext * base)
     __GLXWinContext *gc = (__GLXWinContext *) base;
 
     if (gc != NULL) {
+        __GLXWinDrawable *drawPriv = (__GLXWinDrawable *)gc->base.drawPriv;
+
         GLWIN_DEBUG_MSG("GLXcontext %p destroyed (native ctx %p)", base,
                         gc->ctx);
 
         if (gc->ctx) {
+            BOOL ret;
             /* It's bad style to delete the context while it's still current */
             if (wglGetCurrentContext() == gc->ctx) {
                 wglMakeCurrent(NULL, NULL);
             }
 
-            {
-                BOOL ret = wglDeleteContext(gc->ctx);
-
-                if (!ret)
-                    ErrorF("wglDeleteContext error: %s\n",
-                           glxWinErrorMessage());
-            }
+            ret = wglDeleteContext(gc->ctx);
 
+            if (!ret)
+                ErrorF("wglDeleteContext error: %s\n", glxWinErrorMessage());
+            if (drawPriv && gc->hDC) glxWinReleaseDC(gc->hwnd, gc->hDC, drawPriv);
+            if (gc->base.readPriv && gc->hreadDC) glxWinReleaseDC(gc->hreadwnd, gc->hreadDC, (__GLXWinDrawable *)gc->base.readPriv);
+            gc->hDC=NULL;
+            gc->hreadDC=NULL;
             gc->ctx = NULL;
         }
 
+        /* Clear the last active context in the drawable */
+        if (drawPriv) drawPriv->drawContext = NULL;
+
+        free(gc->Dispatch);
         free(gc);
+        _glapi_set_dispatch(NULL);
     }
 }
 
@@ -1564,12 +1747,11 @@ glxWinCreateContext(__GLXscreen * screen,
     __GLXWinContext *context;
     __GLXWinContext *shareContext = (__GLXWinContext *) baseShareContext;
 
-    context = calloc(1, sizeof(__GLXWinContext));
+    context = calloc(1, sizeof(*context));
 
     if (!context)
         return NULL;
 
-    memset(context, 0, sizeof *context);
     context->base.destroy = glxWinContextDestroy;
     context->base.makeCurrent = glxWinContextMakeCurrent;
     context->base.loseCurrent = glxWinContextLoseCurrent;
@@ -1580,9 +1762,14 @@ glxWinCreateContext(__GLXscreen * screen,
     context->base.pGlxScreen = screen;
 
     // actual native GL context creation is deferred until attach()
-    context->ctx = NULL;
+    //context->ctx = NULL; already done by calloc
     context->shareContext = shareContext;
 
+    context->Dispatch=calloc(sizeof(void*), (sizeof(struct _glapi_table) / sizeof(void *) + MAX_EXTENSION_FUNCS));
+    _glapi_set_dispatch(context->Dispatch);
+
+    glWinSetupDispatchTable();
+
     GLWIN_DEBUG_MSG("GLXcontext %p created", context);
 
     return &(context->base);
@@ -1854,8 +2041,10 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen * screen)
             break;
         }
 
+#ifdef _DEBUG
         if (glxWinDebugSettings.dumpPFD)
             pfdOut(&pfd);
+#endif
 
         if (!(pfd.dwFlags & (PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP)) ||
             !(pfd.dwFlags & PFD_SUPPORT_OPENGL)) {
@@ -2149,12 +2338,15 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen * screen, PixelFormatRejectStats *
 
     /* fill in configs */
     for (i = 0; i < numConfigs; i++) {
-        int values[num_attrs];
+        int sizevalues=num_attrs*sizeof(int);
+        int *values=(int*)_alloca(sizevalues);
         GLXWinConfig temp;
         GLXWinConfig *c = &temp;
         GLXWinConfig *work;
         memset(c, 0, sizeof(GLXWinConfig));
 
+        memset(values,0,sizevalues);
+
         c->pixelFormatIndex = i + 1;
 
         if (!wglGetPixelFormatAttribivARBWrapper
@@ -2434,6 +2626,7 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen * screen, PixelFormatRejectStats *
             first = work;
 
         // update previous config to point to this config
+
         if (prev)
             prev->base.next = &(work->base);
         prev = work;
diff --git a/xserver/hw/xwin/glx/indirect.h b/vcxsrv-code/xorg-server/hw/xwin/glx/indirect.h
index c32ce78..5c8f810 100644
--- a/xserver/hw/xwin/glx/indirect.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/indirect.h
@@ -25,7 +25,7 @@
 #define indirect_h
 
 #include <X11/Xwindows.h>
-#include <GL/wglext.h>
+#include <wglext.h>
 #include <glx/extension_string.h>
 
 /* ---------------------------------------------------------------------- */
@@ -43,6 +43,12 @@ struct __GLXWinContext {
     HGLRC ctx;                  /* Windows GL Context */
     __GLXWinContext *shareContext;      /* Context with which we will share display lists and textures */
     HWND hwnd;                  /* For detecting when HWND has changed */
+
+    HDC hDC;                           /* Windows device context */
+    HDC hreadDC;                     /* Windows device read context */
+    HWND hreadwnd;
+    struct _glapi_table *Dispatch;
+
 };
 
 struct __GLXWinDrawable {
@@ -75,6 +81,8 @@ struct __GLXWinScreen {
     RealizeWindowProcPtr RealizeWindow;
     UnrealizeWindowProcPtr UnrealizeWindow;
     CopyWindowProcPtr CopyWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    PositionWindowProcPtr PositionWindow;
 };
 
 struct __GLXWinConfig {
@@ -88,6 +96,6 @@ struct __GLXWinConfig {
  */
 
 void
-glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXconfig *config);
+glxWinDeferredCreateDrawable(__GLXWinDrawable *draw, __GLXWinContext * gc);
 
 #endif /* indirect_h */
diff --git a/xserver/hw/xwin/glx/wgl_ext_api.c b/vcxsrv-code/xorg-server/hw/xwin/glx/wgl_ext_api.c
index 61cfe80..c11eb4f 100644
--- a/xserver/hw/xwin/glx/wgl_ext_api.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/wgl_ext_api.c
@@ -35,15 +35,20 @@
 #include <GL/glext.h>
 #include <glx/glxserver.h>
 #include <glx/glxext.h>
-#include <GL/wglext.h>
+#include "wglext.h"
 #include <wgl_ext_api.h>
 #include "glwindows.h"
 
 #define RESOLVE_DECL(type) \
     static type type##proc = NULL;
 
+#ifdef _DEBUG
 #define PRERESOLVE(type, symbol) \
     type##proc = (type)wglGetProcAddress(symbol);
+#else
+#define PRERESOLVE(type, symbol) \
+    type##proc = (type)wglGetProcAddress(symbol);
+#endif
 
 #define RESOLVE_RET(type, symbol, retval) \
   if (type##proc == NULL) { \
@@ -69,4 +74,4 @@
  * systems...
  */
 
-#include "generated_wgl_wrappers.ic"
+#include "generated_wgl_wrappers.c"
diff --git a/xserver/hw/xwin/glx/wgl_ext_api.h b/vcxsrv-code/xorg-server/hw/xwin/glx/wgl_ext_api.h
index b7231eb..63b1d7e 100644
--- a/xserver/hw/xwin/glx/wgl_ext_api.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/wgl_ext_api.h
@@ -29,7 +29,7 @@
 #ifndef wgl_ext_api_h
 #define wgl_ext_api_h
 
-#include <GL/wglext.h>
+#include "wglext.h"
 
 void wglResolveExtensionProcs(void);
 
@@ -38,46 +38,46 @@ void wglResolveExtensionProcs(void);
   XXX: should be automatically generated as well
 */
 
-const char *wglGetExtensionsStringARBWrapper(HDC hdc);
-BOOL wglMakeContextCurrentARBWrapper(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
-HDC wglGetCurrentReadDCARBWrapper(VOID);
+const char * __stdcall wglGetExtensionsStringARBWrapper(HDC hdc);
+BOOL __stdcall wglMakeContextCurrentARBWrapper(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
+HDC __stdcall wglGetCurrentReadDCARBWrapper(VOID);
 
-BOOL wglGetPixelFormatAttribivARBWrapper(HDC hdc,
+BOOL __stdcall wglGetPixelFormatAttribivARBWrapper(HDC hdc,
                                          int iPixelFormat,
                                          int iLayerPlane,
                                          UINT nAttributes,
                                          const int *piAttributes,
                                          int *piValues);
 
-BOOL wglGetPixelFormatAttribfvARBWrapper(HDC hdc,
+BOOL __stdcall wglGetPixelFormatAttribfvARBWrapper(HDC hdc,
                                          int iPixelFormat,
                                          int iLayerPlane,
                                          UINT nAttributes,
                                          const int *piAttributes,
                                          FLOAT * pfValues);
 
-BOOL wglChoosePixelFormatARBWrapper(HDC hdc,
+BOOL __stdcall wglChoosePixelFormatARBWrapper(HDC hdc,
                                     const int *piAttribIList,
                                     const FLOAT * pfAttribFList,
                                     UINT nMaxFormats,
                                     int *piFormats, UINT * nNumFormats);
 
-HPBUFFERARB wglCreatePbufferARBWrapper(HDC hDC,
+HPBUFFERARB __stdcall wglCreatePbufferARBWrapper(HDC hDC,
                                        int iPixelFormat,
                                        int iWidth,
                                        int iHeight, const int *piAttribList);
 
-HDC wglGetPbufferDCARBWrapper(HPBUFFERARB hPbuffer);
+HDC __stdcall wglGetPbufferDCARBWrapper(HPBUFFERARB hPbuffer);
 
-int wglReleasePbufferDCARBWrapper(HPBUFFERARB hPbuffer, HDC hDC);
+int __stdcall wglReleasePbufferDCARBWrapper(HPBUFFERARB hPbuffer, HDC hDC);
 
-BOOL wglDestroyPbufferARBWrapper(HPBUFFERARB hPbuffer);
+BOOL __stdcall wglDestroyPbufferARBWrapper(HPBUFFERARB hPbuffer);
 
-BOOL wglQueryPbufferARBWrapper(HPBUFFERARB hPbuffer,
+BOOL __stdcall wglQueryPbufferARBWrapper(HPBUFFERARB hPbuffer,
                                int iAttribute, int *piValue);
 
-BOOL wglSwapIntervalEXTWrapper(int interval);
+BOOL __stdcall wglSwapIntervalEXTWrapper(int interval);
 
-int wglGetSwapIntervalEXTWrapper(void);
+int __stdcall wglGetSwapIntervalEXTWrapper(void);
 
 #endif                          /* wgl_ext_api_h */
diff --git a/xserver/hw/xwin/glx/winpriv.c b/vcxsrv-code/xorg-server/hw/xwin/glx/winpriv.c
index d72c047..2124de2 100644
--- a/xserver/hw/xwin/glx/winpriv.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/winpriv.c
@@ -11,6 +11,8 @@
 #include "winpriv.h"
 #include "winwindow.h"
 
+extern Bool			g_fXdmcpEnabled;
+
 void
  winCreateWindowsWindow(WindowPtr pWin);
 
@@ -21,7 +23,8 @@ void
 HWND
 winGetWindowInfo(WindowPtr pWin)
 {
-    winTrace("%s: pWin %p XID 0x%x\n", __FUNCTION__, pWin, (unsigned int)pWin->drawable.id);
+    HWND hwnd = NULL;
+    winDebug("%s:%d pWin %p XID 0x%x\n", __FUNCTION__, __LINE__, pWin, (unsigned int)pWin->drawable.id);
 
     /* a real window was requested */
     if (pWin != NULL) {
@@ -29,11 +32,10 @@ winGetWindowInfo(WindowPtr pWin)
         ScreenPtr pScreen = pWin->drawable.pScreen;
         winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
         winScreenInfoPtr pScreenInfo = NULL;
-        HWND hwnd = NULL;
 
         if (pWinScreen == NULL) {
             ErrorF("winGetWindowInfo: screen has no privates\n");
-            return NULL;
+            return hwnd;
         }
 
         hwnd = pWinScreen->hwndScreen;
@@ -49,19 +51,103 @@ winGetWindowInfo(WindowPtr pWin)
             }
 
             if (pWinPriv->hWnd == NULL) {
+              if (pWin->parent && pWin->parent->parent)
+              {
+                int offsetx;
+                int offsety;
+                int ExtraClass=(pWin->realized)?WS_VISIBLE:0;
+                HWND hWndParent;
+                WindowPtr pParent=pWin->parent;
+                while (pParent)
+                {
+                  winWindowPriv(pParent);
+                  hWndParent=pWinPriv->hWnd;
+                  if (hWndParent)
+                    break;
+                  pParent=pParent->parent;
+                }
+                if (!hWndParent)
+                  hWndParent=hwnd;
+                if (pParent)
+                {
+                  offsetx=pParent->drawable.x;
+                  offsety=pParent->drawable.y;
+                }
+                else
+                {
+                  offsetx=0;
+                  offsety=0;
+                }
+                pWinPriv->hWnd=CreateWindowExA(0,
+                             WIN_GL_WINDOW_CLASS,
+                             "",
+                             WS_CHILD |WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_DISABLED | ExtraClass,
+                             pWin->drawable.x-offsetx,
+                             pWin->drawable.y-offsety,
+                             pWin->drawable.width,
+                             pWin->drawable.height,
+                             hWndParent,
+                             NULL,
+                             g_hInstance,
+                             pWin);
+                winDebug("Window created %x %x %d %d %d %d\n",pWinPriv->hWnd,hWndParent,pWin->drawable.x-offsetx,pWin->drawable.y-offsety,pWin->drawable.width, pWin->drawable.height);
+                pWinPriv->fWglUsed=TRUE;
+              }
+              else
+              {
                 winCreateWindowsWindow(pWin);
-                winDebug("winGetWindowInfo: forcing window to exist\n");
+                winDebug("winGetWindowInfo: forcing window to exist...\n");
+              }
             }
-
             if (pWinPriv->hWnd != NULL) {
                 /* copy window handle */
                 hwnd = pWinPriv->hWnd;
-
-                /* mark GLX active on that hwnd */
-                pWinPriv->fWglUsed = TRUE;
             }
+        }
+        else if (g_fXdmcpEnabled)
+        {
+            winWindowPriv(pWin);
 
-            return hwnd;
+            if (pWinPriv == NULL)
+            {
+                ErrorF("winGetWindowInfo: window has no privates\n");
+                return hwnd;
+            }
+            if (pWinPriv->hWnd == NULL)
+            {
+              if (!((pWin->drawable.x==0) &&
+                     (pWin->drawable.y==0) &&
+                     (pWin->drawable.width==pScreen->width) &&
+                     (pWin->drawable.height==pScreen->height)
+                    )
+                  )
+              {
+                int ExtraClass=(pWin->realized)?WS_VISIBLE:0;
+                pWinPriv->hWnd=CreateWindowExA(0,
+                             WIN_GL_WINDOW_CLASS,
+                             "",
+                             WS_CHILD |WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_DISABLED | ExtraClass,
+                             pWin->drawable.x,
+                             pWin->drawable.y,
+                             pWin->drawable.width,
+                             pWin->drawable.height,
+                             pWinScreen->hwndScreen,
+                             NULL,
+                             g_hInstance,
+                             pWin);
+                pWinPriv->fWglUsed=TRUE;
+                /* copy size and window handle */
+                hwnd = pWinPriv->hWnd;
+              }
+              else
+              {
+                hwnd = pWinScreen->hwndScreen;
+              }
+            }
+            else
+            {
+              hwnd = pWinPriv->hWnd;
+            }
         }
     }
     else {
@@ -70,15 +156,16 @@ winGetWindowInfo(WindowPtr pWin)
 
         if (pWinScreen == NULL) {
             ErrorF("winGetWindowInfo: screen has no privates\n");
-            return NULL;
         }
+        else
+        {
+            winDebug("winGetWindowInfo: returning root window\n");
 
-        ErrorF("winGetWindowInfo: returning root window\n");
-
-        return pWinScreen->hwndScreen;
+            hwnd=pWinScreen->hwndScreen;
+        }
     }
 
-    return NULL;
+    return hwnd;
 }
 
 Bool
@@ -90,6 +177,9 @@ winCheckScreenAiglxIsSupported(ScreenPtr pScreen)
     if (pScreenInfo->fMultiWindow)
         return TRUE;
 
+
+  if (g_fXdmcpEnabled)
+    return TRUE;
     return FALSE;
 }
 
diff --git a/xserver/hw/xwin/glx/winpriv.h b/vcxsrv-code/xorg-server/hw/xwin/glx/winpriv.h
index 6f695a9..e813325 100644
--- a/xserver/hw/xwin/glx/winpriv.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/glx/winpriv.h
@@ -7,6 +7,8 @@
 #include <X11/Xwindows.h>
 #include <windowstr.h>
 
+#define WIN_GL_WINDOW_CLASS "XWinGLTest"
+
 HWND winGetWindowInfo(WindowPtr pWin);
 Bool winCheckScreenAiglxIsSupported(ScreenPtr pScreen);
 void winSetScreenAiglxIsActive(ScreenPtr pScreen);
diff --git a/xserver/hw/xwin/propertystore.h b/vcxsrv-code/xorg-server/hw/xwin/propertystore.h
index 6afc6c9..b4a761f 100644
--- a/xserver/hw/xwin/propertystore.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/propertystore.h
@@ -26,7 +26,7 @@
 
 #include <windows.h>
 
-#ifdef __MINGW64_VERSION_MAJOR
+#if defined(__MINGW64_VERSION_MAJOR) || defined(_MSC_VER)
 /* If we are using headers from mingw-w64 project, it provides the PSDK headers this needs ... */
 #include <propkey.h>
 #include <propsys.h>
diff --git a/xserver/hw/xwin/win.h b/vcxsrv-code/xorg-server/hw/xwin/win.h
index 48795a8..2d5a907 100644
--- a/xserver/hw/xwin/win.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/win.h
@@ -47,11 +47,6 @@
 #define WM_MOUSEHWHEEL 0x020E
 #endif
 
-/* Turn debug messages on or off */
-#ifndef CYGDEBUG
-#define CYGDEBUG				NO
-#endif
-
 #define WIN_DEFAULT_BPP				0
 #define WIN_DEFAULT_WHITEPIXEL			255
 #define WIN_DEFAULT_BLACKPIXEL			0
@@ -75,7 +70,7 @@
 /*
  * Number of times to call Restore in an attempt to restore the primary surface
  */
-#define WIN_REGAIN_SURFACE_RETRIES		1
+#define WIN_REGAIN_SURFACE_RETRIES		2
 
 /*
  * Build a supported display depths mask by shifting one to the left
@@ -128,6 +123,9 @@
 
 #include <errno.h>
 #define HANDLE void *
+#ifdef _MSC_VER
+typedef int pid_t;
+#endif
 #include <pthread.h>
 #undef HANDLE
 
@@ -189,43 +187,6 @@
 #include "winwindow.h"
 #include "winmsg.h"
 
-/*
- * Debugging macros
- */
-
-#if CYGDEBUG
-#define DEBUG_MSG(str,...) \
-if (fDebugProcMsg) \
-{ \
-  char *pszTemp; \
-  int iLength; \
-  if (asprintf (&pszTemp, str, ##__VA_ARGS__) != -1) { \
-    MessageBox (NULL, pszTemp, szFunctionName, MB_OK); \
-    free (pszTemp); \
-  } \
-}
-#else
-#define DEBUG_MSG(str,...)
-#endif
-
-#if CYGDEBUG
-#define DEBUG_FN_NAME(str) PTSTR szFunctionName = str
-#else
-#define DEBUG_FN_NAME(str)
-#endif
-
-#if CYGDEBUG || YES
-#define DEBUGVARS BOOL fDebugProcMsg = FALSE
-#else
-#define DEBUGVARS
-#endif
-
-#if CYGDEBUG || YES
-#define DEBUGPROC_MSG fDebugProcMsg = TRUE
-#else
-#define DEBUGPROC_MSG
-#endif
-
 #define PROFILEPOINT(point,thresh)\
 {\
 static unsigned int PROFPT##point = 0;\
@@ -244,6 +205,10 @@ static Atom func (void) {					\
     return atom;						\
 }
 
+#define WND_EXTRABYTES  (2*sizeof(LONG_PTR))
+#define WND_IDX_BUTTONDOWNLPARAM 0
+#define WND_IDX_ENTEREDSIZEMOVE  (sizeof(LONG_PTR))
+
 /*
  * Typedefs for engine dependent function pointers
  */
@@ -711,6 +676,9 @@ Bool
  * windialogs.c
  */
 
+int
+GetLiveClients (winPrivScreenPtr pScreenPriv);
+
 void
  winDisplayExitDialog(winPrivScreenPtr pScreenPriv);
 
@@ -927,6 +895,8 @@ void
 
 void
  winReorderWindowsMultiWindow(void);
+int
+winConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client);
 
 void
 
@@ -973,7 +943,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
  */
 
 void
- winInitNotifyIcon(winPrivScreenPtr pScreenPriv);
+ winInitNotifyIcon (winPrivScreenPtr pScreenPriv, Bool Modify);
 
 void
  winDeleteNotifyIcon(winPrivScreenPtr pScreenPriv);
@@ -1015,6 +985,13 @@ Bool
 void
  winInitializeScreens(int maxscreens);
 
+/*
+ * windisplay.c
+ */
+
+void
+winGetDisplayName(char *szDisplay, unsigned int screen);
+
 /*
  * winrandr.c
  */
diff --git a/xserver/hw/xwin/winSetAppUserModelID.c b/vcxsrv-code/xorg-server/hw/xwin/winSetAppUserModelID.c
index f9cb92c..36fe8bb 100644
--- a/xserver/hw/xwin/winSetAppUserModelID.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winSetAppUserModelID.c
@@ -34,6 +34,7 @@
 #include "winmsg.h"
 
 #include <shlwapi.h>
+#include <propvarutil.h>
 
 #define INITGUID
 #include "initguid.h"
@@ -43,6 +44,23 @@
 static HMODULE g_hmodShell32Dll = NULL;
 static SHGETPROPERTYSTOREFORWINDOWPROC g_pSHGetPropertyStoreForWindow = NULL;
 
+extern void winPropertyStoreInit(void);
+
+extern void winPropertyStoreDestroy(void);
+
+static const char * 
+RemoveWhitespaceAndTruncate(HWND hWnd, const char *AppID)
+{
+    const char *p=AppID;
+    static char appID[129];
+
+    while (*p && isspace(*p))
+        p++;
+    strncpy(appID, p, 128);
+    appID[128]=0;
+    return appID;
+}
+
 void
 winPropertyStoreInit(void)
 {
@@ -90,15 +108,15 @@ winSetAppUserModelID(HWND hWnd, const char *AppID)
         return;
     }
 
-    winDebug("winSetAppUserMOdelID - hwnd 0x%p appid '%s'\n", hWnd, AppID);
-
     hr = g_pSHGetPropertyStoreForWindow(hWnd, &IID_IPropertyStore,
                                         (void **) &pps);
     if (SUCCEEDED(hr) && pps) {
-        memset(&pv, 0, sizeof(PROPVARIANT));
+        PropVariantInit(&pv);
         if (AppID) {
+            const char *appID=RemoveWhitespaceAndTruncate(hWnd, AppID);
+            winDebug("winSetAppUserMOdelID - hwnd 0x%p appid '%s'\n", hWnd, appID);
             pv.vt = VT_LPWSTR;
-            hr = SHStrDupA(AppID, &pv.pwszVal);
+            hr = SHStrDupA(appID, &pv.pwszVal);
         }
 
         if (SUCCEEDED(hr)) {
diff --git a/xserver/hw/xwin/winallpriv.c b/vcxsrv-code/xorg-server/hw/xwin/winallpriv.c
index 818805c..abdb5a8 100644
--- a/xserver/hw/xwin/winallpriv.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winallpriv.c
@@ -47,10 +47,8 @@ winAllocatePrivates(ScreenPtr pScreen)
 {
     winPrivScreenPtr pScreenPriv;
 
-#if CYGDEBUG
     winDebug("winAllocateScreenPrivates - g_ulServerGeneration: %lu "
              "serverGeneration: %lu\n", g_ulServerGeneration, serverGeneration);
-#endif
 
     /* We need a new slot for our privates if the screen gen has changed */
     if (g_ulServerGeneration != serverGeneration) {
@@ -72,7 +70,7 @@ winAllocatePrivates(ScreenPtr pScreen)
 
     /* Register our screen private */
     if (!dixRegisterPrivateKey(g_iScreenPrivateKey, PRIVATE_SCREEN, 0)) {
-        ErrorF("winAllocatePrivates - AllocateScreenPrivate () failed\n");
+        ErrorF ("winAllocatePrivates - dixRegisterPrivateKey () failed\n");
         return FALSE;
     }
 
@@ -105,9 +103,7 @@ winAllocatePrivates(ScreenPtr pScreen)
 Bool
 winInitCmapPrivates(ColormapPtr pcmap, int i)
 {
-#if CYGDEBUG
     winDebug("winInitCmapPrivates\n");
-#endif
 
     /*
      * I see no way that this function can do anything useful
@@ -132,9 +128,7 @@ winAllocateCmapPrivates(ColormapPtr pCmap)
     winPrivCmapPtr pCmapPriv;
     static unsigned long s_ulPrivateGeneration = 0;
 
-#if CYGDEBUG
     winDebug("winAllocateCmapPrivates\n");
-#endif
 
     /* Get a new privates index when the server generation changes */
     if (s_ulPrivateGeneration != serverGeneration) {
@@ -161,9 +155,7 @@ winAllocateCmapPrivates(ColormapPtr pCmap)
     /* Save the cmap private pointer */
     winSetCmapPriv(pCmap, pCmapPriv);
 
-#if CYGDEBUG
     winDebug("winAllocateCmapPrivates - Returning\n");
-#endif
 
     return TRUE;
 }
diff --git a/xserver/hw/xwin/winauth.c b/vcxsrv-code/xorg-server/hw/xwin/winauth.c
index 4e1b26d..737249a 100644
--- a/xserver/hw/xwin/winauth.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winauth.c
@@ -92,12 +92,13 @@ winGenerateAuthorization(void)
         ErrorF("winGenerateAuthorization - GenerateAuthorization failed\n");
         return FALSE;
     }
-
+#ifdef WINDBG
     else {
         winDebug("winGenerateAuthorization - GenerateAuthorization success!\n"
                  "AuthDataLen: %d AuthData: %s\n",
                  g_uiAuthDataLen, g_pAuthData);
     }
+#endif
 
     auth_info.name = strdup(AUTH_NAME);
     auth_info.namelen = strlen(AUTH_NAME);
diff --git a/xserver/hw/xwin/winblock.c b/vcxsrv-code/xorg-server/hw/xwin/winblock.c
index c8eb0c9..0bca073 100644
--- a/xserver/hw/xwin/winblock.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winblock.c
@@ -48,16 +48,14 @@ winBlockHandler(ScreenPtr pScreen, void *pTimeout)
         /* If there are still messages to process on the Windows message
            queue, make sure select() just polls rather than blocking.
         */
-        (*tvp)->tv_sec = 0;
-        (*tvp)->tv_usec = 0;
+        *(int*)pTimeout = 0;
       }
       else {
         /* Otherwise, lacking /dev/windows, we must wake up again in
            a reasonable time to check the Windows message queue. without
            noticeable delay.
          */
-        (*tvp)->tv_sec = 0;
-        (*tvp)->tv_usec = 100;
+        *(int*)pTimeout = 1;
       }
     }
 #endif
diff --git a/xserver/hw/xwin/winclipboard/internal.h b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/internal.h
index 368fa70..646fd89 100644
--- a/xserver/hw/xwin/winclipboard/internal.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/internal.h
@@ -31,6 +31,25 @@
 #ifndef WINCLIPBOARD_INTERNAL_H
 #define WINCLIPBOARD_INTERNAL_H
 
+/* Standard library headers */
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#ifndef _MSC_VER
+#include <unistd.h>
+#endif
+#ifdef __CYGWIN__
+#include <sys/select.h>
+#else
+#include <X11/Xwinsock.h>
+#endif
+#include <fcntl.h>
+#include <setjmp.h>
+#ifdef _MSC_VER
+typedef int pid_t;
+#endif
+#include <pthread.h>
+
 #include <xcb/xproto.h>
 #include <X11/Xfuncproto.h> // for _X_ATTRIBUTE_PRINTF
 #include <X11/Xmd.h> // for BOOL
@@ -38,12 +57,14 @@
 /* Windows headers */
 #include <X11/Xwindows.h>
 
+#include "winmsg.h"
+
 #define WIN_XEVENTS_SUCCESS			0  // more like 'CONTINUE'
 #define WIN_XEVENTS_FAILED			1
 #define WIN_XEVENTS_NOTIFY_DATA			3
 #define WIN_XEVENTS_NOTIFY_TARGETS		4
 
-#define WM_WM_QUIT                             (WM_USER + 2)
+#define WM_WM_QUIT                             (WM_USER + 201)
 
 #define ARRAY_SIZE(a)  (sizeof((a)) / sizeof((a)[0]))
 
@@ -51,8 +72,13 @@
  * References to external symbols
  */
 
-extern void winDebug(const char *format, ...) _X_ATTRIBUTE_PRINTF(1, 2);
-extern void ErrorF(const char *format, ...) _X_ATTRIBUTE_PRINTF(1, 2);
+extern char *display;
+/*
+ * winclipboardinit.c
+ */
+
+Bool
+ winInitClipboard(void);
 
 /*
  * winclipboardtextconv.c
diff --git a/xserver/hw/xwin/winclipboard/thread.c b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/thread.c
index 0e60c1b..6e45006 100644
--- a/xserver/hw/xwin/winclipboard/thread.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/thread.c
@@ -36,17 +36,12 @@
 #define HAS_WINSOCK 1
 #endif
 
-#include <assert.h>
-#include <unistd.h>
-#include <fcntl.h>
+#include <sys/types.h>
+#include <signal.h>
 #include <pthread.h>
-#include <sys/param.h> // for MAX() macro
-
-#ifdef HAS_WINSOCK
-#include <X11/Xwinsock.h>
-#else
-#include <errno.h>
-#endif
+#include "windisplay.h"
+#include "misc.h"
+#include "winmsg.h"
 
 #include <xcb/xcb.h>
 #include <xcb/xcb_aux.h>
@@ -56,24 +51,43 @@
 #include "winclipboard.h"
 #include "internal.h"
 
+/* Clipboard module constants */
 #define WIN_CONNECT_RETRIES			40
 #define WIN_CONNECT_DELAY			4
+#define WIN_JMP_OKAY				0
+#define WIN_JMP_ERROR_IO			2
 
 #define WIN_CLIPBOARD_WINDOW_CLASS		"xwinclip"
 #define WIN_CLIPBOARD_WINDOW_TITLE		"xwinclip"
 #ifdef HAS_DEVWINDOWS
-#define WIN_MSG_QUEUE_FNAME "/dev/windows"
+#define WIN_MSG_QUEUE_FNAME			"/dev/windows"
 #endif
 
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#endif
+/*
+ * References to external symbols
+ */
+
+extern Bool g_fUnicodeClipboard;
+extern Bool g_fClipboard;
+extern Bool g_fClipboardStarted;
+extern Bool g_fClipboardLaunched;
+extern HWND g_hwndClipboard;
+extern void *g_pClipboardDisplay;
+extern Window g_iClipboardWindow;
+
 /*
  * Global variables
  */
 
-static HWND g_hwndClipboard = NULL;
 
 int xfixes_event_base;
 int xfixes_error_base;
 
+int xserver_resetting = 0;
+
 /*
  * Local function prototypes
  */
@@ -97,6 +111,9 @@ intern_atom(xcb_connection_t *conn, const char *atomName)
   return atom;
 }
 
+static void
+winClipboardThreadExit(void *arg);
+
 /*
  * Create X11 and Win32 messaging windows, and run message processing loop
  *
@@ -121,6 +138,8 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
     xcb_window_t iWindow = XCB_NONE;
     int iSelectError;
     BOOL fShutdown = FALSE;
+
+    pthread_cleanup_push(&winClipboardThreadExit, NULL);
     ClipboardConversionData data;
     int screen;
 
@@ -130,9 +149,12 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
     conn = xcb_connect_to_display_with_auth_info(szDisplay, auth_info, &screen);
     if (xcb_connection_has_error(conn)) {
         ErrorF("winClipboardProc - Failed opening the display, giving up\n");
-        goto winClipboardProc_Done;
+        goto thread_errorexit;
     }
 
+    /* Save the display in the screen privates */
+    g_pClipboardDisplay = conn;
+
     ErrorF("winClipboardProc - xcb_connect () returned and "
            "successfully opened the display.\n");
 
@@ -144,7 +166,7 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
     fdMessageQueue = open(WIN_MSG_QUEUE_FNAME, O_RDONLY);
     if (fdMessageQueue == -1) {
         ErrorF("winClipboardProc - Failed opening %s\n", WIN_MSG_QUEUE_FNAME);
-        goto winClipboardProc_Done;
+        goto thread_errorexit;
     }
 
     /* Find max of our file descriptors */
@@ -191,7 +213,7 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
     if ((error = xcb_request_check(conn, cookie))) {
         ErrorF("winClipboardProc - Could not create an X window.\n");
         free(error);
-        goto winClipboardProc_Done;
+        goto thread_errorexit;
     }
 
     xcb_icccm_set_wm_name(conn, iWindow, XCB_ATOM_STRING, 8, strlen("xwinclip"), "xwinclip");
@@ -218,6 +240,8 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
                                       XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY |
                                       XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE);
 
+    /* Save the window in the screen privates */
+    g_iClipboardWindow = iWindow;
     /* Initialize monitored selection state */
     winClipboardInitMonitoredSelections();
     /* Create Windows messaging window */
@@ -233,7 +257,7 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
         if ((error = xcb_request_check(conn, cookie))) {
             ErrorF("winClipboardProc - Could not set PRIMARY owner\n");
             free(error);
-            goto winClipboardProc_Done;
+            goto thread_errorexit;
         }
 
         /* CLIPBOARD */
@@ -241,12 +265,16 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
         if ((error = xcb_request_check(conn, cookie))) {
             ErrorF("winClipboardProc - Could not set CLIPBOARD owner\n");
             free(error);
-            goto winClipboardProc_Done;
+            goto thread_errorexit;
         }
     }
 
     data.incr = NULL;
     data.incrsize = 0;
+    data.incrsize = 0;
+    winDebug ("winClipboardProc - Started\n");
+    /* Signal that the clipboard client has started */
+    g_fClipboardStarted = TRUE;
 
     /* Loop for events */
     while (1) {
@@ -309,38 +337,11 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
                    "Bailing.\n", iReturn);
             break;
         }
-
-        if (FD_ISSET(iConnectionNumber, &fdsRead)) {
-            winDebug
-                ("winClipboardProc - X connection ready, pumping X event queue\n");
-        }
-
-#ifdef HAS_DEVWINDOWS
-        /* Check for Windows event ready */
-        if (FD_ISSET(fdMessageQueue, &fdsRead))
-#else
-        if (1)
-#endif
-        {
-            winDebug
-                ("winClipboardProc - /dev/windows ready, pumping Windows message queue\n");
-        }
-
-#ifdef HAS_DEVWINDOWS
-        if (!(FD_ISSET(iConnectionNumber, &fdsRead)) &&
-            !(FD_ISSET(fdMessageQueue, &fdsRead))) {
-            winDebug("winClipboardProc - Spurious wake, select() returned %d\n", iReturn);
-        }
-#endif
     }
 
-    /* broke out of while loop on a shutdown message */
-    fShutdown = TRUE;
-
- winClipboardProc_Done:
-    /* Close our Windows window */
-    if (g_hwndClipboard) {
-        DestroyWindow(g_hwndClipboard);
+    if ( xserver_resetting ) {
+        fShutdown = 1;
+        goto commonexit;
     }
 
     /* Close our X window */
@@ -348,8 +349,10 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
         cookie = xcb_destroy_window_checked(conn, iWindow);
         if ((error = xcb_request_check(conn, cookie)))
             ErrorF("winClipboardProc - XDestroyWindow failed.\n");
+#ifdef WINDBG
         else
-            ErrorF("winClipboardProc - XDestroyWindow succeeded.\n");
+            winDebug("winClipboardProc - XDestroyWindow succeeded.\n");
+#endif
         free(error);
     }
 
@@ -369,8 +372,29 @@ winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info)
         xcb_disconnect(conn);
     }
 
-    /* global clipboard variable reset */
-    g_hwndClipboard = NULL;
+  goto commonexit;
+
+thread_errorexit:
+    if (g_pClipboardDisplay && g_iClipboardWindow)
+    {
+        cookie = xcb_destroy_window_checked(g_pClipboardDisplay, g_iClipboardWindow);
+        if ((error = xcb_request_check(conn, cookie)))
+            ErrorF("winClipboardProc - XDestroyWindow failed.\n");
+#ifdef WINDBG
+        else
+            winDebug("winClipboardProc - XDestroyWindow succeeded.\n");
+#endif
+        free(error);
+    }
+    winDebug ("Clipboard thread died.\n");
+
+commonexit:
+    g_iClipboardWindow = None;
+    g_pClipboardDisplay = NULL;
+    g_fClipboardLaunched = FALSE;
+    g_fClipboardStarted = FALSE;
+
+    pthread_cleanup_pop(0);
 
     return fShutdown;
 }
@@ -395,7 +419,7 @@ winClipboardCreateMessagingWindow(xcb_connection_t *conn, xcb_window_t iWindow,
     wc.hInstance = GetModuleHandle(NULL);
     wc.hIcon = 0;
     wc.hCursor = 0;
-    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
+    wc.hbrBackground = NULL;
     wc.lpszMenuName = NULL;
     wc.lpszClassName = WIN_CLIPBOARD_WINDOW_CLASS;
     wc.hIconSm = 0;
@@ -430,10 +454,16 @@ winClipboardCreateMessagingWindow(xcb_connection_t *conn, xcb_window_t iWindow,
     return hwnd;
 }
 
-void
-winClipboardWindowDestroy(void)
+/*
+ * winClipboardThreadExit - Thread exit handler
+ */
+
+static void
+winClipboardThreadExit(void *arg)
 {
-  if (g_hwndClipboard) {
-    SendMessage(g_hwndClipboard, WM_WM_QUIT, 0, 0);
-  }
+  /* clipboard thread has exited, stop server as well */
+  ddxGiveUp(EXIT_ERR_ABORT);
+  TerminateProcess(GetCurrentProcess(),1);
 }
+
+
diff --git a/xserver/hw/xwin/winclipboard/winclipboard.h b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/winclipboard.h
index 243aa24..4d174c1 100644
--- a/xserver/hw/xwin/winclipboard/winclipboard.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/winclipboard.h
@@ -27,14 +27,13 @@
 #ifndef WINCLIPBOARD_H
 #define WINCLIPBOARD_H
 
+#include <x11/Xdefs.h>
 #include <xcb/xcb.h>
 #include <X11/Xmd.h> // for BOOL type
 
 BOOL winClipboardProc(char *szDisplay, xcb_auth_info_t *auth_info);
 
-void winFixClipboardChain(void);
-
-void winClipboardWindowDestroy(void);
+void winFixClipboardChain (int Removed);
 
 extern BOOL fPrimarySelection;
 
diff --git a/xserver/hw/xwin/winclipboard/wndproc.c b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/wndproc.c
index 63de4b9..6c95848 100644
--- a/xserver/hw/xwin/winclipboard/wndproc.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/wndproc.c
@@ -43,6 +43,11 @@
 #include <xcb/xproto.h>
 #include <xcb/xcb_aux.h>
 
+#include "misc.h"
+#include "winmsg.h"
+#include "objbase.h"
+#include "ddraw.h"
+#include "winwindow.h"
 #include "internal.h"
 #include "winclipboard.h"
 
@@ -52,6 +57,15 @@
 
 #define WIN_POLL_TIMEOUT	1
 
+/*
+ * References to external symbols
+ */
+
+extern void *g_pClipboardDisplay;
+extern Window g_iClipboardWindow;
+extern Atom g_atomLastOwnedSelection;
+extern Bool g_fClipboardStarted;
+extern HWND g_hwndClipboard;
 /*
  * Process X events up to specified timeout
  */
@@ -108,8 +122,8 @@ winProcessXEventsTimeout(HWND hwnd, xcb_window_t iWindow, xcb_connection_t *conn
                          NULL,  /* No exception mask */
                          &tv);  /* Timeout */
         if (iReturn < 0) {
-            ErrorF("winProcessXEventsTimeout - Call to select () failed: %d.  "
-                   "Bailing.\n", iReturn);
+            ErrorF("winProcessXEventsTimeout - Call to select () failed: %d (%x).  "
+                   "Bailing.\n", iReturn, WSAGetLastError());
             break;
         }
 
@@ -142,6 +156,8 @@ winClipboardWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* Remove clipboard listener */
         RemoveClipboardFormatListener(hwnd);
     }
+        g_hwndClipboard = NULL;
+        PostMessage(hwnd, WM_WM_QUIT, 0L, 0L);
         return 0;
 
     case WM_WM_QUIT:
@@ -358,7 +374,7 @@ winClipboardWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             struct target_priority target_priority_table[] =
                 {
                     { atoms->atomUTF8String,   0 },
-                    // { atoms->atomCompoundText, 1 }, not implemented (yet?)
+                    { atoms->atomCompoundText, 1 },
                     { XCB_ATOM_STRING,         2 },
                 };
 
diff --git a/xserver/hw/xwin/winclipboard/xevents.c b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/xevents.c
index cac1715..6264c16 100644
--- a/xserver/hw/xwin/winclipboard/xevents.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboard/xevents.c
@@ -33,8 +33,12 @@
 #ifdef HAVE_XWIN_CONFIG_H
 #include <xwin-config.h>
 #endif
-
+#include "winclipboard.h"
+#include "winglobals.h"
+#include "misc.h"
+#include "winmsg.h"
 #include <limits.h>
+#include <unistd.h>
 #include <wchar.h>
 
 #include <xcb/xcb.h>
@@ -169,13 +173,22 @@ winClipboardSelectionNotifyTargets(HWND hwnd, xcb_window_t iWindow, xcb_connecti
       data->targetList = malloc((nitems+1)*sizeof(xcb_atom_t));
 
       for (i = 0; i < nitems; i++)
-          {
-              xcb_atom_t atom = prop[i];
-              char *pszAtomName = get_atom_name(conn, atom);
+      {
+          xcb_atom_t atom = prop[i];
               data->targetList[i] = atom;
-              winDebug("winClipboardFlushXEvents - SelectionNotify - target[%d] %d = %s\n", i, atom, pszAtomName);
-              free(pszAtomName);
-      }
+          if (atom)
+          {
+            #ifdef _DEBUG
+            char *pszAtomName = get_atom_name(conn, atom);
+            winDebug("winClipboardFlushXEvents - SelectionNotify - target[%d] %ld = %s\n", i, atom, pszAtomName);
+            free(pszAtomName);
+            #endif
+          }
+          else if (i!=nitems-1) // It seems that sometimes the item list is already 0 terminated. If a 0 happens in the middle, print an error
+          {
+            ErrorF("Null atom in item list\n");
+          }
+    }
 
     data->targetList[nitems] = 0;
 
@@ -415,6 +428,8 @@ winClipboardFlushXEvents(HWND hwnd,
             UINT codepage;
 
             xcb_selection_request_event_t *selection_request =  (xcb_selection_request_event_t *)event;
+#ifdef _DEBUG
+        if (g_iLogVerbose >= 3)
         {
             char *pszAtomName = NULL;
 
@@ -424,6 +439,7 @@ winClipboardFlushXEvents(HWND hwnd,
             winDebug("SelectionRequest - Target atom name %s\n", pszAtomName);
             free(pszAtomName);
         }
+#endif
 
             /* Abort if invalid target type */
             if (selection_request->target != XCB_ATOM_STRING
@@ -484,10 +500,8 @@ winClipboardFlushXEvents(HWND hwnd,
                 break;
             }
 
-            /* Close clipboard if we have it open already */
-            if (GetOpenClipboardWindow() == hwnd) {
-                CloseClipboard();
-            }
+            /* Close clipboard in case we have it open already */
+            CloseClipboard();
 
             /* Access the clipboard */
             if (!OpenClipboard(hwnd)) {
@@ -526,8 +540,17 @@ winClipboardFlushXEvents(HWND hwnd,
             hGlobal = GetClipboardData(CF_UNICODETEXT);
 
             if (!hGlobal) {
-                ErrorF("winClipboardFlushXEvents - SelectionRequest - "
-                       "GetClipboardData () failed: %08x\n", (unsigned int)GetLastError());
+                if (GetLastError()==ERROR_CLIPBOARD_NOT_OPEN && g_fClipboardStarted)
+                {
+                    ErrorF("We should not have received a SelectionRequest????\n"
+                            "The owner is the clipboard, but in reality it was"
+                            "an X window\n");
+                    /* Set the owner to None */
+                    if (fPrimarySelection) xcb_set_selection_owner_checked(conn, None, XCB_ATOM_PRIMARY, XCB_CURRENT_TIME);
+                    xcb_set_selection_owner_checked(conn, None, atoms->atomClipboard, XCB_CURRENT_TIME);
+                }
+                ErrorF ("winClipboardFlushXEvents - SelectionRequest - "
+                        "GetClipboardData () failed: %08x\n", (unsigned int)GetLastError());
 
                 /* Abort */
                 fAbort = TRUE;
@@ -680,13 +703,17 @@ winClipboardFlushXEvents(HWND hwnd,
         case XCB_SELECTION_NOTIFY:
         {
             xcb_selection_notify_event_t *selection_notify =  (xcb_selection_notify_event_t *)event;
+#ifdef _DEBUG
             winDebug("winClipboardFlushXEvents - SelectionNotify\n");
+            if (g_iLogVerbose >= 3)
             {
                 char *pszAtomName;
                 pszAtomName = get_atom_name(conn, selection_notify->selection);
                 winDebug("winClipboardFlushXEvents - SelectionNotify - ATOM: %s\n", pszAtomName);
                 free(pszAtomName);
             }
+#endif
+
 
             /*
               SelectionNotify with property of XCB_NONE indicates either:
@@ -775,10 +802,8 @@ winClipboardFlushXEvents(HWND hwnd,
                     break;
                 }
 
-                /* Close clipboard if we have it open already (possible? correct??) */
-                if (GetOpenClipboardWindow() == hwnd) {
-                    CloseClipboard();
-                }
+                /* Close clipboard in case we already have it open */
+                CloseClipboard();
 
                 /* Access the Windows clipboard */
                 if (!OpenClipboard(hwnd)) {
@@ -791,6 +816,7 @@ winClipboardFlushXEvents(HWND hwnd,
                 if (!EmptyClipboard()) {
                     ErrorF("winClipboardFlushXEvents - EmptyClipboard () failed: %08x\n",
                            (int) GetLastError());
+                    CloseClipboard();
                     break;
                 }
 
diff --git a/xserver/hw/xwin/winclipboardinit.c b/vcxsrv-code/xorg-server/hw/xwin/winclipboardinit.c
index dbce0bc..2593330 100644
--- a/xserver/hw/xwin/winclipboardinit.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboardinit.c
@@ -47,7 +47,7 @@
  * Local variables
  */
 
-static pthread_t g_ptClipboardProc;
+int winProcSetSelectionOwner(ClientPtr /* client */ );
 
 /*
  *
@@ -78,9 +78,6 @@ winClipboardThreadProc(void *arg)
       /* Print the display connection string */
       ErrorF("winClipboardThreadProc - DISPLAY=%s\n", szDisplay);
 
-      /* Flag that clipboard client has been launched */
-      g_fClipboardStarted = TRUE;
-
       /* Use our generated cookie for authentication */
       auth_info = winGetXcbAuthInfo();
 
@@ -129,16 +126,21 @@ winInitClipboard(void)
 void
 winClipboardShutdown(void)
 {
-  /* Close down clipboard resources */
-  if (g_fClipboard && g_fClipboardStarted) {
-    /* Synchronously destroy the clipboard window */
-    winClipboardWindowDestroy();
-
-    /* Wait for the clipboard thread to exit */
-    pthread_join(g_ptClipboardProc, NULL);
-
-    g_fClipboardStarted = FALSE;
-
-    winDebug("winClipboardShutdown - Clipboard thread has exited.\n");
-  }
+    /* Close down clipboard resources */
+    if (g_fClipboard && g_fClipboardLaunched && g_fClipboardStarted) {
+        /* Synchronously destroy the clipboard window */
+        if (g_hwndClipboard != NULL) {
+            g_fClipboardStarted=FALSE; /* This is to avoid dead-locls caused by the clipboard thread still doing some stuff */
+            SendMessage(g_hwndClipboard, WM_DESTROY, 0, 0);
+            /* NOTE: g_hwndClipboard is set to NULL in winclipboardthread.c */
+        }
+        else
+            return;
+
+        /* Wait for the clipboard thread to exit */
+        pthread_join(g_ptClipboardProc, NULL);
+
+        winDebug("winClipboardShutdown - Clipboard thread has exited.\n");
+    }
 }
+
diff --git a/xserver/hw/xwin/winclipboardwrappers.c b/vcxsrv-code/xorg-server/hw/xwin/winclipboardwrappers.c
index 2e6b632..cf0d5f9 100644
--- a/xserver/hw/xwin/winclipboardwrappers.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winclipboardwrappers.c
@@ -36,12 +36,28 @@
 
 #include "win.h"
 #include "dixstruct.h"
+#include <X11/Xatom.h>
+
+/*
+ * Constants
+ */
+
+#define CLIP_NUM_SELECTIONS		2
+#define CLIP_OWN_PRIMARY		0
+#define CLIP_OWN_CLIPBOARD		1
 
 /*
  * Local function prototypes
  */
 
 DISPATCH_PROC(winProcEstablishConnection);
+DISPATCH_PROC(winProcSetSelectionOwner);
+
+extern Bool g_fClipboardLaunched;
+extern Bool g_fClipboardStarted;
+extern Window g_iClipboardWindow;
+extern Atom g_atomLastOwnedSelection;
+extern HWND g_hwndClipboard;
 
 /*
  * Wrapper for internal EstablishConnection function.
@@ -56,12 +72,14 @@ winProcEstablishConnection(ClientPtr client)
     static int s_iCallCount = 0;
     static unsigned long s_ulServerGeneration = 0;
 
+  #ifdef WINDBG
     if (s_iCallCount == 0)
         winDebug("winProcEstablishConnection - Hello\n");
+  #endif
 
     /* Do nothing if clipboard is not enabled */
     if (!g_fClipboard) {
-        ErrorF("winProcEstablishConnection - Clipboard is not enabled, "
+      winDebug ("winProcEstablishConnection - Clipboard is not enabled, "
                "returning.\n");
 
         /* Unwrap the original function, call it, and return */
@@ -106,6 +124,13 @@ winProcEstablishConnection(ClientPtr client)
     /* Clear original function pointer */
     winProcEstablishConnectionOrig = NULL;
 
+    /* If the clipboard client has already been started, abort */
+    if (g_fClipboardLaunched) {
+        winDebug ("winProcEstablishConnection - Clipboard client already "
+               "launched, returning.\n");
+        return iReturn;
+    }
+
     /* Startup the clipboard client if clipboard mode is being used */
     if (g_fClipboard) {
         /*
@@ -132,8 +157,11 @@ winProcEstablishConnection(ClientPtr client)
             return iReturn;
         }
 
-        ErrorF("winProcEstablishConnection - winInitClipboard returned.\n");
+        winDebug ("winProcEstablishConnection - winInitClipboard returned.\n");
     }
 
+    /* Flag that clipboard client has been launched */
+    g_fClipboardLaunched = TRUE;
+
     return iReturn;
 }
diff --git a/xserver/hw/xwin/wincmap.c b/vcxsrv-code/xorg-server/hw/xwin/wincmap.c
index 000334c..23d5a13 100644
--- a/xserver/hw/xwin/wincmap.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/wincmap.c
@@ -116,16 +116,12 @@ winInstallColormap(ColormapPtr pColormap)
     winScreenPriv(pScreen);
     ColormapPtr oldpmap = pScreenPriv->pcmapInstalled;
 
-#if CYGDEBUG
     winDebug("winInstallColormap\n");
-#endif
 
     /* Did the colormap actually change? */
     if (pColormap != oldpmap) {
-#if CYGDEBUG
         winDebug("winInstallColormap - Colormap has changed, attempt "
                  "to install.\n");
-#endif
 
         /* Was there a previous colormap? */
         if (oldpmap != (ColormapPtr) None) {
@@ -139,10 +135,9 @@ winInstallColormap(ColormapPtr pColormap)
 
         /* Call the engine specific colormap install procedure */
         if (!((*pScreenPriv->pwinInstallColormap) (pColormap))) {
-            winErrorFVerb(2,
-                          "winInstallColormap - Screen specific colormap install "
-                          "procedure failed.  Continuing, but colors may be "
-                          "messed up from now on.\n");
+            ErrorF ("winInstallColormap - Screen specific colormap install "
+                    "procedure failed.  Continuing, but colors may be "
+                    "messed up from now on.\n");
         }
     }
 
@@ -157,9 +152,7 @@ winUninstallColormap(ColormapPtr pmap)
     winScreenPriv(pmap->pScreen);
     ColormapPtr curpmap = pScreenPriv->pcmapInstalled;
 
-#if CYGDEBUG
     winDebug("winUninstallColormap\n");
-#endif
 
     /* Is the colormap currently installed? */
     if (pmap != curpmap) {
@@ -194,7 +187,7 @@ winStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
     int i;
     unsigned short nRed, nGreen, nBlue;
 
-#if CYGDEBUG
+#ifdef WINDBG
     if (ndef != 1)
         winDebug("winStoreColors - ndef: %d\n", ndef);
 #endif
@@ -216,18 +209,15 @@ winStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
         pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbGreen = nGreen;
         pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbBlue = nBlue;
 
-#if CYGDEBUG
         winDebug("winStoreColors - nRed %d nGreen %d nBlue %d\n",
                  nRed, nGreen, nBlue);
-#endif
     }
 
     /* Call the engine specific store colors procedure */
     if (!((pScreenPriv->pwinStoreColors) (pmap, ndef, pdefs))) {
-        winErrorFVerb(2,
-                      "winStoreColors - Engine cpecific color storage procedure "
-                      "failed.  Continuing, but colors may be messed up from now "
-                      "on.\n");
+        ErrorF ("winStoreColors - Engine cpecific color storage procedure "
+                "failed.  Continuing, but colors may be messed up from now "
+                "on.\n");
     }
 }
 
@@ -237,9 +227,7 @@ winResolveColor(unsigned short *pred,
                 unsigned short *pgreen,
                 unsigned short *pblue, VisualPtr pVisual)
 {
-#if CYGDEBUG
     winDebug("winResolveColor ()\n");
-#endif
 
     miResolveColor(pred, pgreen, pblue, pVisual);
 }
@@ -253,9 +241,7 @@ winCreateColormap(ColormapPtr pmap)
 
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
     winDebug("winCreateColormap\n");
-#endif
 
     /* Allocate colormap privates */
     if (!winAllocateCmapPrivates(pmap)) {
@@ -301,19 +287,16 @@ winDestroyColormap(ColormapPtr pColormap)
 
     /* Call the engine specific colormap destruction procedure */
     if (!((*pScreenPriv->pwinDestroyColormap) (pColormap))) {
-        winErrorFVerb(2,
-                      "winDestroyColormap - Engine specific colormap destruction "
-                      "procedure failed.  Continuing, but it is possible that memory "
-                      "was leaked, or that colors will be messed up from now on.\n");
+        ErrorF ("winDestroyColormap - Engine specific colormap destruction "
+                "procedure failed.  Continuing, but it is possible that memory "
+                "was leaked, or that colors will be messed up from now on.\n");
     }
 
     /* Free the colormap privates */
     free(pCmapPriv);
     winSetCmapPriv(pColormap, NULL);
 
-#if CYGDEBUG
     winDebug("winDestroyColormap - Returning\n");
-#endif
 }
 
 /*
@@ -338,10 +321,8 @@ winGetPaletteDIB(ScreenPtr pScreen, ColormapPtr pcmap)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winGetPaletteDIB - Retrieved %d colors from DIB\n",
              uiColorsRetrieved);
-#endif
 
     /* Set the DIB color table to the default screen palette */
     if (SetDIBColorTable(pScreenPriv->hdcShadow,
@@ -359,10 +340,8 @@ winGetPaletteDIB(ScreenPtr pScreen, ColormapPtr pcmap)
         nGreen = rgbColors[i].rgbGreen << 8;
         nBlue = rgbColors[i].rgbBlue << 8;
 
-#if CYGDEBUG
         winDebug("winGetPaletteDIB - Allocating a color: %u; "
                  "%d %d %d\n", (unsigned int)pixel, nRed, nGreen, nBlue);
-#endif
 
         /* Allocate a entry in the X colormap */
         if (AllocColor(pcmap, &nRed, &nGreen, &nBlue, &pixel, 0) != Success) {
@@ -421,10 +400,8 @@ winGetPaletteDD(ScreenPtr pScreen, ColormapPtr pcmap)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winGetPaletteDD - uiSystemPaletteEntries %d\n",
              uiSystemPaletteEntries);
-#endif
 
     /* Allocate palette entries structure */
     ppeColors = malloc(uiSystemPaletteEntries * sizeof(PALETTEENTRY));
@@ -444,10 +421,8 @@ winGetPaletteDD(ScreenPtr pScreen, ColormapPtr pcmap)
         nRed = ppeColors[i].peRed << 8;
         nGreen = ppeColors[i].peGreen << 8;
         nBlue = ppeColors[i].peBlue << 8;
-#if CYGDEBUG
         winDebug("winGetPaletteDD - Allocating a color: %u; "
                  "%d %d %d\n", (unsigned int)pixel, nRed, nGreen, nBlue);
-#endif
         if (AllocColor(pcmap, &nRed, &nGreen, &nBlue, &pixel, 0) != Success) {
             ErrorF("winGetPaletteDD - AllocColor () failed, pixel %d\n", i);
             free(ppeColors);
@@ -493,9 +468,7 @@ winCreateDefColormap(ScreenPtr pScreen)
     ColormapPtr pcmap = NULL;
     Pixel wp, bp;
 
-#if CYGDEBUG
     winDebug("winCreateDefColormap\n");
-#endif
 
     /* Use standard fb colormaps for non palettized color modes */
     if (pScreenInfo->dwBPP > 8) {
@@ -514,9 +487,7 @@ winCreateDefColormap(ScreenPtr pScreen)
      * to be changed by clients.
      */
 
-#if CYGDEBUG
     winDebug("winCreateDefColormap - defColormap: %lu\n", pScreen->defColormap);
-#endif
 
     /* Allocate an X colormap, owned by client 0 */
     if (CreateColormap(pScreen->defColormap,
@@ -533,9 +504,7 @@ winCreateDefColormap(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winCreateDefColormap - Created a colormap\n");
-#endif
 
     /* Branch on the visual class */
     if (!(pVisual->class & DynamicClass)) {
@@ -570,33 +539,12 @@ winCreateDefColormap(ScreenPtr pScreen)
         pScreen->whitePixel = wp;
         pScreen->blackPixel = bp;
 
-#if 0
-        /* Have to reserve first 10 and last ten pixels in DirectDraw windowed */
-        if (pScreenInfo->dwEngine != WIN_SERVER_SHADOW_GDI) {
-            int k;
-            Pixel p;
-
-            for (k = 1; k < 10; ++k) {
-                p = k;
-                if (AllocColor(pcmap, &ones, &ones, &ones, &p, 0) != Success)
-                    FatalError("Foo!\n");
-            }
-
-            for (k = 245; k < 255; ++k) {
-                p = k;
-                if (AllocColor(pcmap, &zero, &zero, &zero, &p, 0) != Success)
-                    FatalError("Baz!\n");
-            }
-        }
-#endif
     }
 
     /* Install the created colormap */
     (*pScreen->InstallColormap) (pcmap);
 
-#if CYGDEBUG
     winDebug("winCreateDefColormap - Returning\n");
-#endif
 
     return TRUE;
 }
diff --git a/xserver/hw/xwin/winconfig.c b/vcxsrv-code/xorg-server/hw/xwin/winconfig.c
index 4f16b21..3c992d6 100644
--- a/xserver/hw/xwin/winconfig.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winconfig.c
@@ -140,19 +140,19 @@ winReadConfigfile()
         filename = xf86openConfigFile(CONFIGPATH, "XF86Config", PROJECTROOT);
 
     if (filename) {
-        winMsg(from, "Using config file: \"%s\"\n", filename);
+        winDebug ("Using config file: \"%s\"\n", filename);
     }
     else {
-        winMsg(X_ERROR, "Unable to locate/open config file");
+        ErrorF ("Unable to locate/open config file");
         if (xf86ConfigFile)
             ErrorF(": \"%s\"", xf86ConfigFile);
         ErrorF("\n");
     }
     if (dirname) {
-        winMsg(from, "Using config directory: \"%s\"\n", dirname);
+        winDebug("Using config directory: \"%s\"\n", dirname);
     }
     else {
-        winMsg(X_ERROR, "Unable to locate/open config directory");
+        winDebug("Unable to locate/open config directory");
         if (xf86ConfigDir)
             ErrorF(": \"%s\"", xf86ConfigDir);
         ErrorF("\n");
@@ -163,7 +163,7 @@ winReadConfigfile()
     free(filename);
     free(dirname);
     if ((g_xf86configptr = xf86readConfigFile()) == NULL) {
-        winMsg(X_ERROR, "Problem parsing the config file\n");
+        ErrorF ("Problem parsing the config file\n");
         return FALSE;
     }
     xf86closeConfigFile();
@@ -175,12 +175,11 @@ winReadConfigfile()
     if (g_xf86configptr->conf_layout_lst == NULL ||
         g_cmdline.screenname != NULL) {
         if (g_cmdline.screenname == NULL) {
-            winMsg(X_WARNING,
-                   "No Layout section. Using the first Screen section.\n");
+            winDebug ("No Layout section. Using the first Screen section.\n");
         }
         if (!configImpliedLayout(&g_winConfigLayout,
                                  g_xf86configptr->conf_screen_lst)) {
-            winMsg(X_ERROR, "Unable to determine the screen layout\n");
+            ErrorF ("Unable to determine the screen layout\n");
             return FALSE;
         }
     }
@@ -196,14 +195,14 @@ winReadConfigfile()
 
             if (!configLayout(&g_winConfigLayout,
                               g_xf86configptr->conf_layout_lst, dfltlayout)) {
-                winMsg(X_ERROR, "Unable to determine the screen layout\n");
+                ErrorF ("Unable to determine the screen layout\n");
                 return FALSE;
             }
         }
         else {
             if (!configLayout(&g_winConfigLayout,
                               g_xf86configptr->conf_layout_lst, NULL)) {
-                winMsg(X_ERROR, "Unable to determine the screen layout\n");
+                ErrorF ("Unable to determine the screen layout\n");
                 return FALSE;
             }
         }
@@ -264,7 +263,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
                 break;
             }
             g_winInfo.keyboard.rate = (kbd_speed > 0) ? kbd_speed : 1;
-            winMsg(X_PROBED, "Setting autorepeat to delay=%ld, rate=%ld\n",
+            winDebug("Setting autorepeat to delay=%ld, rate=%ld\n",
                    g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
 
         }
@@ -283,9 +282,9 @@ winConfigKeyboard(DeviceIntPtr pDevice)
                    such as the lack of WM_KEYUP for Caps Lock key.
                    Loading US layout fixes this problem. */
                 if (LoadKeyboardLayout("00000409", KLF_ACTIVATE) != NULL)
-                    winMsg(X_INFO, "Loading US keyboard layout.\n");
+                    winDebug("Loading US keyboard layout.\n");
                 else
-                    winMsg(X_ERROR, "LoadKeyboardLayout failed.\n");
+                    ErrorF ("LoadKeyboardLayout failed.\n");
             }
         }
 
@@ -311,9 +310,8 @@ winConfigKeyboard(DeviceIntPtr pDevice)
             free(regpath);
         }
 
-        winMsg(X_PROBED,
-               "Windows keyboard layout: \"%s\" (%08x) \"%s\", type %d\n",
-               layoutName, layoutNum, layoutFriendlyName, keyboardType);
+        winDebug ("Windows keyboard layout: \"%s\" (%08x) \"%s\", type %d\n",
+                  layoutName, layoutNum, layoutFriendlyName, keyboardType);
 
         deviceIdentifier = layoutNum >> 16;
         for (pass = 0; pass < 2; pass++) {
@@ -329,11 +327,11 @@ winConfigKeyboard(DeviceIntPtr pDevice)
                     continue;
 
                 bfound = TRUE;
-                winMsg(X_PROBED,
+                winDebug (
                        "Found matching XKB configuration \"%s\"\n",
                        pLayout->layoutname);
 
-                winMsg(X_PROBED,
+                winDebug(
                        "Model = \"%s\" Layout = \"%s\""
                        " Variant = \"%s\" Options = \"%s\"\n",
                        pLayout->xkbmodel ? pLayout->xkbmodel : "none",
@@ -341,13 +339,13 @@ winConfigKeyboard(DeviceIntPtr pDevice)
                        pLayout->xkbvariant ? pLayout->xkbvariant : "none",
                        pLayout->xkboptions ? pLayout->xkboptions : "none");
 
-                g_winInfo.xkb.model = pLayout->xkbmodel;
-                g_winInfo.xkb.layout = pLayout->xkblayout;
-                g_winInfo.xkb.variant = pLayout->xkbvariant;
-                g_winInfo.xkb.options = pLayout->xkboptions;
+                g_winInfo.xkb.model = (char *)pLayout->xkbmodel;
+                g_winInfo.xkb.layout = (char *)pLayout->xkblayout;
+                g_winInfo.xkb.variant = (char *)pLayout->xkbvariant;
+                g_winInfo.xkb.options = (char *)pLayout->xkboptions;
 
                 if (deviceIdentifier == 0xa000) {
-                    winMsg(X_PROBED, "Windows keyboard layout device identifier indicates Macintosh, setting Model = \"macintosh\"");
+                    winDebug("Windows keyboard layout device identifier indicates Macintosh, setting Model = \"macintosh\"");
                     g_winInfo.xkb.model = "macintosh";
                 }
 
@@ -359,8 +357,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
         }
 
         if (!bfound) {
-            winMsg(X_ERROR,
-                   "Keyboardlayout \"%s\" (%s) is unknown, using X server default layout\n",
+            ErrorF ("Keyboardlayout \"%s\" (%s) is unknown, using X server default layout\n",
                    layoutFriendlyName, layoutName);
         }
     }
@@ -392,8 +389,8 @@ winConfigKeyboard(DeviceIntPtr pDevice)
     if (kbd != NULL) {
 
         if (kbd->inp_identifier)
-            winMsg(kbdfrom, "Using keyboard \"%s\" as primary keyboard\n",
-                   kbd->inp_identifier);
+            winDebug ("Using keyboard \"%s\" as primary keyboard\n",
+                      kbd->inp_identifier);
 
         if ((s = winSetStrOption(kbd->inp_option_lst, "AutoRepeat", NULL))) {
             if ((sscanf(s, "%ld %ld", &g_winInfo.keyboard.delay,
@@ -401,12 +398,12 @@ winConfigKeyboard(DeviceIntPtr pDevice)
                 (g_winInfo.keyboard.delay < 1) ||
                 (g_winInfo.keyboard.rate == 0) ||
                 (1000 / g_winInfo.keyboard.rate) < 1) {
-                winErrorFVerb(2, "\"%s\" is not a valid AutoRepeat value", s);
+                ErrorF ("\"%s\" is not a valid AutoRepeat value", s);
                 free(s);
                 return FALSE;
             }
             free(s);
-            winMsg(X_CONFIG, "AutoRepeat: %ld %ld\n",
+            winDebug ("AutoRepeat: %ld %ld\n", 
                    g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
         }
 #endif
@@ -424,7 +421,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
 #endif
         if (s) {
             g_winInfo.xkb.rules = NULL_IF_EMPTY(s);
-            winMsg(from, "XKB: rules: \"%s\"\n", s);
+            winDebug ("XKB: rules: \"%s\"\n", s);
         }
 
         s = NULL;
@@ -440,7 +437,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
 #endif
         if (s) {
             g_winInfo.xkb.model = NULL_IF_EMPTY(s);
-            winMsg(from, "XKB: model: \"%s\"\n", s);
+            winDebug ("XKB: model: \"%s\"\n", s);
         }
 
         s = NULL;
@@ -456,7 +453,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
 #endif
         if (s) {
             g_winInfo.xkb.layout = NULL_IF_EMPTY(s);
-            winMsg(from, "XKB: layout: \"%s\"\n", s);
+            winDebug ("XKB: layout: \"%s\"\n", s);
         }
 
         s = NULL;
@@ -472,7 +469,7 @@ winConfigKeyboard(DeviceIntPtr pDevice)
 #endif
         if (s) {
             g_winInfo.xkb.variant = NULL_IF_EMPTY(s);
-            winMsg(from, "XKB: variant: \"%s\"\n", s);
+            winDebug ("XKB: variant: \"%s\"\n", s);
         }
 
         s = NULL;
@@ -485,10 +482,16 @@ winConfigKeyboard(DeviceIntPtr pDevice)
             s = winSetStrOption(kbd->inp_option_lst, "XkbOptions", NULL);
             from = X_CONFIG;
         }
+#else
+        else
+          {
+            if (!g_winInfo.xkb.options)
+              s="grab:break_actions";  /* Currently attach default CTRL+ALT+NKP/ and CTRL+ALT+NKP* mappings to release grab functions */
+          }
 #endif
         if (s) {
             g_winInfo.xkb.options = NULL_IF_EMPTY(s);
-            winMsg(from, "XKB: options: \"%s\"\n", s);
+            winDebug ("XKB: options: \"%s\"\n", s);
         }
 
 #ifdef XWIN_XF86CONFIG
@@ -526,8 +529,8 @@ winConfigMouse(DeviceIntPtr pDevice)
 
     if (mouse != NULL) {
         if (mouse->inp_identifier)
-            winMsg(mousefrom, "Using pointer \"%s\" as primary pointer\n",
-                   mouse->inp_identifier);
+            winDebug ("Using pointer \"%s\" as primary pointer\n",
+                      mouse->inp_identifier);
 
         g_winInfo.pointer.emulate3Buttons =
             winSetBoolOption(mouse->inp_option_lst, "Emulate3Buttons", FALSE);
@@ -540,8 +543,8 @@ winConfigMouse(DeviceIntPtr pDevice)
             g_winInfo.pointer.emulate3Timeout = g_cmdline.emulate3timeout;
     }
     else {
-        winMsg(X_ERROR, "No primary pointer configured\n");
-        winMsg(X_DEFAULT, "Using compiletime defaults for pointer\n");
+      winDebug ("No primary pointer configured\n");
+      winDebug ("Using compiletime defaults for pointer\n");
     }
 
     return TRUE;
@@ -569,7 +572,7 @@ winConfigFiles()
         from = X_CONFIG;
         defaultFontPath = strdup(filesptr->file_fontpath);
     }
-    winMsg(from, "FontPath set to \"%s\"\n", defaultFontPath);
+    winDebug ("FontPath set to \"%s\"\n", defaultFontPath);
 
     return TRUE;
 }
@@ -580,7 +583,7 @@ winConfigFiles(void)
     /* Fontpath */
     if (g_cmdline.fontPath) {
         defaultFontPath = g_cmdline.fontPath;
-        winMsg(X_CMDLINE, "FontPath set to \"%s\"\n", defaultFontPath);
+        winDebug("FontPath set to \"%s\"\n", defaultFontPath);
     }
 
     return TRUE;
@@ -755,8 +758,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
         switch (p->type) {
         case OPTV_INTEGER:
             if (*s == '\0') {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires an integer value\n", p->name);
+	      winDebug ( "Option \"%s\" requires an integer value\n",
                 p->found = FALSE;
             }
             else {
@@ -765,8 +767,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                     p->found = TRUE;
                 }
                 else {
-                    winDrvMsg(scrnIndex, X_WARNING,
-                              "Option \"%s\" requires an integer value\n",
+                    winDebug ( "Option \"%s\" requires an integer value\n",
                               p->name);
                     p->found = FALSE;
                 }
@@ -774,8 +775,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
             break;
         case OPTV_STRING:
             if (*s == '\0') {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires a string value\n", p->name);
+                winDebug ( "Option \"%s\" requires a string value\n", p->name);
                 p->found = FALSE;
             }
             else {
@@ -789,8 +789,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
             break;
         case OPTV_REAL:
             if (*s == '\0') {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires a floating point value\n",
+                winDebug ( "Option \"%s\" requires a floating point value\n",
                           p->name);
                 p->found = FALSE;
             }
@@ -800,8 +799,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                     p->found = TRUE;
                 }
                 else {
-                    winDrvMsg(scrnIndex, X_WARNING,
-                              "Option \"%s\" requires a floating point value\n",
+                    winDebug ( "Option \"%s\" requires a floating point value\n",
                               p->name);
                     p->found = FALSE;
                 }
@@ -812,8 +810,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                 p->found = TRUE;
             }
             else {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires a boolean value\n", p->name);
+                winDebug ( "Option \"%s\" requires a boolean value\n", p->name);
                 p->found = FALSE;
             }
             break;
@@ -839,8 +836,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
             }
         case OPTV_FREQ:
             if (*s == '\0') {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires a frequency value\n",
+                winDebug ( "Option \"%s\" requires a frequency value\n",
                           p->name);
                 p->found = FALSE;
             }
@@ -859,8 +855,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                              !winNameCompare(end, "M"))
                         units = 1000000;
                     else {
-                        winDrvMsg(scrnIndex, X_WARNING,
-                                  "Option \"%s\" requires a frequency value\n",
+                        winDebug ( "Option \"%s\" requires a frequency value\n",
                                   p->name);
                         p->found = FALSE;
                     }
@@ -868,8 +863,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                         freq *= (double) units;
                 }
                 else {
-                    winDrvMsg(scrnIndex, X_WARNING,
-                              "Option \"%s\" requires a frequency value\n",
+                    winDebug ( "Option \"%s\" requires a frequency value\n",
                               p->name);
                     p->found = FALSE;
                 }
@@ -885,11 +879,11 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
             break;
         }
         if (p->found) {
-            winDrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", p->name);
+            winDebug ("Option \"%s\"", p->name);
             if (!(p->type == OPTV_BOOLEAN && *s == 0)) {
-                winErrorFVerb(2, " \"%s\"", s);
+                winDebug (" \"%s\"", s);
             }
-            winErrorFVerb(2, "\n");
+            winDebug ("\n");
         }
     }
     else if (p->type == OPTV_BOOLEAN) {
@@ -922,8 +916,7 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
                 p->found = TRUE;
             }
             else {
-                winDrvMsg(scrnIndex, X_WARNING,
-                          "Option \"%s\" requires a boolean value\n", newn);
+	              winDebug ( "Option \"%s\" requires a boolean value\n", newn);
                 p->found = FALSE;
             }
         }
@@ -931,11 +924,11 @@ ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
             p->found = FALSE;
         }
         if (p->found) {
-            winDrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", newn);
+            winDebug ("Option \"%s\"", newn);
             if (*s != 0) {
-                winErrorFVerb(2, " \"%s\"", s);
+                winDebug (" \"%s\"", s);
             }
-            winErrorFVerb(2, "\n");
+            winDebug ("\n");
         }
         free(n);
     }
diff --git a/xserver/hw/xwin/wincreatewnd.c b/vcxsrv-code/xorg-server/hw/xwin/wincreatewnd.c
index 444e843..34d4a17 100644
--- a/xserver/hw/xwin/wincreatewnd.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/wincreatewnd.c
@@ -60,21 +60,21 @@ winCreateBoundingWindowFullScreen(ScreenPtr pScreen)
     HWND *phwnd = &pScreenPriv->hwndScreen;
     WNDCLASSEX wc;
     char szTitle[256];
+    char			HostName[256];
+    gethostname(HostName,256);
 
-#if CYGDEBUG
     winDebug("winCreateBoundingWindowFullScreen\n");
-#endif
 
     /* Setup our window class */
     wc.cbSize = sizeof(WNDCLASSEX);
     wc.style = CS_HREDRAW | CS_VREDRAW;
     wc.lpfnWndProc = winWindowProc;
     wc.cbClsExtra = 0;
-    wc.cbWndExtra = 0;
+    wc.cbWndExtra = WND_EXTRABYTES;
     wc.hInstance = g_hInstance;
     wc.hIcon = pScreenInfo->hIcon;
     wc.hCursor = 0;
-    wc.hbrBackground = 0;
+    wc.hbrBackground = NULL;
     wc.lpszMenuName = NULL;
     wc.lpszClassName = WINDOW_CLASS;
     wc.hIconSm = pScreenInfo->hIconSm;
@@ -85,12 +85,13 @@ winCreateBoundingWindowFullScreen(ScreenPtr pScreen)
         snprintf(szTitle,
                  sizeof(szTitle),
                  WINDOW_TITLE_XDMCP,
-                 g_pszQueryHost, display, (int) pScreenInfo->dwScreen);
+                 g_pszQueryHost, HostName, display, (int) pScreenInfo->dwScreen);
     else
+    {
         snprintf(szTitle,
                  sizeof(szTitle),
-                 WINDOW_TITLE, display, (int) pScreenInfo->dwScreen);
-
+                 WINDOW_TITLE, HostName, display, (int) pScreenInfo->dwScreen);
+    }
     /* Create the window */
     *phwnd = CreateWindowExA(0, /* Extended styles */
                              WINDOW_CLASS,      /* Class name */
@@ -101,7 +102,7 @@ winCreateBoundingWindowFullScreen(ScreenPtr pScreen)
                              iHeight,   /* Bottom edge */
                              (HWND) NULL,       /* No parent or owner window */
                              (HMENU) NULL,      /* No menu */
-                             GetModuleHandle(NULL),     /* Instance handle */
+                             g_hInstance,     /* Instance handle */
                              pScreenPriv);      /* ScreenPrivates */
 
     /* Hide the window */
@@ -135,6 +136,9 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
     DWORD dwWindowStyle;
     BOOL fForceShowWindow = FALSE;
     char szTitle[256];
+    char			HostName[256];
+
+    gethostname(HostName,256);
 
     winDebug("winCreateBoundingWindowWindowed - User w: %d h: %d\n",
              (int) pScreenInfo->dwUserWidth, (int) pScreenInfo->dwUserHeight);
@@ -171,11 +175,11 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
     wc.style = CS_HREDRAW | CS_VREDRAW;
     wc.lpfnWndProc = winWindowProc;
     wc.cbClsExtra = 0;
-    wc.cbWndExtra = 0;
+    wc.cbWndExtra = WND_EXTRABYTES;
     wc.hInstance = g_hInstance;
     wc.hIcon = pScreenInfo->hIcon;
     wc.hCursor = 0;
-    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
+    wc.hbrBackground = NULL;
     wc.lpszMenuName = NULL;
     wc.lpszClassName = WINDOW_CLASS;
     wc.hIconSm = pScreenInfo->hIconSm;
@@ -210,37 +214,29 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
     /* Did the user specify a height and width? */
     if (pScreenInfo->fUserGaveHeightAndWidth) {
         /* User gave a desired height and width, try to accommodate */
-#if CYGDEBUG
         winDebug("winCreateBoundingWindowWindowed - User gave height "
                  "and width\n");
-#endif
 
         /* Adjust the window width and height for borders and title bar */
         if (pScreenInfo->fDecoration
             && !pScreenInfo->fRootless
             && !pScreenInfo->fMultiWindow
             ) {
-#if CYGDEBUG
             winDebug
                 ("winCreateBoundingWindowWindowed - Window has decoration\n");
-#endif
 
             /* Are we resizable */
             if (pScreenInfo->iResizeMode != resizeNotAllowed) {
-#if CYGDEBUG
                 winDebug
                     ("winCreateBoundingWindowWindowed - Window is resizable\n");
-#endif
 
                 iWidth += 2 * GetSystemMetrics(SM_CXSIZEFRAME);
                 iHeight += 2 * GetSystemMetrics(SM_CYSIZEFRAME)
                     + GetSystemMetrics(SM_CYCAPTION);
             }
             else {
-#if CYGDEBUG
                 winDebug
                     ("winCreateBoundingWindowWindowed - Window is not resizable\n");
-#endif
 
                 iWidth += 2 * GetSystemMetrics(SM_CXFIXEDFRAME);
                 iHeight += 2 * GetSystemMetrics(SM_CYFIXEDFRAME)
@@ -250,10 +246,8 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
     }
     else {
         /* By default, we are creating a window that is as large as possible */
-#if CYGDEBUG
         winDebug("winCreateBoundingWindowWindowed - User did not give "
                  "height and width\n");
-#endif
         /* Defaults are wrong if we have multiple monitors */
         if (pScreenInfo->fMultipleMonitors) {
             iWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
@@ -273,10 +267,8 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
         if (iHeight >= (rcWorkArea.bottom - rcWorkArea.top))
             iHeight = rcWorkArea.bottom - rcWorkArea.top;
 
-#if CYGDEBUG
         winDebug("winCreateBoundingWindowWindowed - Adjusted width: %d "
                  "height: %d\n", iWidth, iHeight);
-#endif
     }
 
     /* Set display and screen-specific tooltip text */
@@ -284,11 +276,13 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
         snprintf(szTitle,
                  sizeof(szTitle),
                  WINDOW_TITLE_XDMCP,
-                 g_pszQueryHost, display, (int) pScreenInfo->dwScreen);
+                 g_pszQueryHost, HostName, display, (int) pScreenInfo->dwScreen);
     else
+  {
         snprintf(szTitle,
                  sizeof(szTitle),
-                 WINDOW_TITLE, display, (int) pScreenInfo->dwScreen);
+                 WINDOW_TITLE, HostName, display, (int) pScreenInfo->dwScreen);
+  }
 
     /* Create the window */
     *phwnd = CreateWindowExA(0, /* Extended styles */
@@ -300,16 +294,14 @@ winCreateBoundingWindowWindowed(ScreenPtr pScreen)
                              iHeight,   /* Bottom edge */
                              (HWND) NULL,       /* No parent or owner window */
                              (HMENU) NULL,      /* No menu */
-                             GetModuleHandle(NULL),     /* Instance handle */
+                             g_hInstance,     /* Instance handle */
                              pScreenPriv);      /* ScreenPrivates */
     if (*phwnd == NULL) {
         ErrorF("winCreateBoundingWindowWindowed - CreateWindowEx () failed\n");
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winCreateBoundingWindowWindowed - CreateWindowEx () returned\n");
-#endif
 
     if (fForceShowWindow) {
         ErrorF
diff --git a/xserver/hw/xwin/wincursor.c b/vcxsrv-code/xorg-server/hw/xwin/wincursor.c
index 3fc050b..6faee6a 100644
--- a/xserver/hw/xwin/wincursor.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/wincursor.c
@@ -43,10 +43,9 @@
 
 #define BRIGHTNESS(x) (x##Red * 0.299 + x##Green * 0.587 + x##Blue * 0.114)
 
-#if 0
-#define WIN_DEBUG_MSG winDebug
-#else
-#define WIN_DEBUG_MSG(...)
+#ifdef _MSC_VER
+#define min(a,b) (((a) < (b)) ? (a) : (b))
+#define max(a,b) (((a) > (b)) ? (a) : (b))
 #endif
 
 /*
@@ -82,7 +81,7 @@ winPointerWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
         /* Don't ignore subsequent warps */
         s_fInitialWarp = FALSE;
 
-        winErrorFVerb(2,
+        winDebug (
                       "winPointerWarpCursor - Discarding first warp: %d %d\n",
                       x, y);
 
@@ -162,7 +161,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
     BITMAPINFO *pbmi;
     uint32_t *lpBits;
 
-    WIN_DEBUG_MSG("winLoadCursor: Win32: %dx%d X11: %dx%d hotspot: %d,%d\n",
+    winDebug("winLoadCursor: Win32: %dx%d X11: %dx%d hotspot: %d,%d\n", 
                   pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
                   pCursor->bits->width, pCursor->bits->height,
                   pCursor->bits->xhot, pCursor->bits->yhot);
@@ -176,7 +175,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
     /* Check whether the X11 cursor is bigger than the win32 cursor */
     if (pScreenPriv->cursor.sm_cx < pCursor->bits->width ||
         pScreenPriv->cursor.sm_cy < pCursor->bits->height) {
-        winErrorFVerb(3,
+        ErrorF (
                       "winLoadCursor - Windows requires %dx%d cursor but X requires %dx%d\n",
                       pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
                       pCursor->bits->width, pCursor->bits->height);
@@ -240,7 +239,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
 
     /* We have a truecolor alpha-blended cursor and can use it! */
     if (pCursor->bits->argb) {
-        WIN_DEBUG_MSG("winLoadCursor: Trying truecolor alphablended cursor\n");
+        winDebug("winLoadCursor: Trying truecolor alphablended cursor\n"); 
         memset(&bi, 0, sizeof(BITMAPV4HEADER));
         bi.bV4Size = sizeof(BITMAPV4HEADER);
         bi.bV4Width = pScreenPriv->cursor.sm_cx;
@@ -270,7 +269,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
     if (!lpBits) {
         RGBQUAD *pbmiColors;
         /* Bicolor, use a palettized DIB */
-        WIN_DEBUG_MSG("winLoadCursor: Trying two color cursor\n");
+        winDebug("winLoadCursor: Trying two color cursor\n"); 
         pbmi = (BITMAPINFO *) &bi;
         pbmiColors = &(pbmi->bmiColors[0]);
 
@@ -339,7 +338,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
 
     /* If one of the previous two methods gave us the bitmap we need, make a cursor */
     if (lpBits) {
-        WIN_DEBUG_MSG("winLoadCursor: Creating bitmap cursor: hotspot %d,%d\n",
+        winDebug("winLoadCursor: Creating bitmap cursor: hotspot %d,%d\n",
                       pCursor->bits->xhot, pCursor->bits->yhot);
 
         hAnd = NULL;
@@ -369,13 +368,12 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
             hCursor = (HCURSOR) CreateIconIndirect(&ii);
 
             if (hCursor == NULL)
-                winW32Error(2, "winLoadCursor - CreateIconIndirect failed:");
+                winW32Error("winLoadCursor - CreateIconIndirect failed:");
             else {
                 if (GetIconInfo(hCursor, &ii)) {
                     if (ii.fIcon) {
-                        WIN_DEBUG_MSG
+                        winDebug
                             ("winLoadCursor: CreateIconIndirect returned  no cursor. Trying again.\n");
-
                         DestroyCursor(hCursor);
 
                         ii.fIcon = FALSE;
@@ -384,7 +382,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
                         hCursor = (HCURSOR) CreateIconIndirect(&ii);
 
                         if (hCursor == NULL)
-                            winW32Error(2,
+                            winW32Error(
                                         "winLoadCursor - CreateIconIndirect failed:");
                     }
                     /* GetIconInfo creates new bitmaps. Destroy them again */
@@ -410,7 +408,7 @@ winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
                                pScreenPriv->cursor.sm_cx,
                                pScreenPriv->cursor.sm_cy, pAnd, pXor);
         if (hCursor == NULL)
-            winW32Error(2, "winLoadCursor - CreateCursor failed:");
+            winW32Error("winLoadCursor - CreateCursor failed:");
     }
     free(pAnd);
     free(pXor);
@@ -465,7 +463,7 @@ winSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x,
     BOOL bInhibit;
 
     winScreenPriv(pScreen);
-    WIN_DEBUG_MSG("winSetCursor: cursor=%p\n", pCursor);
+    winDebug("winSetCursor: cursor=%p\n", pCursor); 
 
     /* Inhibit changing the cursor if the mouse is not in a client area */
     bInhibit = FALSE;
@@ -507,7 +505,7 @@ winSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x,
         }
         pScreenPriv->cursor.handle =
             winLoadCursor(pScreen, pCursor, pScreen->myNum);
-        WIN_DEBUG_MSG("winSetCursor: handle=%p\n", pScreenPriv->cursor.handle);
+        winDebug("winSetCursor: handle=%p\n", pScreenPriv->cursor.handle); 
 
         if (!bInhibit)
             SetCursor(pScreenPriv->cursor.handle);
@@ -598,9 +596,11 @@ winInitCursor(ScreenPtr pScreen)
     pPointPriv = (miPointerScreenPtr)
         dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
 
-    pScreenPriv->cursor.spriteFuncs = pPointPriv->spriteFuncs;
-    pPointPriv->spriteFuncs = &winSpriteFuncsRec;
-
+    if (pPointPriv)
+    {
+        pScreenPriv->cursor.spriteFuncs = pPointPriv->spriteFuncs;
+        pPointPriv->spriteFuncs = &winSpriteFuncsRec;
+    }
     pScreenPriv->cursor.handle = NULL;
     pScreenPriv->cursor.visible = FALSE;
 
diff --git a/xserver/hw/xwin/windialogs.c b/vcxsrv-code/xorg-server/hw/xwin/windialogs.c
index 26b2ebd..28226f6 100644
--- a/xserver/hw/xwin/windialogs.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/windialogs.c
@@ -182,8 +182,8 @@ winInitDialog(HWND hwndDlg)
      */
     if (GetSystemMetrics(SM_CMONITORS) > 1) {
         /* Still need to refresh the frame change. */
-        SetWindowPos(hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
-                     SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
+    SetWindowPos (hwndDlg, HWND_TOP, 0,0,0,0,
+		  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
     }
     else {
         GetWindowRect(hwndDesk, &rcDesk);
@@ -218,12 +218,8 @@ winInitDialog(HWND hwndDlg)
     PostMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
 }
 
-/*
- * Display the Exit dialog box
- */
-
-void
-winDisplayExitDialog(winPrivScreenPtr pScreenPriv)
+int
+GetLiveClients (winPrivScreenPtr pScreenPriv)
 {
     int i;
     int liveClients = 0;
@@ -242,6 +238,20 @@ winDisplayExitDialog(winPrivScreenPtr pScreenPriv)
     if (liveClients < 0)
         liveClients = 0;
 
+  pScreenPriv->iConnectedClients = liveClients;
+
+  return liveClients;
+}
+
+/*
+ * Display the Exit dialog box
+ */
+
+void
+winDisplayExitDialog (winPrivScreenPtr pScreenPriv)
+{
+  int liveClients = GetLiveClients(pScreenPriv);
+
     /* Don't show the exit confirmation dialog if SilentExit & no clients,
        or ForceExit, is enabled */
     if ((pref.fSilentExit && liveClients <= 0) || pref.fForceExit) {
@@ -253,8 +263,6 @@ winDisplayExitDialog(winPrivScreenPtr pScreenPriv)
         return;
     }
 
-    pScreenPriv->iConnectedClients = liveClients;
-
     /* Check if dialog already exists */
     if (g_hDlgExit != NULL) {
         /* Dialog box already exists, display it */
@@ -413,50 +421,40 @@ winChangeDepthDlgProc(HWND hwndDialog, UINT message,
     static winPrivScreenPtr s_pScreenPriv = NULL;
     static winScreenInfo *s_pScreenInfo = NULL;
 
-#if CYGDEBUG
     winDebug("winChangeDepthDlgProc\n");
-#endif
 
     /* Branch on message type */
     switch (message) {
     case WM_INITDIALOG:
-#if CYGDEBUG
         winDebug("winChangeDepthDlgProc - WM_INITDIALOG\n");
-#endif
 
         /* Store pointers to private structures for future use */
         s_pScreenPriv = (winPrivScreenPtr) lParam;
         s_pScreenInfo = s_pScreenPriv->pScreenInfo;
 
-#if CYGDEBUG
         winDebug("winChangeDepthDlgProc - WM_INITDIALOG - s_pScreenPriv: %p, "
                  "s_pScreenInfo: %p\n",
                  s_pScreenPriv, s_pScreenInfo);
-#endif
 
-#if CYGDEBUG
         winDebug("winChangeDepthDlgProc - WM_INITDIALOG - orig bpp: %u, "
                  "current bpp: %d\n",
                  (unsigned int)s_pScreenInfo->dwBPP,
                  GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
-#endif
 
         winInitDialog(hwndDialog);
 
         return TRUE;
 
     case WM_DISPLAYCHANGE:
-#if CYGDEBUG
         winDebug("winChangeDepthDlgProc - WM_DISPLAYCHANGE - orig bpp: %u, "
                  "new bpp: %d\n",
                  (unsigned int)s_pScreenInfo->dwBPP,
                  GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
-#endif
 
         /* Dismiss the dialog if the display returns to the original depth */
         if (GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL) ==
             s_pScreenInfo->dwBPP) {
-            ErrorF("winChangeDelthDlgProc - wParam == s_pScreenInfo->dwBPP\n");
+        	  winDebug ("winChangeDelthDlgProc - wParam == s_pScreenInfo->dwBPP\n");
 
             /* Depth has been restored, dismiss dialog */
             DestroyWindow(g_hDlgDepthChange);
@@ -542,16 +540,12 @@ winAboutDlgProc(HWND hwndDialog, UINT message, WPARAM wParam, LPARAM lParam)
 {
     static winPrivScreenPtr s_pScreenPriv = NULL;
 
-#if CYGDEBUG
     winDebug("winAboutDlgProc\n");
-#endif
 
     /* Branch on message type */
     switch (message) {
     case WM_INITDIALOG:
-#if CYGDEBUG
         winDebug("winAboutDlgProc - WM_INITDIALOG\n");
-#endif
 
         /* Store pointer to private structure for future use */
         s_pScreenPriv = (winPrivScreenPtr) lParam;
diff --git a/xserver/hw/xwin/windisplay.c b/vcxsrv-code/xorg-server/hw/xwin/windisplay.c
index 17f0c77..fd6d4cd 100644
--- a/xserver/hw/xwin/windisplay.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/windisplay.c
@@ -45,18 +45,21 @@
 void
 winGetDisplayName(char *szDisplay, unsigned int screen)
 {
+#ifdef LOCALCONN
     if (_XSERVTransIsListening("local")) {
         snprintf(szDisplay, 512, ":%s.%d", display, screen);
     }
-    else if (_XSERVTransIsListening("inet")) {
+    else
+#endif
+    if (_XSERVTransIsListening("inet")) {
         snprintf(szDisplay, 512, "127.0.0.1:%s.%d", display, screen);
     }
     else if (_XSERVTransIsListening("inet6")) {
-        snprintf(szDisplay, 512, "::1:%s.%d", display, screen);
+        snprintf(szDisplay, 512, "[::1]:%s.%d", display, screen);
     }
     else {
         // this can't happen!
-        ErrorF("winGetDisplay: Don't know what to use for DISPLAY\n");
+        winDebug("winGetDisplay: Don't know what to use for DISPLAY\n");
         snprintf(szDisplay, 512, "localhost:%s.%d", display, screen);
     }
 
diff --git a/xserver/hw/xwin/winengine.c b/vcxsrv-code/xorg-server/hw/xwin/winengine.c
index f822324..e2d6648 100644
--- a/xserver/hw/xwin/winengine.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winengine.c
@@ -74,7 +74,7 @@ winDetectSupportedEngines(void)
         ddrval = (*g_fpDirectDrawCreate) (NULL, (void **) &lpdd, NULL);
         if (FAILED(ddrval)) {
             /* No DirectDraw support */
-            winErrorFVerb(2,
+            winDebug (
                           "winDetectSupportedEngines - DirectDraw not installed\n");
             return;
         }
@@ -85,8 +85,8 @@ winDetectSupportedEngines(void)
                                             (LPVOID *) &lpdd4);
         if (SUCCEEDED(ddrval)) {
             /* We have DirectDraw4 */
-            winErrorFVerb(2,
-                          "winDetectSupportedEngines - DirectDraw4 installed, allowing ShadowDDNL\n");
+            winDebug (
+                      "winDetectSupportedEngines - DirectDraw4 installed, allowing ShadowDDNL\n");
             g_dwEnginesSupported |= WIN_SERVER_SHADOW_DDNL;
         }
 
@@ -97,7 +97,7 @@ winDetectSupportedEngines(void)
             IDirectDraw_Release(lpdd);
     }
 
-    winErrorFVerb(2,
+    winDebug (
                   "winDetectSupportedEngines - Returning, supported engines %08x\n",
                   (unsigned int) g_dwEnginesSupported);
 }
@@ -136,7 +136,7 @@ winSetEngine(ScreenPtr pScreen)
 
     /* ShadowGDI is the only engine that supports windowed PseudoColor */
     if (dwBPP == 8 && !pScreenInfo->fFullScreen) {
-        winErrorFVerb(2,
+        winDebug (
                       "winSetEngine - Windowed && PseudoColor => ShadowGDI\n");
         pScreenInfo->dwEngine = WIN_SERVER_SHADOW_GDI;
 
@@ -149,7 +149,7 @@ winSetEngine(ScreenPtr pScreen)
     if (FALSE
         || pScreenInfo->fMultiWindow
         ) {
-        winErrorFVerb(2,
+        winDebug (
                       "winSetEngine - Multi Window or Rootless => ShadowGDI\n");
         pScreenInfo->dwEngine = WIN_SERVER_SHADOW_GDI;
 
@@ -158,9 +158,9 @@ winSetEngine(ScreenPtr pScreen)
         return TRUE;
     }
 
-    /* If the user's choice is supported, we'll use that */
-    if (g_dwEnginesSupported & pScreenInfo->dwEnginePreferred) {
-        winErrorFVerb(2, "winSetEngine - Using user's preference: %d\n",
+  /* If there is a user's choice, we'll use that */
+  if (pScreenInfo->dwEnginePreferred) {
+        winDebug ("winSetEngine - Using user's preference: %d\n",
                       (int) pScreenInfo->dwEnginePreferred);
         pScreenInfo->dwEngine = pScreenInfo->dwEnginePreferred;
 
@@ -173,14 +173,14 @@ winSetEngine(ScreenPtr pScreen)
             winSetEngineFunctionsShadowDDNL(pScreen);
             break;
         default:
-            FatalError("winSetEngine - Invalid engine type\n");
+            FatalError ("winSetEngine - Invalid engine type %d\n",pScreenInfo->dwEngine);
         }
         return TRUE;
     }
 
     /* ShadowDDNL has good performance, so why not */
     if (g_dwEnginesSupported & WIN_SERVER_SHADOW_DDNL) {
-        winErrorFVerb(2, "winSetEngine - Using Shadow DirectDraw NonLocking\n");
+        winDebug ("winSetEngine - Using Shadow DirectDraw NonLocking\n");
         pScreenInfo->dwEngine = WIN_SERVER_SHADOW_DDNL;
 
         /* Set engine function pointers */
@@ -190,7 +190,7 @@ winSetEngine(ScreenPtr pScreen)
 
     /* ShadowGDI is next in line */
     if (g_dwEnginesSupported & WIN_SERVER_SHADOW_GDI) {
-        winErrorFVerb(2, "winSetEngine - Using Shadow GDI DIB\n");
+        winDebug ("winSetEngine - Using Shadow GDI DIB\n");
         pScreenInfo->dwEngine = WIN_SERVER_SHADOW_GDI;
 
         /* Set engine function pointers */
diff --git a/xserver/hw/xwin/winerror.c b/vcxsrv-code/xorg-server/hw/xwin/winerror.c
index 784772f..60a6595 100644
--- a/xserver/hw/xwin/winerror.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winerror.c
@@ -60,11 +60,10 @@ OsVendorVErrorF(const char *pszFormat, va_list va_args)
  *
  * Attempt to do last-ditch, safe, important cleanup here.
  */
+char g_FatalErrorMessage[1024];
 void
 OsVendorFatalError(const char *f, va_list args)
 {
-    char errormsg[1024] = "";
-
     /* Don't give duplicate warning if UseMsg was called */
     if (g_fSilentFatalError)
         return;
@@ -75,9 +74,6 @@ OsVendorFatalError(const char *f, va_list args)
     }
     LogClose(EXIT_ERR_ABORT);
 
-    /* Format the error message */
-    vsnprintf(errormsg, sizeof(errormsg), f, args);
-
     /*
        Sometimes the error message needs a bit of cosmetic cleaning
        up for use in a dialog box...
@@ -85,7 +81,7 @@ OsVendorFatalError(const char *f, va_list args)
     {
         char *s;
 
-        while ((s = strstr(errormsg, "\n\t")) != NULL) {
+        while ((s = strstr(g_FatalErrorMessage, "\n\t")) != NULL) {
             s[0] = ' ';
             s[1] = '\n';
         }
@@ -95,7 +91,7 @@ OsVendorFatalError(const char *f, va_list args)
                    "%s\n\n"
                    "Please open %s for more information.\n",
                    MB_ICONERROR,
-                   errormsg,
+                   g_FatalErrorMessage,
                    (g_pszLogFile ? g_pszLogFile : "the logfile"));
 }
 
diff --git a/xserver/hw/xwin/winglobals.c b/vcxsrv-code/xorg-server/hw/xwin/winglobals.c
index 29abe19..3b4f4f2 100644
--- a/xserver/hw/xwin/winglobals.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winglobals.c
@@ -78,6 +78,7 @@ Bool g_fKeyboardHookLL = FALSE;
 Bool g_fNoHelpMessageBox = FALSE;
 Bool g_fSoftwareCursor = FALSE;
 Bool g_fNativeGl = TRUE;
+Bool g_fswrastwgl = FALSE;
 Bool g_fHostInTitle = TRUE;
 pthread_mutex_t g_pmTerminating = PTHREAD_MUTEX_INITIALIZER;
 
@@ -91,7 +92,19 @@ winDispatchProcPtr winProcEstablishConnectionOrig = NULL;
  */
 
 Bool g_fClipboard = TRUE;
+Bool g_fClipboardLaunched = FALSE;
 Bool g_fClipboardStarted = FALSE;
+pthread_t g_ptClipboardProc;
+HWND g_hwndClipboard = NULL;
+void *g_pClipboardDisplay = NULL;
+Window g_iClipboardWindow = None;
+Atom g_atomLastOwnedSelection = None;
+
+const char WIN_WINDOW_PROP[]=     "vcxsrv_window_prop_rl";
+const char WIN_WID_PROP[]=        "vcxsrv_wid_prop_rl";
+const char WIN_NEEDMANAGE_PROP[]= "vcxsrv_override_redirect_prop_rl";
+const char WIN_STATE_PROP[]=      "vcxsrv_state_prop_rl";
+const char WIN_SCR_PROP[]=        "vcxsrv_screen_prop_rl";
 
 /*
  * Re-initialize global variables that are invalidated
@@ -102,4 +115,8 @@ void
 winInitializeGlobals(void)
 {
     g_dwCurrentThreadID = GetCurrentThreadId();
+    g_iClipboardWindow = None;
+    g_pClipboardDisplay = NULL;
+    g_atomLastOwnedSelection = None;
+    g_hwndClipboard = NULL;
 }
diff --git a/xserver/hw/xwin/winglobals.h b/vcxsrv-code/xorg-server/hw/xwin/winglobals.h
index 29535f0..9020a59 100644
--- a/xserver/hw/xwin/winglobals.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winglobals.h
@@ -46,6 +46,9 @@ extern const char *g_pszLogFile;
 extern Bool g_fLogFileChanged;
 #endif
 extern int g_iLogVerbose;
+
+extern Bool g_iActualCodePage;
+
 extern Bool g_fLogInited;
 
 extern Bool g_fAuthEnabled;
@@ -54,6 +57,7 @@ extern Bool g_fCompositeAlpha;
 
 extern Bool g_fNoHelpMessageBox;
 extern Bool g_fNativeGl;
+extern Bool g_fswrastwgl;
 extern Bool g_fHostInTitle;
 
 extern HWND g_hDlgDepthChange;
@@ -73,6 +77,11 @@ extern winDispatchProcPtr winProcEstablishConnectionOrig;
 extern Bool g_fClipboard;
 extern Bool g_fClipboardStarted;
 
+extern Bool g_fClipboardLaunched;
+
+extern pthread_t g_ptClipboardProc;
+extern HWND g_hwndClipboard;
+
 /* The global X default icons */
 extern HICON g_hIconX;
 extern HICON g_hSmallIconX;
diff --git a/xserver/hw/xwin/winkeybd.c b/vcxsrv-code/xorg-server/hw/xwin/winkeybd.c
index 00586c2..09fa3a3 100644
--- a/xserver/hw/xwin/winkeybd.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winkeybd.c
@@ -156,7 +156,7 @@ winKeybdProc(DeviceIntPtr pDeviceInt, int iState)
         /* FIXME: Maybe we should use winGetKbdLeds () here? */
         defaultKeyboardControl.leds = g_winInfo.keyboard.leds;
 
-        winErrorFVerb(2, "Rules = \"%s\" Model = \"%s\" Layout = \"%s\""
+        winDebug("Rules = \"%s\" Model = \"%s\" Layout = \"%s\""
                       " Variant = \"%s\" Options = \"%s\"\n",
                       g_winInfo.xkb.rules ? g_winInfo.xkb.rules : "none",
                       g_winInfo.xkb.model ? g_winInfo.xkb.model : "none",
@@ -174,8 +174,7 @@ winKeybdProc(DeviceIntPtr pDeviceInt, int iState)
             ctrl->repeat_interval = 1000 / g_winInfo.keyboard.rate;
         }
         else {
-            winErrorFVerb(1,
-                          "winKeybdProc - Error initializing keyboard AutoRepeat\n");
+            winDebug ("winKeybdProc - Error initializing keyboard AutoRepeat\n");
         }
 
         break;
@@ -265,6 +264,21 @@ winRestoreModeKeyStates(void)
         XkbStateFieldFromRec(&inputInfo.keyboard->key->xkbInfo->state);
     winDebug("winRestoreModeKeyStates: state %d\n", internalKeyStates);
 
+    {
+        /* Make sure the message queue is empty, otherwise the GetKeyState will not always
+          return the correct state of the numlock key, capslock key, ... 
+          This is mainly because this function is called from the WM_SETFOCUS handler. 
+          From MSDN GetKeyState: The key status returned from this function changes as a thread
+          reads key messages from its message queue.*/
+        MSG msg;
+
+        /* Process all messages on our queue */
+        while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
+        {
+            DispatchMessage (&msg);
+        }
+    }
+
     /* Check if modifier keys are pressed, and if so, fake a press */
     {
 
diff --git a/xserver/hw/xwin/winmonitors.c b/vcxsrv-code/xorg-server/hw/xwin/winmonitors.c
index 5ff5653..ec4908c 100644
--- a/xserver/hw/xwin/winmonitors.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmonitors.c
@@ -32,6 +32,8 @@ from The Open Group.
 #endif
 
 #include "win.h"
+#define COMPILE_MULTIMON_STUBS
+#include <multimon.h>
 #include "winmonitors.h"
 
 /*
@@ -47,11 +49,16 @@ getMonitorInfo(HMONITOR hMonitor, HDC hdc, LPRECT rect, LPARAM _data)
     // only get data for monitor number specified in <data>
     data->monitorNum++;
     if (data->monitorNum == data->requestedMonitor) {
+        MONITORINFO monitorInfo;
+        monitorInfo.cbSize=sizeof(monitorInfo);
+        if (!GetMonitorInfo(hMonitor, &monitorInfo))
+          return FALSE;
+
         data->bMonitorSpecifiedExists = TRUE;
-        data->monitorOffsetX = rect->left;
-        data->monitorOffsetY = rect->top;
-        data->monitorHeight = rect->bottom - rect->top;
-        data->monitorWidth = rect->right - rect->left;
+        data->monitorOffsetX = monitorInfo.rcWork.left;
+        data->monitorOffsetY = monitorInfo.rcWork.top;
+        data->monitorHeight = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;
+        data->monitorWidth = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
         data->monitorHandle = hMonitor;
         return FALSE;
     }
diff --git a/xserver/hw/xwin/winmouse.c b/vcxsrv-code/xorg-server/hw/xwin/winmouse.c
index aad99d9..5427a53 100644
--- a/xserver/hw/xwin/winmouse.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmouse.c
@@ -36,6 +36,13 @@
 #endif
 #include "win.h"
 
+#ifdef XKB
+#ifndef XKB_IN_SERVER
+#define XKB_IN_SERVER
+#endif
+#include <xkbsrv.h>
+#endif
+
 #include "inputstr.h"
 #include "exevents.h"           /* for button/axes labels */
 #include "xserver-properties.h"
@@ -44,18 +51,6 @@
 /* Peek the internal button mapping */
 static CARD8 const *g_winMouseButtonMap = NULL;
 
-/*
- * Local prototypes
- */
-
-static void
- winMouseCtrl(DeviceIntPtr pDevice, PtrCtrl * pCtrl);
-
-static void
-winMouseCtrl(DeviceIntPtr pDevice, PtrCtrl * pCtrl)
-{
-}
-
 /*
  * See Porting Layer Definition - p. 18
  * This is known as a DeviceProc
@@ -75,7 +70,7 @@ winMouseProc(DeviceIntPtr pDeviceInt, int iState)
     case DEVICE_INIT:
         /* Get number of mouse buttons */
         lngMouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
-        winMsg(X_PROBED, "%d mouse buttons found\n", lngMouseButtons);
+        winDebug("%d mouse buttons found\n", lngMouseButtons);
 
         /* Mapping of windows events to X events:
          * LEFT:1 MIDDLE:2 RIGHT:3
@@ -122,7 +117,7 @@ winMouseProc(DeviceIntPtr pDeviceInt, int iState)
                                 map,
                                 lngMouseButtons + lngWheelEvents,
                                 btn_labels,
-                                winMouseCtrl,
+                                (PtrCtrlProcPtr)NoopDDA,
                                 GetMotionHistorySize(), 2, axes_labels);
         free(map);
 
@@ -231,10 +226,8 @@ winMouseButtonsSendEvent(int iEventType, int iButton)
     QueuePointerEvents(g_pwinPointer, iEventType, iButton,
                        POINTER_RELATIVE, &mask);
 
-#if CYGDEBUG
-    ErrorF("winMouseButtonsSendEvent: iEventType: %d, iButton: %d\n",
+  winDebug("winMouseButtonsSendEvent: iEventType: %d, iButton: %d\n",
            iEventType, iButton);
-#endif
 }
 
 /*
diff --git a/xserver/hw/xwin/winmsg.c b/vcxsrv-code/xorg-server/hw/xwin/winmsg.c
index 2ee48ce..9e1cf98 100644
--- a/xserver/hw/xwin/winmsg.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmsg.c
@@ -33,43 +33,16 @@
 #endif
 #include "win.h"
 #include "winmsg.h"
-#if CYGDEBUG
+#ifdef WINDBG
 #include "winmessages.h"
 #endif
 #include <stdarg.h>
 
-#ifdef XWIN_XF86CONFIG
-void
-winDrvMsg(int scrnIndex, MessageType type, const char *format, ...)
-{
-    va_list ap;
+#ifdef WINDBG
 
-    va_start(ap, format);
-    LogVMessageVerb(type, 0, format, ap);
-    va_end(ap);
-}
 
-void
-winDrvMsgVerb(int scrnIndex, MessageType type, int verb, const char *format,
-              ...)
-{
-    va_list ap;
-
-    va_start(ap, format);
-    LogVMessageVerb(type, verb, format, ap);
-    va_end(ap);
-}
-#endif
 
-void
-winErrorFVerb(int verb, const char *format, ...)
-{
-    va_list ap;
 
-    va_start(ap, format);
-    LogVMessageVerb(X_NONE, verb, format, ap);
-    va_end(ap);
-}
 
 void
 winDebug(const char *format, ...)
@@ -82,23 +55,24 @@ winDebug(const char *format, ...)
 }
 
 void
-winTrace(const char *format, ...)
+winDebug4 (const char *format, ...)
 {
     va_list ap;
 
     va_start(ap, format);
-    LogVMessageVerb(X_NONE, 10, format, ap);
+  LogVMessageVerb(X_NONE, 4, format, ap);
     va_end(ap);
 }
+#endif
 
 void
-winW32Error(int verb, const char *msg)
+winW32Error(const char *msg)
 {
-    winW32ErrorEx(verb, msg, GetLastError());
+    winW32ErrorEx(msg, GetLastError());
 }
 
 void
-winW32ErrorEx(int verb, const char *msg, DWORD errorcode)
+winW32ErrorEx(const char *msg, DWORD errorcode)
 {
     LPVOID buffer;
 
@@ -109,15 +83,16 @@ winW32ErrorEx(int verb, const char *msg, DWORD errorcode)
                        errorcode,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &buffer, 0, NULL)) {
-        winErrorFVerb(verb, "Unknown error in FormatMessage!\n");
+        ErrorF(msg); 
+        ErrorF("Unknown error in FormatMessage!\n"); 
     }
     else {
-        winErrorFVerb(verb, "%s %s", msg, (char *) buffer);
+        ErrorF("%s %s", msg, (char *)buffer); 
         LocalFree(buffer);
     }
 }
 
-#if CYGDEBUG
+#ifdef WINDBG
 void
 winDebugWin32Message(const char *function, HWND hwnd, UINT message,
                      WPARAM wParam, LPARAM lParam)
@@ -146,10 +121,4 @@ winDebugWin32Message(const char *function, HWND hwnd, UINT message,
         }
     }
 }
-#else
-void
-winDebugWin32Message(const char *function, HWND hwnd, UINT message,
-                     WPARAM wParam, LPARAM lParam)
-{
-}
 #endif
diff --git a/xserver/hw/xwin/winmsg.h b/vcxsrv-code/xorg-server/hw/xwin/winmsg.h
index 02f672f..55eba36 100644
--- a/xserver/hw/xwin/winmsg.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmsg.h
@@ -37,32 +37,21 @@
 /*
  * Function prototypes
  */
-
-#ifdef XWIN_XF86CONFIG
-void
-winDrvMsgVerb(int scrnIndex,
-              MessageType type, int verb, const char *format, ...)
-_X_ATTRIBUTE_PRINTF(4, 5);
-void
-winDrvMsg(int scrnIndex, MessageType type, const char *format, ...)
-_X_ATTRIBUTE_PRINTF(3, 4);
+ 
+#include "os.h"
+
+#if !defined(_MSC_VER) || defined(_DEBUG)
+#define WINDBG
+void winDebug (const char *format, ...);
+void winDebug4 (const char *format, ...);
+void winDebugWin32Message(const char* function, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
+#else
+#define winDebug(...)
+#define winDebug4(...)
+#define winDebugWin32Message(...)
 #endif
 
-#define winMsg LogMessage
-
-void
-winDebug(const char *format, ...)
-_X_ATTRIBUTE_PRINTF(1, 2);
-void
-winTrace(const char *format, ...)
-_X_ATTRIBUTE_PRINTF(1, 2);
-
-void
-winErrorFVerb(int verb, const char *format, ...)
-_X_ATTRIBUTE_PRINTF(2, 3);
-void winW32Error(int verb, const char *message);
-void winW32ErrorEx(int verb, const char *message, DWORD errorcode);
-void winDebugWin32Message(const char *function, HWND hwnd, UINT message,
-                          WPARAM wParam, LPARAM lParam);
+void winW32Error(const char *message);
+void winW32ErrorEx(const char *message, DWORD errorcode);
 
 #endif
diff --git a/xserver/hw/xwin/winmsgwindow.c b/vcxsrv-code/xorg-server/hw/xwin/winmsgwindow.c
index f5649b7..bbffc88 100644
--- a/xserver/hw/xwin/winmsgwindow.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmsgwindow.c
@@ -109,7 +109,7 @@ winCreateMsgWindow(void)
         wcx.hInstance = g_hInstance;
         wcx.hIcon = NULL;
         wcx.hCursor = 0;
-        wcx.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
+        wcx.hbrBackground = NULL;
         wcx.lpszMenuName = NULL;
         wcx.lpszClassName = WINDOW_CLASS_X_MSG;
         wcx.hIconSm = NULL;
diff --git a/xserver/hw/xwin/winmultiwindowclass.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowclass.c
index 6787332..ec28361 100644
--- a/xserver/hw/xwin/winmultiwindowclass.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowclass.c
@@ -134,8 +134,9 @@ winMultiWindowGetWMHints(WindowPtr pWin, WinXWMHints * hints)
     memset(hints, 0, sizeof(WinXWMHints));
 
     while (prop) {
-        if (prop->propertyName == XA_WM_HINTS && prop->data) {
-            memcpy(hints, prop->data, sizeof(WinXWMHints));
+        if (prop->propertyName == XA_WM_HINTS && prop->data
+            && prop->format == 32) {
+            memcpy (hints, prop->data, 4*(int)prop->size); /* format/8 = 4 */
             return 1;
         }
         else
@@ -208,8 +209,9 @@ winMultiWindowGetWMNormalHints(WindowPtr pWin, WinXSizeHints * hints)
     memset(hints, 0, sizeof(WinXSizeHints));
 
     while (prop) {
-        if (prop->propertyName == XA_WM_NORMAL_HINTS && prop->data) {
-            memcpy(hints, prop->data, sizeof(WinXSizeHints));
+        if (prop->propertyName == XA_WM_NORMAL_HINTS && prop->data
+            && prop->format == 32) {
+            memcpy (hints, prop->data, 4*(int)prop->size); /* format/8 = 4 */
             return 1;
         }
         else
@@ -241,9 +243,11 @@ winMultiWindowGetTransientFor(WindowPtr pWin, Window *pDaddyId)
         *pDaddyId = 0;
 
     while (prop) {
-        if (prop->propertyName == XA_WM_TRANSIENT_FOR) {
+        if (prop->propertyName == XA_WM_TRANSIENT_FOR
+            && prop->format == 32
+            && prop->data) {
             if (pDaddyId)
-                memcpy(pDaddyId, prop->data, sizeof(Window));
+                memcpy (pDaddyId, prop->data, 4*(int)prop->size); /* format/8 = 4 */
             return 1;
         }
         else
diff --git a/xserver/hw/xwin/winmultiwindowclass.h b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowclass.h
index 37ee9fb..d49151a 100644
--- a/xserver/hw/xwin/winmultiwindowclass.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowclass.h
@@ -60,16 +60,6 @@ typedef struct {
     /* this structure may be extended in the future */
 } WinXWMHints;
 
-/* Window manager hints mask bits */
-#define	InputHint	(1L << 0)
-#define	StateHint	(1L << 1)
-#define	IconPixmapHint	(1L << 2)
-#define	IconWindowHint	(1L << 3)
-#define	IconPositionHint	(1L << 4)
-#define	IconMaskHint	(1L << 5)
-#define	WindowGroupHint	(1L << 6)
-#define	UrgencyHint	(1L << 8)
-#define	AllHints 	(InputHint|StateHint|IconPixmapHint|IconWindowHint|IconPositionHint|IconMaskHint|WindowGroupHint)
 
 /*
  * ICCCM 1.0 version containing base_width, base_height, and win_gravity fields;
diff --git a/xserver/hw/xwin/winmultiwindowicons.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowicons.c
index 0ef666d..5898c15 100644
--- a/xserver/hw/xwin/winmultiwindowicons.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowicons.c
@@ -242,18 +242,20 @@ NetWMToWinIconAlpha(uint32_t * icon)
     HDC hdc = GetDC(NULL);
     uint32_t *DIB_pixels;
     ICONINFO ii;
-    BITMAPV4HEADER bmh = { sizeof(bmh) };
+    BITMAPV5HEADER bmh;
 
     /* Define an ARGB pixel format used for Color+Alpha icons */
-    bmh.bV4Width = width;
-    bmh.bV4Height = -height;    /* Invert the image */
-    bmh.bV4Planes = 1;
-    bmh.bV4BitCount = 32;
-    bmh.bV4V4Compression = BI_BITFIELDS;
-    bmh.bV4AlphaMask = 0xFF000000;
-    bmh.bV4RedMask = 0x00FF0000;
-    bmh.bV4GreenMask = 0x0000FF00;
-    bmh.bV4BlueMask = 0x000000FF;
+    ZeroMemory(&bmh,sizeof(bmh));
+    bmh.bV5Size = sizeof(bmh);
+    bmh.bV5Width = width;
+    bmh.bV5Height = -height; /* Invert the image */
+    bmh.bV5Planes = 1;
+    bmh.bV5BitCount = 32;
+    bmh.bV5Compression = BI_BITFIELDS;
+    bmh.bV5AlphaMask = 0xFF000000;
+    bmh.bV5RedMask =   0x00FF0000;
+    bmh.bV5GreenMask = 0x0000FF00;
+    bmh.bV5BlueMask =  0x000000FF;
 
     ii.fIcon = TRUE;
     ii.xHotspot = 0;            /* ignored */
@@ -332,40 +334,6 @@ NetWMToWinIconThreshold(uint32_t * icon)
     return result;
 }
 
-static HICON
-NetWMToWinIcon(int bpp, uint32_t * icon)
-{
-    static bool hasIconAlphaChannel = FALSE;
-    static bool versionChecked = FALSE;
-
-    if (!versionChecked) {
-        OSVERSIONINFOEX osvi = { 0 };
-        ULONGLONG dwlConditionMask = 0;
-
-        osvi.dwOSVersionInfoSize = sizeof(osvi);
-        osvi.dwMajorVersion = 5;
-        osvi.dwMinorVersion = 1;
-
-        /* Windows versions later than XP have icon alpha channel support, 2000 does not */
-        VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION,
-                          VER_GREATER_EQUAL);
-        VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION,
-                          VER_GREATER_EQUAL);
-        hasIconAlphaChannel =
-            VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION,
-                              dwlConditionMask);
-        versionChecked = TRUE;
-
-        ErrorF("OS has icon alpha channel support: %s\n",
-               hasIconAlphaChannel ? "yes" : "no");
-    }
-
-    if (hasIconAlphaChannel && (bpp == 32))
-        return NetWMToWinIconAlpha(icon);
-    else
-        return NetWMToWinIconThreshold(icon);
-}
-
 /*
  * Attempt to create a custom icon from the WM_HINTS bitmaps
  */
@@ -439,7 +407,7 @@ winXIconToHICON(xcb_connection_t *conn, xcb_window_t id, int iconSize)
             if (icon[0] == iconSize && icon[1] == iconSize) {
                 winDebug("winXIconToHICON: selected %d x %d NetIcon\n",
                          iconSize, iconSize);
-                hIcon = NetWMToWinIcon(bpp, icon);
+                hIcon = (bpp == 32) ? NetWMToWinIconAlpha(icon) : NetWMToWinIconThreshold(icon);
                 break;
             }
             /* Otherwise, find the biggest icon and let Windows scale the size */
@@ -454,7 +422,7 @@ winXIconToHICON(xcb_connection_t *conn, xcb_window_t id, int iconSize)
                 ("winXIconToHICON: selected %u x %u NetIcon for scaling to %d x %d\n",
                  biggest_icon[0], biggest_icon[1], iconSize, iconSize);
 
-            hIcon = NetWMToWinIcon(bpp, biggest_icon);
+            hIcon = (bpp == 32) ? NetWMToWinIconAlpha(biggest_icon) : NetWMToWinIconThreshold(biggest_icon);
         }
 
         free(reply);
@@ -585,34 +553,40 @@ winUpdateIcon(HWND hWnd, xcb_connection_t *conn, xcb_window_t id, HICON hIconNew
 {
     HICON hIcon, hIconSmall = NULL, hIconOld;
 
-    if (hIconNew)
-      {
+    if (hIconNew) {
         /* Start with the icon from preferences, if any */
         hIcon = hIconNew;
         hIconSmall = hIconNew;
-      }
-    else
-      {
+    } else {
         /* If we still need an icon, try and get the icon from WM_HINTS */
         hIcon = winXIconToHICON(conn, id, GetSystemMetrics(SM_CXICON));
         hIconSmall = winXIconToHICON(conn, id, GetSystemMetrics(SM_CXSMICON));
-      }
+        /* If we got the small, but not the large one swap them */
+        if (!hIcon && hIconSmall) {
+            hIcon = hIconSmall;
+            hIconSmall = NULL;
+        }
+    }
 
-    /* If we got the small, but not the large one swap them */
-    if (!hIcon && hIconSmall) {
-        hIcon = hIconSmall;
-        hIconSmall = NULL;
+    /* If we still need an icon, use the default one */
+    if (!hIcon) {
+        hIcon = g_hIconX;
+        hIconSmall = g_hSmallIconX;
     }
 
-    /* Set the large icon */
-    hIconOld = (HICON) SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
-    /* Delete the old icon if its not the default */
-    winDestroyIcon(hIconOld);
+    if (hIcon) {
+        /* Set the large icon */
+        hIconOld = (HICON) SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
+        /* Delete the old icon if its not the default */
+        winDestroyIcon(hIconOld);
+    }
 
-    /* Same for the small icon */
-    hIconOld =
-        (HICON) SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
-    winDestroyIcon(hIconOld);
+    if (hIconSmall) {
+        /* Same for the small icon */
+        hIconOld =
+            (HICON) SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
+        winDestroyIcon(hIconOld);
+    }
 }
 
 void
diff --git a/xserver/hw/xwin/winmultiwindowshape.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowshape.c
index 73afaea..15c5ebe 100644
--- a/xserver/hw/xwin/winmultiwindowshape.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowshape.c
@@ -46,9 +46,7 @@ winSetShapeMultiWindow(WindowPtr pWin, int kind)
 
     winScreenPriv(pScreen);
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("winSetShapeMultiWindow - pWin: %p kind: %i\n", pWin, kind);
-#endif
+  winDebug ("winSetShapeMultiWindow - pWin: %p kind: %i\n", pWin, kind);
 
     WIN_UNWRAP(SetShape);
     (*pScreen->SetShape) (pWin, kind);
@@ -89,9 +87,7 @@ winReshapeMultiWindow(WindowPtr pWin)
 
     winWindowPriv(pWin);
 
-#if CYGDEBUG
     winDebug("winReshape ()\n");
-#endif
 
     /* Bail if the window is the root window */
     if (pWin->parent == NULL)
@@ -197,3 +193,14 @@ winReshapeMultiWindow(WindowPtr pWin)
 
     return;
 }
+
+void
+winShapeRgnUpdateMultiwindow(HWND hwnd)
+{
+  WindowPtr pWin = GetProp (hwnd, WIN_WINDOW_PROP);
+  if (pWin)
+    {
+      winReshapeMultiWindow(pWin);
+      winUpdateRgnMultiWindow(pWin);
+    }
+}
diff --git a/xserver/hw/xwin/winmultiwindowwindow.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwindow.c
index 5b9b74e..f3d64c6 100644
--- a/xserver/hw/xwin/winmultiwindowwindow.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwindow.c
@@ -75,17 +75,17 @@ winInitMultiWindowClass(void)
         wcx.style = CS_HREDRAW | CS_VREDRAW | (g_fNativeGl ? CS_OWNDC : 0);
         wcx.lpfnWndProc = winTopLevelWindowProc;
         wcx.cbClsExtra = 0;
-        wcx.cbWndExtra = 0;
+        wcx.cbWndExtra = WND_EXTRABYTES;
         wcx.hInstance = g_hInstance;
         wcx.hIcon = hIcon;
         wcx.hCursor = 0;
-        wcx.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
+        wcx.hbrBackground = NULL;
         wcx.lpszMenuName = NULL;
         wcx.lpszClassName = WINDOW_CLASS_X;
         wcx.hIconSm = hIconSmall;
 
 #if CYGMULTIWINDOW_DEBUG
-        ErrorF("winCreateWindowsWindow - Creating class: %s\n", WINDOW_CLASS_X);
+        winDebug ("winCreateWindowsWindow - Creating class: %s\n", WINDOW_CLASS_X);
 #endif
 
         atomXWinClass = RegisterClassEx(&wcx);
@@ -106,7 +106,7 @@ winCreateWindowMultiWindow(WindowPtr pWin)
     winScreenPriv(pScreen);
 
 #if CYGMULTIWINDOW_DEBUG
-    winTrace("winCreateWindowMultiWindow - pWin: %p\n", pWin);
+    winDebug ("winCreateWindowMultiWindow - pWin: %p\n", pWin);
 #endif
 
     WIN_UNWRAP(CreateWindow);
@@ -139,7 +139,7 @@ winDestroyWindowMultiWindow(WindowPtr pWin)
     winScreenPriv(pScreen);
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winDestroyWindowMultiWindow - pWin: %p\n", pWin);
+    winDebug ("winDestroyWindowMultiWindow - pWin: %p\n", pWin);
 #endif
 
     WIN_UNWRAP(DestroyWindow);
@@ -177,30 +177,29 @@ winPositionWindowMultiWindow(WindowPtr pWin, int x, int y)
     RECT rcNew;
     RECT rcOld;
 
-#if CYGMULTIWINDOW_DEBUG
+#ifdef WINDBG
     RECT rcClient;
     RECT *lpRc;
 #endif
     DWORD dwExStyle;
     DWORD dwStyle;
 
-#if CYGMULTIWINDOW_DEBUG
-    winTrace("winPositionWindowMultiWindow - pWin: %p\n", pWin);
-#endif
+    winDebug ("winPositionWindowMultiWindow - pWin: %p\n", pWin);
 
     WIN_UNWRAP(PositionWindow);
     fResult = (*pScreen->PositionWindow) (pWin, x, y);
     WIN_WRAP(PositionWindow, winPositionWindowMultiWindow);
 
-#if CYGWINDOWING_DEBUG
-    ErrorF("winPositionWindowMultiWindow: (x, y) = (%d, %d)\n", x, y);
-#endif
+    winDebug ("winPositionWindowMultiWindow: (x, y) = (%d, %d)\n", x, y);
 
     /* Bail out if the Windows window handle is bad */
     if (!hWnd) {
-#if CYGWINDOWING_DEBUG
-        ErrorF("\timmediately return since hWnd is NULL\n");
-#endif
+        winDebug ("\timmediately return since hWnd is NULL\n");
+        if (pWin->redirectDraw != RedirectDrawNone)
+        {
+          winDebug("winPositionWindowMultiWindow: Calling compReallocPixmap to make sure the pixmap buffer is valid.\n");
+          compReallocPixmap(pWin, x, y, pWin->drawable.width, pWin->drawable.height, pWin->borderWidth);
+        }
         return fResult;
     }
 
@@ -221,7 +220,7 @@ winPositionWindowMultiWindow(WindowPtr pWin, int x, int y)
 
 #if CYGMULTIWINDOW_DEBUG
     lpRc = &rcNew;
-    ErrorF("winPositionWindowMultiWindow - drawable (%d, %d)-(%d, %d)\n",
+    winDebug("winPositionWindowMultiWindow - drawable (%d, %d)-(%d, %d)\n",
            (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
 #endif
 
@@ -239,37 +238,41 @@ winPositionWindowMultiWindow(WindowPtr pWin, int x, int y)
     GetClientRect(hWnd, &rcClient);
 
     lpRc = &rcNew;
-    ErrorF("winPositionWindowMultiWindow - rcNew (%d, %d)-(%d, %d)\n",
+    winDebug("winPositionWindowMultiWindow - rcNew (%d, %d)-(%d, %d)\n",
            (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
 
     lpRc = &rcOld;
-    ErrorF("winPositionWindowMultiWindow - rcOld (%d, %d)-(%d, %d)\n",
+    winDebug("winPositionWindowMultiWindow - rcOld (%d, %d)-(%d, %d)\n",
            (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
 
     lpRc = &rcClient;
-    ErrorF("rcClient (%d, %d)-(%d, %d)\n",
+    winDebug("rcClient (%d, %d)-(%d, %d)\n",
            (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
 #endif
 
     /* Check if the old rectangle and new rectangle are the same */
     if (!EqualRect(&rcNew, &rcOld)) {
-#if CYGMULTIWINDOW_DEBUG
-        ErrorF("winPositionWindowMultiWindow - Need to move\n");
-#endif
-
-#if CYGWINDOWING_DEBUG
-        ErrorF("\tMoveWindow to (%d, %d) - %dx%d\n", (int)rcNew.left, (int)rcNew.top,
+      winDebug ("winPositionWindowMultiWindow - Need to move\n");
+        winDebug("\tMoveWindow to (%d, %d) - %dx%d\n", (int)rcNew.left, (int)rcNew.top,
                (int)(rcNew.right - rcNew.left), (int)(rcNew.bottom - rcNew.top));
-#endif
+
         /* Change the position and dimensions of the Windows window */
-        MoveWindow(hWnd,
-                   rcNew.left, rcNew.top,
-                   rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, TRUE);
+      if (pWinPriv->fWglUsed)
+      {
+        int iWidth=rcNew.right - rcNew.left;
+        int iHeight=rcNew.bottom - rcNew.top;
+        ScreenToClient(GetParent(hWnd), (LPPOINT)&rcNew);
+        MoveWindow (hWnd,
+                    rcNew.left, rcNew.top,
+                    iWidth, iHeight, TRUE);
+      }
+      else
+        MoveWindow (hWnd,
+                    rcNew.left, rcNew.top,
+                    rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, TRUE);
     }
     else {
-#if CYGMULTIWINDOW_DEBUG
-        ErrorF("winPositionWindowMultiWindow - Not need to move\n");
-#endif
+      winDebug ("winPositionWindowMultiWindow - Not need to move\n");
     }
 
     return fResult;
@@ -287,9 +290,7 @@ winChangeWindowAttributesMultiWindow(WindowPtr pWin, unsigned long mask)
 
     winScreenPriv(pScreen);
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("winChangeWindowAttributesMultiWindow - pWin: %p\n", pWin);
-#endif
+    winDebug ("winChangeWindowAttributesMultiWindow - pWin: %p\n", pWin);
 
     WIN_UNWRAP(ChangeWindowAttributes);
     fResult = (*pScreen->ChangeWindowAttributes) (pWin, mask);
@@ -317,7 +318,7 @@ winUnmapWindowMultiWindow(WindowPtr pWin)
     winScreenPriv(pScreen);
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winUnmapWindowMultiWindow - pWin: %p\n", pWin);
+    winDebug ("winUnmapWindowMultiWindow - pWin: %p\n", pWin);
 #endif
 
     WIN_UNWRAP(UnrealizeWindow);
@@ -348,7 +349,7 @@ winMapWindowMultiWindow(WindowPtr pWin)
     winScreenPriv(pScreen);
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winMapWindowMultiWindow - pWin: %p\n", pWin);
+    winDebug ("winMapWindowMultiWindow - pWin: %p\n", pWin);
 #endif
 
     WIN_UNWRAP(RealizeWindow);
@@ -394,6 +395,24 @@ winReparentWindowMultiWindow(WindowPtr pWin, WindowPtr pPriorParent)
     winUpdateWindowsWindow(pWin);
 }
 
+static int localConfigureWindow;
+int
+winConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
+{
+  localConfigureWindow++;
+  int ret=ConfigureWindow(pWin, mask, vlist, client);
+  localConfigureWindow--;
+  return ret;
+}
+
+static int isWindowOnTop(HWND hAbove, HWND hBeneath)
+{
+    HWND hNext=GetNextWindow(hAbove, GW_HWNDNEXT);
+    while (hNext && hNext!=hBeneath)
+       hNext=GetNextWindow(hNext, GW_HWNDNEXT);
+    return hNext==hBeneath;
+}
+
 /*
  * RestackWindow - Shuffle the z-order of a window
  */
@@ -401,76 +420,23 @@ winReparentWindowMultiWindow(WindowPtr pWin, WindowPtr pPriorParent)
 void
 winRestackWindowMultiWindow(WindowPtr pWin, WindowPtr pOldNextSib)
 {
-#if 0
-    WindowPtr pPrevWin;
-    UINT uFlags;
-    HWND hInsertAfter;
-    HWND hWnd = NULL;
-#endif
     ScreenPtr pScreen = pWin->drawable.pScreen;
 
     winScreenPriv(pScreen);
 
-#if CYGMULTIWINDOW_DEBUG || CYGWINDOWING_DEBUG
-    winTrace("winRestackMultiWindow - %p\n", pWin);
-#endif
+    winDebug ("winRestackMultiWindow - %p\n", pWin);
 
     WIN_UNWRAP(RestackWindow);
     if (pScreen->RestackWindow)
         (*pScreen->RestackWindow) (pWin, pOldNextSib);
     WIN_WRAP(RestackWindow, winRestackWindowMultiWindow);
 
-#if 1
     /*
      * Calling winReorderWindowsMultiWindow here means our window manager
      * (i.e. Windows Explorer) has initiative to determine Z order.
      */
     if (pWin->nextSib != pOldNextSib)
         winReorderWindowsMultiWindow();
-#else
-    /* Bail out if no window privates or window handle is invalid */
-    if (!pWinPriv || !pWinPriv->hWnd)
-        return;
-
-    /* Get a pointer to our previous sibling window */
-    pPrevWin = pWin->prevSib;
-
-    /*
-     * Look for a sibling window with
-     * valid privates and window handle
-     */
-    while (pPrevWin && !winGetWindowPriv(pPrevWin)
-           && !winGetWindowPriv(pPrevWin)->hWnd)
-        pPrevWin = pPrevWin->prevSib;
-
-    /* Check if we found a valid sibling */
-    if (pPrevWin) {
-        /* Valid sibling - get handle to insert window after */
-        hInsertAfter = winGetWindowPriv(pPrevWin)->hWnd;
-        uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
-
-        hWnd = GetNextWindow(pWinPriv->hWnd, GW_HWNDPREV);
-
-        do {
-            if (GetProp(hWnd, WIN_WINDOW_PROP)) {
-                if (hWnd == winGetWindowPriv(pPrevWin)->hWnd) {
-                    uFlags |= SWP_NOZORDER;
-                }
-                break;
-            }
-            hWnd = GetNextWindow(hWnd, GW_HWNDPREV);
-        }
-        while (hWnd);
-    }
-    else {
-        /* No valid sibling - make this window the top window */
-        hInsertAfter = HWND_TOP;
-        uFlags = SWP_NOMOVE | SWP_NOSIZE;
-    }
-
-    /* Perform the restacking operation in Windows */
-    SetWindowPos(pWinPriv->hWnd, hInsertAfter, 0, 0, 0, 0, uFlags);
-#endif
 }
 
 /*
@@ -504,46 +470,76 @@ winCreateWindowsWindow(WindowPtr pWin)
     iHeight = pWin->drawable.height;
 
     /* If it's an InputOutput window, and so is going to end up being made visible,
-       make sure the window actually ends up somewhere where it will be visible
-
-       To handle arrangements of monitors which form a non-rectangular virtual
-       desktop, check if the window will end up with its top-left corner on any
-       monitor
-    */
+     make sure the window actually ends up somewhere where it will be visible 
+     Dont't do it by making just one of the two iX and iY CW_USEDEFAULT since
+     this will create a window at place CW_USEDEFAULT which is 0x80000000 */
     if (pWin->drawable.class != InputOnly) {
-        POINT pt = { iX, iY };
-        if (MonitorFromPoint(pt, MONITOR_DEFAULTTONULL) == NULL)
-            {
-                iX = CW_USEDEFAULT;
-                iY = CW_USEDEFAULT;
-            }
+      while (1) {
+        if (iX < GetSystemMetrics (SM_XVIRTUALSCREEN)) {
+          iX = GetSystemMetrics (SM_XVIRTUALSCREEN);
+          ErrorF("Resetting iX to %d\n",iX);
+        }
+        else if  (iX > GetSystemMetrics (SM_CXVIRTUALSCREEN))
+        {
+          iX = GetSystemMetrics (SM_CXVIRTUALSCREEN)-iWidth;
+          ErrorF("Resetting iX to %d\n",iX);
+        }
+        else
+          break;
+      }
+
+      while (1) {
+        if (iY < GetSystemMetrics (SM_YVIRTUALSCREEN)) {
+          iY = GetSystemMetrics (SM_YVIRTUALSCREEN);
+          ErrorF("Resetting iY to %d\n",iY);
+        }
+        else if (iY > GetSystemMetrics (SM_CYVIRTUALSCREEN)) {
+          iY = GetSystemMetrics (SM_CYVIRTUALSCREEN)-iHeight;
+          ErrorF("Resetting iY to %d\n",iY);
+        }
+        else
+          break;
+      }
     }
 
-    winDebug("winCreateWindowsWindow - %dx%d @ %dx%d\n", iWidth, iHeight, iX,
+    winDebug("winCreateWindowsWindow - 1 - %dx%d @ %dx%d\n", iWidth, iHeight, iX,
              iY);
 
     if (winMultiWindowGetTransientFor(pWin, &daddyId)) {
-        if (daddyId) {
+        if (daddyId && !pWin->overrideRedirect) {
             WindowPtr pParent;
             int res = dixLookupWindow(&pParent, daddyId, serverClient, DixReadAccess);
-            if (res == Success)
-                {
-                    winPrivWinPtr pParentPriv = winGetWindowPriv(pParent);
-                    hFore = pParentPriv->hWnd;
-                }
+            if (res == Success) {
+                winPrivWinPtr pParentPriv = winGetWindowPriv(pParent);
+                hFore = pParentPriv->hWnd;
+            }
         }
     }
-    else {
+    else if (!pWin->overrideRedirect) {
         /* Default positions if none specified */
         if (!winMultiWindowGetWMNormalHints(pWin, &hints))
             hints.flags = 0;
-        if (!(hints.flags & (USPosition | PPosition)) &&
-            !pWin->overrideRedirect) {
+
+
+        if ((hints.flags & USPosition) ||
+            ((hints.flags & PPosition) &&
+             ((pWin->drawable.x - pWin->borderWidth != 0) ||
+              (pWin->drawable.y - pWin->borderWidth != 0)))) {
+            /*
+              Always respect user specified position, respect program
+              specified position if it's not the origin
+            */
+        }
+        else {
+            /* Use default position */
             iX = CW_USEDEFAULT;
             iY = CW_USEDEFAULT;
         }
     }
 
+    winDebug("winCreateWindowsWindow - 2 - %dx%d @ %dx%d\n", iWidth,
+             iHeight, iX, iY);
+
     /* Make it WS_OVERLAPPED in create call since WS_POPUP doesn't support */
     /* CW_USEDEFAULT, change back to popup after creation */
     dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
@@ -565,7 +561,7 @@ winCreateWindowsWindow(WindowPtr pWin)
     iHeight = rc.bottom - rc.top;
     iWidth = rc.right - rc.left;
 
-    winDebug("winCreateWindowsWindow - %dx%d @ %dx%d\n", iWidth, iHeight, iX,
+    winDebug("winCreateWindowsWindow - 3 - %dx%d @ %dx%d\n", iWidth, iHeight, iX,
              iY);
 
     /* Create the window */
@@ -579,7 +575,7 @@ winCreateWindowsWindow(WindowPtr pWin)
                            iHeight,     /* Bottom edge */
                            hFore,       /* Null or Parent window if transient */
                            (HMENU) NULL,        /* No menu */
-                           GetModuleHandle(NULL),       /* Instance handle */
+                           g_hInstance,       /* Instance handle */
                            pWin);       /* ScreenPrivates */
     if (hWnd == NULL) {
         ErrorF("winCreateWindowsWindow - CreateWindowExA () failed: %d\n",
@@ -587,6 +583,13 @@ winCreateWindowsWindow(WindowPtr pWin)
     }
     pWinPriv->hWnd = hWnd;
 
+    /* If we asked the native WM to place the window, synchronize the X window position.
+       Do this before the next SetWindowPos because this one is generating a WM_STYLECHANGED
+       message which is causing a window move, which is wrong if the Xwindow does not
+       have the correct coordinates yet */
+    if (iX == CW_USEDEFAULT) {
+      winAdjustXWindow(pWin, hWnd);
+    }
     /* Change style back to popup, already placed... */
     SetWindowLongPtr(hWnd, GWL_STYLE,
                      WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
@@ -594,9 +597,6 @@ winCreateWindowsWindow(WindowPtr pWin)
                  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE |
                  SWP_NOACTIVATE);
 
-    /* Adjust the X window to match the window placement we actually got... */
-    winAdjustXWindow(pWin, hWnd);
-
     /* Make sure it gets the proper system menu for a WS_POPUP, too */
     GetSystemMenu(hWnd, TRUE);
 
@@ -653,12 +653,12 @@ winDestroyWindowsWindow(WindowPtr pWin)
     pWinPriv->fWglUsed = FALSE;
 #endif
 
-    /* Process all messages on our queue */
+    /* Process all messages on our queue 
     while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
         if (g_hDlgDepthChange == 0 || !IsDialogMessage(g_hDlgDepthChange, &msg)) {
             DispatchMessage(&msg);
         }
-    }
+    }*/
 
     winInDestroyWindowsWindow = oldstate;
 
@@ -677,7 +677,7 @@ winUpdateWindowsWindow(WindowPtr pWin)
     HWND hWnd = pWinPriv->hWnd;
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winUpdateWindowsWindow\n");
+    winDebug("winUpdateWindowsWindow\n");
 #endif
 
     /* Check if the Windows window's parents have been destroyed */
@@ -693,16 +693,51 @@ winUpdateWindowsWindow(WindowPtr pWin)
             ShowWindow(pWinPriv->hWnd, SW_SHOWNOACTIVATE);
 
         /* Send first paint message */
-        UpdateWindow(pWinPriv->hWnd);
+        UpdateWindow(pWinPriv->hWnd); // IZI 2019
     }
     else if (hWnd != NULL) {
-        /* Destroy the Windows window if its parents are destroyed */
-        winDestroyWindowsWindow(pWin);
-        assert(pWinPriv->hWnd == NULL);
+        if (pWinPriv->fWglUsed) {
+            /* We do not need to destroy the window but to reparent it and move it to the
+               correct place when it is an opengl window */
+            int offsetx;
+            int offsety;
+            HWND hParentWnd;
+            WindowPtr pParent=pWin->parent;
+
+            while (pParent) {
+                winWindowPriv(pParent);
+                hParentWnd=pWinPriv->hWnd;
+                if (hParentWnd)
+                    break;
+                pParent=pParent->parent;
+            }
+
+            if (pParent) {
+                offsetx=pParent->drawable.x;
+                offsety=pParent->drawable.y;
+            }
+            else {
+                offsetx=0;
+                offsety=0;
+            }
+            if (hParentWnd == NULL)
+                winDestroyWindowsWindow (pWin);
+            else {
+                winDebug ("-winUpdateWindowsWindow: %x changing parent to %x and moving to %d,%d\n",pWinPriv->hWnd,hParentWnd,pWin->drawable.x-offsetx,pWin->drawable.y-offsety);
+                SetParent(pWinPriv->hWnd,hParentWnd);
+                SetWindowPos(pWinPriv->hWnd,NULL,pWin->drawable.x-offsetx,pWin->drawable.y-offsety,0,0,SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
+            }
+        }
+        else {
+            /* Destroy the Windows window if its parents are destroyed */
+            /* First check if we need to release the DC when it is an opengl window */
+            winDestroyWindowsWindow (pWin);
+            assert (pWinPriv->hWnd == NULL);
+        }
     }
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("-winUpdateWindowsWindow\n");
+    winDebug ("-winUpdateWindowsWindow\n");
 #endif
 }
 
@@ -720,7 +755,7 @@ winGetWindowID(WindowPtr pWin)
     FindClientResourcesByType(c, RT_WINDOW, winFindWindow, &wi);
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winGetWindowID - Window ID: %u\n", (unsigned int)wi.id);
+    winDebug("winGetWindowID - Window ID: %u\n", (unsigned int)wi.id);
 #endif
 
     return wi.id;
@@ -784,13 +819,13 @@ winReorderWindowsMultiWindow(void)
             if (!pWinSib) {     /* 1st window - raise to the top */
                 vlist[0] = Above;
 
-                ConfigureWindow(pWin, CWStackMode, vlist, wClient(pWin));
+                winConfigureWindow(pWin, CWStackMode, vlist, wClient(pWin));
             }
             else {              /* 2nd or deeper windows - just below the previous one */
                 vlist[0] = winGetWindowID(pWinSib);
                 vlist[1] = Below;
 
-                ConfigureWindow(pWin, CWSibling | CWStackMode,
+                winConfigureWindow(pWin, CWSibling | CWStackMode,
                                 vlist, wClient(pWin));
             }
         }
@@ -809,9 +844,8 @@ winCopyWindowMultiWindow(WindowPtr pWin, DDXPointRec oldpt, RegionPtr oldRegion)
 
     winScreenPriv(pScreen);
 
-#if CYGWINDOWING_DEBUG
-    ErrorF("CopyWindowMultiWindow\n");
-#endif
+    winDebug("CopyWindowMultiWindow\n");
+
     WIN_UNWRAP(CopyWindow);
     (*pScreen->CopyWindow) (pWin, oldpt, oldRegion);
     WIN_WRAP(CopyWindow, winCopyWindowMultiWindow);
@@ -828,9 +862,7 @@ winMoveWindowMultiWindow(WindowPtr pWin, int x, int y,
 
     winScreenPriv(pScreen);
 
-#if CYGWINDOWING_DEBUG
-    ErrorF("MoveWindowMultiWindow to (%d, %d)\n", x, y);
-#endif
+    winDebug("MoveWindowMultiWindow to (%d, %d)\n", x, y);
 
     WIN_UNWRAP(MoveWindow);
     (*pScreen->MoveWindow) (pWin, x, y, pSib, kind);
@@ -848,9 +880,8 @@ winResizeWindowMultiWindow(WindowPtr pWin, int x, int y, unsigned int w,
 
     winScreenPriv(pScreen);
 
-#if CYGWINDOWING_DEBUG
-    ErrorF("ResizeWindowMultiWindow to (%d, %d) - %dx%d\n", x, y, w, h);
-#endif
+    winDebug("ResizeWindowMultiWindow to (%d, %d) - %dx%d\n", x, y, w, h);
+
     WIN_UNWRAP(ResizeWindow);
     (*pScreen->ResizeWindow) (pWin, x, y, w, h, pSib);
     WIN_WRAP(ResizeWindow, winResizeWindowMultiWindow);
@@ -879,21 +910,20 @@ winAdjustXWindow(WindowPtr pWin, HWND hwnd)
 #define WIDTH(rc) (rc.right - rc.left)
 #define HEIGHT(rc) (rc.bottom - rc.top)
 
-#if CYGWINDOWING_DEBUG
-    ErrorF("winAdjustXWindow\n");
-#endif
+    if( !pWin->realized) //  IZI  Window is being destroyed?
+        return 0;
+
+    winDebug("winAdjustXWindow\n");
 
     if (IsIconic(hwnd)) {
-#if CYGWINDOWING_DEBUG
-        ErrorF("\timmediately return because the window is iconized\n");
-#endif
+      winDebug("\timmediately return because the window is iconized\n");
         /*
          * If the Windows window is minimized, its WindowRect has
          * meaningless values so we don't adjust X window to it.
          */
         vlist[0] = 0;
         vlist[1] = 0;
-        return ConfigureWindow(pWin, CWX | CWY, vlist, wClient(pWin));
+        return winConfigureWindow(pWin, CWX | CWY, vlist, wClient(pWin));
     }
 
     pDraw = &pWin->drawable;
@@ -902,34 +932,26 @@ winAdjustXWindow(WindowPtr pWin, HWND hwnd)
     x = pDraw->x + GetSystemMetrics(SM_XVIRTUALSCREEN);
     y = pDraw->y + GetSystemMetrics(SM_YVIRTUALSCREEN);
     SetRect(&rcDraw, x, y, x + pDraw->width, y + pDraw->height);
-#ifdef CYGMULTIWINDOW_DEBUG
     winDebug("\tDrawable extend {%d, %d, %d, %d}, {%d, %d}\n",
              (int)rcDraw.left, (int)rcDraw.top, (int)rcDraw.right, (int)rcDraw.bottom,
              (int)(rcDraw.right - rcDraw.left), (int)(rcDraw.bottom - rcDraw.top));
-#endif
     dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
     dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
-#ifdef CYGMULTIWINDOW_DEBUG
     winDebug("\tWindowStyle: %08x %08x\n", (unsigned int)dwStyle, (unsigned int)dwExStyle);
-#endif
     AdjustWindowRectEx(&rcDraw, dwStyle, FALSE, dwExStyle);
 
     /* The source of adjust */
     GetWindowRect(hwnd, &rcWin);
-#ifdef CYGMULTIWINDOW_DEBUG
     winDebug("\tWindow extend {%d, %d, %d, %d}, {%d, %d}\n",
              (int)rcWin.left, (int)rcWin.top, (int)rcWin.right, (int)rcWin.bottom,
              (int)(rcWin.right - rcWin.left), (int)(rcWin.bottom - rcWin.top));
     winDebug("\tDraw extend {%d, %d, %d, %d}, {%d, %d}\n",
              (int)rcDraw.left, (int)rcDraw.top, (int)rcDraw.right, (int)rcDraw.bottom,
              (int)(rcDraw.right - rcDraw.left), (int)(rcDraw.bottom - rcDraw.top));
-#endif
 
     if (EqualRect(&rcDraw, &rcWin)) {
         /* Bail if no adjust is needed */
-#if CYGWINDOWING_DEBUG
-        ErrorF("\treturn because already adjusted\n");
-#endif
+    winDebug("\treturn because already adjusted\n");
         return 0;
     }
 
@@ -943,19 +965,18 @@ winAdjustXWindow(WindowPtr pWin, HWND hwnd)
      * Adjust.
      * We may only need to move (vlist[0] and [1]), or only resize
      * ([2] and [3]) but currently we set all the parameters and leave
-     * the decision to ConfigureWindow.  The reason is code simplicity.
+     * the decision to winConfigureWindow.  The reason is code simplicity.
      */
     vlist[0] = pDraw->x + dX - wBorderWidth(pWin);
     vlist[1] = pDraw->y + dY - wBorderWidth(pWin);
     vlist[2] = pDraw->width + dW;
     vlist[3] = pDraw->height + dH;
-#if CYGWINDOWING_DEBUG
-    ErrorF("\tConfigureWindow to (%u, %u) - %ux%u\n",
+
+    winDebug("\tConfigureWindow to (%u, %u) - %ux%u\n",
            (unsigned int)vlist[0], (unsigned int)vlist[1],
            (unsigned int)vlist[2], (unsigned int)vlist[3]);
-#endif
-    return ConfigureWindow(pWin, CWX | CWY | CWWidth | CWHeight,
-                           vlist, wClient(pWin));
+    return winConfigureWindow(pWin, CWX | CWY | CWWidth | CWHeight,
+                              vlist, wClient(pWin));
 
 #undef WIDTH
 #undef HEIGHT
diff --git a/xserver/hw/xwin/winmultiwindowwm.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwm.c
index 37f1a7a..643b606 100644
--- a/xserver/hw/xwin/winmultiwindowwm.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwm.c
@@ -43,28 +43,40 @@
 #include <fcntl.h>
 #include <setjmp.h>
 #define HANDLE void *
+#ifdef _MSC_VER
+typedef int pid_t;
+#endif
 #include <pthread.h>
 #undef HANDLE
-#include <xcb/xcb.h>
-#include <xcb/xcb_icccm.h>
-#include <xcb/xcb_ewmh.h>
-#include <xcb/xcb_aux.h>
+#include <X11/X.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xproto.h>
 #include <xcb/composite.h>
-
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
 #include <X11/Xwindows.h>
 
 /* Local headers */
-#include "X11/Xdefs.h" // for Bool type
 #include "winwindow.h"
 #include "winprefs.h"
 #include "window.h"
 #include "pixmapstr.h"
+#include "winmsg.h"
 #include "windowstr.h"
+#include "winmultiwindowclass.h"
 #include "winglobals.h"
 #include "windisplay.h"
 #include "winmultiwindowicons.h"
 #include "winauth.h"
 
+#include <xcb/xcb.h>
+#include <xcb/xcb_icccm.h>
+#include <xcb/xcb_ewmh.h>
+#include <xcb/xcb_aux.h>
+#include <xcb/composite.h>
+#include <xcb/xcb_errors.h>
+
 /* We need the native HWND atom for intWM, so for consistency use the
    same name as extWM does */
 #define WINDOWSWM_NATIVE_HWND "_WINDOWSWM_NATIVE_HWND"
@@ -77,9 +89,7 @@ extern void winDebug(const char *format, ...);
 extern void winReshapeMultiWindow(WindowPtr pWin);
 extern void winUpdateRgnMultiWindow(WindowPtr pWin);
 
-#ifndef CYGDEBUG
-#define CYGDEBUG NO
-#endif
+extern void winSetAuthorization(void);
 
 /*
  * Constant defines
@@ -91,6 +101,9 @@ extern void winUpdateRgnMultiWindow(WindowPtr pWin);
 #define WIN_MSG_QUEUE_FNAME	"/dev/windows"
 #endif
 
+#define HINT_MAX	(1L<<0)
+#define HINT_MIN	(1L<<1)
+
 /*
  * Local structures
  */
@@ -109,6 +122,7 @@ typedef struct _WMMsgQueueRec {
 
 typedef struct _WMInfo {
     xcb_connection_t *conn;
+    xcb_errors_context_t *err_ctx;
     WMMsgQueueRec wmMsgQueue;
     xcb_atom_t atmWmProtos;
     xcb_atom_t atmWmDelete;
@@ -119,6 +133,7 @@ typedef struct _WMInfo {
     xcb_atom_t atmCurrentDesktop;
     xcb_atom_t atmNumberDesktops;
     xcb_atom_t atmDesktopNames;
+    xcb_atom_t atmWmState;
     xcb_ewmh_connection_t ewmh;
     Bool fCompositeWM;
 } WMInfoRec, *WMInfoPtr;
@@ -131,6 +146,7 @@ typedef struct _WMProcArgRec {
 
 typedef struct _XMsgProcArgRec {
     xcb_connection_t *conn;
+    xcb_errors_context_t *err_ctx;
     DWORD dwScreen;
     WMInfoPtr pWMInfo;
     pthread_mutex_t *ppmServerStarted;
@@ -165,16 +181,15 @@ static void *winMultiWindowXMsgProc(void *pArg);
 static void
  winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg);
 
-#if 0
 static void
- PreserveWin32Stack(WMInfoPtr pWMInfo, xcb_window_t iWindow, UINT direction);
-#endif
+ winMultiWindowThreadExit(void *arg);
+
 
 static Bool
 CheckAnotherWindowManager(xcb_connection_t *conn, DWORD dwScreen);
 
 static void
- winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle);
+ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle, unsigned long *maxmin);
 
 void
  winUpdateWindowPosition(HWND hWnd, HWND * zstyle);
@@ -189,7 +204,6 @@ static Bool g_shutdown = FALSE;
  * Translate msg id to text, for debug purposes
  */
 
-#if CYGMULTIWINDOW_DEBUG
 static const char *
 MessageName(winWMMessagePtr msg)
 {
@@ -239,8 +253,6 @@ MessageName(winWMMessagePtr msg)
       break;
     }
 }
-#endif
-
 
 /*
  * PushMessage - Push a message onto the queue
@@ -386,9 +398,7 @@ GetWindowName(WMInfoPtr pWMInfo, xcb_window_t iWin, char **ppWindowName)
     xcb_connection_t *conn = pWMInfo->conn;
     char *pszWindowName = NULL;
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("GetWindowName\n");
-#endif
+    winDebug ("GetWindowName\n");
 
     /* Try to get window name from _NET_WM_NAME */
     {
@@ -684,25 +694,31 @@ UpdateIcon(WMInfoPtr pWMInfo, xcb_window_t iWindow)
  */
 
 static void
-UpdateStyle(WMInfoPtr pWMInfo, xcb_window_t iWindow)
+UpdateStyle(WMInfoPtr pWMInfo, xcb_window_t iWindow, unsigned long *maxmin, int extra)
 {
     HWND hWnd;
     HWND zstyle = HWND_NOTOPMOST;
     UINT flags;
 
+    /* If window isn't override-redirect */
+    if (IsOverrideRedirect(pWMInfo->conn, iWindow))
+        return;
+
     hWnd = getHwnd(pWMInfo, iWindow);
     if (!hWnd)
         return;
 
     /* Determine the Window style, which determines borders and clipping region... */
-    winApplyHints(pWMInfo, iWindow, hWnd, &zstyle);
-    winUpdateWindowPosition(hWnd, &zstyle);
-
-    /* Apply the updated window style, without changing its show or activation state */
-    flags = SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
-    if (zstyle == HWND_NOTOPMOST)
-        flags |= SWP_NOZORDER | SWP_NOOWNERZORDER;
-    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, flags);
+    winApplyHints(pWMInfo, iWindow, hWnd, &zstyle, maxmin);
+    if (extra)
+    {
+      winUpdateWindowPosition(hWnd, &zstyle);
+      /* Apply the updated window style, without changing its show or activation state */
+      flags = SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
+      if (zstyle == HWND_NOTOPMOST)
+          flags |= SWP_NOZORDER | SWP_NOOWNERZORDER;
+      SetWindowPos(hWnd, NULL, 0, 0, 0, 0, flags);
+    }
 
     /*
        Use the WS_EX_TOOLWINDOW style to remove window from Alt-Tab window switcher
@@ -713,28 +729,156 @@ UpdateStyle(WMInfoPtr pWMInfo, xcb_window_t iWindow)
        But that doesn't seem to work reliably, and causes the window to flicker, so use
        the iTaskbarList interface to tell the taskbar to show or hide this window.
      */
+    // parentless windows appears also on task bar, regardless of style
     winShowWindowOnTaskbar(hWnd,
-                           (GetWindowLongPtr(hWnd, GWL_EXSTYLE) &
-                            WS_EX_APPWINDOW) ? TRUE : FALSE);
+                           (GetWindowLongPtr(hWnd, GWL_EXSTYLE)&WS_EX_APPWINDOW)||
+                            GetWindowLongPtr(hWnd, GWLP_HWNDPARENT)==0 ? TRUE : FALSE);
 }
 
 /*
  * Updates the state of a HWND
- * (only minimization supported at the moment)
  */
 
 static void
-UpdateState(WMInfoPtr pWMInfo, xcb_window_t iWindow)
+UpdateState(WMInfoPtr pWMInfo, xcb_window_t iWindow, int state)
 {
     HWND hWnd;
+    int current_state = -1;
 
-    winDebug("UpdateState: iWindow 0x%08x\n", (int)iWindow);
+    winDebug("UpdateState: iWindow 0x%08x %d\n", (int)iWindow, state);
 
     hWnd = getHwnd(pWMInfo, iWindow);
-    if (!hWnd)
-        return;
+    if (hWnd)
+        {
+            // Keep track of the Window state, do nothing if it's not changing
+            current_state = (intptr_t)GetProp(hWnd, WIN_STATE_PROP);
+
+            if (current_state == state)
+                return;
+
+            SetProp(hWnd, WIN_STATE_PROP, (HANDLE)(intptr_t)state);
+
+            switch (state)
+                {
+                case XCB_ICCCM_WM_STATE_ICONIC:
+                    ShowWindow(hWnd, SW_SHOWMINNOACTIVE);
+                    break;
+
+#define XCB_ICCCM_WM_STATE_ZOOM 2
+                case XCB_ICCCM_WM_STATE_ZOOM:
+                    // There doesn't seem to be a SW_SHOWMAXNOACTIVE.  Hopefully
+                    // always activating a maximized window isn't so bad...
+                    ShowWindow(hWnd, SW_SHOWMAXIMIZED);
+                    break;
+
+                case XCB_ICCCM_WM_STATE_NORMAL:
+                    ShowWindow(hWnd, SW_SHOWNOACTIVATE);
+                    break;
+
+                case XCB_ICCCM_WM_STATE_WITHDRAWN:
+                    ShowWindow(hWnd, SW_HIDE);
+                    break;
+                }
+        }
+
+    // Update WM_STATE property
+    {
+        // ZoomState is obsolete in ICCCM, so map it to NormalState
+        int icccm_state = state;
+        int icccm_current_state = current_state;
+
+        if (icccm_state == XCB_ICCCM_WM_STATE_ZOOM)
+            icccm_state = XCB_ICCCM_WM_STATE_NORMAL;
+
+        if (icccm_current_state == XCB_ICCCM_WM_STATE_ZOOM)
+            icccm_current_state = XCB_ICCCM_WM_STATE_NORMAL;
+
+        // Don't change property unnecessarily
+        //
+        // (Note that we do not take notice of WM_STATE PropertyNotify, only
+        // WM_CHANGE_STATE ClientMessage, so this should not cause the state to
+        // change itself)
+        if (icccm_current_state != icccm_state)
+            {
+                struct
+                {
+                    CARD32 state;
+                    XID     icon;
+                } wmstate;
+
+                wmstate.state = icccm_state;
+                wmstate.icon = None;
+
+                xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
+                                    iWindow, pWMInfo->atmWmState,
+                                    pWMInfo->atmWmState, 32,
+                                    sizeof(wmstate)/sizeof(int),
+                                    (unsigned char *) &wmstate);
+            }
+    }
 
-    ShowWindow(hWnd, SW_MINIMIZE);
+    // Update _NET_WM_STATE property
+    if (state == XCB_ICCCM_WM_STATE_WITHDRAWN) {
+        xcb_delete_property(pWMInfo->conn, iWindow, pWMInfo->ewmh._NET_WM_STATE);
+    }
+    else {
+        xcb_get_property_cookie_t cookie;
+        xcb_get_property_reply_t *reply;
+
+        cookie = xcb_get_property(pWMInfo->conn, FALSE, iWindow,
+                                  pWMInfo->ewmh._NET_WM_STATE,
+                                  XCB_ATOM_ATOM,
+                                  0, INT_MAX);
+        reply = xcb_get_property_reply(pWMInfo->conn, cookie, NULL);
+        if (reply) {
+            int nitems = xcb_get_property_value_length(reply)/sizeof(xcb_atom_t);
+            xcb_atom_t *pAtom = xcb_get_property_value(reply);
+            unsigned long i, o = 0;
+            xcb_atom_t *netwmstate=alloca((nitems + 2)*sizeof(xcb_atom_t));
+            Bool changed = FALSE;
+
+            // Make a copy with _NET_WM_HIDDEN, _NET_WM_MAXIMIZED_{VERT,HORZ}
+            // removed
+            for (i = 0; i < nitems; i++) {
+                if ((pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_HIDDEN) &&
+                    (pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                    (pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                    netwmstate[o++] = pAtom[i];
+            }
+            free(reply);
+
+            // if iconized, add _NET_WM_HIDDEN
+            if (state == XCB_ICCCM_WM_STATE_ICONIC) {
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_HIDDEN;
+            }
+
+            // if maximized, add  _NET_WM_MAXIMIZED_{VERT,HORZ}
+            if (state == XCB_ICCCM_WM_STATE_ZOOM) {
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT;
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ;
+            }
+
+            // Don't change property unnecessarily
+            if (nitems != o)
+                changed = TRUE;
+            else
+                for (i = 0; i < nitems; i++)
+                    {
+                        if (pAtom[i] != netwmstate[i])
+                            {
+                                changed = TRUE;
+                                break;
+                            }
+                    }
+
+            if (changed)
+                xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
+                                    iWindow,
+                                    pWMInfo->ewmh._NET_WM_STATE,
+                                    XCB_ATOM_ATOM, 32,
+                                    o, (unsigned char *) &netwmstate);
+        }
+    }
 }
 
 #if 0
@@ -788,12 +932,12 @@ winMultiWindowWMProc(void *pArg)
     WMProcArgPtr pProcArg = (WMProcArgPtr) pArg;
     WMInfoPtr pWMInfo = pProcArg->pWMInfo;
 
+    pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
+
     /* Initialize the Window Manager */
     winInitMultiWindowWM(pWMInfo, pProcArg);
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("winMultiWindowWMProc ()\n");
-#endif
+    winDebug ("winMultiWindowWMProc ()\n");
 
     /* Loop until we explicitly break out */
     for (;;) {
@@ -808,21 +952,11 @@ winMultiWindowWMProc(void *pArg)
             pthread_exit(NULL);
         }
 
-#if CYGMULTIWINDOW_DEBUG
-        ErrorF("winMultiWindowWMProc - MSG: %s (%d) ID: %d\n",
+        winDebug("winMultiWindowWMProc - MSG: %s (%d) ID: %d\n",
                MessageName(&(pNode->msg)), (int)pNode->msg.msg, (int)pNode->msg.dwID);
-#endif
 
         /* Branch on the message type */
         switch (pNode->msg.msg) {
-#if 0
-        case WM_WM_MOVE:
-            break;
-
-        case WM_WM_SIZE:
-            break;
-#endif
-
         case WM_WM_RAISE:
             /* Raise the window */
             {
@@ -831,9 +965,6 @@ winMultiWindowWMProc(void *pArg)
                                      XCB_CONFIG_WINDOW_STACK_MODE, values);
             }
 
-#if 0
-            PreserveWin32Stack(pWMInfo, pNode->msg.iWindow, GW_HWNDPREV);
-#endif
             break;
 
         case WM_WM_LOWER:
@@ -855,6 +986,9 @@ winMultiWindowWMProc(void *pArg)
             break;
 
         case WM_WM_MAP_MANAGED:
+          {
+            unsigned long maxmin = 0;
+
             /* Put a note as to the HWND associated with this Window */
             xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
                                 pNode->msg.iWindow, pWMInfo->atmPrivMap,
@@ -862,9 +996,7 @@ winMultiWindowWMProc(void *pArg)
                                 sizeof(HWND)/4, &(pNode->msg.hwndWindow));
 
             UpdateName(pWMInfo, pNode->msg.iWindow);
-            UpdateIcon(pWMInfo, pNode->msg.iWindow);
-            UpdateStyle(pWMInfo, pNode->msg.iWindow);
-
+            UpdateStyle(pWMInfo, pNode->msg.iWindow, &maxmin, 1);
 
             /* Reshape */
             {
@@ -876,6 +1008,20 @@ winMultiWindowWMProc(void *pArg)
                 }
             }
 
+            UpdateIcon(pWMInfo, pNode->msg.iWindow);
+            /* Establish initial state */
+            UpdateState(pWMInfo, pNode->msg.iWindow, XCB_ICCCM_WM_STATE_NORMAL);
+
+            /*
+              It only makes sense to apply minimize/maximize override as the
+              initial state, otherwise that state can't be changed.
+            */
+            if (maxmin & HINT_MAX)
+                SendMessage(pNode->msg.hwndWindow, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
+            else if (maxmin & HINT_MIN)
+                SendMessage(pNode->msg.hwndWindow, WM_SYSCOMMAND, SC_MINIMIZE, 0);
+          }
+
             break;
 
         case WM_WM_UNMAP:
@@ -909,6 +1055,7 @@ winMultiWindowWMProc(void *pArg)
                -- independently, the WM_TAKE_FOCUS protocol determines whether
                the WM should send a WM_TAKE_FOCUS ClientMessage.
             */
+            if (pNode->msg.iWindow)
             {
               Bool neverFocus = FALSE;
               xcb_get_property_cookie_t cookie;
@@ -922,7 +1069,7 @@ winMultiWindowWMProc(void *pArg)
               }
 
               if (!neverFocus)
-                xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_POINTER_ROOT,
+                xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_PARENT,
                                     pNode->msg.iWindow, XCB_CURRENT_TIME);
 
               if (IsWmProtocolAvailable(pWMInfo,
@@ -932,6 +1079,13 @@ winMultiWindowWMProc(void *pArg)
                              pNode->msg.iWindow,
                              pWMInfo->atmWmProtos, pWMInfo->atmWmTakeFocus);
 
+            }
+            else
+            /* Set the input focus to none */
+            {
+              xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_NONE,
+                                  XCB_NONE, XCB_CURRENT_TIME);
+
             }
             break;
 
@@ -945,16 +1099,14 @@ winMultiWindowWMProc(void *pArg)
 
         case WM_WM_HINTS_EVENT:
             {
-            /* Don't do anything if this is an override-redirect window */
-            if (IsOverrideRedirect(pWMInfo->conn, pNode->msg.iWindow))
-              break;
+            unsigned long maxmin = 0;
 
-            UpdateStyle(pWMInfo, pNode->msg.iWindow);
+            UpdateStyle(pWMInfo, pNode->msg.iWindow, &maxmin, 0);
             }
             break;
 
         case WM_WM_CHANGE_STATE:
-            UpdateState(pWMInfo, pNode->msg.iWindow);
+            UpdateState(pWMInfo, pNode->msg.iWindow, pNode->msg.dwID);
             break;
 
         default:
@@ -963,9 +1115,6 @@ winMultiWindowWMProc(void *pArg)
             break;
         }
 
-        /* Free the retrieved message */
-        free(pNode);
-
         /* Flush any pending events on our display */
         xcb_flush(pWMInfo->conn);
 
@@ -974,15 +1123,24 @@ winMultiWindowWMProc(void *pArg)
             xcb_generic_event_t *event = xcb_poll_for_event(pWMInfo->conn);
             if (event) {
                 if ((event->response_type & ~0x80) == 0) {
+                    const char *extension;
                     xcb_generic_error_t *err = (xcb_generic_error_t *)event;
-                    ErrorF("winMultiWindowWMProc - Error code: %i, ID: 0x%08x, "
-                           "Major opcode: %i, Minor opcode: %i\n",
-                           err->error_code, err->resource_id,
-                           err->major_code, err->minor_code);
+                    ErrorF("winMultiWindowWMProc - Error code: %i (%s), ID: 0x%08x, "
+                           "Major opcode: %i (%s), Minor opcode: %i (%s)\n",
+                           err->error_code,
+                           xcb_errors_get_name_for_error(pWMInfo->err_ctx, err->error_code, &extension),
+                           err->resource_id,
+                           err->major_code,
+                           xcb_errors_get_name_for_major_code(pWMInfo->err_ctx, err->major_code),
+                           err->minor_code,
+                           xcb_errors_get_name_for_minor_code(pWMInfo->err_ctx, err->major_code, err->minor_code));
                 }
             }
         }
 
+        /* Free the retrieved message */
+        free(pNode);
+
         /* I/O errors etc. */
         {
             int e = xcb_connection_has_error(pWMInfo->conn);
@@ -999,12 +1157,19 @@ winMultiWindowWMProc(void *pArg)
     /* Free the mutex variable */
     pthread_mutex_destroy(&pWMInfo->wmMsgQueue.pmMutex);
 
+    xcb_disconnect(pWMInfo->conn);
+    xcb_errors_context_free(pWMInfo->err_ctx);
+    pWMInfo->conn=NULL;
+    pWMInfo->err_ctx=NULL;
+
+
     /* Free the passed-in argument */
     free(pProcArg);
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("-winMultiWindowWMProc ()\n");
-#endif
+    winDebug("-winMultiWindowWMProc ()\n");
+
+    pthread_cleanup_pop(0);
+
     return NULL;
 }
 
@@ -1046,6 +1211,8 @@ winMultiWindowXMsgProc(void *pArg)
     xcb_screen_t *root_screen;
     xcb_window_t root_window_id;
 
+    pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
+
     winDebug("winMultiWindowXMsgProc - Hello\n");
 
     /* Check that argument pointer is not invalid */
@@ -1075,7 +1242,7 @@ winMultiWindowXMsgProc(void *pArg)
     winGetDisplayName(pszDisplay, (int) pProcArg->dwScreen);
 
     /* Print the display connection string */
-    ErrorF("winMultiWindowXMsgProc - DISPLAY=%s\n", pszDisplay);
+    winDebug("winMultiWindowXMsgProc - DISPLAY=%s\n", pszDisplay);
 
     /* Use our generated cookie for authentication */
     auth_info = winGetXcbAuthInfo();
@@ -1107,8 +1274,10 @@ winMultiWindowXMsgProc(void *pArg)
         pthread_exit(NULL);
     }
 
-    ErrorF("winMultiWindowXMsgProc - xcb_connect() returned and "
-           "successfully opened the display.\n");
+    winDebug("winMultiWindowXMsgProc - xcb_connect() returned and "
+             "successfully opened the display.\n");
+
+    xcb_errors_context_new(pProcArg->conn, &pProcArg->err_ctx);
 
     /* Check if another window manager is already running */
     if (CheckAnotherWindowManager(pProcArg->conn, pProcArg->dwScreen)) {
@@ -1149,16 +1318,6 @@ winMultiWindowXMsgProc(void *pArg)
     atmWindowType = intern_atom(pProcArg->conn, "_NET_WM_WINDOW_TYPE");
     atmNormalHints = intern_atom(pProcArg->conn, "WM_NORMAL_HINTS");
 
-    /*
-       iiimxcf had a bug until 2009-04-27, assuming that the
-       WM_STATE atom exists, causing clients to fail with
-       a BadAtom X error if it doesn't.
-
-       Since this is on in the default Solaris 10 install,
-       workaround this by making sure it does exist...
-     */
-    intern_atom(pProcArg->conn, "WM_STATE");
-
     /*
       Enable Composite extension and redirect subwindows of the root window
      */
@@ -1218,11 +1377,17 @@ winMultiWindowXMsgProc(void *pArg)
 
         /* Branch on event type */
         if (type == 0) {
+            const char *extension;
             xcb_generic_error_t *err = (xcb_generic_error_t *)event;
-            ErrorF("winMultiWindowXMsgProc - Error code: %i, ID: 0x%08x, "
-                   "Major opcode: %i, Minor opcode: %i\n",
-                   err->error_code, err->resource_id,
-                   err->major_code, err->minor_code);
+            ErrorF("winMultiWindowWMProc - Error code: %i (%s), ID: 0x%08x, "
+                "Major opcode: %i (%s), Minor opcode: %i (%s)\n",
+                err->error_code,
+                xcb_errors_get_name_for_error(pProcArg->err_ctx, err->error_code, &extension),
+                err->resource_id,
+                err->major_code,
+                xcb_errors_get_name_for_major_code(pProcArg->err_ctx, err->major_code),
+                err->minor_code,
+                xcb_errors_get_name_for_minor_code(pProcArg->err_ctx, err->major_code, err->minor_code));
             }
         else if (type == XCB_CREATE_NOTIFY) {
             xcb_create_notify_event_t *notify = (xcb_create_notify_event_t *)event;
@@ -1281,6 +1446,7 @@ winMultiWindowXMsgProc(void *pArg)
                     event_send.parent = reply_qt->parent;
                     event_send.x = reply->x;
                     event_send.y = reply->y;
+                    event_send.override_redirect = False;
 
                     xcb_send_event (pProcArg->conn, TRUE, notify->window,
                                     XCB_EVENT_MASK_STRUCTURE_NOTIFY,
@@ -1291,6 +1457,16 @@ winMultiWindowXMsgProc(void *pArg)
                 }
             }
         }
+        else if (type == XCB_UNMAP_NOTIFY) {
+            xcb_unmap_notify_event_t *notify = (xcb_unmap_notify_event_t *)event;
+
+            memset(&msg, 0, sizeof(msg));
+            msg.msg = WM_WM_CHANGE_STATE;
+            msg.iWindow = notify->window;
+            msg.dwID = XCB_ICCCM_WM_STATE_WITHDRAWN;
+
+            winSendMessageToWM(pProcArg->pWMInfo, &msg);
+        }
         else if (type == XCB_CONFIGURE_NOTIFY) {
             if (!send_event) {
                 /*
@@ -1317,6 +1493,15 @@ winMultiWindowXMsgProc(void *pArg)
         else if (type ==  XCB_PROPERTY_NOTIFY) {
             xcb_property_notify_event_t *notify = (xcb_property_notify_event_t *)event;
 
+            xcb_get_atom_name_cookie_t cookie = xcb_get_atom_name(pProcArg->conn, notify->atom);
+            xcb_get_atom_name_reply_t *reply = xcb_get_atom_name_reply(pProcArg->conn, cookie, NULL);
+            if (reply) {
+                winDebug("winMultiWindowXMsgProc: PropertyNotify %.*s\n",
+                         xcb_get_atom_name_name_length(reply),
+                         xcb_get_atom_name_name(reply));
+                free(reply);
+            }
+
             if ((notify->atom == atmWmName) ||
                 (notify->atom == atmNetWmName)) {
                 memset(&msg, 0, sizeof(msg));
@@ -1368,9 +1553,51 @@ winMultiWindowXMsgProc(void *pArg)
 
                 msg.msg = WM_WM_CHANGE_STATE;
                 msg.iWindow = client_msg->window;
+                msg.dwID = client_msg->data.data32[0];
 
                 winSendMessageToWM(pProcArg->pWMInfo, &msg);
             }
+            else if (client_msg->type == pProcArg->pWMInfo->ewmh._NET_WM_STATE) {
+                int action = client_msg->data.data32[0];
+                int state = -1;
+
+                if (action == XCB_EWMH_WM_STATE_ADD) {
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                        state = XCB_ICCCM_WM_STATE_ZOOM;
+
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT))
+                        state = XCB_ICCCM_WM_STATE_ZOOM;
+
+                    if (client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_HIDDEN)
+                        state = XCB_ICCCM_WM_STATE_ICONIC;
+                }
+                else if (action == XCB_EWMH_WM_STATE_REMOVE) {
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT))
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+
+                    if (client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_HIDDEN)
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+                }
+                else {
+                    ErrorF("winMultiWindowXMsgProc: ClientMEssage _NET_WM_STATE unsupported action %d\n", action);
+                }
+
+                if (state != -1) {
+                    memset(&msg, 0, sizeof(msg));
+                    msg.msg = WM_WM_CHANGE_STATE;
+                    msg.iWindow = client_msg->window;
+                    msg.dwID = state;
+
+                    winSendMessageToWM(pProcArg->pWMInfo, &msg);
+                }
+            }
         }
 
         /* Free the event */
@@ -1378,7 +1605,9 @@ winMultiWindowXMsgProc(void *pArg)
     }
 
     xcb_disconnect(pProcArg->conn);
-    pthread_exit(NULL);
+    xcb_errors_context_free(pProcArg->err_ctx);
+    pthread_cleanup_pop(0);
+
     return NULL;
 }
 
@@ -1446,9 +1675,7 @@ winInitWM(void **ppWMInfo,
         return FALSE;
     }
 
-#if CYGDEBUG || YES
     winDebug("winInitWM - Returning.\n");
-#endif
 
     return TRUE;
 }
@@ -1496,7 +1723,7 @@ winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
     winGetDisplayName(pszDisplay, (int) pProcArg->dwScreen);
 
     /* Print the display connection string */
-    ErrorF("winInitMultiWindowWM - DISPLAY=%s\n", pszDisplay);
+    winDebug("winInitMultiWindowWM - DISPLAY=%s\n", pszDisplay);
 
     /* Use our generated cookie for authentication */
     auth_info = winGetXcbAuthInfo();
@@ -1525,8 +1752,10 @@ winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
         pthread_exit(NULL);
     }
 
-    ErrorF("winInitMultiWindowWM - xcb_connect () returned and "
-           "successfully opened the display.\n");
+    winDebug("winInitMultiWindowWM - xcb_connect () returned and "
+             "successfully opened the display.\n");
+
+    xcb_errors_context_new(pWMInfo->conn, &pWMInfo->err_ctx);
 
     /* Create some atoms */
     pWMInfo->atmWmProtos = intern_atom(pWMInfo->conn, "WM_PROTOCOLS");
@@ -1538,6 +1767,7 @@ winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
     pWMInfo->atmCurrentDesktop = intern_atom(pWMInfo->conn, "_NET_CURRENT_DESKTOP");
     pWMInfo->atmNumberDesktops = intern_atom(pWMInfo->conn, "_NET_NUMBER_OF_DESKTOPS");
     pWMInfo->atmDesktopNames = intern_atom(pWMInfo->conn, "__NET_DESKTOP_NAMES");
+    pWMInfo->atmWmState = intern_atom(pWMInfo->conn, "WM_STATE");
 
     /* Initialization for the xcb_ewmh and EWMH atoms */
     {
@@ -1562,6 +1792,8 @@ winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
                     pWMInfo->ewmh._NET_WM_STATE_ABOVE,
                     pWMInfo->ewmh._NET_WM_STATE_BELOW,
                     pWMInfo->ewmh._NET_WM_STATE_SKIP_TASKBAR,
+                    pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT,
+                    pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ,
                 };
 
             xcb_ewmh_set_supported(&pWMInfo->ewmh, pProcArg->dwScreen,
@@ -1627,6 +1859,19 @@ winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
     }
 }
 
+/*
+ * winMultiWindowThreadExit - Thread exit handler
+ */
+
+static void
+winMultiWindowThreadExit(void *arg)
+{
+    ddxGiveUp(EXIT_ERR_ABORT);
+
+    /* multiwindow client thread has exited, stop server as well */
+    TerminateProcess(GetCurrentProcess(),1);
+}
+
 /*
  * winSendMessageToWM - Send a message from the X thread to the WM thread
  */
@@ -1636,9 +1881,7 @@ winSendMessageToWM(void *pWMInfo, winWMMessagePtr pMsg)
 {
     WMMsgNodePtr pNode;
 
-#if CYGMULTIWINDOW_DEBUG
-    ErrorF("winSendMessageToWM %s\n", MessageName(pMsg));
-#endif
+    winDebug("winSendMessageToWM %s\n", MessageName(pMsg));
 
     pNode = malloc(sizeof(WMMsgNodeRec));
     if (pNode != NULL) {
@@ -1702,7 +1945,8 @@ CheckAnotherWindowManager(xcb_connection_t *conn, DWORD dwScreen)
 void
 winDeinitMultiWindowWM(void)
 {
-    ErrorF("winDeinitMultiWindowWM - Noting shutdown in progress\n");
+    if (g_shutdown == TRUE) return;
+    winDebug("winDeinitMultiWindowWM - Noting shutdown in progress\n");
     g_shutdown = TRUE;
 }
 
@@ -1715,14 +1959,10 @@ winDeinitMultiWindowWM(void)
 #define HINT_NOMINIMIZE (1L<<5)
 #define HINT_NOSYSMENU  (1L<<6)
 #define HINT_SKIPTASKBAR (1L<<7)
-/* These two are used on their own */
-#define HINT_MAX	(1L<<0)
-#define HINT_MIN	(1L<<1)
 
 static void
-winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
+winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle, unsigned long *maxmin)
 {
-
     xcb_connection_t *conn = pWMInfo->conn;
     static xcb_atom_t windowState, motif_wm_hints;
     static xcb_atom_t hiddenState, fullscreenState, belowState, aboveState,
@@ -1730,8 +1970,13 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
     static xcb_atom_t splashType;
     static int generation;
 
-    unsigned long hint = 0, maxmin = 0;
+    unsigned long hint = HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION;
+    unsigned long taskbar = 0;
     unsigned long style, exStyle;
+    unsigned long oristyle, oriexStyle;
+    Bool nodecoration = FALSE;
+
+    *maxmin = 0;
 
     if (!hWnd)
         return;
@@ -1757,20 +2002,29 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
         int i;
         int nitems = xcb_get_property_value_length(reply)/sizeof(xcb_atom_t);
         xcb_atom_t *pAtom = xcb_get_property_value(reply);
+        Bool verMax = FALSE;
+        Bool horMax = FALSE;
 
             for (i = 0; i < nitems; i++) {
                 if (pAtom[i] == skiptaskbarState)
                     hint |= HINT_SKIPTASKBAR;
                 if (pAtom[i] == hiddenState)
-                    maxmin |= HINT_MIN;
+                    *maxmin |= HINT_MIN;
                 else if (pAtom[i] == fullscreenState)
-                    maxmin |= HINT_MAX;
+                    *maxmin |= HINT_MAX;
                 if (pAtom[i] == belowState)
                     *zstyle = HWND_BOTTOM;
                 else if (pAtom[i] == aboveState)
                     *zstyle = HWND_TOPMOST;
+                if (pAtom[i] == pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT)
+                  verMax = TRUE;
+                if (pAtom[i] == pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ)
+                  horMax = TRUE;
             }
 
+            if (verMax && horMax)
+              *maxmin |= HINT_MAX;
+
             free(reply);
       }
     }
@@ -1783,15 +2037,47 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
         MwmHints *mwm_hint = xcb_get_property_value(reply);
         if (mwm_hint && (nitems >= PropMwmHintsElements) &&
             (mwm_hint->flags & MwmHintsDecorations)) {
-            if (!mwm_hint->decorations)
-                hint |= (HINT_NOFRAME | HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE);
-            else if (!(mwm_hint->decorations & MwmDecorAll)) {
-                if (mwm_hint->decorations & MwmDecorBorder)
-                    hint |= HINT_BORDER;
-                if (mwm_hint->decorations & MwmDecorHandle)
-                    hint |= HINT_SIZEBOX;
-                if (mwm_hint->decorations & MwmDecorTitle)
-                    hint |= HINT_CAPTION;
+          if (!mwm_hint->decorations)
+          {
+            WindowPtr pWin = GetProp(hWnd, WIN_WINDOW_PROP);
+            if (pWin)
+            {
+              int iX, iY, iWidth, iHeight;
+              int monitorHeight= GetSystemMetrics(SM_CYVIRTUALSCREEN);
+              float proportion;
+              DrawablePtr pDraw = &pWin->drawable;
+
+              /* Get the X and Y location of the X window */
+              iX = pWin->drawable.x + GetSystemMetrics(SM_XVIRTUALSCREEN);
+              iY = pWin->drawable.y + GetSystemMetrics(SM_YVIRTUALSCREEN);
+
+              /* Get the height and width of the X window */
+              iWidth = pWin->drawable.width;
+              iHeight = pWin->drawable.height;
+
+              proportion= ((float)pWin->drawable.height)/monitorHeight;
+              winDebug("nodecoration %x = proportion %f\n",hWnd,proportion);
+              if( proportion>0.95 && proportion<1.00)
+              {   // if height is inside 5% of full range , make it fullscreen (there is no HINT_FULLSCREEN)
+                winDebug("nodecoration %x SET fullscreen\n",hWnd);
+                *maxmin |= HINT_MAX; // make fullscreen !
+              }
+              pWin->borderWidth=0;
+            }
+
+            hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION | HINT_NOFRAME);
+            hint |= ( HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE | HINT_NOFRAME);
+            nodecoration = TRUE;
+            winDebug("nodecoration %x = TRUE\n",hWnd);
+          }
+          else if (!(mwm_hint->decorations & MwmDecorAll))
+            {
+                if (!(mwm_hint->decorations & MwmDecorBorder))
+                    hint &= ~HINT_BORDER;
+                if (!(mwm_hint->decorations & MwmDecorHandle))
+                    hint &= ~HINT_SIZEBOX;
+                if (!(mwm_hint->decorations & MwmDecorTitle))
+                    hint &= ~HINT_CAPTION;
                 if (!(mwm_hint->decorations & MwmDecorMenu))
                     hint |= HINT_NOSYSMENU;
                 if (!(mwm_hint->decorations & MwmDecorMinimize))
@@ -1799,7 +2085,8 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
                 if (!(mwm_hint->decorations & MwmDecorMaximize))
                     hint |= HINT_NOMAXIMIZE;
             }
-            else {
+            else
+            {
                 /*
                    MwmDecorAll means all decorations *except* those specified by other flag
                    bits that are set.  Not yet implemented.
@@ -1817,11 +2104,13 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
       if (xcb_ewmh_get_wm_window_type_reply(&pWMInfo->ewmh, cookie, &type, NULL)) {
         for (i = 0; i < type.atoms_len; i++) {
             if (type.atoms[i] ==  pWMInfo->ewmh._NET_WM_WINDOW_TYPE_DOCK) {
-                hint = (hint & ~HINT_NOFRAME) | HINT_SKIPTASKBAR | HINT_SIZEBOX;
+                hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION | HINT_NOFRAME);
+                hint |= (HINT_SKIPTASKBAR | HINT_SIZEBOX);
                 *zstyle = HWND_TOPMOST;
             }
             else if ((type.atoms[i] == pWMInfo->ewmh._NET_WM_WINDOW_TYPE_SPLASH)
                      || (type.atoms[i] == splashType)) {
+                hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION);
                 hint |= (HINT_SKIPTASKBAR | HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE);
                 *zstyle = HWND_TOPMOST;
             }
@@ -1835,8 +2124,14 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
 
         cookie = xcb_icccm_get_wm_normal_hints(conn, iWindow);
         if (xcb_icccm_get_wm_normal_hints_reply(conn, cookie, &size_hints, NULL)) {
-            if (size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE) {
+            /* Notwithstanding MwmDecorHandle, if we have a border, and
+               WM_NORMAL_HINTS indicates the window should be resizeable, let
+               the window have a resizing border.  This is necessary for windows
+               with gtk3+ 3.14 csd. */
+            if (hint & HINT_BORDER)
+                hint |= HINT_SIZEBOX;
 
+            if (size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE) {
                 /* Not maximizable if a maximum size is specified, and that size
                    is smaller (in either dimension) than the screen size */
                 if ((size_hints.max_width < GetSystemMetrics(SM_CXVIRTUALSCREEN))
@@ -1849,8 +2144,10 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
                        don't bother with a resizing frame
                      */
                     if ((size_hints.min_width == size_hints.max_width)
-                        && (size_hints.min_height == size_hints.max_height))
+                        && (size_hints.min_height == size_hints.max_height)) {
+                        hint |= HINT_NOMAXIMIZE;
                         hint = (hint & ~HINT_SIZEBOX);
+                    }
                 }
             }
         }
@@ -1865,44 +2162,49 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
         char *window_name = 0;
         char *res_name = 0;
         char *res_class = 0;
+        char *rand_id = 0;
 
         GetClassNames(pWMInfo, iWindow, &res_name, &res_class, &window_name);
 
         style = STYLE_NONE;
         style = winOverrideStyle(res_name, res_class, window_name);
+        taskbar = winOverrideTaskbar(res_name, res_class, window_name);
 
-#define APPLICATION_ID_FORMAT	"%s.xwin.%s"
-#define APPLICATION_ID_UNKNOWN "unknown"
-        if (res_class) {
-            asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
-                     res_class);
-        }
-        else {
-            asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
-                     APPLICATION_ID_UNKNOWN);
+        if (taskbar & TASKBAR_NEWTAB) {
+            int irand_id;
+            srand((unsigned)time(NULL));
+            irand_id = rand();
+            asprintf(&rand_id, "%d", irand_id);
         }
+        /* AppUserModelID in the following form CompanyName.ProductName.SubProduct.VersionInformation
+           VersionInformation is set random with NEWTAB and to display-number normally. No spaces allowed. */
+        asprintf(&application_id,
+                 "%s.%s.%s.%s",
+                 XVENDORNAME,
+                 PROJECT_NAME,
+                 (res_class) ? res_class :
+                 (res_name) ? res_name :
+                 (window_name) ? window_name : "SubProductUnknown",
+                 (taskbar & TASKBAR_NEWTAB) ? rand_id :
+                 (getenv("DISNO")) ? getenv("DISNO") : 0);
         winSetAppUserModelID(hWnd, application_id);
 
         free(application_id);
         free(res_name);
         free(res_class);
         free(window_name);
+        free(rand_id);
     }
 
     if (style & STYLE_TOPMOST)
         *zstyle = HWND_TOPMOST;
     else if (style & STYLE_MAXIMIZE)
-        maxmin = (hint & ~HINT_MIN) | HINT_MAX;
+        *maxmin = (hint & ~HINT_MIN) | HINT_MAX;
     else if (style & STYLE_MINIMIZE)
-        maxmin = (hint & ~HINT_MAX) | HINT_MIN;
+        *maxmin = (hint & ~HINT_MAX) | HINT_MIN;
     else if (style & STYLE_BOTTOM)
         *zstyle = HWND_BOTTOM;
 
-    if (maxmin & HINT_MAX)
-        SendMessage(hWnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
-    else if (maxmin & HINT_MIN)
-        SendMessage(hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
-
     if (style & STYLE_NOTITLE)
         hint =
             (hint & ~HINT_NOFRAME & ~HINT_BORDER & ~HINT_CAPTION) |
@@ -1916,14 +2218,18 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
             (hint & ~HINT_BORDER & ~HINT_CAPTION & ~HINT_SIZEBOX) |
             HINT_NOFRAME;
 
+    if (taskbar & TASKBAR_NOTAB)
+        hint |= HINT_SKIPTASKBAR;
+
     /* Now apply styles to window */
     style = GetWindowLongPtr(hWnd, GWL_STYLE);
     if (!style)
         return;                 /* GetWindowLongPointer returns 0 on failure, we hope this isn't a valid style */
+    oristyle = style;
 
     style &= ~WS_CAPTION & ~WS_SIZEBOX; /* Just in case */
 
-    if (!(hint & ~HINT_SKIPTASKBAR))    /* No hints, default */
+    if (!(hint & ~(HINT_SKIPTASKBAR|HINT_NOMAXIMIZE)))    /* No hints, default */
         style = style | WS_CAPTION | WS_SIZEBOX;
     else if (hint & HINT_NOFRAME)       /* No frame, no decorations */
         style = style & ~WS_CAPTION & ~WS_SIZEBOX;
@@ -1941,17 +2247,41 @@ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
     if (hint & HINT_NOSYSMENU)
         style = style & ~WS_SYSMENU;
 
-    if (hint & HINT_SKIPTASKBAR)
+    if (hint & HINT_SKIPTASKBAR) {
         style = style & ~WS_MINIMIZEBOX;        /* window will become lost if minimized */
+    }
 
-    SetWindowLongPtr(hWnd, GWL_STYLE, style);
+    if (nodecoration)
+    {	// fullscreen
+        style &= ~(WS_THICKFRAME|WS_DLGFRAME|WS_SIZEBOX|WS_MAXIMIZEBOX|WS_MINIMIZEBOX|WS_SYSMENU|WS_MINIMIZEBOX|WS_CAPTION);
+        style |= WS_POPUP|WS_VISIBLE;
+        winDebug("nodecoration %x style SET %x\n", hWnd, style);
+    }
+
+    if (!IsWindow (hWnd))
+    {
+        ErrorF("Windows window 0x%x has become invalid, so returning without applying hints\n",hWnd);
+        return;
+    }
+
+    if (style!=oristyle)
+    {
+        if (hint & HINT_SKIPTASKBAR) {
+            winShowWindowOnTaskbar(hWnd, FALSE);
+        }
+        SetWindowLongPtr(hWnd, GWL_STYLE, style);
+    }
 
     exStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
+    oriexStyle=exStyle;
     if (hint & HINT_SKIPTASKBAR)
         exStyle = (exStyle & ~WS_EX_APPWINDOW) | WS_EX_TOOLWINDOW;
     else
         exStyle = (exStyle & ~WS_EX_TOOLWINDOW) | WS_EX_APPWINDOW;
-    SetWindowLongPtr(hWnd, GWL_EXSTYLE, exStyle);
+    if (exStyle!=oriexStyle)
+    {
+        SetWindowLongPtr(hWnd, GWL_EXSTYLE, exStyle);
+    }
 
     winDebug
         ("winApplyHints: iWindow 0x%08x hints 0x%08x style 0x%08x exstyle 0x%08x\n",
@@ -1964,6 +2294,8 @@ winUpdateWindowPosition(HWND hWnd, HWND * zstyle)
     int iX, iY, iWidth, iHeight;
     int iDx, iDy;
     RECT rcNew;
+    HMONITOR hMonitor;
+    MONITORINFO monitorInfo;
     WindowPtr pWin = GetProp(hWnd, WIN_WINDOW_PROP);
     DrawablePtr pDraw = NULL;
 
@@ -1984,28 +2316,27 @@ winUpdateWindowPosition(HWND hWnd, HWND * zstyle)
     /* Setup a rectangle with the X window position and size */
     SetRect(&rcNew, iX, iY, iX + iWidth, iY + iHeight);
 
-    winDebug("winUpdateWindowPosition - drawable extent (%d, %d)-(%d, %d)\n",
-             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);
-
     AdjustWindowRectEx(&rcNew, GetWindowLongPtr(hWnd, GWL_STYLE), FALSE,
                        GetWindowLongPtr(hWnd, GWL_EXSTYLE));
 
-    /* Don't allow window decoration to disappear off to top-left as a result of this adjustment */
-    if (rcNew.left < GetSystemMetrics(SM_XVIRTUALSCREEN)) {
-        iDx = GetSystemMetrics(SM_XVIRTUALSCREEN) - rcNew.left;
+    hMonitor=MonitorFromWindow(hWnd, MONITOR_DEFAULTTONEAREST);
+    monitorInfo.cbSize=sizeof(monitorInfo);
+    if (GetMonitorInfo(hMonitor, &monitorInfo))
+    {
+      /* Don't allow window decoration to disappear off to top-left as a result of this adjustment */
+      if (rcNew.left < monitorInfo.rcMonitor.left) {
+        iDx = monitorInfo.rcMonitor.left - rcNew.left;
         rcNew.left += iDx;
         rcNew.right += iDx;
-    }
+      }
 
-    if (rcNew.top < GetSystemMetrics(SM_YVIRTUALSCREEN)) {
-        iDy = GetSystemMetrics(SM_YVIRTUALSCREEN) - rcNew.top;
+      if (rcNew.top < monitorInfo.rcMonitor.top) {
+        iDy = monitorInfo.rcMonitor.top - rcNew.top;
         rcNew.top += iDy;
         rcNew.bottom += iDy;
+      }
     }
 
-    winDebug("winUpdateWindowPosition - Window extent (%d, %d)-(%d, %d)\n",
-             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);
-
     /* Position the Windows window */
     SetWindowPos(hWnd, *zstyle, rcNew.left, rcNew.top,
                  rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, 0);
diff --git a/xserver/hw/xwin/winmultiwindowwndproc.c b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwndproc.c
index 31b5d63..42e30ee 100644
--- a/xserver/hw/xwin/winmultiwindowwndproc.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winmultiwindowwndproc.c
@@ -35,6 +35,10 @@
 #ifdef HAVE_XWIN_CONFIG_H
 #include <xwin-config.h>
 #endif
+#define GC tempGC  // This is to avoid name conflicts when including the next headers which also define GC
+#include <X11/Xutil.h>
+#include <X11/Xwindows.h>
+#undef GC
 
 #include "win.h"
 #include "dixevents.h"
@@ -50,6 +54,14 @@
 
 extern void winUpdateWindowPosition(HWND hWnd, HWND * zstyle);
 
+#ifdef XKB
+#ifndef XKB_IN_SERVER
+#define XKB_IN_SERVER
+#endif
+#include <xkbsrv.h>
+#endif
+
+
 /*
  * Local globals
  */
@@ -275,16 +287,43 @@ winRaiseWindow(WindowPtr pWin)
 {
     if (!winInDestroyWindowsWindow && !winInRaiseWindow) {
         BOOL oldstate = winInRaiseWindow;
-        XID vlist[1] = { 0 };
+        XID vlist[1];
+        vlist[0]= Above;
         winInRaiseWindow = TRUE;
         /* Call configure window directly to make sure it gets processed
          * in time
          */
-        ConfigureWindow(pWin, CWStackMode, vlist, serverClient);
+        winConfigureWindow(pWin, CWStackMode, vlist, serverClient);
         winInRaiseWindow = oldstate;
     }
 }
 
+static void raiseWinIfNeeded(WindowPtr pWin, HWND hwnd)
+{
+    /* Check if this window is top of X windows. */
+    HWND hWndAbove = NULL;
+    DWORD dwCurrentProcessID = GetCurrentProcessId();
+    DWORD dwWindowProcessID = 0;
+
+    for (hWndAbove = hwnd;
+            hWndAbove != NULL;
+            hWndAbove = GetNextWindow(hWndAbove, GW_HWNDPREV)) {
+        /* Ignore other XWin process's window */
+        GetWindowThreadProcessId(hWndAbove, &dwWindowProcessID);
+
+        if ((dwWindowProcessID == dwCurrentProcessID)
+                && GetProp(hWndAbove, WIN_WINDOW_PROP)
+                && !IsWindowVisible(hWndAbove)
+                && !IsIconic(hWndAbove))        /* ignore minimized windows */
+            break;
+    }
+    /* If this is top of X windows in Windows stack,
+       raise it in X stack. */
+    if (hWndAbove == NULL) {
+        winRaiseWindow(pWin);
+    }
+}
+
 static
     void
 winStartMousePolling(winPrivScreenPtr s_pScreenPriv)
@@ -320,7 +359,7 @@ typedef struct _WINCOMPATTR
 
 #define WCA_ACCENT_POLICY 19
 
-typedef WINBOOL WINAPI (*PFNSETWINDOWCOMPOSITIONATTRIBUTE)(HWND, WINCOMPATTR *);
+typedef BOOL (WINAPI *PFNSETWINDOWCOMPOSITIONATTRIBUTE)(HWND, WINCOMPATTR *);
 
 static void
 CheckForAlpha(HWND hWnd, WindowPtr pWin, winScreenInfo *pScreenInfo)
@@ -407,6 +446,38 @@ CheckForAlpha(HWND hWnd, WindowPtr pWin, winScreenInfo *pScreenInfo)
         }
 }
 
+void DispatchQueuedEvents(Bool);
+#define UPDATETIMER 1234
+
+static
+void
+winAdjustXWindowState(winPrivScreenPtr s_pScreenPriv, winWMMessageRec *wmMsg)
+{
+    /* Do nothing if window has not yet been given initial state */
+    if (!GetProp(wmMsg->hwndWindow, WIN_STATE_PROP))
+        return;
+
+    wmMsg->msg = WM_WM_CHANGE_STATE;
+    if (IsIconic(wmMsg->hwndWindow)) {
+        wmMsg->dwID = 3; // IconicState
+        winSendMessageToWM(s_pScreenPriv->pWMInfo, wmMsg);
+    }
+    else if (IsZoomed(wmMsg->hwndWindow)) {
+        wmMsg->dwID = 2; // ZoomState
+        winSendMessageToWM(s_pScreenPriv->pWMInfo, wmMsg);
+    }
+    else if (IsWindowVisible(wmMsg->hwndWindow)) {
+        wmMsg->dwID = 1; // NormalState
+        winSendMessageToWM(s_pScreenPriv->pWMInfo, wmMsg);
+     }
+    else {
+        /* Only the client, not the user can Withdraw windows, so it doesn't make
+           much sense to handle that state here, and anything else is an
+           unanticapted state. */
+        ErrorF("winAdjustXWindowState - Unknown state for %p\n", wmMsg->hwndWindow);
+    }
+}
+
 /*
  * winTopLevelWindowProc - Window procedure for all top-level Windows windows.
  */
@@ -424,16 +495,12 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     HWND hwndScreen = NULL;
     DrawablePtr pDraw = NULL;
     winWMMessageRec wmMsg;
-    Bool fWMMsgInitialized = FALSE;
     static Bool s_fTracking = FALSE;
     Bool needRestack = FALSE;
     LRESULT ret;
-    static Bool hasEnteredSizeMove = FALSE;
 
-#if CYGDEBUG
     winDebugWin32Message("winTopLevelWindowProc", hwnd, message, wParam,
                          lParam);
-#endif
 
     /*
        If this is WM_CREATE, set up the Windows window properties which point to
@@ -470,40 +537,16 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* */
         wmMsg.msg = 0;
         wmMsg.hwndWindow = hwnd;
-        wmMsg.iWindow = (Window) (INT_PTR) GetProp(hwnd, WIN_WID_PROP);
+        wmMsg.iWindow = pWin->drawable.id;
 
         wmMsg.iX = pDraw->x;
         wmMsg.iY = pDraw->y;
         wmMsg.iWidth = pDraw->width;
         wmMsg.iHeight = pDraw->height;
-
-        fWMMsgInitialized = TRUE;
-
-#if 0
-        /*
-         * Print some debugging information
-         */
-
-        ErrorF("hWnd %08X\n", hwnd);
-        ErrorF("pWin %08X\n", pWin);
-        ErrorF("pDraw %08X\n", pDraw);
-        ErrorF("\ttype %08X\n", pWin->drawable.type);
-        ErrorF("\tclass %08X\n", pWin->drawable.class);
-        ErrorF("\tdepth %08X\n", pWin->drawable.depth);
-        ErrorF("\tbitsPerPixel %08X\n", pWin->drawable.bitsPerPixel);
-        ErrorF("\tid %08X\n", pWin->drawable.id);
-        ErrorF("\tx %08X\n", pWin->drawable.x);
-        ErrorF("\ty %08X\n", pWin->drawable.y);
-        ErrorF("\twidth %08X\n", pWin->drawable.width);
-        ErrorF("\thenght %08X\n", pWin->drawable.height);
-        ErrorF("\tpScreen %08X\n", pWin->drawable.pScreen);
-        ErrorF("\tserialNumber %08X\n", pWin->drawable.serialNumber);
-        ErrorF("g_iWindowPrivateKey %p\n", g_iWindowPrivateKey);
-        ErrorF("pWinPriv %08X\n", pWinPriv);
-        ErrorF("s_pScreenPriv %08X\n", s_pScreenPriv);
-        ErrorF("s_pScreenInfo %08X\n", s_pScreenInfo);
-        ErrorF("hwndScreen %08X\n", hwndScreen);
-#endif
+    }
+    else
+    {
+        winDebug("Warning: message 0x%x received when WIN_WINDOW_PROP NULL\n",message);
     }
 
     /* Branch on message type */
@@ -524,10 +567,9 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             GetWindowRect(hwnd, &rWindow);
             hRgnWindow = CreateRectRgnIndirect(&rWindow);
             SetWindowRgn(hwnd, hRgnWindow, TRUE);
-            DeleteObject(hRgnWindow);
         }
 
-        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) XMING_SIGNATURE);
+        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)VCXSRV_SIGNATURE);
 
         CheckForAlpha(hwnd, pWin, s_pScreenInfo);
 
@@ -594,10 +636,18 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             /* Call the engine dependent repainter */
             if (*s_pScreenPriv->pwinBltExposedWindowRegion)
                 (*s_pScreenPriv->pwinBltExposedWindowRegion) (s_pScreen, pWin);
-
         return 0;
 
     case WM_MOUSEMOVE:
+        if (wParam & (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON))
+        {
+            if (lParam==GetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM))
+            {
+                return 0;  /* Ignore the mouse since the mouse was not moved wrt the button down click */
+            }
+            SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,-1);
+        }
+
         /* Unpack the client area mouse coordinates */
         ptMouse.x = GET_X_LPARAM(lParam);
         ptMouse.y = GET_Y_LPARAM(lParam);
@@ -681,6 +731,9 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         break;
 
     case WM_MOUSELEAVE:
+       /* We can't do anything without privates */
+        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
+            break;
         /* Mouse has left our client area */
 
         /* Flag that we are no longer tracking */
@@ -698,6 +751,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_LBUTTONDBLCLK:
     case WM_LBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         g_fButton[0] = TRUE;
@@ -714,6 +768,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_MBUTTONDBLCLK:
     case WM_MBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         g_fButton[1] = TRUE;
@@ -730,6 +785,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_RBUTTONDBLCLK:
     case WM_RBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         g_fButton[2] = TRUE;
@@ -746,6 +802,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_XBUTTONDBLCLK:
     case WM_XBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         SetCapture(hwnd);
@@ -801,6 +858,16 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* Add the keyboard hook if possible */
         if (g_fKeyboardHookLL)
             g_fKeyboardHookLL = winInstallKeyboardHookLL();
+
+        /* Tell our Window Manager thread to activate the window */
+        if (pWin)
+            {
+                wmMsg.msg = WM_WM_ACTIVATE;
+                /* don't focus override redirect windows (e.g. menus) */
+                if (!pWin->overrideRedirect)
+                    winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
+            }
+
         return 0;
 
     case WM_KILLFOCUS:
@@ -810,9 +877,13 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* Remove our keyboard hook if it is installed */
         winRemoveKeyboardHookLL();
 
-        /* Revert the X focus as well, but only if the Windows focus is going to another window */
-        if (!wParam && pWin)
-            DeleteWindowFromAnyEvents(pWin, FALSE);
+        /* Revert the X focus as well */
+        if (pWin)
+            {
+                wmMsg.msg = WM_WM_ACTIVATE;
+                wmMsg.iWindow = 0;
+                winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
+            }
 
         return 0;
 
@@ -844,7 +915,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         if (wParam == VK_F4 && (GetKeyState(VK_MENU) & 0x8000))
             break;
 
-#if CYGWINDOWING_DEBUG
+#ifdef WINDBG
         if (wParam == VK_ESCAPE) {
             /* Place for debug: put any tests and dumps here */
             WINDOWPLACEMENT windPlace;
@@ -854,25 +925,25 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             windPlace.length = sizeof(WINDOWPLACEMENT);
             GetWindowPlacement(hwnd, &windPlace);
             pRect = &windPlace.rcNormalPosition;
-            ErrorF("\nCYGWINDOWING Dump:\n"
+            winDebug ("\nCYGWINDOWING Dump:\n"
                    "\tdrawable: (%hd, %hd) - %hdx%hd\n", pDraw->x,
                    pDraw->y, pDraw->width, pDraw->height);
-            ErrorF("\twindPlace: (%d, %d) - %dx%d\n", (int)pRect->left,
+            winDebug("\twindPlace: (%d, %d) - %dx%d\n", (int)pRect->left,
                    (int)pRect->top, (int)(pRect->right - pRect->left),
                    (int)(pRect->bottom - pRect->top));
             if (GetClientRect(hwnd, &rc)) {
                 pRect = &rc;
-                ErrorF("\tClientRect: (%d, %d) - %dx%d\n", (int)pRect->left,
+                winDebug("\tClientRect: (%d, %d) - %dx%d\n", (int)pRect->left,
                        (int)pRect->top, (int)(pRect->right - pRect->left),
                        (int)(pRect->bottom - pRect->top));
             }
             if (GetWindowRect(hwnd, &rc)) {
                 pRect = &rc;
-                ErrorF("\tWindowRect: (%d, %d) - %dx%d\n", (int)pRect->left,
+                winDebug("\tWindowRect: (%d, %d) - %dx%d\n", (int)pRect->left,
                        (int)pRect->top, (int)(pRect->right - pRect->left),
                        (int)(pRect->bottom - pRect->top));
             }
-            ErrorF("\n");
+            winDebug ("\n");
         }
 #endif
 
@@ -896,26 +967,9 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* Pass the message to the root window */
         SendMessage(hwndScreen, message, wParam, lParam);
 
-        if (LOWORD(wParam) != WA_INACTIVE) {
-            /* Raise the window to the top in Z order */
-            /* ago: Activate does not mean putting it to front! */
-            /*
-               wmMsg.msg = WM_WM_RAISE;
-               if (fWMMsgInitialized)
-               winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
-             */
+        /* Allow DefWindowProc to SetFocus() as needed */
+        break;
 
-            /* Tell our Window Manager thread to activate the window */
-            wmMsg.msg = WM_WM_ACTIVATE;
-            if (fWMMsgInitialized)
-                if (!pWin || !pWin->overrideRedirect)   /* for OOo menus */
-                    winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
-        }
-        /* Prevent the mouse wheel from stalling when another window is minimized */
-        if (HIWORD(wParam) == 0 && LOWORD(wParam) == WA_ACTIVE &&
-            (HWND) lParam != NULL && (HWND) lParam != GetParent(hwnd))
-            SetFocus(hwnd);
-        return 0;
 
     case WM_ACTIVATEAPP:
         /*
@@ -935,7 +989,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         else {
             /* Tell our Window Manager thread to kill the window */
             wmMsg.msg = WM_WM_KILL;
-            if (fWMMsgInitialized)
+            if (pWin)
                 winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
         }
         return 0;
@@ -944,25 +998,27 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
         /* Branch on if the window was killed in X already */
         if (pWinPriv && !pWinPriv->fXKilled) {
-            ErrorF("winTopLevelWindowProc - WM_DESTROY - WM_WM_KILL\n");
+            winDebug ("winTopLevelWindowProc - WM_DESTROY - WM_WM_KILL\n");
 
             /* Tell our Window Manager thread to kill the window */
             wmMsg.msg = WM_WM_KILL;
-            if (fWMMsgInitialized)
+            if (pWin)
                 winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
         }
 
         RemoveProp(hwnd, WIN_WINDOW_PROP);
         RemoveProp(hwnd, WIN_WID_PROP);
         RemoveProp(hwnd, WIN_NEEDMANAGE_PROP);
+        RemoveProp(hwnd, WIN_STATE_PROP);
 
+        winReorderWindowsMultiWindow();
         break;
 
     case WM_MOVE:
         /* Adjust the X Window to the moved Windows window */
-        if (!hasEnteredSizeMove)
-            winAdjustXWindow(pWin, hwnd);
-        /* else: Wait for WM_EXITSIZEMOVE */
+        winAdjustXWindow(pWin, hwnd);
+        if (GetWindowLongPtr(hwnd, WND_IDX_ENTEREDSIZEMOVE))
+          DispatchQueuedEvents(0);
         return 0;
 
     case WM_SHOWWINDOW:
@@ -1010,13 +1066,10 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         else {                  /* It is an overridden window so make it top of Z stack */
 
             HWND forHwnd = GetForegroundWindow();
-
-#if CYGWINDOWING_DEBUG
-            ErrorF("overridden window is shown\n");
-#endif
+            winDebug ("overridden window is shown\n");
             if (forHwnd != NULL) {
                 if (GetWindowLongPtr(forHwnd, GWLP_USERDATA) & (LONG_PTR)
-                    XMING_SIGNATURE) {
+                    VCXSRV_SIGNATURE) {
                     if (GetWindowLongPtr(forHwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                         SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
@@ -1029,7 +1082,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         }
 
         /* Tell our Window Manager thread to map the window */
-        if (fWMMsgInitialized)
+        if (pWin)
             winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
 
         winStartMousePolling(s_pScreenPriv);
@@ -1041,6 +1094,26 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         /* for applications like xterm */
         return ValidateSizing(hwnd, pWin, wParam, lParam);
 
+    case WM_WINDOWPOSCHANGING:
+      {
+        /*
+          When window is moved or resized, force it to be redrawn, so that
+          any OpenGL content is re-drawn correctly, rather than copying bits
+          (which seem to be wrong, either because we are copying the wrong
+          window in the window heirarchy, or because we don't have the bits
+          drawn by OpenGL at all)
+
+          XXX: really this should check if any child has fWglUsed set, but
+          that might be expensive to check....
+         */
+        if (g_fNativeGl)
+          {
+            LPWINDOWPOS pWinPos = (LPWINDOWPOS)lParam;
+            pWinPos->flags |= SWP_NOCOPYBITS;
+          }
+      }
+      break;
+
     case WM_WINDOWPOSCHANGED:
     {
         LPWINDOWPOS pWinPos = (LPWINDOWPOS) lParam;
@@ -1061,31 +1134,7 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             else if (pWinPos->hwndInsertAfter == HWND_BOTTOM) {
             }
             else {
-                /* Check if this window is top of X windows. */
-                HWND hWndAbove = NULL;
-                DWORD dwCurrentProcessID = GetCurrentProcessId();
-                DWORD dwWindowProcessID = 0;
-
-                for (hWndAbove = pWinPos->hwndInsertAfter;
-                     hWndAbove != NULL;
-                     hWndAbove = GetNextWindow(hWndAbove, GW_HWNDPREV)) {
-                    /* Ignore other XWin process's window */
-                    GetWindowThreadProcessId(hWndAbove, &dwWindowProcessID);
-
-                    if ((dwWindowProcessID == dwCurrentProcessID)
-                        && GetProp(hWndAbove, WIN_WINDOW_PROP)
-                        && !IsWindowVisible(hWndAbove)
-                        && !IsIconic(hWndAbove))        /* ignore minimized windows */
-                        break;
-                }
-                /* If this is top of X windows in Windows stack,
-                   raise it in X stack. */
-                if (hWndAbove == NULL) {
-#if CYGWINDOWING_DEBUG
-                    winDebug("\traise to top\n");
-#endif
-                    winRaiseWindow(pWin);
-                }
+                raiseWinIfNeeded(pWin, pWinPos->hwndInsertAfter);
             }
         }
     }
@@ -1096,18 +1145,26 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         break;
 
     case WM_ENTERSIZEMOVE:
-        hasEnteredSizeMove = TRUE;
+        SetWindowLongPtr(hwnd, WND_IDX_ENTEREDSIZEMOVE, TRUE);
+        SetTimer(hwnd, UPDATETIMER, 10, NULL);
+        return 0;
+
+    case WM_TIMER:
+        DispatchQueuedEvents(0);
         return 0;
 
     case WM_EXITSIZEMOVE:
         /* Adjust the X Window to the moved Windows window */
-        hasEnteredSizeMove = FALSE;
+        SetWindowLongPtr(hwnd, WND_IDX_ENTEREDSIZEMOVE, FALSE);
         winAdjustXWindow(pWin, hwnd);
+        KillTimer(hwnd, UPDATETIMER);
+        if (pWin)
+            winAdjustXWindowState(s_pScreenPriv, &wmMsg);
         return 0;
 
     case WM_SIZE:
         /* see dix/window.c */
-#if CYGWINDOWING_DEBUG
+#ifdef WINDBG
     {
         char buf[64];
 
@@ -1124,86 +1181,31 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         default:
             strcpy(buf, "UNKNOWN_FLAG");
         }
-        ErrorF("winTopLevelWindowProc - WM_SIZE to %dx%d (%s)\n",
+        winDebug("winTopLevelWindowProc - WM_SIZE to %dx%d (%s)\n",
                (int) LOWORD(lParam), (int) HIWORD(lParam), buf);
     }
 #endif
-        if (!hasEnteredSizeMove) {
-            /* Adjust the X Window to the moved Windows window */
-            winAdjustXWindow(pWin, hwnd);
-        }
-        /* else: wait for WM_EXITSIZEMOVE */
-        return 0;               /* end of WM_SIZE handler */
-
-    case WM_STYLECHANGING:
-        /*
-           When the style changes, adjust the Windows window size so the client area remains the same size,
-           and adjust the Windows window position so that the client area remains in the same place.
-         */
-    {
-        RECT newWinRect;
-        DWORD dwExStyle;
-        DWORD dwStyle;
-        DWORD newStyle = ((STYLESTRUCT *) lParam)->styleNew;
-        WINDOWINFO wi;
-
-        dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
-        dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
-
-        winDebug("winTopLevelWindowProc - WM_STYLECHANGING from %08x %08x\n",
-                 (unsigned int)dwStyle, (unsigned int)dwExStyle);
-
-        if (wParam == GWL_EXSTYLE)
-            dwExStyle = newStyle;
-
-        if (wParam == GWL_STYLE)
-            dwStyle = newStyle;
-
-        winDebug("winTopLevelWindowProc - WM_STYLECHANGING to %08x %08x\n",
-                 (unsigned int)dwStyle, (unsigned int)dwExStyle);
-
-        /* Get client rect in screen coordinates */
-        wi.cbSize = sizeof(WINDOWINFO);
-        GetWindowInfo(hwnd, &wi);
-
-        winDebug
-            ("winTopLevelWindowProc - WM_STYLECHANGING client area {%d, %d, %d, %d}, {%d x %d}\n",
-             (int)wi.rcClient.left, (int)wi.rcClient.top, (int)wi.rcClient.right,
-             (int)wi.rcClient.bottom, (int)(wi.rcClient.right - wi.rcClient.left),
-             (int)(wi.rcClient.bottom - wi.rcClient.top));
-
-        newWinRect = wi.rcClient;
-        if (!AdjustWindowRectEx(&newWinRect, dwStyle, FALSE, dwExStyle))
-            winDebug
-                ("winTopLevelWindowProc - WM_STYLECHANGING AdjustWindowRectEx failed\n");
-
-        winDebug
-            ("winTopLevelWindowProc - WM_STYLECHANGING window area should be {%d, %d, %d, %d}, {%d x %d}\n",
-             (int)newWinRect.left, (int)newWinRect.top, (int)newWinRect.right,
-             (int)newWinRect.bottom, (int)(newWinRect.right - newWinRect.left),
-             (int)(newWinRect.bottom - newWinRect.top));
-
-        /*
-           Style change hasn't happened yet, so we can't adjust the window size yet, as the winAdjustXWindow()
-           which WM_SIZE does will use the current (unchanged) style.  Instead make a note to change it when
-           WM_STYLECHANGED is received...
-         */
-        pWinPriv->hDwp = BeginDeferWindowPos(1);
-        pWinPriv->hDwp =
-            DeferWindowPos(pWinPriv->hDwp, hwnd, NULL, newWinRect.left,
-                           newWinRect.top, newWinRect.right - newWinRect.left,
-                           newWinRect.bottom - newWinRect.top,
-                           SWP_NOACTIVATE | SWP_NOZORDER);
-    }
-        return 0;
+        /* Adjust the X Window to the moved Windows window */
+        winAdjustXWindow (pWin, hwnd);
+        if (pWin)
+            winAdjustXWindowState(s_pScreenPriv, &wmMsg);
+        if (wParam == SIZE_MINIMIZED)
+            winReorderWindowsMultiWindow();
+        if (GetWindowLongPtr(hwnd, WND_IDX_ENTEREDSIZEMOVE))
+            DispatchQueuedEvents(0);
+    /* else: wait for WM_EXITSIZEMOVE */
+    return 0; /* end of WM_SIZE handler */
 
     case WM_STYLECHANGED:
+      /* when the style changes, adjust the window size so the client area remains the same */
     {
-        if (pWinPriv->hDwp) {
-            EndDeferWindowPos(pWinPriv->hDwp);
-            pWinPriv->hDwp = NULL;
-        }
-        winDebug("winTopLevelWindowProc - WM_STYLECHANGED done\n");
+        LONG x,y;
+        DrawablePtr pDraw = &pWin->drawable;
+        x =  pDraw->x - wBorderWidth(pWin);
+        y = pDraw->y - wBorderWidth(pWin);
+        PositionWindowProcPtr saved=s_pScreen->PositionWindow;  // winPositionWindowMultiWindow is going to overwrite it
+        winPositionWindowMultiWindow(pWin, x, y);
+        s_pScreen->PositionWindow = saved;
     }
         return 0;
 
@@ -1211,10 +1213,8 @@ winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
         /* Check if this window needs to be made active when clicked */
         if (!GetProp(pWinPriv->hWnd, WIN_NEEDMANAGE_PROP)) {
-#if CYGMULTIWINDOW_DEBUG
-            ErrorF("winTopLevelWindowProc - WM_MOUSEACTIVATE - "
-                   "MA_NOACTIVATE\n");
-#endif
+            winDebug ("winTopLevelWindowProc - WM_MOUSEACTIVATE - "
+                      "MA_NOACTIVATE\n");
 
             /* */
             return MA_NOACTIVATE;
diff --git a/xserver/hw/xwin/winos.c b/vcxsrv-code/xorg-server/hw/xwin/winos.c
index 0d825bb..bc22fce 100644
--- a/xserver/hw/xwin/winos.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winos.c
@@ -36,8 +36,8 @@ typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS)(HANDLE, PBOOL);
 static const char*
 IsWow64(void)
 {
-#ifdef __x86_64__
-    return " (64-bit)";
+#ifdef _WIN64
+  return " (64-bit)";
 #else
     WINBOOL bIsWow64;
     LPFN_ISWOW64PROCESS fnIsWow64Process =
diff --git a/xserver/hw/xwin/winprefs.c b/vcxsrv-code/xorg-server/hw/xwin/winprefs.c
index d0b2ef2..86fd7e6 100644
--- a/xserver/hw/xwin/winprefs.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winprefs.c
@@ -48,12 +48,15 @@
 #include "windisplay.h"
 #include "winmultiwindowclass.h"
 #include "winmultiwindowicons.h"
+#include "windowstr.h"
 
 /* Where will the custom menu commands start counting from? */
 #define STARTMENUID WM_USER
 
 extern const char *winGetBaseDir(void);
 
+extern const char *g_pszLogFile;
+
 /* From winprefslex.l, the real parser */
 extern int parse_file(FILE * fp);
 
@@ -180,7 +183,7 @@ ReloadEnumWindowsProc(HWND hwnd, LPARAM lParam)
 
                 wmMsg.msg = WM_WM_ICON_EVENT;
                 wmMsg.hwndWindow = hwnd;
-                wmMsg.iWindow = (Window) (INT_PTR) GetProp(hwnd, WIN_WID_PROP);
+                wmMsg.iWindow = pWin->drawable.id;
 
                 winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
             }
@@ -343,8 +346,8 @@ HandleCustomWM_COMMAND(HWND hwnd, WORD command, winPrivScreenPtr pScreenPriv)
 
                     memset(&start, 0, sizeof(start));
                     start.cb = sizeof(start);
-                    start.dwFlags = STARTF_USESHOWWINDOW;
-                    start.wShowWindow = SW_HIDE;
+                    //start.dwFlags = STARTF_USESHOWWINDOW;
+                    //start.wShowWindow = SW_HIDE;
 
                     memset(&child, 0, sizeof(child));
 
@@ -356,7 +359,7 @@ HandleCustomWM_COMMAND(HWND hwnd, WORD command, winPrivScreenPtr pScreenPriv)
                     }
                     else
                         MessageBox(NULL, m->menuItem[j].param,
-                                   "Mingrc Exec Command Error!",
+                                   "VcXsrv Exec Command Error!",
                                    MB_OK | MB_ICONEXCLAMATION);
                 }
                     return TRUE;
@@ -721,8 +724,8 @@ LoadPreferences(void)
     home = getenv("HOME");
     if (home) {
         strcpy(fname, home);
-        if (fname[strlen(fname) - 1] != '/')
-            strcat(fname, "/");
+        if (fname[strlen(fname) - 1] != '\\')
+            strcat(fname, "\\");
         strcat(fname, ".XWinrc");
         parsed = winPrefsLoadPreferences(fname);
     }
@@ -732,7 +735,7 @@ LoadPreferences(void)
         char buffer[MAX_PATH];
 
 #ifdef RELOCATE_PROJECTROOT
-        snprintf(buffer, sizeof(buffer), "%s\\system.XWinrc", winGetBaseDir());
+        snprintf(buffer, sizeof(buffer), "%ssystem.XWinrc", winGetBaseDir());
 #else
         strncpy(buffer, SYSCONFDIR "/X11/system.XWinrc", sizeof(buffer));
 #endif
@@ -748,13 +751,11 @@ LoadPreferences(void)
     }
 
     /* Setup a DISPLAY environment variable, need to allocate on heap */
-    /* because putenv doesn't copy the argument... */
+    /* because putenv doesn't copy the argument... Always use screen 0 */
     winGetDisplayName(szDisplay, 0);
-    szEnvDisplay = (char *) (malloc(strlen(szDisplay) + strlen("DISPLAY=") + 1));
-    if (szEnvDisplay) {
-        snprintf(szEnvDisplay, 512, "DISPLAY=%s", szDisplay);
-        putenv(szEnvDisplay);
-    }
+    szEnvDisplay = (char *)(malloc(strlen(szDisplay)+9/*strlen("DISPLAY=")+1*/));
+    snprintf(szEnvDisplay, 512, "DISPLAY=%s", szDisplay);
+    putenv (szEnvDisplay);
 
     /* Replace any "%display%" in menu commands with display string */
     for (i = 0; i < pref.menuItems; i++) {
@@ -768,6 +769,11 @@ LoadPreferences(void)
                         dstParam += strlen(szDisplay);
                         srcParam += 9;
                     }
+                    else if (!strncmp(srcParam, "%logfile%", 9)) {
+                        memcpy (dstParam, g_pszLogFile, strlen(g_pszLogFile));
+                        dstParam += strlen(g_pszLogFile);
+                        srcParam += 9;
+                    }
                     else {
                         *dstParam = *srcParam;
                         dstParam++;
@@ -803,3 +809,24 @@ winOverrideStyle(char *res_name, char *res_class, char *wmName)
     /* Didn't find the style, fail gracefully */
     return STYLE_NONE;
 }
+
+/*
+ * Check for a match of the window class to one specified in the
+ * TASKBAR{} section in the prefs file
+ */
+unsigned long
+winOverrideTaskbar(char *res_name, char *res_class, char *wmName)
+{
+    int i;
+
+    for (i=0; i<pref.taskbarItems; i++) {
+        if ((res_name && !strcmp(pref.taskbar[i].match, res_name)) ||
+            (res_class && !strcmp(pref.taskbar[i].match, res_class)) ||
+            (wmName && strstr(wmName, pref.taskbar[i].match))) {
+            if (pref.taskbar[i].type) return pref.taskbar[i].type;
+        }
+    }
+
+    /* Didn't find a taskbar type */
+    return TASKBAR_NONE;
+}
diff --git a/xserver/hw/xwin/winprefs.h b/vcxsrv-code/xorg-server/hw/xwin/winprefs.h
index 597398e..95c822f 100644
--- a/xserver/hw/xwin/winprefs.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winprefs.h
@@ -69,6 +69,10 @@ typedef enum MENUCOMMANDTYPE {
 #define STYLE_MINIMIZE (1L<<5)  /* Open a window minimized                    */
 #define STYLE_BOTTOM   (1L<<6)  /* Open a window at the bottom of the Z order */
 
+#define TASKBAR_NONE   (0L)     /* Dummy the first entry                      */
+#define TASKBAR_NOTAB  (1L)     /* Force no taskbar icon                      */
+#define TASKBAR_NEWTAB (1L<<1)  /* Force new taskbar icon                     */
+
 /* Where to place a system menu */
 typedef enum MENUPOSITION {
     AT_START,                   /* Place menu at the top of the system menu   */
@@ -110,6 +114,12 @@ typedef struct STYLEITEM {
     unsigned long type;         /* What should it do? */
 } STYLEITEM;
 
+/* To redefine taskbar properties for certain window types */
+typedef struct TASKBARITEM {
+    char match[MENU_MAX+1];     /* What string to search for? */
+    unsigned long type;         /* What should it do? */
+} TASKBARITEM;
+
 typedef struct WINPREFS {
     /* Menu information */
     MENUPARSED *menu;           /* Array of created menus */
@@ -137,12 +147,18 @@ typedef struct WINPREFS {
     STYLEITEM *style;
     int styleItems;
 
+    TASKBARITEM *taskbar;
+    int taskbarItems;
+
     /* Force exit flag */
     Bool fForceExit;
 
     /* Silent exit flag */
     Bool fSilentExit;
 
+    /* No tray icon flag */
+    Bool fNoTrayIcon;
+
 } WINPREFS;
 
 /* The global pref settings structure loaded by the winprefyacc.y parser */
@@ -172,6 +188,9 @@ HICON winOverrideIcon(char *res_name, char *res_class, char *wmName);
 unsigned long
  winOverrideStyle(char *res_name, char *res_class, char *wmName);
 
+unsigned long
+ winOverrideTaskbar(char *res_name, char *res_class, char *wmName);
+
 HICON winTaskbarIcon(void);
 
 HICON winOverrideDefaultIcon(int size);
diff --git a/xserver/hw/xwin/winprefslex.l b/vcxsrv-code/xorg-server/hw/xwin/winprefslex.l
index 9e6f0d6..0caeb67 100644
--- a/xserver/hw/xwin/winprefslex.l
+++ b/vcxsrv-code/xorg-server/hw/xwin/winprefslex.l
@@ -37,8 +37,6 @@
 #include <string.h>
 #include "winprefsyacc.h"
 
-extern void ErrorF (const char* /*f*/, ...);
-
 /* Copy the parsed string, must be free()d in yacc parser */
 static char *makestr(char *str)
 {
@@ -70,6 +68,9 @@ ICONDIRECTORY           { return ICONDIRECTORY; }
 DEFAULTICON             { return DEFAULTICON; }
 ICONS                   { return ICONS; }
 STYLES                  { return STYLES; }
+TASKBAR                 { return TASKBAR; }
+NOTAB                   { return NOTAB; }
+NEWTAB                  { return NEWTAB; }
 TOPMOST                 { return TOPMOST; }
 MAXIMIZE                { return MAXIMIZE; }
 MINIMIZE                { return MINIMIZE; }
diff --git a/xserver/hw/xwin/winprefsyacc.y b/vcxsrv-code/xorg-server/hw/xwin/winprefsyacc.y
index 9bb28ae..6cbb9cc 100644
--- a/xserver/hw/xwin/winprefsyacc.y
+++ b/vcxsrv-code/xorg-server/hw/xwin/winprefsyacc.y
@@ -40,6 +40,7 @@
 #define _STDLIB_H 1 /* bison checks this to know if stdlib has been included */
 #include <string.h>
 #include "winprefs.h"
+#include "winmsg.h"
 
 /* The following give better error messages in bison at the cost of a few KB */
 #define YYERROR_VERBOSE 1
@@ -75,6 +76,12 @@ static void OpenStyles(void);
 static void AddStyleLine(char *matchstr, unsigned long style);
 static void CloseStyles(void);
 
+static void SetNoTrayIcon(void);
+
+static void OpenTaskbar(void);
+static void AddTaskbarLine(char *matchstr, unsigned long type);
+static void CloseTaskbar(void);
+
 static void OpenSysMenu(void);
 static void AddSysMenuLine(char *matchstr, char *menuname, int pos);
 static void CloseSysMenu(void);
@@ -85,6 +92,9 @@ extern char *yytext;
 extern int yylineno;
 extern int yylex(void);
 
+#define YYMALLOC malloc
+#define YYFREE   free
+
 %}
 
 %union {
@@ -108,6 +118,9 @@ extern int yylex(void);
 %token NOTITLE
 %token OUTLINE
 %token NOFRAME
+%token TASKBAR
+%token NOTAB
+%token NEWTAB
 %token DEFAULTSYSMENU
 %token SYSMENU
 %token ROOTMENU
@@ -126,6 +139,7 @@ extern int yylex(void);
 %type <uVal>  group1
 %type <uVal>  group2
 %type <uVal>  stylecombo
+%type <uVal>  group3
 %type <iVal>  atspot
 
 %%
@@ -148,6 +162,7 @@ command:	defaulticon
 	| menu
 	| icons
 	| styles
+	| taskbar
 	| sysmenu
 	| rootmenu
 	| defaultsysmenu
@@ -223,6 +238,20 @@ stylelist:	styleline
 styles:	STYLES LB {OpenStyles();} newline_or_nada stylelist RB {CloseStyles();}
 	;
 
+group3:	NOTAB { $$=TASKBAR_NOTAB; }
+        | NEWTAB { $$=TASKBAR_NEWTAB; }
+        ;
+
+taskbarline:	STRING group3 NEWLINE newline_or_nada { AddTaskbarLine($1, $2); free($1); }
+	;
+
+taskbarlist:	taskbarline
+	| taskbarline taskbarlist
+	;
+
+taskbar:	TASKBAR LB {OpenTaskbar();} newline_or_nada taskbarlist RB {CloseTaskbar();}
+	;
+
 atspot:	{ $$=AT_END; }
 	| ATSTART { $$=AT_START; }
 	| ATEND { $$=AT_END; }
@@ -244,7 +273,7 @@ forceexit:	FORCEEXIT NEWLINE { pref.fForceExit = TRUE; }
 silentexit:	SILENTEXIT NEWLINE { pref.fSilentExit = TRUE; }
 	;
 
-debug: 	DEBUGOUTPUT STRING NEWLINE { ErrorF("LoadPreferences: %s\n", $2); free($2); }
+debug: 	DEBUGOUTPUT STRING NEWLINE { winDebug("LoadPreferences: %s\n", $2); free($2); }
 	;
 
 
@@ -351,7 +380,7 @@ static void
 OpenIcons (void)
 {
   if (pref.icon != NULL) {
-    ErrorF("LoadPreferences: Redefining icon mappings\n");
+    winDebug("LoadPreferences: Redefining icon mappings\n");
     free(pref.icon);
     pref.icon = NULL;
   }
@@ -386,7 +415,7 @@ static void
 OpenStyles (void)
 {
   if (pref.style != NULL) {
-    ErrorF("LoadPreferences: Redefining window style\n");
+    winDebug("LoadPreferences: Redefining window style\n");
     free(pref.style);
     pref.style = NULL;
   }
@@ -414,11 +443,50 @@ CloseStyles (void)
 {
 }
 
+static void
+SetNoTrayIcon (void)
+{
+  pref.fNoTrayIcon=TRUE;
+}
+
+
+static void
+OpenTaskbar (void)
+{
+  if (pref.taskbar != NULL) {
+    ErrorF("LoadPreferences - Redefining taskbar property\n");
+    free(pref.taskbar);
+    pref.taskbar = NULL;
+  }
+  pref.taskbarItems = 0;
+}
+
+static void
+AddTaskbarLine (char *matchstr, unsigned long type)
+{
+  if (pref.taskbar==NULL)
+    pref.taskbar = malloc(sizeof(TASKBARITEM));
+  else
+    pref.taskbar = realloc(pref.taskbar, sizeof(TASKBARITEM)*(pref.taskbarItems+1));
+
+  strncpy(pref.taskbar[pref.taskbarItems].match, matchstr, MENU_MAX);
+  pref.taskbar[pref.taskbarItems].match[MENU_MAX] = 0;
+
+  pref.taskbar[pref.taskbarItems].type = type;
+
+  pref.taskbarItems++;
+}
+
+static void
+CloseTaskbar (void)
+{
+}
+
 static void
 OpenSysMenu (void)
 {
   if (pref.sysMenu != NULL) {
-    ErrorF("LoadPreferences: Redefining system menu\n");
+    winDebug("LoadPreferences: Redefining system menu\n");
     free(pref.sysMenu);
     pref.sysMenu = NULL;
   }
diff --git a/xserver/hw/xwin/winprocarg.c b/vcxsrv-code/xorg-server/hw/xwin/winprocarg.c
index 66023f3..c5ea46b 100644
--- a/xserver/hw/xwin/winprocarg.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winprocarg.c
@@ -43,6 +43,7 @@ from The Open Group.
 #include "winprefs.h"
 
 #include "winclipboard/winclipboard.h"
+extern Bool g_fClipboardPrimary;
 
 /*
  * Function prototypes
@@ -82,9 +83,9 @@ winInitializeScreenDefaults(void)
     dwWidth = GetSystemMetrics(SM_CXSCREEN);
     dwHeight = GetSystemMetrics(SM_CYSCREEN);
 
-    winErrorFVerb(2,
-                  "winInitializeScreenDefaults - primary monitor w %d h %d\n",
-                  (int) dwWidth, (int) dwHeight);
+    winDebug (
+              "winInitializeScreenDefaults - primary monitor w %d h %d\n",
+              (int) dwWidth, (int) dwHeight);
 
     /* Set a default DPI, if no '-dpi' option was used */
     if (monitorResolution == 0) {
@@ -94,17 +95,17 @@ winInitializeScreenDefaults(void)
             int dpiX = GetDeviceCaps(hdc, LOGPIXELSX);
             int dpiY = GetDeviceCaps(hdc, LOGPIXELSY);
 
-            winErrorFVerb(2,
-                          "winInitializeScreenDefaults - native DPI x %d y %d\n",
-                          dpiX, dpiY);
+            winDebug(
+                     "winInitializeScreenDefaults - native DPI x %d y %d\n",
+                     dpiX, dpiY);
 
             monitorResolution = dpiY;
             ReleaseDC(NULL, hdc);
         }
         else {
-            winErrorFVerb(1,
-                          "winInitializeScreenDefaults - Failed to retrieve native DPI, falling back to default of %d DPI\n",
-                          WIN_DEFAULT_DPI);
+            winDebug(
+                     "winInitializeScreenDefaults - Failed to retrieve native DPI, falling back to default of %d DPI\n",
+                     WIN_DEFAULT_DPI);
             monitorResolution = WIN_DEFAULT_DPI;
         }
     }
@@ -131,6 +132,7 @@ winInitializeScreenDefaults(void)
     defaultScreenInfo.fMultiWindow = FALSE;
     defaultScreenInfo.fCompositeWM = TRUE;
     defaultScreenInfo.fMultiMonitorOverride = FALSE;
+    defaultScreenInfo.fCompositeWM = TRUE;
     defaultScreenInfo.fMultipleMonitors = FALSE;
     defaultScreenInfo.fLessPointer = FALSE;
     defaultScreenInfo.iResizeMode = resizeDefault;
@@ -155,7 +157,7 @@ winInitializeScreenDefaults(void)
 static void
 winInitializeScreen(int i)
 {
-    winErrorFVerb(3, "winInitializeScreen - %d\n", i);
+    winDebug ("winInitializeScreen - %d\n",i);
 
     /* Initialize default screen values, if needed */
     winInitializeScreenDefaults();
@@ -172,7 +174,7 @@ winInitializeScreens(int maxscreens)
 {
     int i;
 
-    winErrorFVerb(3, "winInitializeScreens - %i\n", maxscreens);
+    winDebug ("winInitializeScreens - %i\n", maxscreens);
 
     if (maxscreens > g_iNumScreens) {
         /* Reallocate the memory for DDX-specific screen info */
@@ -246,23 +248,22 @@ ddxProcessArgument(int argc, char *argv[], int i)
              * OsVendorInit () gets called, otherwise we will overwrite
              * settings changed by parameters such as -fullscreen, etc.
              */
-            winErrorFVerb(3, "ddxProcessArgument - Initializing default "
-                          "screens\n");
+            winDebug ("ddxProcessArgument - Initializing default "
+                      "screens\n");
             winInitializeScreenDefaults();
         }
     }
 
-#if CYGDEBUG
     winDebug("ddxProcessArgument - arg: %s\n", argv[i]);
-#endif
 
     /*
      * Look for the '-help' and similar options
      */
     if (IS_OPTION("-help") || IS_OPTION("-h") || IS_OPTION("--help")) {
         /* Reset logfile. We don't need that helpmessage in the logfile */
-        g_pszLogFile = NULL;
+#ifdef _DEBUG
         g_fNoHelpMessageBox = TRUE;
+#endif
         UseMsg();
         exit(0);
         return 1;
@@ -270,12 +271,17 @@ ddxProcessArgument(int argc, char *argv[], int i)
 
     if (IS_OPTION("-version") || IS_OPTION("--version")) {
         /* Reset logfile. We don't need that versioninfo in the logfile */
-        g_pszLogFile = NULL;
         winLogVersionInfo();
         exit(0);
         return 1;
     }
 
+    if (IS_OPTION("-silent-dup-error"))
+    {
+        g_fSilentFatalError = TRUE;
+        return 1;
+    }
+
     /*
      * Look for the '-screen scr_num [width height]' argument
      */
@@ -285,9 +291,7 @@ ddxProcessArgument(int argc, char *argv[], int i)
         int iWidth, iHeight, iX, iY;
         int iMonitor;
 
-#if CYGDEBUG
         winDebug("ddxProcessArgument - screen - argc: %d i: %d\n", argc, i);
-#endif
 
         /* Display the usage message if the argument is malformed */
         if (i + 1 >= argc) {
@@ -318,9 +322,9 @@ ddxProcessArgument(int argc, char *argv[], int i)
             struct GetMonitorInfoData data;
 
             if (QueryMonitor(iMonitor, &data)) {
-                winErrorFVerb(2,
-                              "ddxProcessArgument - screen - Found Valid ``@Monitor'' = %d arg\n",
-                              iMonitor);
+                winDebug(
+                         "ddxProcessArgument - screen - Found Valid ``@Monitor'' = %d arg\n",
+                         iMonitor);
                 iArgsProcessed = 3;
                 g_ScreenInfo[nScreenNum].fUserGaveHeightAndWidth = FALSE;
                 g_ScreenInfo[nScreenNum].fUserGavePosition = TRUE;
@@ -347,8 +351,8 @@ ddxProcessArgument(int argc, char *argv[], int i)
         else if (i + 2 < argc
                  && 2 == sscanf(argv[i + 2], "%dx%d",
                                 (int *) &iWidth, (int *) &iHeight)) {
-            winErrorFVerb(2,
-                          "ddxProcessArgument - screen - Found ``WxD'' arg\n");
+            winDebug (
+                      "ddxProcessArgument - screen - Found ``WxD'' arg\n");
             iArgsProcessed = 3;
             g_ScreenInfo[nScreenNum].fUserGaveHeightAndWidth = TRUE;
             g_ScreenInfo[nScreenNum].dwWidth = iWidth;
@@ -358,8 +362,8 @@ ddxProcessArgument(int argc, char *argv[], int i)
             /* Look for WxD+X+Y */
             if (2 == sscanf(argv[i + 2], "%*dx%*d+%d+%d",
                             (int *) &iX, (int *) &iY)) {
-                winErrorFVerb(2,
-                              "ddxProcessArgument - screen - Found ``X+Y'' arg\n");
+                winDebug (
+                          "ddxProcessArgument - screen - Found ``X+Y'' arg\n");
                 g_ScreenInfo[nScreenNum].fUserGavePosition = TRUE;
                 g_ScreenInfo[nScreenNum].dwInitialX = iX;
                 g_ScreenInfo[nScreenNum].dwInitialY = iY;
@@ -393,9 +397,9 @@ ddxProcessArgument(int argc, char *argv[], int i)
                 struct GetMonitorInfoData data;
 
                 if (QueryMonitor(iMonitor, &data)) {
-                    winErrorFVerb(2,
-                                  "ddxProcessArgument - screen - Found Valid ``@Monitor'' = %d arg\n",
-                                  iMonitor);
+                    winDebug (
+                              "ddxProcessArgument - screen - Found Valid ``@Monitor'' = %d arg\n",
+                              iMonitor);
                     g_ScreenInfo[nScreenNum].fUserGavePosition = TRUE;
                     g_ScreenInfo[nScreenNum].iMonitor = iMonitor;
                     g_ScreenInfo[nScreenNum].hMonitor = data.monitorHandle;
@@ -414,7 +418,7 @@ ddxProcessArgument(int argc, char *argv[], int i)
         }
         else if (i + 3 < argc && 1 == sscanf(argv[i + 2], "%d", (int *) &iWidth)
                  && 1 == sscanf(argv[i + 3], "%d", (int *) &iHeight)) {
-            winErrorFVerb(2,
+            winDebug (
                           "ddxProcessArgument - screen - Found ``W D'' arg\n");
             iArgsProcessed = 4;
             g_ScreenInfo[nScreenNum].fUserGaveHeightAndWidth = TRUE;
@@ -424,7 +428,7 @@ ddxProcessArgument(int argc, char *argv[], int i)
             g_ScreenInfo[nScreenNum].dwUserHeight = iHeight;
             if (i + 5 < argc && 1 == sscanf(argv[i + 4], "%d", (int *) &iX)
                 && 1 == sscanf(argv[i + 5], "%d", (int *) &iY)) {
-                winErrorFVerb(2,
+                winDebug (
                               "ddxProcessArgument - screen - Found ``X Y'' arg\n");
                 iArgsProcessed = 6;
                 g_ScreenInfo[nScreenNum].fUserGavePosition = TRUE;
@@ -433,11 +437,11 @@ ddxProcessArgument(int argc, char *argv[], int i)
             }
         }
         else {
-            winErrorFVerb(2,
+            ErrorF (
                           "ddxProcessArgument - screen - Did not find size arg. "
-                          "dwWidth: %d dwHeight: %d\n",
-                          (int) g_ScreenInfo[nScreenNum].dwWidth,
-                          (int) g_ScreenInfo[nScreenNum].dwHeight);
+                    "dwWidth: %d dwHeight: %d\n",
+                    (int) g_ScreenInfo[nScreenNum].dwWidth,
+                    (int) g_ScreenInfo[nScreenNum].dwHeight);
             iArgsProcessed = 2;
             g_ScreenInfo[nScreenNum].fUserGaveHeightAndWidth = FALSE;
         }
@@ -512,6 +516,8 @@ ddxProcessArgument(int argc, char *argv[], int i)
         if (!screenInfoPtr->fMultiMonitorOverride)
             screenInfoPtr->fMultipleMonitors = FALSE;
         screenInfoPtr->fFullScreen = TRUE;
+        // resizing is not allowed in full screen so change the default to not allowed
+        screenInfoPtr->iResizeMode=resizeNotAllowed;
 
         /* Indicate that we have processed this argument */
         return 1;
@@ -539,6 +545,7 @@ ddxProcessArgument(int argc, char *argv[], int i)
         return 1;
     }
 
+
     /*
      * Look for the '-rootless' argument
      */
@@ -601,6 +608,26 @@ ddxProcessArgument(int argc, char *argv[], int i)
         return 1;
     }
 
+    /*
+     * Look for the '-compositewm' argument
+     */
+    if (IS_OPTION("-compositewm")) {
+        screenInfoPtr->fCompositeWM = TRUE;
+
+        /* Indicate that we have processed this argument */
+        return 1;
+    }
+
+    /*
+     * Look for the '-compositewm' argument
+     */
+    if (IS_OPTION("-nocompositewm")) {
+        screenInfoPtr->fCompositeWM = FALSE;
+
+        /* Indicate that we have processed this argument */
+        return 1;
+    }
+
     /*
      * Look for the '-multiplemonitors' argument
      */
@@ -921,7 +948,21 @@ ddxProcessArgument(int argc, char *argv[], int i)
      * Look for the '-auth' argument
      */
     if (IS_OPTION("-auth")) {
+        HANDLE hFile;
+        char *pszFile;
+        CHECK_ARGS(1);
         g_fAuthEnabled = TRUE;
+        pszFile = argv[++i];
+        hFile = CreateFile(pszFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+        if (hFile == INVALID_HANDLE_VALUE)
+            winMessageBoxF("This authorization file for the -auth option could not be opened...\n"
+                           "\"%s\"\n"
+                           "You should use an \"Xauthority\" file in your HOME directory.\n"
+                           "\nIgnoring and continuing.\n",
+                           MB_ICONINFORMATION,
+                           pszFile);
+        else
+          CloseHandle(hFile);
         return 0;               /* Let DIX parse this again */
     }
 
@@ -1001,6 +1042,7 @@ ddxProcessArgument(int argc, char *argv[], int i)
     if (IS_OPTION("-logverbose")) {
         CHECK_ARGS(1);
         g_iLogVerbose = atoi(argv[++i]);
+        LogSetParameter(XLOG_VERBOSITY, g_iLogVerbose);
         return 2;
     }
 
@@ -1050,10 +1092,27 @@ ddxProcessArgument(int argc, char *argv[], int i)
         return 1;
     }
 
-    if (IS_OPTION("-nowgl")) {
+    else if (IS_OPTION("-nowgl")) {
         g_fNativeGl = FALSE;
         return 1;
     }
+    else if (IS_OPTION("-swrastwgl"))
+    {
+        g_fswrastwgl = TRUE;
+        return 1;
+    }
+    else if (IS_OPTION("-parentprocessid"))
+    {
+        DWORD dwProcessId;
+        CHECK_ARGS (1);
+        dwProcessId = atoi(argv[++i]);
+        if (!AllowSetForegroundWindow(dwProcessId))
+        {
+            winMessageBoxF ("Error calling AllowSetForegroundWindow.", MB_ICONINFORMATION);
+            return 0;
+        }
+        return 2;
+    }
 
     if (IS_OPTION("-hostintitle")) {
         g_fHostInTitle = TRUE;
@@ -1088,6 +1147,11 @@ ddxProcessArgument(int argc, char *argv[], int i)
         return 2;
     }
 
+    if (IS_OPTION("-codepage")) {
+        g_iActualCodePage = TRUE;
+        return 1;
+    }
+
     return 0;
 }
 
@@ -1154,7 +1218,7 @@ winLogCommandLine(int argc, char *argv[])
         iCurrLen += strlen(argv[i]);
     }
 
-    ErrorF("XWin was started with the following command line:\n\n"
+    winDebug ("XWin was started with the following command line:\n\n"
            "%s\n\n", g_pszCommandLine);
 }
 
@@ -1171,9 +1235,9 @@ winLogVersionInfo(void)
         return;
     s_fBeenHere = TRUE;
 
-    ErrorF("Welcome to the XWin X Server\n");
+    ErrorF("Welcome to the VcXsrv X Server\n");
     ErrorF("Vendor: %s\n", XVENDORNAME);
-    ErrorF("Release: %d.%d.%d.%d\n", XORG_VERSION_MAJOR,
+    ErrorF("Release: %d.%d.%d.%d\n\n", XORG_VERSION_MAJOR,
            XORG_VERSION_MINOR, XORG_VERSION_PATCH, XORG_VERSION_SNAP);
 #ifdef HAVE_SYS_UTSNAME_H
     {
diff --git a/xserver/hw/xwin/winrandr.c b/vcxsrv-code/xorg-server/hw/xwin/winrandr.c
index 038d63b..e13036b 100644
--- a/xserver/hw/xwin/winrandr.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winrandr.c
@@ -298,7 +298,7 @@ winRandRInit(ScreenPtr pScreen)
        monitor size (we can have scrollbars :-), so set the
        upper limit to the maximum coordinates X11 can use.
      */
-    RRScreenSetSizeRange(pScreen, 0, 0, 32768, 32768);
+    RRScreenSetSizeRange(pScreen, 0, 0, 32767, 32767);
 
     return TRUE;
 }
diff --git a/xserver/hw/xwin/winresource.h b/vcxsrv-code/xorg-server/hw/xwin/winresource.h
index 37e92ce..399ea81 100644
--- a/xserver/hw/xwin/winresource.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winresource.h
@@ -44,7 +44,10 @@
 #define ID_APP_ALWAYS_ON_TOP	202
 #define ID_APP_ABOUT		203
 #define ID_APP_MONITOR_PRIMARY	204
+#define ID_APP_GATHER_WINDOWS	205
 
 #define ID_ABOUT_WEBSITE	303
 
+#define IDC_HOSTLIST            100
+
 #endif
diff --git a/xserver/hw/xwin/winscrinit.c b/vcxsrv-code/xorg-server/hw/xwin/winscrinit.c
index ae6bc12..c9fff7e 100644
--- a/xserver/hw/xwin/winscrinit.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winscrinit.c
@@ -52,10 +52,8 @@ winScreenInit(ScreenPtr pScreen, int argc, char **argv)
     HDC hdc;
     DWORD dwInitialBPP;
 
-#if CYGDEBUG || YES
     winDebug("winScreenInit - dwWidth: %u dwHeight: %u\n",
              (unsigned int)pScreenInfo->dwWidth, (unsigned int)pScreenInfo->dwHeight);
-#endif
 
     /* Allocate privates for this screen */
     if (!winAllocatePrivates(pScreen)) {
@@ -86,27 +84,27 @@ winScreenInit(ScreenPtr pScreen, int argc, char **argv)
 
     /* Horribly misnamed function: Allow engine to adjust BPP for screen */
     dwInitialBPP = pScreenInfo->dwBPP;
-
-    if (!(*pScreenPriv->pwinAdjustVideoMode) (pScreen)) {
+  
+    if (pScreenPriv->pwinAdjustVideoMode && !(*pScreenPriv->pwinAdjustVideoMode) (pScreen)) {
         ErrorF("winScreenInit - winAdjustVideoMode () failed\n");
         return FALSE;
     }
 
     if (dwInitialBPP == WIN_DEFAULT_BPP) {
         /* No -depth parameter was passed, let the user know the depth being used */
-        ErrorF
+        winDebug
             ("winScreenInit - Using Windows display depth of %d bits per pixel\n",
              (int) pScreenInfo->dwBPP);
     }
     else if (dwInitialBPP != pScreenInfo->dwBPP) {
         /* Warn user if engine forced a depth different to -depth parameter */
-        ErrorF
+        winDebug
             ("winScreenInit - Command line depth of %d bpp overridden by engine, using %d bpp\n",
              (int) dwInitialBPP, (int) pScreenInfo->dwBPP);
     }
     else {
-        ErrorF("winScreenInit - Using command line depth of %d bpp\n",
-               (int) pScreenInfo->dwBPP);
+        winDebug("winScreenInit - Using command line depth of %d bpp\n",
+                 (int) pScreenInfo->dwBPP);
     }
 
     /* Check for supported display depth */
@@ -139,7 +137,7 @@ winScreenInit(ScreenPtr pScreen, int argc, char **argv)
     }
 
     /* Create display window */
-    if (!(*pScreenPriv->pwinCreateBoundingWindow) (pScreen)) {
+    if (pScreenPriv->pwinCreateBoundingWindow && !(*pScreenPriv->pwinCreateBoundingWindow) (pScreen)) {
         ErrorF("winScreenInit - pwinCreateBoundingWindow () " "failed\n");
         return FALSE;
     }
@@ -166,7 +164,7 @@ winScreenInit(ScreenPtr pScreen, int argc, char **argv)
     miClearVisualTypes();
 
     /* Call the engine dependent screen initialization procedure */
-    if (!((*pScreenPriv->pwinFinishScreenInit) (pScreen->myNum, pScreen, argc, argv))) {
+    if (pScreenPriv->pwinFinishScreenInit && !((*pScreenPriv->pwinFinishScreenInit) (pScreen->myNum, pScreen, argc, argv))) {
         ErrorF("winScreenInit - winFinishScreenInit () failed\n");
 
         /* call the engine dependent screen close procedure to clean up from a failure */
@@ -177,26 +175,25 @@ winScreenInit(ScreenPtr pScreen, int argc, char **argv)
 
     if (!g_fSoftwareCursor)
         winInitCursor(pScreen);
+#ifdef WINDBG
     else
-        winErrorFVerb(2, "winScreenInit - Using software cursor\n");
+        winDebug("winScreenInit - Using software cursor\n");  
+#endif
 
     if (!noPanoramiXExtension) {
         /*
            Note the screen origin in a normalized coordinate space where (0,0) is at the top left
            of the native virtual desktop area
          */
-        pScreen->x =
-            pScreenInfo->dwInitialX - GetSystemMetrics(SM_XVIRTUALSCREEN);
-        pScreen->y =
-            pScreenInfo->dwInitialY - GetSystemMetrics(SM_YVIRTUALSCREEN);
+		pScreen->x =
+			pScreenInfo->dwInitialX;
+		pScreen->y =
+			pScreenInfo->dwInitialY;
 
-        ErrorF("Screen %d added at virtual desktop coordinate (%d,%d).\n",
+        winDebug("Screen %d added at virtual desktop coordinate (%d,%d).\n",
                pScreen->myNum, pScreen->x, pScreen->y);
     }
-
-#if CYGDEBUG || YES
     winDebug("winScreenInit - returning\n");
-#endif
 
     return TRUE;
 }
@@ -247,10 +244,10 @@ winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
             + winCountBits(pScreenPriv->dwGreenMask)
             + winCountBits(pScreenPriv->dwBlueMask);
 
-    winErrorFVerb(2, "winFinishScreenInitFB - Masks: %08x %08x %08x\n",
-                  (unsigned int) pScreenPriv->dwRedMask,
-                  (unsigned int) pScreenPriv->dwGreenMask,
-                  (unsigned int) pScreenPriv->dwBlueMask);
+    winDebug ("winFinishScreenInitFB - Masks: %08x %08x %08x\n",
+              (unsigned int) pScreenPriv->dwRedMask,
+              (unsigned int) pScreenPriv->dwGreenMask,
+              (unsigned int) pScreenPriv->dwBlueMask);
 
     /* Init visuals */
     if (!(*pScreenPriv->pwinInitVisuals) (pScreen)) {
@@ -333,16 +330,12 @@ winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
 #endif
 
     /* Setup the cursor routines */
-#if CYGDEBUG
     winDebug("winFinishScreenInitFB - Calling miDCInitialize ()\n");
-#endif
     miDCInitialize(pScreen, &g_winPointerCursorFuncs);
 
     /* KDrive does winCreateDefColormap right after miDCInitialize */
     /* Create a default colormap */
-#if CYGDEBUG
     winDebug("winFinishScreenInitFB - Calling winCreateDefColormap ()\n");
-#endif
     if (!winCreateDefColormap(pScreen)) {
         ErrorF("winFinishScreenInitFB - Could not create colormap\n");
         return FALSE;
@@ -351,9 +344,7 @@ winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
     /* Initialize the shadow framebuffer layer */
     if ((pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI
          || pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)) {
-#if CYGDEBUG
         winDebug("winFinishScreenInitFB - Calling shadowSetup ()\n");
-#endif
         if (!shadowSetup(pScreen)) {
             ErrorF("winFinishScreenInitFB - shadowSetup () failed\n");
             return FALSE;
@@ -473,9 +464,12 @@ winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
 
 
     if (pScreenInfo->fMultiWindow) {
-#if CYGDEBUG || YES
+        if ((pScreenInfo->dwBPP == 8) && (pScreenInfo->fCompositeWM)) {
+            ErrorF("-compositewm disabled due to 8bpp depth\n");
+            pScreenInfo->fCompositeWM = FALSE;
+        }
+
         winDebug("winFinishScreenInitFB - Calling winInitWM.\n");
-#endif
 
         /* Initialize multi window mode */
         if (!winInitWM(&pScreenPriv->pWMInfo,
@@ -496,9 +490,7 @@ winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
     /* Tell the server that we have a valid depth */
     pScreenPriv->fBadDepth = FALSE;
 
-#if CYGDEBUG || YES
     winDebug("winFinishScreenInitFB - returning\n");
-#endif
 
     return TRUE;
 }
diff --git a/xserver/hw/xwin/winshadddnl.c b/vcxsrv-code/xorg-server/hw/xwin/winshadddnl.c
index 2901769..cd1b8f5 100644
--- a/xserver/hw/xwin/winshadddnl.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winshadddnl.c
@@ -35,6 +35,7 @@
 #include <xwin-config.h>
 #endif
 #include "win.h"
+#include "winprefs.h"
 
 #define FAIL_MSG_MAX_BLT	10
 
@@ -87,6 +88,65 @@ static Bool
 static Bool
  winReleasePrimarySurfaceShadowDDNL(ScreenPtr pScreen);
 
+static HRESULT myIDirectDrawSurface4_Blt( ScreenPtr pScreen, RECT *pRect, RECT *prcSrc)
+{
+  HRESULT ddrval = DD_OK;
+  unsigned i;
+  winScreenPriv(pScreen);
+
+
+  for (i = 0; i < 3; ++i)
+  {
+    if (pScreenPriv->pddsPrimary4)
+      ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4, pRect, pScreenPriv->pddsShadow4, prcSrc, DDBLT_WAIT, NULL);
+    else
+      ddrval = DDERR_SURFACELOST; // Surface has been closed
+     /* Try to regain the primary surface and blit again if we've lost it */
+    if (ddrval == DDERR_SURFACELOST)
+    {
+      /* Surface was lost */
+      ErrorF ("IDirectDrawSurface4_Blt reported that the primary "
+              "surface was lost, trying to restore, retry: %d\n", i + 1);
+    
+      /* Try to restore the surface, once */
+      
+      if (i==1)
+      {
+        ErrorF("Recreating DDraw surface because restoring of surface didn't work.\n");
+        winAllocateFBShadowDDNL(pScreen);
+      }
+      else
+      {
+        ddrval = IDirectDraw4_RestoreAllSurfaces (pScreenPriv->pdd4);
+        ErrorF ("IDirectDraw4_RestoreAllSurfaces returned: ");
+        if (ddrval == DD_OK)
+          ErrorF ("DD_OK\n");
+        else if (ddrval == DDERR_WRONGMODE)
+          ErrorF ("DDERR_WRONGMODE\n");
+        else if (ddrval == DDERR_INCOMPATIBLEPRIMARY)
+          ErrorF ("DDERR_INCOMPATIBLEPRIMARY\n");
+        else if (ddrval == DDERR_UNSUPPORTED)
+          ErrorF ("DDERR_UNSUPPORTED\n");
+        else if (ddrval == DDERR_INVALIDPARAMS)
+          ErrorF ("DDERR_INVALIDPARAMS\n");
+        else if (ddrval == DDERR_INVALIDOBJECT)
+          ErrorF ("DDERR_INVALIDOBJECT\n");
+        else
+          ErrorF ("unknown error: %08x\n", ddrval);
+      }
+      /* Loop around to try the blit one more time */
+      continue;
+    }
+    else if (FAILED (ddrval))
+    {
+      ErrorF ("IDirectDrawSurface4_Blt failed, but surface not "
+              "lost: %08x %d\n", ddrval, ddrval);
+    }
+    break;
+  }
+  return ddrval;
+}
+
 /*
  * Create the primary surface and attach the clipper.
  * Used for both the initial surface creation and during
@@ -127,9 +187,7 @@ winCreatePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if 1
     winDebug("winCreatePrimarySurfaceShadowDDNL - Created primary surface\n");
-#endif
 
     /* Attach our clipper to our primary surface handle */
     ddrval = IDirectDrawSurface4_SetClipper(pScreenPriv->pddsPrimary4,
@@ -140,34 +198,22 @@ winCreatePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if 1
     winDebug("winCreatePrimarySurfaceShadowDDNL - Attached clipper to primary "
              "surface\n");
-#endif
 
     /* Everything was correct */
     return TRUE;
 }
 
-/*
- * Detach the clipper and release the primary surface.
- * Called from WM_DISPLAYCHANGE.
- */
-
-static Bool
-winReleasePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
+static void ClosePrimarySurfaceShadowDDNL (winPrivScreenPtr pScreenPriv)
 {
-    winScreenPriv(pScreen);
-
-    winDebug("winReleasePrimarySurfaceShadowDDNL - Hello\n");
-
     /* Release the primary surface and clipper, if they exist */
     if (pScreenPriv->pddsPrimary4) {
         /*
          * Detach the clipper from the primary surface.
          * NOTE: We do this explicity for clarity.  The Clipper is not released.
          */
-        IDirectDrawSurface4_SetClipper(pScreenPriv->pddsPrimary4, NULL);
+        IDirectDrawSurface4_SetClipper (pScreenPriv->pddsPrimary4, NULL);
 
         winDebug("winReleasePrimarySurfaceShadowDDNL - Detached clipper\n");
 
@@ -176,6 +222,47 @@ winReleasePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
         pScreenPriv->pddsPrimary4 = NULL;
     }
 
+}
+
+static void ReleaseDDNL(winPrivScreenPtr pScreenPriv)
+{
+  /* Release the clipper object */
+  if (pScreenPriv->pddcPrimary)
+    {
+      IDirectDrawClipper_Release (pScreenPriv->pddcPrimary);
+      pScreenPriv->pddcPrimary = NULL;
+    }
+
+  /* Free the DirectDraw4 object, if there is one */
+  if (pScreenPriv->pdd4)
+    {
+      IDirectDraw4_RestoreDisplayMode (pScreenPriv->pdd4);
+      IDirectDraw4_Release (pScreenPriv->pdd4);
+      pScreenPriv->pdd4 = NULL;
+    }
+
+  /* Free the DirectDraw object, if there is one */
+  if (pScreenPriv->pdd)
+    {
+      IDirectDraw_Release (pScreenPriv->pdd);
+      pScreenPriv->pdd = NULL;
+    }
+}
+
+/*
+ * Detach the clipper and release the primary surface.
+ * Called from WM_DISPLAYCHANGE.
+ */
+
+static Bool
+winReleasePrimarySurfaceShadowDDNL (ScreenPtr pScreen)
+{
+  winScreenPriv(pScreen);
+
+  winDebug ("winReleasePrimarySurfaceShadowDDNL - Hello\n");
+
+  ClosePrimarySurfaceShadowDDNL(pScreenPriv);
+
     winDebug("winReleasePrimarySurfaceShadowDDNL - Released primary surface\n");
 
     return TRUE;
@@ -199,30 +286,43 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
     char *lpSurface = NULL;
     DDPIXELFORMAT ddpfPrimary;
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - w %u h %u d %u\n",
              (unsigned int)pScreenInfo->dwWidth,
              (unsigned int)pScreenInfo->dwHeight,
              (unsigned int)pScreenInfo->dwDepth);
-#endif
 
     /* Set the padded screen width */
     pScreenInfo->dwPaddedWidth = PixmapBytePad(pScreenInfo->dwWidth,
                                                pScreenInfo->dwBPP);
 
-    /* Allocate memory for our shadow surface */
-    lpSurface = malloc(pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
-    if (lpSurface == NULL) {
-        ErrorF("winAllocateFBShadowDDNL - Could not allocate bits\n");
-        return FALSE;
-    }
-
-    /*
-     * Initialize the framebuffer memory so we don't get a
-     * strange display at startup
-     */
-    ZeroMemory(lpSurface, pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
+    if ( pScreenInfo->pfb)
+    {
+        ErrorF("winAllocateFBShadowDDNL calling for the second time, reallocating\n");
+        lpSurface=pScreenInfo->pfb;
 
+        if (pScreenPriv->pddsShadow4)
+        {
+            IDirectDrawSurface4_Release (pScreenPriv->pddsShadow4);
+            pScreenPriv->pddsShadow4 = NULL;
+        }
+        ClosePrimarySurfaceShadowDDNL(pScreenPriv);
+        ReleaseDDNL(pScreenPriv);
+    }
+    else
+    {
+        /* Allocate memory for our shadow surface */
+        lpSurface = malloc (pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
+        if (lpSurface == NULL) {
+            ErrorF ("winAllocateFBShadowDDNL - Could not allocate bits\n");
+            return FALSE;
+        }
+  
+        /*
+         * Initialize the framebuffer memory so we don't get a
+         * strange display at startup
+         */
+        ZeroMemory (lpSurface, pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
+    }
     /* Create a clipper */
     ddrval = (*g_fpDirectDrawCreateClipper) (0,
                                              &pScreenPriv->pddcPrimary, NULL);
@@ -232,9 +332,7 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - Created a clipper\n");
-#endif
 
     /* Attach the clipper to our display window */
     ddrval = IDirectDrawClipper_SetHWnd(pScreenPriv->pddcPrimary,
@@ -245,9 +343,7 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - Attached clipper to window\n");
-#endif
 
     /* Create a DirectDraw object, store the address at lpdd */
     ddrval = (*g_fpDirectDrawCreate) (NULL,
@@ -259,9 +355,7 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - Created and initialized DD\n");
-#endif
 
     /* Get a DirectDraw4 interface pointer */
     ddrval = IDirectDraw_QueryInterface(pScreenPriv->pdd,
@@ -400,14 +494,12 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - Primary masks: %08x %08x %08x "
              "dwRGBBitCount: %u\n",
              (unsigned int)ddpfPrimary.u2.dwRBitMask,
              (unsigned int)ddpfPrimary.u3.dwGBitMask,
              (unsigned int)ddpfPrimary.u4.dwBBitMask,
              (unsigned int)ddpfPrimary.u1.dwRGBBitCount);
-#endif
 
     /* Describe the shadow surface to be created */
     /*
@@ -442,19 +534,15 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG || YES
     winDebug("winAllocateFBShadowDDNL - Created shadow pitch: %d\n",
              (int) ddsdShadow.u1.lPitch);
-#endif
 
     /* Grab the pitch from the surface desc */
     pScreenInfo->dwStride = (ddsdShadow.u1.lPitch * 8)
         / pScreenInfo->dwBPP;
 
-#if CYGDEBUG || YES
     winDebug("winAllocateFBShadowDDNL - Created shadow stride: %d\n",
              (int) pScreenInfo->dwStride);
-#endif
 
     /* Save the pointer to our surface memory */
     pScreenInfo->pfb = lpSurface;
@@ -464,9 +552,7 @@ winAllocateFBShadowDDNL(ScreenPtr pScreen)
     pScreenPriv->dwGreenMask = ddsdShadow.u4.ddpfPixelFormat.u3.dwGBitMask;
     pScreenPriv->dwBlueMask = ddsdShadow.u4.ddpfPixelFormat.u4.dwBBitMask;
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowDDNL - Returning\n");
-#endif
 
     return TRUE;
 }
@@ -488,24 +574,7 @@ winFreeFBShadowDDNL(ScreenPtr pScreen)
     /* Detach the clipper from the primary surface and release the primary surface, if there is one */
     winReleasePrimarySurfaceShadowDDNL(pScreen);
 
-    /* Release the clipper object */
-    if (pScreenPriv->pddcPrimary) {
-        IDirectDrawClipper_Release(pScreenPriv->pddcPrimary);
-        pScreenPriv->pddcPrimary = NULL;
-    }
-
-    /* Free the DirectDraw4 object, if there is one */
-    if (pScreenPriv->pdd4) {
-        IDirectDraw4_RestoreDisplayMode(pScreenPriv->pdd4);
-        IDirectDraw4_Release(pScreenPriv->pdd4);
-        pScreenPriv->pdd4 = NULL;
-    }
-
-    /* Free the DirectDraw object, if there is one */
-    if (pScreenPriv->pdd) {
-        IDirectDraw_Release(pScreenPriv->pdd);
-        pScreenPriv->pdd = NULL;
-    }
+    ReleaseDDNL(pScreenPriv);
 
     /* Invalidate the ScreenInfo's fb pointer */
     pScreenInfo->pfb = NULL;
@@ -521,7 +590,6 @@ winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf)
     winScreenPriv(pScreen);
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
     RegionPtr damage = DamageRegion(pBuf->pDamage);
-    HRESULT ddrval = DD_OK;
     RECT rcDest, rcSrc;
     POINT ptOrigin;
     DWORD dwBox = RegionNumRects(damage);
@@ -568,27 +636,10 @@ winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf)
             rcDest.bottom = ptOrigin.y + rcSrc.bottom;
 
             /* Blit the damaged areas */
-            ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
-                                             &rcDest,
-                                             pScreenPriv->pddsShadow4,
-                                             &rcSrc, DDBLT_WAIT, NULL);
-            if (FAILED(ddrval)) {
-                static int s_iFailCount = 0;
-
-                if (s_iFailCount < FAIL_MSG_MAX_BLT) {
-                    ErrorF("winShadowUpdateDDNL - IDirectDrawSurface4_Blt () "
-                           "failed: %08x\n", (unsigned int) ddrval);
-
-                    ++s_iFailCount;
-
-                    if (s_iFailCount == FAIL_MSG_MAX_BLT) {
-                        ErrorF("winShadowUpdateDDNL - IDirectDrawSurface4_Blt "
-                               "failure message maximum (%d) reached.  No "
-                               "more failure messages will be printed.\n",
-                               FAIL_MSG_MAX_BLT);
-                    }
-                }
-            }
+            if (pScreenPriv->pddsPrimary4)
+                myIDirectDrawSurface4_Blt (pScreen,
+                                           &rcDest,
+                                           &rcSrc);
 
             /* Get a pointer to the next box */
             ++pBox;
@@ -607,11 +658,9 @@ winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf)
         DeleteObject(hrgnCombined);
         hrgnCombined = NULL;
 
-#if CYGDEBUG
         winDebug("winShadowUpdateDDNL - be x1 %d y1 %d x2 %d y2 %d\n",
                  pBoxExtents->x1, pBoxExtents->y1,
                  pBoxExtents->x2, pBoxExtents->y2);
-#endif
 
         /* Calculating a bounding box for the source is easy */
         rcSrc.left = pBoxExtents->x1;
@@ -626,10 +675,7 @@ winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf)
         rcDest.bottom = ptOrigin.y + rcSrc.bottom;
 
         /* Our Blt should be clipped to the invalidated region */
-        ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
-                                         &rcDest,
-                                         pScreenPriv->pddsShadow4,
-                                         &rcSrc, DDBLT_WAIT, NULL);
+        myIDirectDrawSurface4_Blt (pScreen, &rcDest, &rcSrc);
 
         /* Reset the clip region */
         SelectClipRgn(pScreenPriv->hdcScreen, NULL);
@@ -660,9 +706,7 @@ winCloseScreenShadowDDNL(ScreenPtr pScreen)
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
     Bool fReturn = TRUE;
 
-#if CYGDEBUG
     winDebug("winCloseScreenShadowDDNL - Freeing screen resources\n");
-#endif
 
     /* Flag that the screen is closed */
     pScreenPriv->fClosed = TRUE;
@@ -682,7 +726,7 @@ winCloseScreenShadowDDNL(ScreenPtr pScreen)
     RemoveProp(pScreenPriv->hwndScreen, WIN_SCR_PROP);
 
     /* Delete tray icon, if we have one */
-    if (!pScreenInfo->fNoTrayIcon)
+    if (!pScreenInfo->fNoTrayIcon && !pref.fNoTrayIcon)
         winDeleteNotifyIcon(pScreenPriv);
 
     /* Free the exit confirmation dialog box, if it exists */
@@ -698,7 +742,7 @@ winCloseScreenShadowDDNL(ScreenPtr pScreen)
     }
 
     /* Destroy the thread startup mutex */
-    pthread_mutex_destroy(&pScreenPriv->pmServerStarted);
+    if (pScreenPriv->pmServerStarted) pthread_mutex_destroy (&pScreenPriv->pmServerStarted);
 
     /* Kill our screeninfo's pointer to the screen */
     pScreenInfo->pScreen = NULL;
@@ -799,9 +843,7 @@ winInitVisualsShadowDDNL(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winInitVisualsShadowDDNL - Returning\n");
-#endif
 
     return TRUE;
 }
@@ -893,58 +935,14 @@ winBltExposedRegionsShadowDDNL(ScreenPtr pScreen)
     rcSrc.right = pScreenInfo->dwWidth;
     rcSrc.bottom = pScreenInfo->dwHeight;
 
-    /* Try to regain the primary surface and blit again if we've lost it */
-    for (i = 0; i <= WIN_REGAIN_SURFACE_RETRIES; ++i) {
-        /* Our Blt should be clipped to the invalidated region */
-        ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
-                                         &rcDest,
-                                         pScreenPriv->pddsShadow4,
-                                         &rcSrc, DDBLT_WAIT, NULL);
-        if (ddrval == DDERR_SURFACELOST) {
-            /* Surface was lost */
-            winErrorFVerb(1, "winBltExposedRegionsShadowDDNL - "
-                          "IDirectDrawSurface4_Blt reported that the primary "
-                          "surface was lost, trying to restore, retry: %d\n",
-                          i + 1);
-
-            /* Try to restore the surface, once */
-
-            ddrval = IDirectDrawSurface4_Restore(pScreenPriv->pddsPrimary4);
-            winDebug("winBltExposedRegionsShadowDDNL - "
-                     "IDirectDrawSurface4_Restore returned: ");
-            if (ddrval == DD_OK)
-                winDebug("DD_OK\n");
-            else if (ddrval == DDERR_WRONGMODE)
-                winDebug("DDERR_WRONGMODE\n");
-            else if (ddrval == DDERR_INCOMPATIBLEPRIMARY)
-                winDebug("DDERR_INCOMPATIBLEPRIMARY\n");
-            else if (ddrval == DDERR_UNSUPPORTED)
-                winDebug("DDERR_UNSUPPORTED\n");
-            else if (ddrval == DDERR_INVALIDPARAMS)
-                winDebug("DDERR_INVALIDPARAMS\n");
-            else if (ddrval == DDERR_INVALIDOBJECT)
-                winDebug("DDERR_INVALIDOBJECT\n");
-            else
-                winDebug("unknown error: %08x\n", (unsigned int) ddrval);
-
-            /* Loop around to try the blit one more time */
-            continue;
-        }
-        else if (FAILED(ddrval)) {
-            fReturn = FALSE;
-            winErrorFVerb(1, "winBltExposedRegionsShadowDDNL - "
-                          "IDirectDrawSurface4_Blt failed, but surface not "
-                          "lost: %08x %d\n",
-                          (unsigned int) ddrval, (int) ddrval);
-            goto winBltExposedRegionsShadowDDNL_Exit;
-        }
-        else {
-            /* Success, stop looping */
-            break;
-        }
+    /* Our Blt should be clipped to the invalidated region */
+    ddrval = myIDirectDrawSurface4_Blt (pScreen, &rcDest, &rcSrc);
+    if (FAILED (ddrval))
+    {
+        fReturn = FALSE;
     }
 
- winBltExposedRegionsShadowDDNL_Exit:
+winBltExposedRegionsShadowDDNL_Exit:
     /* EndPaint frees the DC */
     if (hdcUpdate != NULL)
         EndPaint(pScreenPriv->hwndScreen, &ps);
@@ -983,7 +981,6 @@ winRedrawScreenShadowDDNL(ScreenPtr pScreen)
 {
     winScreenPriv(pScreen);
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
-    HRESULT ddrval = DD_OK;
     RECT rcSrc, rcDest;
     POINT ptOrigin;
 
@@ -1008,15 +1005,7 @@ winRedrawScreenShadowDDNL(ScreenPtr pScreen)
     rcSrc.bottom = pScreenInfo->dwHeight;
 
     /* Redraw the whole window, to take account for the new colors */
-    ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
-                                     &rcDest,
-                                     pScreenPriv->pddsShadow4,
-                                     &rcSrc, DDBLT_WAIT, NULL);
-    if (FAILED(ddrval)) {
-        ErrorF("winRedrawScreenShadowDDNL - IDirectDrawSurface4_Blt () "
-               "failed: %08x\n", (unsigned int) ddrval);
-    }
-
+    myIDirectDrawSurface4_Blt (pScreen, &rcDest, &rcSrc);
     return TRUE;
 }
 
@@ -1046,7 +1035,7 @@ winInstallColormapShadowDDNL(ColormapPtr pColormap)
     /* Install the DirectDraw palette on the primary surface */
     ddrval = IDirectDrawSurface4_SetPalette(pScreenPriv->pddsPrimary4,
                                             pCmapPriv->lpDDPalette);
-    if (FAILED(ddrval)) {
+    if (FAILED(ddrval) && ddrval != DDERR_SURFACELOST) {
         ErrorF("winInstallColormapShadowDDNL - Failed installing the "
                "DirectDraw palette.\n");
         return FALSE;
@@ -1144,10 +1133,8 @@ winDestroyColormapShadowDDNL(ColormapPtr pColormap)
      * we need to handle the default colormap in a special way.
      */
     if (pColormap->flags & IsDefault) {
-#if CYGDEBUG
         winDebug
             ("winDestroyColormapShadowDDNL - Destroying default colormap\n");
-#endif
 
         /*
          * FIXME: Walk the list of all screens, popping the default
diff --git a/xserver/hw/xwin/winshadgdi.c b/vcxsrv-code/xorg-server/hw/xwin/winshadgdi.c
index 25e16bf..6484057 100644
--- a/xserver/hw/xwin/winshadgdi.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winshadgdi.c
@@ -32,6 +32,7 @@
 #include <xwin-config.h>
 #endif
 #include "win.h"
+#include "winprefs.h"
 
 /*
  * Local function prototypes
@@ -93,8 +94,7 @@ winQueryScreenDIBFormat(ScreenPtr pScreen, BITMAPINFOHEADER * pbmih)
 {
     winScreenPriv(pScreen);
     HBITMAP hbmp;
-
-#if CYGDEBUG
+#ifdef WINDBG
     LPDWORD pdw = NULL;
 #endif
 
@@ -117,7 +117,7 @@ winQueryScreenDIBFormat(ScreenPtr pScreen, BITMAPINFOHEADER * pbmih)
         return FALSE;
     }
 
-#if CYGDEBUG
+#ifdef WINDBG
     /* Get a pointer to bitfields */
     pdw = (DWORD *) ((CARD8 *) pbmih + sizeof(BITMAPINFOHEADER));
 
@@ -170,8 +170,8 @@ winQueryRGBBitsAndMasks(ScreenPtr pScreen)
     /* Color masks for 24 bpp are standardized */
     if (GetDeviceCaps(pScreenPriv->hdcScreen, PLANES)
         * GetDeviceCaps(pScreenPriv->hdcScreen, BITSPIXEL) == 24) {
-        ErrorF("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
-               "returned 24 for the screen.  Using default 24bpp masks.\n");
+        winDebug ("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
+                  "returned 24 for the screen.  Using default 24bpp masks.\n");
 
         /* 8 bits per primary color */
         pScreenPriv->dwBitsPerRGB = 8;
@@ -196,7 +196,7 @@ winQueryRGBBitsAndMasks(ScreenPtr pScreen)
         /* Get a pointer to bitfields */
         pdw = (DWORD *) ((CARD8 *) pbmih + sizeof(BITMAPINFOHEADER));
 
-#if CYGDEBUG
+#ifdef WINDBG
         winDebug("%s - Masks: %08x %08x %08x\n", __FUNCTION__,
                  (unsigned int)pdw[0], (unsigned int)pdw[1], (unsigned int)pdw[2]);
         winDebug("%s - Bitmap: %dx%d %d bpp %d planes\n", __FUNCTION__,
@@ -326,10 +326,10 @@ winAllocateFBShadowGDI(ScreenPtr pScreen)
     pScreenPriv->pbmih->biWidth = pScreenInfo->dwWidth;
     pScreenPriv->pbmih->biHeight = -pScreenInfo->dwHeight;
 
-    ErrorF("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
-           "depth: %d\n",
-           (int) pScreenPriv->pbmih->biWidth,
-           (int) -pScreenPriv->pbmih->biHeight, pScreenPriv->pbmih->biBitCount);
+    winDebug ("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
+              "depth: %d\n",
+              (int) pScreenPriv->pbmih->biWidth,
+              (int) -pScreenPriv->pbmih->biHeight, pScreenPriv->pbmih->biBitCount);
 
     /* Create a DI shadow bitmap with a bit pointer */
     pScreenPriv->hbmpShadow = CreateDIBSection(pScreenPriv->hdcScreen,
@@ -338,32 +338,26 @@ winAllocateFBShadowGDI(ScreenPtr pScreen)
                                                (VOID **) &pScreenInfo->pfb,
                                                NULL, 0);
     if (pScreenPriv->hbmpShadow == NULL || pScreenInfo->pfb == NULL) {
-        winW32Error(2, "winAllocateFBShadowGDI - CreateDIBSection failed:");
+        winW32Error ("winAllocateFBShadowGDI - CreateDIBSection failed:");
         return FALSE;
     }
     else {
-#if CYGDEBUG
         winDebug("winAllocateFBShadowGDI - Shadow buffer allocated\n");
-#endif
     }
 
     /* Get information about the bitmap that was allocated */
     GetObject(pScreenPriv->hbmpShadow, sizeof(dibsection), &dibsection);
 
-#if CYGDEBUG || YES
     /* Print information about bitmap allocated */
     winDebug("winAllocateFBShadowGDI - Dibsection width: %d height: %d "
              "depth: %d size image: %d\n",
              (int) dibsection.dsBmih.biWidth, (int) dibsection.dsBmih.biHeight,
              dibsection.dsBmih.biBitCount, (int) dibsection.dsBmih.biSizeImage);
-#endif
 
     /* Select the shadow bitmap into the shadow DC */
     SelectObject(pScreenPriv->hdcShadow, pScreenPriv->hbmpShadow);
 
-#if CYGDEBUG
     winDebug("winAllocateFBShadowGDI - Attempting a shadow blit\n");
-#endif
 
     /* Do a test blit from the shadow to the screen, I think */
     fReturn = BitBlt(pScreenPriv->hdcScreen,
@@ -371,20 +365,14 @@ winAllocateFBShadowGDI(ScreenPtr pScreen)
                      pScreenInfo->dwWidth, pScreenInfo->dwHeight,
                      pScreenPriv->hdcShadow, 0, 0, SRCCOPY);
     if (fReturn) {
-#if CYGDEBUG
         winDebug("winAllocateFBShadowGDI - Shadow blit success\n");
-#endif
     }
     else {
-        winW32Error(2, "winAllocateFBShadowGDI - Shadow blit failure\n");
-#if 0
-        return FALSE;
-#else
+        winW32Error ("winAllocateFBShadowGDI - Shadow blit failure\n");
         /* ago: ignore this error. The blit fails with wine, but does not
          * cause any problems later. */
 
         fReturn = TRUE;
-#endif
     }
 
     /* Look for height weirdness */
@@ -397,10 +385,8 @@ winAllocateFBShadowGDI(ScreenPtr pScreen)
                               / dibsection.dsBmih.biHeight)
                              * 8) / pScreenInfo->dwBPP;
 
-#if CYGDEBUG || YES
     winDebug("winAllocateFBShadowGDI - Created shadow stride: %d\n",
              (int) pScreenInfo->dwStride);
-#endif
 
     /* Redraw all windows */
     if (pScreenInfo->fMultiWindow)
@@ -458,15 +444,15 @@ winShadowUpdateGDI(ScreenPtr pScreen, shadowBufPtr pBuf)
 
     if (dwBox != 1) {
         ++s_dwNonUnitRegions;
-        ErrorF("winShadowUpdatGDI - dwBox: %d\n", dwBox);
+        winDebug ("winShadowUpdatGDI - dwBox: %d\n", dwBox);
     }
 
     if ((s_dwTotalUpdates % 100) == 0)
-        ErrorF("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
-               "nu: %d tu: %d\n",
-               (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
-               s_dwTotalBoxes / s_dwTotalUpdates,
-               s_dwNonUnitRegions, s_dwTotalUpdates);
+        winDebug ("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
+                  "nu: %d tu: %d\n",
+                  (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
+                  s_dwTotalBoxes / s_dwTotalUpdates,
+                  s_dwNonUnitRegions, s_dwTotalUpdates);
 #endif                          /* XWIN_UPDATESTATS */
 
     /*
@@ -573,9 +559,7 @@ winCloseScreenShadowGDI(ScreenPtr pScreen)
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
     Bool fReturn = TRUE;
 
-#if CYGDEBUG
     winDebug("winCloseScreenShadowGDI - Freeing screen resources\n");
-#endif
 
     /* Flag that the screen is closed */
     pScreenPriv->fClosed = TRUE;
@@ -598,7 +582,7 @@ winCloseScreenShadowGDI(ScreenPtr pScreen)
     ReleaseDC(pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);
 
     /* Delete tray icon, if we have one */
-    if (!pScreenInfo->fNoTrayIcon)
+    if (!pScreenInfo->fNoTrayIcon && !pref.fNoTrayIcon)
         winDeleteNotifyIcon(pScreenPriv);
 
     /* Free the exit confirmation dialog box, if it exists */
@@ -614,7 +598,7 @@ winCloseScreenShadowGDI(ScreenPtr pScreen)
     }
 
     /* Destroy the thread startup mutex */
-    pthread_mutex_destroy(&pScreenPriv->pmServerStarted);
+    if (pScreenPriv->pmServerStarted) pthread_mutex_destroy (&pScreenPriv->pmServerStarted);
 
     /* Invalidate our screeninfo's pointer to the screen */
     pScreenInfo->pScreen = NULL;
@@ -640,13 +624,13 @@ winInitVisualsShadowGDI(ScreenPtr pScreen)
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
 
     /* Display debugging information */
-    ErrorF("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
-           "bpp %d\n",
-           (unsigned int) pScreenPriv->dwRedMask,
-           (unsigned int) pScreenPriv->dwGreenMask,
-           (unsigned int) pScreenPriv->dwBlueMask,
-           (int) pScreenPriv->dwBitsPerRGB,
-           (int) pScreenInfo->dwDepth, (int) pScreenInfo->dwBPP);
+    winDebug ("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
+              "bpp %d\n",
+              (unsigned int) pScreenPriv->dwRedMask,
+              (unsigned int) pScreenPriv->dwGreenMask,
+              (unsigned int) pScreenPriv->dwBlueMask,
+              (int) pScreenPriv->dwBitsPerRGB,
+              (int) pScreenInfo->dwDepth, (int) pScreenInfo->dwBPP);
 
     /* Create a single visual according to the Windows screen depth */
     switch (pScreenInfo->dwDepth) {
@@ -698,9 +682,7 @@ winInitVisualsShadowGDI(ScreenPtr pScreen)
         return FALSE;
     }
 
-#if CYGDEBUG
     winDebug("winInitVisualsShadowGDI - Returning\n");
-#endif
 
     return TRUE;
 }
@@ -1002,16 +984,12 @@ winRealizeInstalledPaletteShadowGDI(ScreenPtr pScreen)
     winScreenPriv(pScreen);
     winPrivCmapPtr pCmapPriv = NULL;
 
-#if CYGDEBUG
     winDebug("winRealizeInstalledPaletteShadowGDI\n");
-#endif
 
     /* Don't do anything if there is not a colormap */
     if (pScreenPriv->pcmapInstalled == NULL) {
-#if CYGDEBUG
         winDebug("winRealizeInstalledPaletteShadowGDI - No colormap "
                  "installed\n");
-#endif
         return TRUE;
     }
 
@@ -1214,10 +1192,8 @@ winDestroyColormapShadowGDI(ColormapPtr pColormap)
      * we need to handle the default colormap in a special way.
      */
     if (pColormap->flags & IsDefault) {
-#if CYGDEBUG
         winDebug("winDestroyColormapShadowGDI - Destroying default "
                  "colormap\n");
-#endif
 
         /*
          * FIXME: Walk the list of all screens, popping the default
diff --git a/xserver/hw/xwin/wintaskbar.c b/vcxsrv-code/xorg-server/hw/xwin/wintaskbar.c
index 401ec17..161ddb6 100644
--- a/xserver/hw/xwin/wintaskbar.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/wintaskbar.c
@@ -26,34 +26,7 @@
 #include "win.h"
 #include "winwindow.h"
 
-const GUID CLSID_TaskbarList = {0x56fdf344,0xfd6d,0x11d0,{0x95,0x8a,0x0,0x60,0x97,0xc9,0xa0,0x90}};
-const GUID IID_ITaskbarList =  {0x56fdf342,0xfd6d,0x11d0,{0x95,0x8a,0x0,0x60,0x97,0xc9,0xa0,0x90}};
-
-#ifdef INTERFACE
-#undef INTERFACE
-#endif
-
-#define INTERFACE ITaskbarList
-DECLARE_INTERFACE_(ITaskbarList, IUnknown)
-{
-  /* IUnknown methods */
-  STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
-  STDMETHOD_(ULONG, AddRef) (THIS) PURE;
-  STDMETHOD_(ULONG, Release) (THIS) PURE;
-
-  /* ITaskbarList methods */
-  STDMETHOD(HrInit) (THIS) PURE;
-  STDMETHOD(AddTab) (THIS_ HWND hWnd) PURE;
-  STDMETHOD(DeleteTab) (THIS_ HWND hWnd) PURE;
-  STDMETHOD(ActivateTab) (THIS_ HWND hWnd) PURE;
-  STDMETHOD(SetActiveAlt) (THIS_ HWND hWnd) PURE;
-};
-#undef INTERFACE
-
-/*
-   The stuff above needs to be in win32api headers, not defined here,
-   or at least generated from the MIDL :-)
-*/
+#include <shobjidl.h>
 
 /*
   This is unnecessarily heavyweight, we could just call CoInitialize() once at
diff --git a/xserver/hw/xwin/wintrayicon.c b/vcxsrv-code/xorg-server/hw/xwin/wintrayicon.c
index 5d1e6ae..ff86b27 100644
--- a/xserver/hw/xwin/wintrayicon.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/wintrayicon.c
@@ -38,34 +38,57 @@
 #include "winprefs.h"
 #include "winclipboard/winclipboard.h"
 
+static NOTIFYICONDATA nid;
 /*
  * Initialize the tray icon
  */
 
 void
-winInitNotifyIcon(winPrivScreenPtr pScreenPriv)
+winInitNotifyIcon(winPrivScreenPtr pScreenPriv, Bool Modify)
 {
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
-    NOTIFYICONDATA nid = { 0 };
+    char HostName[256];
 
-    nid.cbSize = sizeof(NOTIFYICONDATA);
-    nid.hWnd = pScreenPriv->hwndScreen;
-    nid.uID = pScreenInfo->dwScreen;
-    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
-    nid.uCallbackMessage = WM_TRAYICON;
-    nid.hIcon = winTaskbarIcon();
+    if (!Modify)
+    {
+        nid.cbSize = sizeof(NOTIFYICONDATA);
+        nid.hWnd = pScreenPriv->hwndScreen;
+        nid.uID = pScreenInfo->dwScreen;
+        nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
+        nid.uCallbackMessage = WM_TRAYICON;
+        nid.hIcon = winTaskbarIcon();
+
+        /* Save handle to the icon so it can be freed later */
+        pScreenPriv->hiconNotifyIcon = nid.hIcon;
+    }
 
-    /* Save handle to the icon so it can be freed later */
-    pScreenPriv->hiconNotifyIcon = nid.hIcon;
+    gethostname(HostName,256);
 
     /* Set display and screen-specific tooltip text */
-    snprintf(nid.szTip,
-             sizeof(nid.szTip),
-             PROJECT_NAME " Server:%s.%d",
-             display, (int) pScreenInfo->dwScreen);
+    if (g_pszQueryHost)
+    {
+        snprintf(nid.szTip,
+                 sizeof(nid.szTip),
+                 "%s - %s:%s.%d - %d clients",
+	               g_pszQueryHost,
+	               HostName,
+                 display, 
+                 (int) pScreenInfo->dwScreen,
+                 pScreenPriv->iConnectedClients);
+    }
+    else
+    {
+        snprintf (nid.szTip,
+                  sizeof (nid.szTip),
+                  "%s:%s.%d - %d clients",
+                  HostName,
+                  display, 
+                  (int) pScreenInfo->dwScreen,
+                  pScreenPriv->iConnectedClients);
+    }
 
     /* Add the tray icon */
-    if (!Shell_NotifyIcon(NIM_ADD, &nid))
+    if (!Shell_NotifyIcon ((Modify) ? NIM_MODIFY : NIM_ADD, &nid))
         ErrorF("winInitNotifyIcon - Shell_NotifyIcon Failed\n");
 }
 
@@ -77,27 +100,16 @@ void
 winDeleteNotifyIcon(winPrivScreenPtr pScreenPriv)
 {
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
-    NOTIFYICONDATA nid = { 0 };
-
-#if 0
-    ErrorF("winDeleteNotifyIcon\n");
-#endif
 
-    nid.cbSize = sizeof(NOTIFYICONDATA);
-    nid.hWnd = pScreenPriv->hwndScreen;
-    nid.uID = pScreenInfo->dwScreen;
+    if (!pScreenPriv->hiconNotifyIcon)
+        return;
 
     /* Delete the tray icon */
-    if (!Shell_NotifyIcon(NIM_DELETE, &nid)) {
-        ErrorF("winDeleteNotifyIcon - Shell_NotifyIcon failed\n");
-        return;
-    }
+    Shell_NotifyIcon (NIM_DELETE, &nid);
 
     /* Free the icon that was loaded */
-    if (pScreenPriv->hiconNotifyIcon != NULL
-        && DestroyIcon(pScreenPriv->hiconNotifyIcon) == 0) {
-        ErrorF("winDeleteNotifyIcon - DestroyIcon failed\n");
-    }
+    DestroyIcon (pScreenPriv->hiconNotifyIcon);
+
     pScreenPriv->hiconNotifyIcon = NULL;
 }
 
@@ -112,6 +124,17 @@ winHandleIconMessage(HWND hwnd, UINT message,
     winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
 
     switch (lParam) {
+    case WM_MOUSEMOVE:
+    {
+      static int PrevNrClients;
+      int NrClients=GetLiveClients(pScreenPriv);
+      if (NrClients!=PrevNrClients)
+      {
+        PrevNrClients=NrClients;
+        winInitNotifyIcon (pScreenPriv, TRUE);
+      }
+    }
+    break;
     case WM_LBUTTONUP:
         /* Restack and bring all windows to top */
         SetForegroundWindow (pScreenPriv->hwndScreen);
diff --git a/xserver/hw/xwin/winvalargs.c b/vcxsrv-code/xorg-server/hw/xwin/winvalargs.c
index 008c111..317fb91 100644
--- a/xserver/hw/xwin/winvalargs.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winvalargs.c
@@ -67,12 +67,11 @@ winValidateArgs(void)
      *    XWin -screen 1 -screen 2
      */
     if (!isEveryScreenExplicit()) {
-        ErrorF("winValidateArgs - Malformed set of screen parameter(s).  "
-               "Screens must be specified consecutively starting with "
-               "screen 0.  That is, you cannot have only a screen 1, nor "
-               "could you have screen 0 and screen 2.  You instead must "
-               "have screen 0, or screen 0 and screen 1, respectively.  "
-               "You can specify as many screens as you want.\n");
+        ErrorF("winValidateArgs - Malformed set of screen parameter(s).\n"
+               "\t\tScreens must be specified consecutively starting with screen 0.\n"
+               "\t\tThat is, you cannot have only a screen 1, nor could you have screen 0 and screen 2.\n"
+               "\t\tYou instead must have screen 0, or screen 0 and screen 1, respectively.\n"
+               "\t\tYou can specify as many screens as you want.\n");
         return FALSE;
     }
 
@@ -160,7 +159,7 @@ winValidateArgs(void)
         if (g_ScreenInfo[i].fMultiWindow && g_ScreenInfo[i].fCompositeWM) {
             if (g_fSoftwareCursor) {
                 g_fSoftwareCursor = FALSE;
-                winMsg(X_WARNING, "Ignoring -swcursor due to -compositewm\n");
+                ErrorF("Ignoring -swcursor due to -compositewm\n");
             }
         }
     }
diff --git a/xserver/hw/xwin/winwindow.c b/vcxsrv-code/xorg-server/hw/xwin/winwindow.c
index 934f6d8..0ec17bb 100644
--- a/xserver/hw/xwin/winwindow.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winwindow.c
@@ -61,9 +61,7 @@ winCreateWindowRootless(WindowPtr pWin)
     winWindowPriv(pWin);
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winCreateWindowRootless (%p)\n", pWin);
-#endif
+  winDebug ("winCreateWindowRootless (%p)\n", pWin);
 
     WIN_UNWRAP(CreateWindow);
     fResult = (*pScreen->CreateWindow) (pWin);
@@ -86,9 +84,7 @@ winDestroyWindowRootless(WindowPtr pWin)
     winWindowPriv(pWin);
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winDestroyWindowRootless (%p)\n", pWin);
-#endif
+  winDebug ("winDestroyWindowRootless (%p)\n", pWin);
 
     WIN_UNWRAP(DestroyWindow);
     fResult = (*pScreen->DestroyWindow) (pWin);
@@ -115,9 +111,7 @@ winPositionWindowRootless(WindowPtr pWin, int x, int y)
 
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winPositionWindowRootless (%p)\n", pWin);
-#endif
+    winDebug ("winPositionWindowRootless (%p)\n", pWin);
 
     WIN_UNWRAP(PositionWindow);
     fResult = (*pScreen->PositionWindow) (pWin, x, y);
@@ -139,9 +133,7 @@ winChangeWindowAttributesRootless(WindowPtr pWin, unsigned long mask)
 
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winChangeWindowAttributesRootless (%p)\n", pWin);
-#endif
+  winDebug ("winChangeWindowAttributesRootless (%p)\n", pWin);
 
     WIN_UNWRAP(ChangeWindowAttributes);
     fResult = (*pScreen->ChangeWindowAttributes) (pWin, mask);
@@ -165,9 +157,7 @@ winUnmapWindowRootless(WindowPtr pWin)
     winWindowPriv(pWin);
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winUnmapWindowRootless (%p)\n", pWin);
-#endif
+  winDebug ("winUnmapWindowRootless (%p)\n", pWin);
 
     WIN_UNWRAP(UnrealizeWindow);
     fResult = (*pScreen->UnrealizeWindow) (pWin);
@@ -195,9 +185,7 @@ winMapWindowRootless(WindowPtr pWin)
 
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winMapWindowRootless (%p)\n", pWin);
-#endif
+  winDebug ("winMapWindowRootless (%p)\n", pWin);
 
     WIN_UNWRAP(RealizeWindow);
     fResult = (*pScreen->RealizeWindow) (pWin);
@@ -217,9 +205,7 @@ winSetShapeRootless(WindowPtr pWin, int kind)
 
     winScreenPriv(pScreen);
 
-#if CYGDEBUG
-    winTrace("winSetShapeRootless (%p, %i)\n", pWin, kind);
-#endif
+  winDebug ("winSetShapeRootless (%p, %i)\n", pWin, kind);
 
     WIN_UNWRAP(SetShape);
     (*pScreen->SetShape) (pWin, kind);
@@ -247,9 +233,7 @@ winAddRgn(WindowPtr pWin, void *data)
 
     /* If pWin is not Root */
     if (pWin->parent != NULL) {
-#if CYGDEBUG
         winDebug("winAddRgn ()\n");
-#endif
         if (pWin->mapped) {
             iBorder = wBorderWidth(pWin);
 
@@ -262,9 +246,9 @@ winAddRgn(WindowPtr pWin, void *data)
             hRgnWin = CreateRectRgn(0, 0, iWidth, iHeight);
 
             if (hRgnWin == NULL) {
-                ErrorF("winAddRgn - CreateRectRgn () failed\n");
-                ErrorF("  Rect %d %d %d %d\n",
-                       iX, iY, iX + iWidth, iY + iHeight);
+                 winDebug ("winAddRgn - CreateRectRgn () failed\n");
+                 winDebug ("  Rect %d %d %d %d\n",
+                           iX, iY, iX + iWidth, iY + iHeight);
             }
 
             if (pWinPriv->hRgn) {
@@ -320,9 +304,7 @@ winReshapeRootless(WindowPtr pWin)
 
     winWindowPriv(pWin);
 
-#if CYGDEBUG
     winDebug("winReshapeRootless ()\n");
-#endif
 
     /* Bail if the window is the root window */
     if (pWin->parent == NULL)
diff --git a/xserver/hw/xwin/winwindow.h b/vcxsrv-code/xorg-server/hw/xwin/winwindow.h
index 92a839c..ddaca34 100644
--- a/xserver/hw/xwin/winwindow.h
+++ b/vcxsrv-code/xorg-server/hw/xwin/winwindow.h
@@ -32,6 +32,8 @@
 #if !defined(_WINWINDOW_H_)
 #define _WINWINDOW_H_
 
+#include <pthread.h>
+
 #ifndef NO
 #define NO			0
 #endif
@@ -41,30 +43,25 @@
 
 /* Constant strings */
 #ifndef PROJECT_NAME
-#define PROJECT_NAME		"Cygwin/X"
+#define PROJECT_NAME		"VcXsrv"
 #endif
-#define EXECUTABLE_NAME         "XWin"
-#define WINDOW_CLASS		"cygwin/x"
-#define WINDOW_TITLE		PROJECT_NAME ":%s.%d"
-#define WINDOW_TITLE_XDMCP	"%s:%s.%d"
-#define WIN_SCR_PROP		"cyg_screen_prop rl"
-#define WINDOW_CLASS_X		"cygwin/x X rl"
-#define WINDOW_CLASS_X_MSG      "cygwin/x X msg"
-#define WINDOW_TITLE_X		PROJECT_NAME " X"
-#define WIN_WINDOW_PROP		"cyg_window_prop_rl"
+#define EXECUTABLE_NAME         "VcXsrv"
+#define WINDOW_CLASS            "VcXsrv/x"
+#define WINDOW_TITLE            PROJECT_NAME " Server - Display %s:%s.%d"
+#define WINDOW_TITLE_XDMCP      PROJECT_NAME " Server - %s - Display %s:%s.%d"
+extern const char WIN_SCR_PROP[];
+#define WINDOW_CLASS_X          "vcxsrv/x X rl"
+#define WINDOW_CLASS_X_MSG      "vcxsrv/x X msg"
+#define WINDOW_TITLE_X          PROJECT_NAME " X"
+extern const char WIN_WINDOW_PROP[];
 #ifdef HAS_DEVWINDOWS
-#define WIN_MSG_QUEUE_FNAME	"/dev/windows"
-#endif
-#define WIN_WID_PROP		"cyg_wid_prop_rl"
-#define WIN_NEEDMANAGE_PROP	"cyg_override_redirect_prop_rl"
-#ifndef CYGMULTIWINDOW_DEBUG
-#define CYGMULTIWINDOW_DEBUG    NO
-#endif
-#ifndef CYGWINDOWING_DEBUG
-#define CYGWINDOWING_DEBUG	NO
+#define WIN_MSG_QUEUE_FNAME     "/dev/windows"
 #endif
+extern const char WIN_WID_PROP[];
+extern const char WIN_NEEDMANAGE_PROP[];
+extern const char WIN_STATE_PROP[];
 
-#define XMING_SIGNATURE		0x12345678L
+#define VCXSRV_SIGNATURE        0xdeaddeadL
 
 typedef struct _winPrivScreenRec *winPrivScreenPtr;
 
@@ -76,6 +73,7 @@ typedef struct {
     DWORD dwDummy;
     HRGN hRgn;
     HWND hWnd;
+    BOOL OpenGlWindow;
     winPrivScreenPtr pScreenPriv;
     Bool fXKilled;
     HDWP hDwp;
@@ -149,6 +147,15 @@ winInitWM(void **ppWMInfo,
 void
  winDeinitMultiWindowWM(void);
 
+void
+winTaskbarInit (void);
+
+void
+winTaskbarDestroy (void);
+
+void
+winSetAppID (HWND hWnd, const char* AppID);
+
 void
  winPropertyStoreInit(void);
 
diff --git a/xserver/hw/xwin/winwndproc.c b/vcxsrv-code/xorg-server/hw/xwin/winwndproc.c
index c795088..54d9eee 100644
--- a/xserver/hw/xwin/winwndproc.c
+++ b/vcxsrv-code/xorg-server/hw/xwin/winwndproc.c
@@ -44,13 +44,101 @@
 #include "inputstr.h"
 #include "winclipboard/winclipboard.h"
 
+#ifndef XKB_IN_SERVER
+#define XKB_IN_SERVER
+#endif
+#include <xkbsrv.h>
+
 /*
  * Global variables
  */
 
+extern Bool		g_fClipboardStarted;
 Bool g_fCursor = TRUE;
 Bool g_fButton[3] = { FALSE, FALSE, FALSE };
 
+
+wBOOL CALLBACK enumWindowsProc(HWND hwnd, LPARAM lParam)
+{
+  DWORD thisProcessId=(DWORD)lParam;
+  DWORD wndProcessId;
+
+  GetWindowThreadProcessId(hwnd, &wndProcessId);
+
+  if (thisProcessId!=wndProcessId)
+    return TRUE;
+
+  if (!IsWindowVisible(hwnd)) // Leave hidden windows hidden
+    return TRUE;
+
+  WINDOWPLACEMENT wp;
+  wp.length=sizeof(wp);
+  if (!GetWindowPlacement(hwnd, &wp))
+    return TRUE;
+
+  wp.showCmd=SW_RESTORE;
+  SetWindowPlacement(hwnd, &wp);
+
+  RECT rect;
+  if (!GetWindowRect(hwnd, &rect))
+    return TRUE;
+
+  HMONITOR hMonitor=MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
+  MONITORINFO monitorInfo;
+  monitorInfo.cbSize=sizeof(monitorInfo);
+  if (!GetMonitorInfo(hMonitor, &monitorInfo))
+    return TRUE;
+
+  BOOL moveWin=FALSE;
+  if (rect.left<monitorInfo.rcWork.left)
+  {
+    moveWin=TRUE;
+    rect.right+=monitorInfo.rcWork.left-rect.left;
+    rect.left=monitorInfo.rcWork.left;
+  }
+  if (rect.top<monitorInfo.rcWork.top)
+  {
+    moveWin=TRUE;
+    rect.bottom+=monitorInfo.rcWork.top-rect.top;
+    rect.top=monitorInfo.rcWork.top;
+  }
+  if (rect.bottom>monitorInfo.rcWork.bottom)
+  {
+    moveWin=TRUE;
+    rect.top+=monitorInfo.rcWork.bottom-rect.bottom;
+    rect.bottom=monitorInfo.rcWork.bottom;
+  }
+  if (rect.right>monitorInfo.rcWork.right)
+  {
+    moveWin=TRUE;
+    rect.left+=monitorInfo.rcWork.right-rect.right;
+    rect.right=monitorInfo.rcWork.right;
+  }
+  if (rect.left<monitorInfo.rcWork.left)
+  {
+    moveWin=TRUE;
+    rect.left=monitorInfo.rcWork.left;
+  }
+  if (rect.top<monitorInfo.rcWork.top)
+  {
+    moveWin=TRUE;
+    rect.top=monitorInfo.rcWork.top;
+  }
+  if (moveWin)
+  {
+    SetWindowPos(hwnd, NULL, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
+                 SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER);
+  }
+
+  return TRUE;
+}
+
+static void gatherWindows(void)
+{
+  DWORD processId=GetCurrentProcessId();
+  EnumDesktopWindows(NULL, enumWindowsProc, (LPARAM)processId);
+}
+
 /*
  * Called by winWakeupHandler
  * Processes current Windows message
@@ -69,9 +157,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     int iScanCode;
     int i;
 
-#if CYGDEBUG
     winDebugWin32Message("winWindowProc", hwnd, message, wParam, lParam);
-#endif
 
     /* Watch for server regeneration */
     if (g_ulServerGeneration != s_ulServerGeneration) {
@@ -82,9 +168,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     /* Only retrieve new privates pointers if window handle is null or changed */
     if ((s_pScreenPriv == NULL || hwnd != s_hwndLastPrivates)
         && (s_pScreenPriv = GetProp(hwnd, WIN_SCR_PROP)) != NULL) {
-#if CYGDEBUG
         winDebug("winWindowProc - Setting privates handle\n");
-#endif
         s_pScreenInfo = s_pScreenPriv->pScreenInfo;
         s_pScreen = s_pScreenInfo->pScreen;
         s_hwndLastPrivates = hwnd;
@@ -103,9 +187,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
                                     s_pScreenPriv);
 
     case WM_CREATE:
-#if CYGDEBUG
         winDebug("winWindowProc - WM_CREATE\n");
-#endif
 
         /*
          * Add a property to our display window that references
@@ -124,7 +206,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         SetProp(hwnd, WIN_SCR_PROP, s_pScreenPriv);
 
         /* Setup tray icon */
-        if (!s_pScreenInfo->fNoTrayIcon) {
+        if (!s_pScreenInfo->fNoTrayIcon && !pref.fNoTrayIcon) {
             /*
              * NOTE: The WM_CREATE message is processed before CreateWindowEx
              * returns, so s_pScreenPriv->hwndScreen is invalid at this point.
@@ -136,7 +218,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
             s_pScreenPriv->hwndScreen = hwnd;
 
-            winInitNotifyIcon(s_pScreenPriv);
+            winInitNotifyIcon(s_pScreenPriv,FALSE);
         }
         return 0;
 
@@ -164,9 +246,9 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             break;
         }
 
-        ErrorF("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
-               "new height: %d new bpp: %d\n",
-               LOWORD(lParam), HIWORD(lParam), (int)wParam);
+        winDebug ("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
+                  "new height: %d new bpp: %d\n",
+                  LOWORD(lParam), HIWORD(lParam), (int)wParam);
 
         /* 0 bpp has no defined meaning, ignore this message */
         if (wParam == 0)
@@ -185,7 +267,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL)) {
             if (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL) {
                 /* Cannot display the visual until the depth is restored */
-                ErrorF("winWindowProc - Disruptive change in depth\n");
+                winDebug ("winWindowProc - Disruptive change in depth\n");
 
                 /* Display depth change dialog */
                 winDisplayDepthChangeDialog(s_pScreenPriv);
@@ -281,27 +363,31 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
                 winDebug
                     ("winWindowProc - WM_DISPLAYCHANGE - Releasing and recreating primary surface\n");
 
-                /* Release the old primary surface */
-                if (*s_pScreenPriv->pwinReleasePrimarySurface)
-                    (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);
+                /* Reallocate the framebuffer used by the drawing engine */
+                (*s_pScreenPriv->pwinFreeFB)(s_pScreen);
+                if (!(*s_pScreenPriv->pwinAllocateFB)(s_pScreen))
+                {
+                    ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Could not reallocate framebuffer\n");
+                }
+                /* Update the screen pixmap to point to the new framebuffer */
+                winUpdateFBPointer(s_pScreen, s_pScreenPriv->pScreenInfo->pfb);
+                // Restore the ability to update screen, now with new dimensions
+                SetRootClip(s_pScreen, TRUE);
 
-                /* Create the new primary surface */
-                if (*s_pScreenPriv->pwinCreatePrimarySurface)
-                    (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);
+                // and arrange for it to be repainted
+                miPaintWindow(s_pScreen->root, &s_pScreen->root->borderClip,  PW_BACKGROUND);
             }
         }
 
         break;
-
+      
     case WM_SIZE:
     {
         SCROLLINFO si;
         RECT rcWindow;
         int iWidth, iHeight;
 
-#if CYGDEBUG
         winDebug("winWindowProc - WM_SIZE\n");
-#endif
 
         /* Break if we do not allow resizing */
         if ((s_pScreenInfo->iResizeMode == resizeNotAllowed)
@@ -315,8 +401,8 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         if (wParam == SIZE_MINIMIZED)
             return 0;
 
-        ErrorF("winWindowProc - WM_SIZE - new client area w: %d h: %d\n",
-               LOWORD(lParam), HIWORD(lParam));
+        winDebug ("winWindowProc - WM_SIZE - new client area w: %d h: %d\n",
+                  LOWORD(lParam), HIWORD(lParam));
 
         if (s_pScreenInfo->iResizeMode == resizeWithRandr) {
             /* Actual resizing is done on WM_EXITSIZEMOVE */
@@ -395,20 +481,22 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         s_pScreenInfo->dwYOffset = -si.nPos;
     }
         return 0;
-
-    case WM_SYSCOMMAND:
-        if (s_pScreenInfo->iResizeMode == resizeWithRandr &&
-            ((wParam & 0xfff0) == SC_MAXIMIZE ||
-             (wParam & 0xfff0) == SC_RESTORE))
-            PostMessage(hwnd, WM_EXITSIZEMOVE, 0, 0);
+      
+      case WM_SYSCOMMAND:
+          if ((wParam & 0xfff0) == SC_MAXIMIZE ||
+              (wParam & 0xfff0) == SC_RESTORE)
+          {
+              winDebug("Posting WM_EXITSIZEMOVE message since windows does not send it when the maximised/restored button is clicked.\n");
+              PostMessage(hwnd, WM_EXITSIZEMOVE, 0, 0);
+          }
         break;
 
     case WM_ENTERSIZEMOVE:
-        ErrorF("winWindowProc - WM_ENTERSIZEMOVE\n");
+        winDebug("winWindowProc - WM_ENTERSIZEMOVE\n");
         break;
 
     case WM_EXITSIZEMOVE:
-        ErrorF("winWindowProc - WM_EXITSIZEMOVE\n");
+        winDebug("winWindowProc - WM_EXITSIZEMOVE\n");
 
         if (s_pScreenInfo->iResizeMode == resizeWithRandr) {
             /* Set screen size to match new client area, if it is different to current */
@@ -437,9 +525,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         SCROLLINFO si;
         int iVertPos;
 
-#if CYGDEBUG
         winDebug("winWindowProc - WM_VSCROLL\n");
-#endif
 
         /* Get vertical scroll bar info */
         si.cbSize = sizeof(si);
@@ -516,9 +602,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         SCROLLINFO si;
         int iHorzPos;
 
-#if CYGDEBUG
         winDebug("winWindowProc - WM_HSCROLL\n");
-#endif
 
         /* Get horizontal scroll bar info */
         si.cbSize = sizeof(si);
@@ -595,10 +679,8 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         int iCaptionHeight;
         int iBorderHeight, iBorderWidth;
 
-#if CYGDEBUG
         winDebug("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %p\n",
                  s_pScreenInfo);
-#endif
 
         /* Can't do anything without screen info */
         if (s_pScreenInfo == NULL
@@ -634,9 +716,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         return 0;
 
     case WM_ERASEBKGND:
-#if CYGDEBUG
         winDebug("winWindowProc - WM_ERASEBKGND\n");
-#endif
         /*
          * Pretend that we did erase the background but we don't care,
          * the application uses the full window estate. This avoids some
@@ -645,9 +725,6 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         return TRUE;
 
     case WM_PAINT:
-#if CYGDEBUG
-        winDebug("winWindowProc - WM_PAINT\n");
-#endif
         /* Only paint if we have privates and the server is enabled */
         if (s_pScreenPriv == NULL
             || !s_pScreenPriv->fEnabled
@@ -667,9 +744,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_PALETTECHANGED:
     {
-#if CYGDEBUG
         winDebug("winWindowProc - WM_PALETTECHANGED\n");
-#endif
         /*
          * Don't process if we don't have privates or a colormap,
          * or if we have an invalid depth.
@@ -695,6 +770,14 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     }
 
     case WM_MOUSEMOVE:
+        if (wParam & (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON))
+        {
+            if (lParam==GetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM))
+            {
+                return 0;  /* Ignore the mouse since the mouse was not moved wrt the button down click */
+            }
+            SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,-1);
+        }
         /* We can't do anything without privates */
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
@@ -782,6 +865,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_LBUTTONDBLCLK:
     case WM_LBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         if (s_pScreenInfo->fRootless)
@@ -797,6 +881,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_MBUTTONDBLCLK:
     case WM_MBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         if (s_pScreenInfo->fRootless)
@@ -812,6 +897,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_RBUTTONDBLCLK:
     case WM_RBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         if (s_pScreenInfo->fRootless)
@@ -827,6 +913,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     case WM_XBUTTONDBLCLK:
     case WM_XBUTTONDOWN:
+        SetWindowLongPtr(hwnd, WND_IDX_BUTTONDOWNLPARAM,lParam);
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
         if (s_pScreenInfo->fRootless)
@@ -906,9 +993,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     case WM_MOUSEWHEEL:
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
-#if CYGDEBUG
         winDebug("winWindowProc - WM_MOUSEWHEEL\n");
-#endif
         /* Button4 = WheelUp */
         /* Button5 = WheelDown */
         winMouseWheel(&(s_pScreenPriv->iDeltaZ), GET_WHEEL_DELTA_WPARAM(wParam), Button4, Button5);
@@ -917,9 +1002,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     case WM_MOUSEHWHEEL:
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
-#if CYGDEBUG
         winDebug("winWindowProc - WM_MOUSEHWHEEL\n");
-#endif
         /* Button7 = TiltRight */
         /* Button6 = TiltLeft */
         winMouseWheel(&(s_pScreenPriv->iDeltaV), GET_WHEEL_DELTA_WPARAM(wParam), 7, 6);
@@ -972,21 +1055,13 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
              * user enters Alt + F4 and is surprised when the application
              * quits.
              */
-            ErrorF("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");
+            winDebug ("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");
 
             /* Display Exit dialog */
             winDisplayExitDialog(s_pScreenPriv);
             return 0;
         }
 
-        /*
-         * Don't do anything for the Windows keys, as focus will soon
-         * be returned to Windows.  We may be able to trap the Windows keys,
-         * but we should determine if that is desirable before doing so.
-         */
-        if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
-            break;
-
         /* Discard fake Ctrl_L events that precede AltGR on non-US keyboards */
         if (winIsFakeCtrl_L(message, wParam, lParam))
             return 0;
@@ -1026,14 +1101,6 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
 
-        /*
-         * Don't do anything for the Windows keys, as focus will soon
-         * be returned to Windows.  We may be able to trap the Windows keys,
-         * but we should determine if that is desirable before doing so.
-         */
-        if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
-            break;
-
         /* Ignore the fake Ctrl_L that follows an AltGr release */
         if (winIsFakeCtrl_L(message, wParam, lParam))
             return 0;
@@ -1053,7 +1120,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
         /* TODO: Override display of window when we have a bad depth */
         if (LOWORD(wParam) != WA_INACTIVE && s_pScreenPriv->fBadDepth) {
-            ErrorF("winWindowProc - WM_ACTIVATE - Bad depth, trying "
+            winDebug ("winWindowProc - WM_ACTIVATE - Bad depth, trying "
                    "to override window activation\n");
 
             /* Minimize the window */
@@ -1073,9 +1140,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             return 0;
         }
 
-#if CYGDEBUG
         winDebug("winWindowProc - WM_ACTIVATE\n");
-#endif
 
         /*
          * Focus is being changed to another window.
@@ -1099,9 +1164,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
             break;
 
-#if CYGDEBUG || TRUE
         winDebug("winWindowProc - WM_ACTIVATEAPP\n");
-#endif
 
         /* Activate or deactivate */
         s_pScreenPriv->fActive = wParam;
@@ -1137,6 +1200,10 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
             fPrimarySelection = !fPrimarySelection;
             return 0;
 
+        case ID_APP_GATHER_WINDOWS:
+            gatherWindows();
+            return 0;
+
         case ID_APP_ABOUT:
             /* Display the About box */
             winDisplayAboutDialog(s_pScreenPriv);
@@ -1150,9 +1217,13 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         break;
 
     case WM_GIVEUP:
+        /* Delete the tray Icon */
+        if (!s_pScreenInfo->fNoTrayIcon && s_pScreenPriv->hiconNotifyIcon != NULL)
+            winDeleteNotifyIcon(s_pScreenPriv);
         /* Tell X that we are giving up */
         if (s_pScreenInfo->fMultiWindow)
             winDeinitMultiWindowWM();
+        g_fClipboardStarted=FALSE; /* This is to avoid dead-locks caused by the clipboard thread still doing some stuff */
         GiveUp(0);
         return 0;
 
@@ -1171,7 +1242,7 @@ winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
 
     default:
         if ((message == s_uTaskbarRestart) && !s_pScreenInfo->fNoTrayIcon)  {
-            winInitNotifyIcon(s_pScreenPriv);
+            winInitNotifyIcon(s_pScreenPriv,FALSE);
         }
         break;
     }
diff --git a/xserver/include/callback.h b/vcxsrv-code/xorg-server/include/callback.h
index fe7015e..8a65af8 100644
--- a/xserver/include/callback.h
+++ b/vcxsrv-code/xorg-server/include/callback.h
@@ -52,6 +52,10 @@ SOFTWARE.
 #include <X11/Xproto.h>
 #include <X11/Xfuncproto.h>
 
+#ifdef _MSC_VER
+#define inline __inline
+#endif
+
 /*
  *  callback manager stuff
  */
diff --git a/xserver/include/closestr.h b/vcxsrv-code/xorg-server/include/closestr.h
index 60e6f09..87a2f17 100644
--- a/xserver/include/closestr.h
+++ b/vcxsrv-code/xorg-server/include/closestr.h
@@ -52,6 +52,7 @@ typedef struct _OFclosure {
     XID fontid;
     char *fontname;
     int fnamelen;
+    Bool	from_dispatch;
     FontPtr non_cachable_font;
 } OFclosureRec;
 
@@ -77,6 +78,7 @@ typedef struct _LFWIclosure {
     LFWIstateRec saved;
     int savedNumFonts;
     Bool haveSaved;
+    Bool	        from_dispatch;
     char *savedName;
 } LFWIclosureRec;
 
@@ -90,6 +92,7 @@ typedef struct _LFclosure {
     LFWIstateRec current;
     LFWIstateRec saved;
     Bool haveSaved;
+    Bool	from_dispatch;    
     char *savedName;
     int savedNameLen;
 } LFclosureRec;
@@ -108,6 +111,7 @@ typedef struct _PTclosure {
     CARD8 reqType;
     XID did;
     int err;
+    Bool	        from_dispatch;
 } PTclosureRec;
 
 /* ImageText */
@@ -122,5 +126,6 @@ typedef struct _ITclosure {
     int yorg;
     CARD8 reqType;
     XID did;
+    Bool	        from_dispatch;
 } ITclosureRec;
 #endif                          /* CLOSESTR_H */
diff --git a/xserver/include/dix.h b/vcxsrv-code/xorg-server/include/dix.h
index 0dcd09b..6b081d6 100644
--- a/xserver/include/dix.h
+++ b/vcxsrv-code/xorg-server/include/dix.h
@@ -154,7 +154,7 @@ typedef HWEventQueueType *HWEventQueuePtr;
 
 extern _X_EXPORT HWEventQueuePtr checkForInput[2];
 
-static inline _X_NOTSAN Bool
+static inline Bool
 InputCheckPending(void)
 {
     return (*checkForInput[0] != *checkForInput[1]);
diff --git a/xserver/include/dixstruct.h b/vcxsrv-code/xorg-server/include/dixstruct.h
index fb0ac14..655ba58 100644
--- a/xserver/include/dixstruct.h
+++ b/vcxsrv-code/xorg-server/include/dixstruct.h
@@ -92,7 +92,7 @@ typedef struct _Client {
     int priority;
     ReplySwapPtr pSwapReplyFunc;
     XID errorValue;
-    int sequence;
+    unsigned short sequence;    //MH
     int ignoreCount;            /* count for Attend/IgnoreClient */
     int numSaved;
     SaveSetElt *saveSet;
diff --git a/xserver/include/gc.h b/vcxsrv-code/xorg-server/include/gc.h
index 53f9c29..70695f1 100644
--- a/xserver/include/gc.h
+++ b/vcxsrv-code/xorg-server/include/gc.h
@@ -87,8 +87,8 @@ extern _X_EXPORT void ValidateGC(DrawablePtr /*pDraw */ ,
                                  GCPtr /*pGC */ );
 
 typedef union {
-    CARD32 val;
     void *ptr;
+    CARD32 val;
 } ChangeGCVal, *ChangeGCValPtr;
 
 extern int ChangeGCXIDs(ClientPtr /*client */ ,
diff --git a/xserver/include/globals.h b/vcxsrv-code/xorg-server/include/globals.h
index 341ce83..384f6f7 100644
--- a/xserver/include/globals.h
+++ b/vcxsrv-code/xorg-server/include/globals.h
@@ -28,7 +28,6 @@ extern _X_EXPORT int GrabInProgress;
 extern _X_EXPORT Bool noTestExtensions;
 extern _X_EXPORT char *SeatId;
 extern _X_EXPORT char *ConnectionInfo;
-extern _X_EXPORT sig_atomic_t inSignalContext;
 
 #ifdef PANORAMIX
 extern _X_EXPORT Bool PanoramiXExtensionDisabledHack;
diff --git a/xserver/include/input.h b/vcxsrv-code/xorg-server/include/input.h
index b1aef36..e7a135f 100644
--- a/xserver/include/input.h
+++ b/vcxsrv-code/xorg-server/include/input.h
@@ -638,7 +638,7 @@ extern void TouchEventHistoryReplay(TouchPointInfoPtr ti, DeviceIntPtr dev,
 extern Bool TouchResourceIsOwner(TouchPointInfoPtr ti, XID resource);
 extern void TouchAddListener(TouchPointInfoPtr ti, XID resource, int resource_type,
                              enum InputLevel level, enum TouchListenerType type,
-                             enum TouchListenerState state, WindowPtr window, GrabPtr grab);
+                             enum TouchListenerState state, WindowPtr window, const GrabPtr grab);
 extern Bool TouchRemoveListener(TouchPointInfoPtr ti, XID resource);
 extern void TouchSetupListeners(DeviceIntPtr dev, TouchPointInfoPtr ti,
                                 InternalEvent *ev);
diff --git a/xserver/include/misc.h b/vcxsrv-code/xorg-server/include/misc.h
index 4b63209..b3d4d23 100644
--- a/xserver/include/misc.h
+++ b/vcxsrv-code/xorg-server/include/misc.h
@@ -80,6 +80,16 @@ OF THIS SOFTWARE.
 #include <stddef.h>
 #include <stdint.h>
 #include <pthread.h>
+#include <unistd.h>
+
+#ifdef _MSC_VER
+#define inline __inline
+#include <math.h>
+static double __inline trunc(double d)
+{
+  return (d>0) ? floor(d) : ceil(d) ;
+}
+#endif
 
 #ifndef MAXSCREENS
 #define MAXSCREENS	16
@@ -88,7 +98,7 @@ OF THIS SOFTWARE.
 #define MAXGPUSCREENS	16
 #endif
 #define MAXCLIENTS	2048
-#define LIMITCLIENTS	256     /* Must be a power of 2 and <= MAXCLIENTS */
+#define LIMITCLIENTS	1024     /* Must be a power of 2 and <= MAXCLIENTS */
 #define MAXEXTENSIONS   128
 #define MAXFORMATS	8
 #ifndef MAXDEVICES
@@ -162,9 +172,9 @@ typedef struct _xReq *xReqPtr;
 
 #include <math.h>
 #undef MAXSHORT
-#define MAXSHORT SHRT_MAX
+#define MAXSHORT 32767
 #undef MINSHORT
-#define MINSHORT SHRT_MIN
+#define MINSHORT -32768
 #undef MAXINT
 #define MAXINT INT_MAX
 #undef MININT
@@ -192,7 +202,7 @@ typedef struct _xReq *xReqPtr;
  * @param bits The minimum number of bits needed.
  * @return The number of bytes needed to hold bits.
  */
-static inline int
+static __inline int
 bits_to_bytes(const int bits)
 {
     return ((bits + 7) >> 3);
@@ -204,7 +214,7 @@ bits_to_bytes(const int bits)
  * @param bytes The minimum number of bytes needed.
  * @return The number of 4-byte units needed to hold bytes.
  */
-static inline int
+static __inline int
 bytes_to_int32(const int bytes)
 {
     return (((bytes) + 3) >> 2);
@@ -215,7 +225,7 @@ bytes_to_int32(const int bytes)
  * @param bytes The minimum number of bytes needed.
  * @return The closest multiple of 4 that is equal or higher than bytes.
  */
-static inline int
+static __inline int
 pad_to_int32(const int bytes)
 {
     return (((bytes) + 3) & ~3);
@@ -421,7 +431,7 @@ extern _X_EXPORT unsigned long serverGeneration;
           do { if (cond) {                                                \
               ErrorFSigSafe("BUG: triggered 'if (" #cond ")'\n");          \
               ErrorFSigSafe("BUG: %s:%u in %s()\n",                        \
-                           __FILE__, __LINE__, __func__);                 \
+                           __FILE__, __LINE__, __FUNCTION__);                 \
               if (with_msg) ErrorFSigSafe(__VA_ARGS__);                    \
               xorg_backtrace();                                           \
           } } while(0)
diff --git a/xserver/include/opaque.h b/vcxsrv-code/xorg-server/include/opaque.h
index 256261c..95a8743 100644
--- a/xserver/include/opaque.h
+++ b/vcxsrv-code/xorg-server/include/opaque.h
@@ -47,7 +47,7 @@ extern _X_EXPORT int ScreenSaverAllowExposures;
 extern _X_EXPORT int defaultScreenSaverBlanking;
 extern _X_EXPORT int defaultScreenSaverAllowExposures;
 extern _X_EXPORT const char *display;
-extern _X_EXPORT int displayfd;
+extern _X_EXPORT intptr_t displayfd;
 extern _X_EXPORT Bool explicit_display;
 
 extern _X_EXPORT Bool disableBackingStore;
diff --git a/xserver/include/os.h b/vcxsrv-code/xorg-server/include/os.h
index bb3348b..2559909 100644
--- a/xserver/include/os.h
+++ b/vcxsrv-code/xorg-server/include/os.h
@@ -127,6 +127,8 @@ extern _X_EXPORT int WriteToClient(ClientPtr /*who */ , int /*count */ ,
 
 extern _X_EXPORT void ResetOsBuffers(void);
 
+extern _X_EXPORT int TransIsListening(char *protocol);
+
 extern _X_EXPORT void NotifyParentProcess(void);
 
 extern _X_EXPORT void CreateWellKnownSockets(void);
@@ -143,6 +145,9 @@ extern _X_EXPORT const char *ClientAuthorized(ClientPtr /*client */ ,
                                               unsigned int /*string_n */ ,
                                               char * /*auth_string */ );
 
+extern _X_EXPORT void EstablishNewConnections(ClientPtr clientUnused,
+                                              void *closure);
+
 extern _X_EXPORT void CloseDownConnection(ClientPtr /*client */ );
 
 typedef void (*NotifyFdProcPtr)(int fd, int ready, void *data);
@@ -698,10 +703,20 @@ _X_ATTRIBUTE_PRINTF(1, 2)
 #define DebugF(...)             /* */
 #endif
 
+#ifdef _MSC_VER
+#ifdef INSERVER
+#define SERVEXTERN _declspec(dllimport)
+#else
+#define SERVEXTERN _declspec(dllexport)
+#endif
+#else
+#define SERVEXTERN _X_EXPORT
+#endif
+
 extern _X_EXPORT void
 VErrorF(const char *f, va_list args)
 _X_ATTRIBUTE_PRINTF(1, 0);
-extern _X_EXPORT void
+extern SERVEXTERN void
 ErrorF(const char *f, ...)
 _X_ATTRIBUTE_PRINTF(1, 2);
 extern _X_EXPORT void
@@ -716,16 +731,15 @@ LogPrintMarkers(void);
 extern _X_EXPORT void
 xorg_backtrace(void);
 
-extern _X_EXPORT int
-os_move_fd(int fd);
-
-#include <signal.h>
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#endif
 
-#if defined(WIN32) && !defined(__CYGWIN__)
+#if defined(WIN32) && !defined(__CYGWIN__) && !defined(_MSC_VER)
 typedef _sigset_t sigset_t;
 #endif
 
 extern _X_EXPORT int
-xthread_sigmask(int how, const sigset_t *set, sigset_t *oldest);
+os_move_fd(int fd);
 
 #endif                          /* OS_H */
diff --git a/xserver/include/pixmapstr.h b/vcxsrv-code/xorg-server/include/pixmapstr.h
index faf54fa..849f095 100644
--- a/xserver/include/pixmapstr.h
+++ b/vcxsrv-code/xorg-server/include/pixmapstr.h
@@ -78,10 +78,8 @@ typedef struct _Pixmap {
     int refcnt;
     int devKind;                /* This is the pitch of the pixmap, typically width*bpp/8. */
     DevUnion devPrivate;        /* When !NULL, devPrivate.ptr points to the raw pixel data. */
-#ifdef COMPOSITE
     short screen_x;
     short screen_y;
-#endif
     unsigned usage_hint;        /* see CREATE_PIXMAP_USAGE_* */
 
     PixmapPtr primary_pixmap;    /* pointer to primary copy of pixmap for pixmap sharing */
diff --git a/xserver/include/resource.h b/vcxsrv-code/xorg-server/include/resource.h
index 6caf846..d8d41dd 100644
--- a/xserver/include/resource.h
+++ b/vcxsrv-code/xorg-server/include/resource.h
@@ -69,7 +69,7 @@ typedef uint32_t RESTYPE;
 #define RC_LASTPREDEF	RC_NEVERRETAIN
 #define RC_ANY		(~(RESTYPE)0)
 
-/* types for Resource routines */
+/* types for Resource routines. When you change one of them, please also update the predefTypes array in resource.c*/
 
 #define RT_WINDOW	((RESTYPE)1|RC_DRAWABLE)
 #define RT_PIXMAP	((RESTYPE)2|RC_DRAWABLE)
diff --git a/xserver/include/scrnintstr.h b/vcxsrv-code/xorg-server/include/scrnintstr.h
index 24ca423..3c15fd7 100644
--- a/xserver/include/scrnintstr.h
+++ b/vcxsrv-code/xorg-server/include/scrnintstr.h
@@ -67,7 +67,7 @@ typedef struct _Visual {
     VisualID vid;
     short class;
     short bitsPerRGBValue;
-    short ColormapEntries;
+    long ColormapEntries;
     short nplanes;              /* = log2 (ColormapEntries). This does not
                                  * imply that the screen has this many planes.
                                  * it may have more or fewer */
@@ -345,6 +345,10 @@ typedef void (*MarkUnrealizedWindowProcPtr) (WindowPtr /*pChild */ ,
                                              WindowPtr /*pWin */ ,
                                              Bool /*fromConfigure */ );
 
+#ifdef CreateWindow
+#undef CreateWindow
+#endif
+
 typedef Bool (*DeviceCursorInitializeProcPtr) (DeviceIntPtr /* pDev */ ,
                                                ScreenPtr /* pScreen */ );
 
diff --git a/xserver/include/servermd.h b/vcxsrv-code/xorg-server/include/servermd.h
index 087826f..8577e88 100644
--- a/xserver/include/servermd.h
+++ b/vcxsrv-code/xorg-server/include/servermd.h
@@ -68,6 +68,12 @@ SOFTWARE.
 #define GLYPHPADBYTES           4
 #endif
 
+#ifdef WIN32
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#endif
+
 /* size of buffer to use with GetImage, measured in bytes. There's obviously
  * a trade-off between the amount of heap used and the number of times the
  * ddx routine has to be called.
diff --git a/xserver/include/windowstr.h b/vcxsrv-code/xorg-server/include/windowstr.h
index c7e2796..8c245ca 100644
--- a/xserver/include/windowstr.h
+++ b/vcxsrv-code/xorg-server/include/windowstr.h
@@ -140,7 +140,7 @@ typedef struct _Window {
     RegionRec borderSize;
     DDXPointRec origin;         /* position relative to parent */
     unsigned short borderWidth;
-    unsigned short deliverableEvents;   /* all masks from all clients */
+    unsigned long deliverableEvents;   /* all masks from all clients */
     Mask eventMask;             /* mask from the creating client */
     PixUnion background;
     PixUnion border;
diff --git a/xserver/include/xkbstr.h b/vcxsrv-code/xorg-server/include/xkbstr.h
index 8a9f01c..00fe5b6 100644
--- a/xserver/include/xkbstr.h
+++ b/vcxsrv-code/xorg-server/include/xkbstr.h
@@ -46,10 +46,10 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 typedef struct _XkbStateRec {
     unsigned char group;        /* base + latched + locked */
+    unsigned char locked_group;
     /* FIXME: Why are base + latched short and not char?? */
     unsigned short base_group;  /* physically ... down? */
     unsigned short latched_group;
-    unsigned char locked_group;
 
     unsigned char mods;         /* base + latched + locked */
     unsigned char base_mods;    /* physically down */
diff --git a/xserver/meson_options.txt b/vcxsrv-code/xorg-server/meson_options.txt
index b7719e0..1ce818c 100644
--- a/xserver/meson_options.txt
+++ b/vcxsrv-code/xorg-server/meson_options.txt
@@ -31,6 +31,7 @@ option('xdmcp', type: 'boolean', value: true)
 option('xdm-auth-1', type: 'boolean', value: true)
 option('secure-rpc', type: 'boolean', value: true)
 option('ipv6', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto')
+option('hyperv', type: 'boolean', value: true)
 option('input_thread', type: 'combo', choices: ['true', 'false', 'auto'], value: 'auto')
 
 option('xkb_dir', type: 'string')
diff --git a/xserver/mi/mi.h b/vcxsrv-code/xorg-server/mi/mi.h
index 8b0a231..0c74cc4 100644
--- a/xserver/mi/mi.h
+++ b/vcxsrv-code/xorg-server/mi/mi.h
@@ -65,6 +65,10 @@ typedef struct _miDash *miDashPtr;
 #define EVEN_DASH	0
 #define ODD_DASH	~0
 
+#ifdef _MSC_VER
+#define _X_COLD
+#endif
+
 /* miarc.c */
 
 extern _X_EXPORT void miWideArc(DrawablePtr pDraw,
diff --git a/xserver/mi/miarc.c b/vcxsrv-code/xorg-server/mi/miarc.c
index 3936f6c..29b0940 100644
--- a/xserver/mi/miarc.c
+++ b/vcxsrv-code/xorg-server/mi/miarc.c
@@ -63,6 +63,11 @@ SOFTWARE.
 #include "mifillarc.h"
 #include <X11/Xfuncproto.h>
 
+#ifdef _MSC_VER
+#define hypot _hypot
+#define HAVE_CBRT
+#endif
+
 #define EPSILON	0.000001
 #define ISEQUAL(a,b) (fabs((a) - (b)) <= EPSILON)
 #define UNEQUAL(a,b) (fabs((a) - (b)) > EPSILON)
diff --git a/xserver/mi/micmap.c b/vcxsrv-code/xorg-server/mi/micmap.c
index 7003a53..7dae8f4 100644
--- a/xserver/mi/micmap.c
+++ b/vcxsrv-code/xorg-server/mi/micmap.c
@@ -118,17 +118,26 @@ miInitializeColormap(ColormapPtr pmap)
         unsigned limr, limg, limb;
 
         limr = pVisual->redMask >> pVisual->offsetRed;
-        limg = pVisual->greenMask >> pVisual->offsetGreen;
-        limb = pVisual->blueMask >> pVisual->offsetBlue;
-        for (i = 0; i <= maxent; i++) {
+        for(i = 0; i <= min(limr,maxent); i++) {
             /* rescale to [0..65535] then rgb bits */
             pmap->red[i].co.local.red =
                 ((((i * 65535) / limr) >> shift) * 65535) / lim;
+        }
+        for(; i <= maxent; i++) pmap->red[i].co.local.red = 65535;
+        limg = pVisual->greenMask >> pVisual->offsetGreen;
+        for(i = 0; i <= min(limg,maxent); i++) {
+            /* rescale to [0..65535] then rgb bits */
             pmap->green[i].co.local.green =
                 ((((i * 65535) / limg) >> shift) * 65535) / lim;
+        }
+        for(; i <= maxent; i++) pmap->green[i].co.local.green = 65535;
+        limb = pVisual->blueMask >> pVisual->offsetBlue;
+        for(i = 0; i <= min(limb,maxent); i++) {
+            /* rescale to [0..65535] then rgb bits */
             pmap->blue[i].co.local.blue =
                 ((((i * 65535) / limb) >> shift) * 65535) / lim;
         }
+        for(; i <= maxent; i++) pmap->blue[i].co.local.blue = 65535;
     }
     else if (pVisual->class == StaticColor) {
         unsigned limr, limg, limb;
diff --git a/xserver/mi/micoord.h b/vcxsrv-code/xorg-server/mi/micoord.h
index c83bffd..71587c0 100644
--- a/xserver/mi/micoord.h
+++ b/vcxsrv-code/xorg-server/mi/micoord.h
@@ -35,14 +35,14 @@
 #define GetHighWord(x) (((int) (x)) >> 16)
 
 #if IMAGE_BYTE_ORDER == MSBFirst
-#define intToCoord(i,x,y)   (((x) = GetHighWord(i)), ((y) = (int) ((short) (i))))
+#define intToCoord(i,x,y)   (((x) = GetHighWord(i)), ((y) = (int) ((short) ((i)&0xffff))))
 #define coordToInt(x,y)	(((x) << 16) | ((y) & 0xffff))
 #define intToX(i)	(GetHighWord(i))
-#define intToY(i)	((int) ((short) i))
+#define intToY(i)	((int) ((short) ((i)&0xffff)))
 #else
-#define intToCoord(i,x,y)   (((x) = (int) ((short) (i))), ((y) = GetHighWord(i)))
+#define intToCoord(i,x,y)   (((x) = (int) ((short) ((i)&0xffff))), ((y) = GetHighWord(i)))
 #define coordToInt(x,y)	(((y) << 16) | ((x) & 0xffff))
-#define intToX(i)	((int) ((short) (i)))
+#define intToX(i)	((int) ((short) ((i)&0xffff)))
 #define intToY(i)	(GetHighWord(i))
 #endif
 
diff --git a/xserver/mi/mieq.c b/vcxsrv-code/xorg-server/mi/mieq.c
index c98d468..25a8496 100644
--- a/xserver/mi/mieq.c
+++ b/vcxsrv-code/xorg-server/mi/mieq.c
@@ -60,7 +60,7 @@ in this Software without prior written authorization from The Open Group.
 #endif
 
 /* Maximum size should be initial size multiplied by a power of 2 */
-#define QUEUE_INITIAL_SIZE                 512
+#define QUEUE_INITIAL_SIZE                 1024
 #define QUEUE_RESERVED_SIZE                 64
 #define QUEUE_MAXIMUM_SIZE                4096
 #define QUEUE_DROP_BACKTRACE_FREQUENCY     100
diff --git a/xserver/mi/miline.h b/vcxsrv-code/xorg-server/mi/miline.h
index c1a51c1..ada3bf7 100644
--- a/xserver/mi/miline.h
+++ b/vcxsrv-code/xorg-server/mi/miline.h
@@ -119,7 +119,7 @@ extern _X_EXPORT void miSetZeroLineBias(ScreenPtr /* pScreen */ ,
         t = y1;  y1 = y2;  y2 = t;\
 }
 
-#define miGetZeroLineBias(_pScreen) ((unsigned long) (unsigned long*)\
+#define miGetZeroLineBias(_pScreen) ((unsigned long) (uintptr_t)(unsigned long*)\
     dixLookupPrivate(&(_pScreen)->devPrivates, miZeroLineScreenKey))
 
 #define CalcLineDeltas(_x1,_y1,_x2,_y2,_adx,_ady,_sx,_sy,_SX,_SY,_octant) \
diff --git a/xserver/mi/mioverlay.c b/vcxsrv-code/xorg-server/mi/mioverlay.c
index b8b7a5b..9ac500b 100644
--- a/xserver/mi/mioverlay.c
+++ b/vcxsrv-code/xorg-server/mi/mioverlay.c
@@ -3,6 +3,10 @@
 #include <dix-config.h>
 #endif
 
+#ifdef CreateWindow
+#undef CreateWindow
+#endif
+
 #include <X11/X.h>
 #include "scrnintstr.h"
 #include <X11/extensions/shapeproto.h>
diff --git a/xserver/mi/miscrinit.c b/vcxsrv-code/xorg-server/mi/miscrinit.c
index 3bb52b1..20c3213 100644
--- a/xserver/mi/miscrinit.c
+++ b/vcxsrv-code/xorg-server/mi/miscrinit.c
@@ -303,5 +303,5 @@ miSetZeroLineBias(ScreenPtr pScreen, unsigned int bias)
         return;
 
     dixSetPrivate(&pScreen->devPrivates, miZeroLineScreenKey,
-                  (unsigned long *) (unsigned long) bias);
+                  (unsigned long *) (uintptr_t) bias);
 }
diff --git a/xserver/mi/misprite.c b/vcxsrv-code/xorg-server/mi/misprite.c
index ce8c571..bb8e70d 100644
--- a/xserver/mi/misprite.c
+++ b/vcxsrv-code/xorg-server/mi/misprite.c
@@ -380,7 +380,7 @@ miSpriteSourceValidate(DrawablePtr pDrawable, int x, int y, int width,
         for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
             if (DevHasCursor(pDev)) {
                 pCursorInfo = GetSprite(pDev);
-                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
+                if (pCursorInfo && pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                     ORG_OVERLAP(&pCursorInfo->saved, pDrawable->x, pDrawable->y,
                                 x, y, width, height)) {
                     SPRITE_DEBUG(("SourceValidate remove\n"));
@@ -412,7 +412,7 @@ miSpriteCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
             /*
              * Damage will take care of destination check
              */
-            if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
+            if (pCursorInfo && pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                 RegionContainsRect(prgnSrc, &pCursorInfo->saved) != rgnOUT) {
                 SPRITE_DEBUG(("CopyWindow remove\n"));
                 miSpriteRemoveCursor(pDev, pScreen);
@@ -486,9 +486,12 @@ miSpriteInstallColormap(ColormapPtr pMap)
         for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
             if (DevHasCursor(pDev)) {
                 pCursorInfo = GetSprite(pDev);
-                pCursorInfo->checkPixels = TRUE;
-                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen)
-                    miSpriteRemoveCursor(pDev, pScreen);
+                if (pCursorInfo)
+                {
+                  pCursorInfo->checkPixels = TRUE;
+                  if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen)
+                      miSpriteRemoveCursor(pDev, pScreen);
+                }
             }
         }
 
diff --git a/xserver/mi/mivaltree.c b/vcxsrv-code/xorg-server/mi/mivaltree.c
index ea6889f..b73f76c 100644
--- a/xserver/mi/mivaltree.c
+++ b/vcxsrv-code/xorg-server/mi/mivaltree.c
@@ -275,6 +275,9 @@ miComputeClips(WindowPtr pParent,
           eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
         SendVisibilityNotify(pParent);
 
+    if (pParent->valdata==UnmapValData)
+      return; // return if no valid valdata
+
     dx = pParent->drawable.x - pParent->valdata->before.oldAbsCorner.x;
     dy = pParent->drawable.y - pParent->valdata->before.oldAbsCorner.y;
 
@@ -704,9 +707,11 @@ miValidateTree(WindowPtr pParent,       /* Parent to validate */
         RegionUninit(&childUnion);
     }
 
-    RegionNull(&pParent->valdata->after.exposed);
-    RegionNull(&pParent->valdata->after.borderExposed);
-
+    if (pParent->valdata && pParent->valdata!=UnmapValData)
+    {
+      RegionNull(&pParent->valdata->after.exposed);
+      RegionNull(&pParent->valdata->after.borderExposed);
+    }
     /*
      * each case below is responsible for updating the
      * clipList and serial number for the parent window
@@ -721,8 +726,9 @@ miValidateTree(WindowPtr pParent,       /* Parent to validate */
          * exposures and obscures as per miComputeClips and reset the parent's
          * clipList.
          */
-        RegionSubtract(&pParent->valdata->after.exposed,
-                       &totalClip, &pParent->clipList);
+         if (pParent->valdata && pParent->valdata!=UnmapValData)
+             RegionSubtract(&pParent->valdata->after.exposed,
+                            &totalClip, &pParent->clipList);
         /* fall through */
     case VTMap:
         RegionCopy(&pParent->clipList, &totalClip);
diff --git a/xserver/mi/miwideline.c b/vcxsrv-code/xorg-server/mi/miwideline.c
index 54de1d3..3bb2979 100644
--- a/xserver/mi/miwideline.c
+++ b/vcxsrv-code/xorg-server/mi/miwideline.c
@@ -64,6 +64,10 @@ SOFTWARE.
 #include <math.h>
 #undef _XOPEN_SOURCE
 #endif
+#ifdef _MSC_VER
+#define hypot _hypot
+#endif
+
 #include <X11/X.h>
 #include "windowstr.h"
 #include "gcstruct.h"
diff --git a/xserver/mi/miwindow.c b/vcxsrv-code/xorg-server/mi/miwindow.c
index 39c279e..643bbc2 100644
--- a/xserver/mi/miwindow.c
+++ b/vcxsrv-code/xorg-server/mi/miwindow.c
@@ -129,6 +129,7 @@ miMarkWindow(WindowPtr pWin)
     val->before.oldAbsCorner.y = pWin->drawable.y;
     val->before.borderVisible = NullRegion;
     val->before.resized = FALSE;
+    val->after.borderExposed.data= 0; // unitialised member--> causes crash
     pWin->valdata = val;
 }
 
@@ -217,7 +218,7 @@ miHandleValidateExposures(WindowPtr pWin)
     pChild = pWin;
     WindowExposures = pChild->drawable.pScreen->WindowExposures;
     while (1) {
-        if ((val = pChild->valdata)) {
+        if ( (val = pChild->valdata) && val!=UnmapValData) {
             if (RegionNotEmpty(&val->after.borderExposed))
                 pWin->drawable.pScreen->PaintWindow(pChild,
                                                     &val->after.borderExposed,
@@ -364,7 +365,7 @@ miResizeWindow(WindowPtr pWin, int x, int y, unsigned int w, unsigned int h,
     RegionPtr borderVisible = NullRegion;       /* visible area of the border */
     Bool shrunk = FALSE;        /* shrunk in an inner dimension */
     Bool moved = FALSE;         /* window position changed */
-    WindowPtr pLayerWin;
+    WindowPtr pLayerWin=0;
 
     /* if this is a root window, can't be resized */
     if (!(pParent = pWin->parent))
diff --git a/xserver/miext/damage/damage.c b/vcxsrv-code/xorg-server/miext/damage/damage.c
index f3ae4eb..5a383dd 100644
--- a/xserver/miext/damage/damage.c
+++ b/vcxsrv-code/xorg-server/miext/damage/damage.c
@@ -1201,9 +1201,9 @@ damagePolyFillRect(DrawablePtr pDrawable,
         int nRectsTmp = nRects;
 
         box.x1 = pRectsTmp->x;
-        box.x2 = box.x1 + pRectsTmp->width;
+        box.x2 = box.x1 + (short)pRectsTmp->width;
         box.y1 = pRectsTmp->y;
-        box.y2 = box.y1 + pRectsTmp->height;
+        box.y2 = box.y1 + (short)pRectsTmp->height;
 
         while (--nRectsTmp) {
             pRectsTmp++;
@@ -1340,10 +1340,58 @@ damageText(DrawablePtr pDrawable,
     free(charinfo);
 }
 
+Bool g_iActualCodePage=TRUE;
+
+// convert Slovak to iso8859-2
+void convert_1250_8859_2(char* text, int len)
+{
+    int i;
+    for( i=0;i<len;i++ )
+    {
+        unsigned char c= text[i];
+        switch(c)
+        {
+            case 0x8A: text[i]= 0xA9; break; // L?
+            case 0x9A: text[i]= 0xB9; break; // L?
+            case 0x8E: text[i]= 0xAE; break; // L?
+            case 0x9E: text[i]= 0xBE; break; // Ll
+
+            case 0x8C: text[i]= 0xA6; break; // L?
+            case 0x8D: text[i]= 0xAB; break; // L?
+            case 0x8F: text[i]= 0xAC; break; // La
+            case 0x9C: text[i]= 0xB6; break; // L?
+            case 0x9D: text[i]= 0xBB; break; // LA
+            case 0x9F: text[i]= 0xBC; break; // Ls
+            case 0xA1: text[i]= 0xB7; break; // 
+            case 0xA5: text[i]= 0xA1; break; // 
+            case 0xB9: text[i]= 0xB1; break; // 
+            case 0xBC: text[i]= 0xA5; break; // 
+            case 0xBE: text[i]= 0xB5; break; // 
+        }
+    }
+}
+
+
 static int
 damagePolyText8(DrawablePtr pDrawable,
                 GCPtr pGC, int x, int y, int count, char *chars)
 {
+    if( g_iActualCodePage)
+    {
+        unsigned int acp_code= GetACP();
+        switch( acp_code )
+        {
+            case 1250: // central europe --slovak
+                convert_1250_8859_2(chars,count);
+                break;
+            case 1251: // eastern europe --russian
+                //convert_1251_8859_5(chars,count);
+                break;
+            case 1252: // west europe --german
+                //:wqconvert_1252_8859_1(chars,count);
+                break;
+        }
+    }
     DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
     damageText(pDrawable, pGC, x, y, (unsigned long) count, chars, Linear8Bit,
                TT_POLY8);
@@ -1906,7 +1954,7 @@ DamageRegionProcessPending(DrawablePtr pDrawable)
 
 /* This call is very odd, i'm leaving it intact for API sake, but please don't use it. */
 void
-DamageDamageRegion(DrawablePtr pDrawable, RegionPtr pRegion)
+DamageDamageRegion(DrawablePtr pDrawable, const RegionPtr pRegion)
 {
     damageRegionAppend(pDrawable, pRegion, FALSE, -1);
 
diff --git a/xserver/miext/rootless/rootlessGC.c b/vcxsrv-code/xorg-server/miext/rootless/rootlessGC.c
index 52d9df9..583324f 100644
--- a/xserver/miext/rootless/rootlessGC.c
+++ b/vcxsrv-code/xorg-server/miext/rootless/rootlessGC.c
@@ -49,6 +49,9 @@
 
 #include "rootlessCommon.h"
 
+#ifdef _MSC_VER
+#define inline __inline
+#endif
 // GC functions
 static void RootlessValidateGC(GCPtr pGC, unsigned long changes,
                                DrawablePtr pDrawable);
diff --git a/xserver/miext/rootless/rootlessWindow.c b/vcxsrv-code/xorg-server/miext/rootless/rootlessWindow.c
index 106d432..514427f 100644
--- a/xserver/miext/rootless/rootlessWindow.c
+++ b/vcxsrv-code/xorg-server/miext/rootless/rootlessWindow.c
@@ -51,6 +51,12 @@ extern Bool no_configure_window;
 #include "rootlessCommon.h"
 #include "rootlessWindow.h"
 
+#ifdef _MSC_VER
+#define inline __inline
+#include "xplugin.h"
+extern int darwinMainScreenX, darwinMainScreenY;
+#endif
+
 #define SCREEN_TO_GLOBAL_X \
     (pScreen->x + rootlessGlobalOffsetX)
 #define SCREEN_TO_GLOBAL_Y \
@@ -1016,6 +1022,7 @@ StartFrameResize(WindowPtr pWin, Bool gravity,
     }
     else if (gravity) {
         /* The general case. Just copy everything. */
+        BoxRec tmpBoxRec={oldX, oldY, oldX2, oldY2};
 
         RootlessStartDrawing(pWin);
 
@@ -1024,8 +1031,7 @@ StartFrameResize(WindowPtr pWin, Bool gravity,
         memcpy(gResizeDeathBits, winRec->pixelData,
                winRec->bytesPerRow * winRec->height);
 
-        gResizeDeathBounds[0] = (BoxRec) {
-        oldX, oldY, oldX2, oldY2};
+        gResizeDeathBounds[0] = tmpBoxRec;
         gResizeDeathPix[0]
             = GetScratchPixmapHeader(pScreen, winRec->width,
                                      winRec->height,
@@ -1062,8 +1068,8 @@ StartFrameResize(WindowPtr pWin, Bool gravity,
        window bits. */
 
     if (need_window_source) {
-        gResizeDeathBounds[0] = (BoxRec) {
-        oldX, oldY, oldX2, oldY2};
+        BoxRec tmpBoxRec={oldX, oldY, oldX2, oldY2};
+        gResizeDeathBounds[0] = tmpBoxRec;
         gResizeDeathPix[0]
             = GetScratchPixmapHeader(pScreen, oldW, oldH,
                                      winRec->win->drawable.depth,
diff --git a/xserver/os/WaitFor.c b/vcxsrv-code/xorg-server/os/WaitFor.c
index ff1d376..17ba617 100644
--- a/xserver/os/WaitFor.c
+++ b/vcxsrv-code/xorg-server/os/WaitFor.c
@@ -162,24 +162,21 @@ check_timers(void)
  *     pClientsReady is an array to store ready client->index values into.
  *****************/
 
+static Bool timer_is_running;
+
 Bool
 WaitForSomething(Bool are_ready)
 {
     int i;
     int timeout;
     int pollerr;
-    static Bool were_ready;
-    Bool timer_is_running;
-
-    timer_is_running = were_ready;
 
-    if (were_ready && !are_ready) {
+    if (timer_is_running && !are_ready)
+    {
         timer_is_running = FALSE;
         SmartScheduleStopTimer();
     }
 
-    were_ready = FALSE;
-
 #ifdef BUSFAULT
     busfault_check();
 #endif
@@ -205,30 +202,118 @@ WaitForSomething(Bool are_ready)
         if (dispatchException)
             i = -1;
         else
+        {
+            if (!timeout) timeout=10; /* Avoid a 100 % usage loop, timeout is in milliseconds */
             i = ospoll_wait(server_poll, timeout);
+        }
         pollerr = GetErrno();
+        if (i <= 0) {           /* An error or timeout occurred */
+            if (dispatchException)
+                return FALSE;
+            if (i < 0) {
+                char szMessage[1024];
+                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, pollerr, 0, szMessage, 1024, NULL );
+                ErrorF("WaitForSomething(): poll: %d %s\n", pollerr, szMessage);
+                if (pollerr == WSAENOTSOCK)
+                {
+                  CheckServerConnections(server_poll);
+                  WakeupHandler(i);
+                  are_ready = clients_are_ready();
+                  continue; // try again
+                }
+            }
+        }
+
+        if (InputCheckPending())
+        {
+            WakeupHandler(i);
+            return FALSE;
+        }
+        are_ready = clients_are_ready();
+        if (are_ready)
+        {
+            if (!timer_is_running)
+            {
+                timer_is_running=TRUE;
+                SmartScheduleStartTimer();
+            }
+            WakeupHandler(i);
+            return TRUE;
+        }
         WakeupHandler(i);
+    }
+}
+
+Bool isThereSomething(Bool are_ready)
+{
+    if (timer_is_running && !are_ready)
+    {
+        timer_is_running = FALSE;
+        SmartScheduleStopTimer();
+    }
+
+#ifdef BUSFAULT
+    busfault_check();
+#endif
+
+    /* We need a while loop here to handle
+       crashed connections and the screen saver timeout */
+    while (1) {
+        int i;
+        int pollerr;
+        int timeout=0;
+        /* deal with any blocked jobs */
+        if (workQueue) {
+            ProcessWorkQueue();
+        }
+
+        timeout = check_timers();
+        are_ready = clients_are_ready();
+
+        if (are_ready)
+            timeout = 0;
+
+        BlockHandler(&timeout);
+        if (NewOutputPending)
+            FlushAllOutput();
+        /* keep this check close to select() call to minimize race */
+        if (dispatchException)
+            i = -1;
+        else
+        {
+            i = ospoll_wait(server_poll, 1);
+        }
+        pollerr = GetErrno();
         if (i <= 0) {           /* An error or timeout occurred */
             if (dispatchException)
                 return FALSE;
             if (i < 0) {
-                if (pollerr != EINTR && !ETEST(pollerr)) {
-                    ErrorF("WaitForSomething(): poll: %s\n",
-                           strerror(pollerr));
+                char szMessage[1024];
+                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, pollerr, 0, szMessage, 1024, NULL );
+                ErrorF("PollForSomething(): poll: %d %s\n", pollerr, szMessage);
+                if (pollerr == WSAENOTSOCK)
+                {
+                  CheckServerConnections(server_poll);
+                  are_ready = clients_are_ready();
+                  continue; // try again
                 }
             }
-        } else
-            are_ready = clients_are_ready();
+        }
 
         if (InputCheckPending())
             return FALSE;
 
-        if (are_ready) {
-            were_ready = TRUE;
+        if (clients_are_ready())
+        {
             if (!timer_is_running)
+            {
+                timer_is_running=TRUE;
                 SmartScheduleStartTimer();
+            }
             return TRUE;
         }
+        else
+          return FALSE;
     }
 }
 
diff --git a/xserver/os/access.c b/vcxsrv-code/xorg-server/os/access.c
index b170304..7a1445d 100644
--- a/xserver/os/access.c
+++ b/vcxsrv-code/xorg-server/os/access.c
@@ -82,6 +82,10 @@ SOFTWARE.
 
 #ifdef WIN32
 #include <X11/Xwinsock.h>
+
+#ifndef AF_HYPERV
+#define AF_HYPERV 34
+#endif
 #endif
 
 #include <stdio.h>
@@ -245,6 +249,84 @@ static Bool siAddrMatch(int family, void *addr, int len, HOST * host,
 static int siCheckAddr(const char *addrString, int length);
 static void siTypesInitialize(void);
 
+#if NTDDI_VERSION < NTDDI_VISTA
+const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt)
+{
+    if (af == AF_INET)
+    {
+        struct sockaddr_in in;
+        memset(&in, 0, sizeof(in));
+        in.sin_family = AF_INET;
+        memcpy(&in.sin_addr, src, sizeof(struct in_addr));
+        if (getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in), dst, cnt, NULL, 0, NI_NUMERICHOST) != 0)
+        {
+            errno = WSAGetLastError();
+            return NULL;
+        }
+        else return dst;
+    }
+    else if (af == AF_INET6)
+    {
+        struct sockaddr_in6 in;
+        memset(&in, 0, sizeof(in));
+        in.sin6_family = AF_INET6;
+        memcpy(&in.sin6_addr, src, sizeof(struct in_addr6));
+        if (getnameinfo((struct sockaddr *)&in, sizeof(struct sockaddr_in6), dst, cnt, NULL, 0, NI_NUMERICHOST) != 0)
+        {
+            errno = WSAGetLastError();
+            return NULL;
+        }
+        else return dst;
+    }
+    errno = WSAEAFNOSUPPORT;
+    return NULL;
+}
+
+int inet_pton(int af, const char *src, void *dst)
+{
+    struct sockaddr_storage ss;
+    int sslen = sizeof(ss);
+    if (af == AF_INET)
+    {
+        struct in_addr out;
+        char buffer[INET_ADDRSTRLEN + 1];
+        strncpy (buffer, src, INET_ADDRSTRLEN);
+        buffer [INET_ADDRSTRLEN] = '\0';
+        if (WSAStringToAddressA(buffer, AF_INET, NULL, (struct sockaddr*)&ss, &sslen) == SOCKET_ERROR)
+        {
+            errno = WSAGetLastError();
+            return 0;
+        }
+        else
+        {
+            out = ((struct sockaddr_in *)&ss)->sin_addr;
+            memcpy (dst, &out, sizeof(struct in_addr));
+            return 1;
+        }
+    }
+    else if (af == AF_INET6)
+    {
+        struct in6_addr out6;
+        char buffer6[INET6_ADDRSTRLEN + 1];
+        strncpy (buffer6, src, INET6_ADDRSTRLEN);
+        buffer6 [INET6_ADDRSTRLEN] = '\0';
+        if (WSAStringToAddressA(buffer6, AF_INET6, NULL, (struct sockaddr*)&ss, &sslen) == SOCKET_ERROR)
+        {
+            errno = WSAGetLastError();
+            return 0;
+        }
+        else
+        {
+            out6 = ((struct sockaddr_in6 *)&ss)->sin6_addr;
+            memcpy (dst, &out6, sizeof(struct in6_addr));
+            return 1;
+        }
+    }
+    errno = WSAEAFNOSUPPORT;
+    return -1;
+}
+#endif
+
 /*
  * called when authorization is not enabled to add the
  * local host to the access list
@@ -998,6 +1080,13 @@ ResetHosts(const char *display)
             }
 #endif
 #endif
+#ifdef HYPERV
+            else if(!strncmp("hyperv", lhostname, 6)) {
+                family = FamilyLocal;
+                NewHost(family, "", 0, FALSE);
+                hostname = ohostname + 6;
+            }
+#endif
 #ifdef SECURE_RPC
             else if (!strncmp("nis:", lhostname, 4)) {
                 family = FamilyNetname;
@@ -1032,9 +1121,15 @@ ResetHosts(const char *display)
                     (family == FamilyWild)) {
                     struct addrinfo *addresses;
                     struct addrinfo *a;
+                    struct addrinfo hints;
                     int f;
 
-                    if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
+                    ZeroMemory(&hints, sizeof(hints));
+                    if (family == FamilyInternet)
+                        hints.ai_family = AF_INET;
+                    else if (family == FamilyInternet6)
+                        hints.ai_family = AF_INET6;
+                    if (getaddrinfo(hostname, NULL, &hints, &addresses) == 0) {
                         for (a = addresses; a != NULL; a = a->ai_next) {
                             len = a->ai_addrlen;
                             f = ConvertAddr(a->ai_addr, &len,
@@ -1341,6 +1436,9 @@ ForEachHostInFamily(int family, Bool (*func) (unsigned char *addr,
 {
     HOST *host;
 
+    if (family == FamilyLocal)
+        return TRUE;            /* No FamilyLocal in Xming */
+
     for (host = validhosts; host; host = host->next)
         if (family == host->family && func(host->addr, host->len, closure))
             return TRUE;
@@ -1367,7 +1465,7 @@ NewHost(int family, const void *addr, int len, int addingLocalHosts)
         }
     }
     MakeHost(host, len)
-        if (!host)
+    if (!host)
         return FALSE;
     host->family = family;
     host->len = len;
@@ -1586,6 +1684,10 @@ ConvertAddr(register struct sockaddr *saddr, int *len, void **addr)
         }
     }
 #endif
+#endif
+#if defined(HYPERV)
+    case AF_HYPERV:
+        return FamilyLocal;
 #endif
     default:
         return -1;
@@ -1811,6 +1913,7 @@ siHostnameAddrMatch(int family, void *addr, int len,
         char hostname[SI_HOSTNAME_MAXLEN];
         struct addrinfo *addresses;
         struct addrinfo *a;
+        struct addrinfo hints;
         int f, hostaddrlen;
         void *hostaddr = NULL;
 
@@ -1819,7 +1922,12 @@ siHostnameAddrMatch(int family, void *addr, int len,
 
         strlcpy(hostname, siAddr, siAddrLen + 1);
 
-        if (getaddrinfo(hostname, NULL, NULL, &addresses) == 0) {
+        ZeroMemory(&hints, sizeof(hints));
+        if (family == FamilyInternet)
+            hints.ai_family = AF_INET;
+        else if (family == FamilyInternet6)
+            hints.ai_family = AF_INET6;
+        if (getaddrinfo(hostname, NULL, &hints, &addresses) == 0) {
             for (a = addresses; a != NULL; a = a->ai_next) {
                 hostaddrlen = a->ai_addrlen;
                 f = ConvertAddr(a->ai_addr, &hostaddrlen, &hostaddr);
@@ -1852,7 +1960,7 @@ siHostnameAddrMatch(int family, void *addr, int len,
         if ((hp = _XGethostbyname(hostname, hparams)) != NULL) {
 #ifdef h_addr                   /* new 4.3bsd version of gethostent */
             /* iterate over the addresses */
-            for (addrlist = hp->h_addr_list; *addrlist; addrlist++)
+            for (addrlist = (const char **)hp->h_addr_list; *addrlist; addrlist++)
 #else
             addrlist = &hp->h_addr;
 #endif
diff --git a/xserver/os/auth.c b/vcxsrv-code/xorg-server/os/auth.c
index 611e4ef..65726de 100644
--- a/xserver/os/auth.c
+++ b/vcxsrv-code/xorg-server/os/auth.c
@@ -202,11 +202,11 @@ CheckAuthorization(unsigned int name_length,
          */
 
         if (loadauth > 0) {
-            DisableLocalAccess(); /* got at least one */
+            DisableLocalHost(); /* got at least one */
             loaded = TRUE;
         }
         else if (loadauth == 0 || !loaded)
-            EnableLocalAccess();
+            EnableLocalHost();
     }
     if (name_length) {
         for (i = 0; i < NUM_AUTHORIZATION; i++) {
@@ -313,6 +313,17 @@ GenerateAuthorization(unsigned name_length,
 void
 GenerateRandomData(int len, char *buf)
 {
+#ifdef _MSC_VER
+    static HANDLE hAdvApi32;
+    static BOOLEAN (_stdcall * RtlGenRandom)(void *,unsigned long);
+
+    if (!hAdvApi32)
+    {
+      hAdvApi32=LoadLibrary("advapi32.dll");
+      RtlGenRandom=(BOOLEAN (_stdcall *)(void*,unsigned long))GetProcAddress(hAdvApi32,"SystemFunction036");
+    }
+    RtlGenRandom(buf, len);
+#else
 #ifdef HAVE_ARC4RANDOM_BUF
     arc4random_buf(buf, len);
 #else
@@ -322,4 +333,5 @@ GenerateRandomData(int len, char *buf)
     read(fd, buf, len);
     close(fd);
 #endif
+#endif
 }
diff --git a/xserver/os/connection.c b/vcxsrv-code/xorg-server/os/connection.c
index 9e8d47f..20380c9 100644
--- a/xserver/os/connection.c
+++ b/vcxsrv-code/xorg-server/os/connection.c
@@ -66,6 +66,9 @@ SOFTWARE.
 
 #ifdef WIN32
 #include <X11/Xwinsock.h>
+#ifdef _DEBUG
+#define DEBUG
+#endif
 #endif
 #include <X11/X.h>
 #include <X11/Xproto.h>
@@ -106,6 +109,11 @@ SOFTWARE.
 #include "opaque.h"
 #include "dixstruct.h"
 #include "xace.h"
+#include "xserver_poll.h"
+
+#ifdef _MSC_VER
+typedef int pid_t;
+#endif
 
 #define Pid_t pid_t
 
@@ -127,17 +135,20 @@ struct ospoll   *server_poll;
 Bool NewOutputPending;          /* not yet attempted to write some new output */
 Bool NoListenAll;               /* Don't establish any listening sockets */
 
+#if !defined(_MSC_VER)
 static Bool RunFromSmartParent; /* send SIGUSR1 to parent process */
+static Pid_t ParentProcess;
+#endif
 Bool RunFromSigStopParent;      /* send SIGSTOP to our own process; Upstart (or
                                    equivalent) will send SIGCONT back. */
 static char dynamic_display[7]; /* display name */
+static int dynamic_display_id;
 Bool PartialNetwork;            /* continue even if unable to bind all addrs */
-static Pid_t ParentProcess;
 
 int GrabInProgress = 0;
 
 static void
-EstablishNewConnections(int curconn, int ready, void *data);
+EstablishNewConnections_local(int curconn, int ready, void *data);
 
 static void
 set_poll_client(ClientPtr client);
@@ -165,6 +176,23 @@ lookup_trans_conn(int fd)
     return NULL;
 }
 
+int
+TransIsListening(char *protocol)
+{
+  /* look for this transport in the list of listeners */
+  int i;
+  for (i = 0; i < ListenTransCount; i++)
+    {
+      if (!strcmp(protocol, ListenTransConns[i]->transptr->TransName))
+        {
+          return 1;
+        }
+    }
+
+  return 0;
+}
+
+
 /*
  * If SIGUSR1 was set to SIG_IGN when the server started, assume that either
  *
@@ -216,6 +244,11 @@ NotifyParentProcess(void)
        we are ready. Otherwise sd_notify() won't do anything. */
     sd_notify(0, "READY=1");
 #endif
+#else
+/* On windows the displayfd points to shared memory, so write the id to it */
+    int *pDisplayfd=(int*)MapViewOfFile((HANDLE)displayfd, FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
+    if (pDisplayfd)
+      *pDisplayfd=dynamic_display_id;
 #endif
 }
 
@@ -257,7 +290,7 @@ CreateWellKnownSockets(void)
     else { /* -displayfd and no explicit display number */
         Bool found = 0;
         for (i = 0; i < 65536 - X_TCP_PORT; i++) {
-            if (TryCreateSocket(i, &partial) && !partial) {
+            if (TryCreateSocket(i, &partial) && ListenTransCount >= 1 && (PartialNetwork || !partial)) {
                 found = 1;
                 break;
             }
@@ -266,6 +299,7 @@ CreateWellKnownSockets(void)
         }
         if (!found)
             FatalError("Failed to find a socket to listen on");
+        dynamic_display_id=i;
         snprintf(dynamic_display, sizeof(dynamic_display), "%d", i);
         display = dynamic_display;
         LogSetDisplay();
@@ -275,13 +309,13 @@ CreateWellKnownSockets(void)
     if (ListenTransFds == NULL)
         FatalError ("Failed to create listening socket array");
 
-    for (i = 0; i < ListenTransCount; i++) {
-        int fd = _XSERVTransGetConnectionNumber(ListenTransConns[i]);
+    for (i = ListenTransCount; i > 0; i--) {
+        int fd = _XSERVTransGetConnectionNumber (ListenTransConns[i-1]);
 
-        ListenTransFds[i] = fd;
-        SetNotifyFd(fd, EstablishNewConnections, X_NOTIFY_READ, NULL);
+        ListenTransFds[i-1] = fd;
+        SetNotifyFd(fd, EstablishNewConnections_local, X_NOTIFY_READ, NULL);
 
-        if (!_XSERVTransIsLocal(ListenTransConns[i]))
+        if (!_XSERVTransIsLocal (ListenTransConns[i-1]))
             DefineSelf (fd);
     }
 
@@ -339,7 +373,7 @@ ResetWellKnownSockets(void)
         }
     }
     for (i = 0; i < ListenTransCount; i++)
-        SetNotifyFd(ListenTransFds[i], EstablishNewConnections, X_NOTIFY_READ,
+        SetNotifyFd(ListenTransFds[i], EstablishNewConnections_local, X_NOTIFY_READ,
                     NULL);
 
     ResetAuthorization();
@@ -646,13 +680,13 @@ AllocNewConnection(XtransConnInfo trans_conn, int fd, CARD32 conn_time)
 }
 
 /*****************
- * EstablishNewConnections
+ * EstablishNewConnections_local
  *    If anyone is waiting on listened sockets, accept them. Drop pending
  *    connections if they've stuck around for more than one minute.
  *****************/
 #define TimeOutValue 60 * MILLI_PER_SECOND
 static void
-EstablishNewConnections(int curconn, int ready, void *data)
+EstablishNewConnections_local(int curconn, int ready, void *data)
 {
     int newconn;       /* fd of new client */
     CARD32 connect_time;
@@ -765,6 +799,56 @@ CloseDownFileDescriptor(OsCommPtr oc)
     }
 }
 
+/*****************
+ * CheckConnections
+ *    Some connection has died, go find which one and shut it down
+ *    The file descriptor has been closed, but is still in AllClients.
+ *    If would truly be wonderful if select() would put the bogus
+ *    file descriptors in the exception mask, but nooooo.  So we have
+ *    to check each and every socket individually.
+ *****************/
+
+#ifdef WIN32
+void
+CheckConnections(struct pollfd *fds, int num)
+{
+    fd_set tmask;
+    int i;
+    struct timeval notime;
+    int r;
+
+    notime.tv_sec = 0;
+    notime.tv_usec = 0;
+
+    for (i=0; i<num; i++)
+    {
+      int curclient=fds[i].fd;
+      fd_set tmask;
+      FD_ZERO(&tmask);
+      FD_SET(curclient, &tmask);
+      do
+      {
+        r = select (curclient + 1, &tmask, NULL, NULL, &notime);
+      } while (r == SOCKET_ERROR && (WSAGetLastError() == WSAEINTR || WSAGetLastError() == WSAEWOULDBLOCK));
+      if (r < 0)
+      {
+        for (i = 0; i < currentMaxClients; i++) {
+          ClientPtr client = clients[i];
+          if (client && !client->clientGone)
+          {
+            OsCommPtr oc = (OsCommPtr) (client->osPrivate);
+            if (oc->fd==curclient)
+            {
+              CloseDownClient(client);
+              break;
+            }
+          }
+        }
+      }
+    }
+}
+#endif
+
 /*****************
  * CloseDownConnection
  *    Delete client from AllClients and free resources
@@ -778,8 +862,12 @@ CloseDownConnection(ClientPtr client)
     if (FlushCallback)
         CallCallbacks(&FlushCallback, client);
 
+#ifdef DEBUG
+    ErrorF("CloseDownConnection: client index = %d, socket fd = %d\n",
+           client->index, oc->fd);
+#endif
     if (oc->output)
-	FlushClient(client, oc, (char *) NULL, 0);
+        FlushClient(client, oc, (char *) NULL, 0);
     CloseDownFileDescriptor(oc);
     FreeOsBuffers(oc);
     free(client->osPrivate);
@@ -1025,7 +1113,7 @@ ListenOnOpenFD(int fd, int noxauth)
     ListenTransConns[ListenTransCount] = ciptr;
     ListenTransFds[ListenTransCount] = fd;
 
-    SetNotifyFd(fd, EstablishNewConnections, X_NOTIFY_READ, NULL);
+    SetNotifyFd(fd, EstablishNewConnections_local, X_NOTIFY_READ, NULL);
 
     /* Increment the count */
     ListenTransCount++;
diff --git a/xserver/os/inputthread.c b/vcxsrv-code/xorg-server/os/inputthread.c
index 3469cfc..9de4f3d 100644
--- a/xserver/os/inputthread.c
+++ b/vcxsrv-code/xorg-server/os/inputthread.c
@@ -312,11 +312,13 @@ InputThreadPipeNotify(int fd, int revents, void *data)
 static void*
 InputThreadDoWork(void *arg)
 {
+#ifdef SIG_BLOCK
     sigset_t set;
 
     /* Don't handle any signals on this thread */
     sigfillset(&set);
     pthread_sigmask(SIG_BLOCK, &set, NULL);
+#endif
 
     ddxInputThreadInit();
 
@@ -336,7 +338,7 @@ InputThreadDoWork(void *arg)
 
     while (inputThreadInfo->running)
     {
-        DebugF("input-thread: %s waiting for devices\n", __func__);
+        DebugF("input-thread: %s waiting for devices\n", __FUNCTION__);
 
         /* Check for hotplug changes and modify the ospoll structure to suit */
         if (inputThreadInfo->changed) {
@@ -368,9 +370,9 @@ InputThreadDoWork(void *arg)
 
         if (ospoll_wait(inputThreadInfo->fds, -1) < 0) {
             if (errno == EINVAL)
-                FatalError("input-thread: %s (%s)", __func__, strerror(errno));
+                FatalError("input-thread: %s (%s)", __FUNCTION__, strerror(errno));
             else if (errno != EINTR)
-                ErrorF("input-thread: %s (%s)\n", __func__, strerror(errno));
+                ErrorF("input-thread: %s (%s)\n", __FUNCTION__, strerror(errno));
         }
 
         /* Kick main thread to process the generated input events and drain
@@ -414,7 +416,7 @@ InputThreadPreInit(void)
 
     inputThreadInfo->changed = FALSE;
 
-    inputThreadInfo->thread = 0;
+    inputThreadInfo->thread.p = 0;
     xorg_list_init(&inputThreadInfo->devs);
     inputThreadInfo->fds = ospoll_create();
 
@@ -525,10 +527,12 @@ InputThreadFini(void)
     inputThreadInfo = NULL;
 }
 
+#ifdef SIG_BLOCK
 int xthread_sigmask(int how, const sigset_t *set, sigset_t *oldset)
 {
     return pthread_sigmask(how, set, oldset);
 }
+#endif
 
 #else /* INPUTTHREAD */
 
@@ -556,6 +560,7 @@ extern int InputThreadUnregisterDev(int fd)
     return 1;
 }
 
+#ifdef SIG_BLOCK
 int xthread_sigmask(int how, const sigset_t *set, sigset_t *oldset)
 {
 #ifdef HAVE_SIGPROCMASK
@@ -564,5 +569,6 @@ int xthread_sigmask(int how, const sigset_t *set, sigset_t *oldset)
     return 0;
 #endif
 }
+#endif
 
 #endif
diff --git a/xserver/os/io.c b/vcxsrv-code/xorg-server/os/io.c
index 5b7fac3..98fb838 100644
--- a/xserver/os/io.c
+++ b/vcxsrv-code/xorg-server/os/io.c
@@ -686,7 +686,7 @@ WriteToClient(ClientPtr who, int count, const void *__buf)
     const char *buf = __buf;
 
     BUG_RETURN_VAL_MSG(in_input_thread(), 0,
-                       "******** %s called from input thread *********\n", __func__);
+                       "******** %s called from input thread *********\n", __FUNCTION__);
 
 #ifdef DEBUG_COMMUNICATION
     Bool multicount = FALSE;
diff --git a/xserver/os/log.c b/vcxsrv-code/xorg-server/os/log.c
index 4bd6b7e..118d1c9 100644
--- a/xserver/os/log.c
+++ b/vcxsrv-code/xorg-server/os/log.c
@@ -92,8 +92,14 @@ OR PERFORMANCE OF THIS SOFTWARE.
 
 #ifdef WIN32
 #include <process.h>
+#ifndef _MSC_VER
 #define getpid(x) _getpid(x)
 #endif
+#endif
+
+#ifdef _MSC_VER
+#define S_ISREG(m)  (((m)&_S_IFMT) == _S_IFREG)
+#endif
 
 #ifdef XF86BIGFONT
 #include "xf86bigfontsrv.h"
@@ -186,8 +192,10 @@ strlen_sigsafe(const char *s)
  * an old file out of the way, but it doesn't actually open the file,
  * since it may be used for renaming a file we're already logging to.
  */
+#ifndef _MSC_VER
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wformat-nonliteral"
+#endif
 
 static char *
 LogFilePrep(const char *fname, const char *backup, const char *idstring)
@@ -212,23 +220,31 @@ LogFilePrep(const char *fname, const char *backup, const char *idstring)
             }
             free(suffix);
 
+            if (!stat(oldLog, &buf) && S_ISREG(buf.st_mode))
+            {
+                remove(oldLog);
+            }
+
             if (rename(logFileName, oldLog) == -1) {
-                FatalError("Cannot move old log file \"%s\" to \"%s\"\n",
-                           logFileName, oldLog);
+                ErrorF("Cannot move old log file \"%s\" to \"%s\"\n",
+                       logFileName, oldLog);
             }
             free(oldLog);
         }
     }
     else {
         if (remove(logFileName) != 0 && errno != ENOENT) {
-            FatalError("Cannot remove old log file \"%s\": %s\n",
+            LogMessageVerb(X_WARNING, 0, "Cannot remove old log file \"%s\": %s\n",
                        logFileName, strerror(errno));
         }
     }
 
     return logFileName;
 }
+
+#ifndef _MSC_VER
 #pragma GCC diagnostic pop
+#endif
 
 /*
  * LogInit is called to start logging to a file.  It is also called (with
@@ -591,9 +607,7 @@ pnprintf(char *string, int size, const char *f, ...)
     return rc;
 }
 
-/* This function does the actual log message writes. It must be signal safe.
- * When attempting to call non-signal-safe functions, guard them with a check
- * of the inSignalContext global variable. */
+/* This function does the actual log message writes. */
 static void
 LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
 {
@@ -604,16 +618,9 @@ LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
         ret = write(2, buf, len);
 
     if (verb < 0 || logFileVerbosity >= verb) {
-        if (inSignalContext && logFileFd >= 0) {
-            ret = write(logFileFd, buf, len);
-#ifndef WIN32
-            if (logFlush && logSync)
-                fsync(logFileFd);
-#endif
-        }
-        else if (!inSignalContext && logFile) {
-            if (newline)
-                fprintf(logFile, "[%10.3f] ", GetTimeInMillis() / 1000.0);
+        if (logFile) {
+//            if (newline)
+//                fprintf(logFile, "[%10.3f] ", GetTimeInMillis() / 1000.0);
             newline = end_line;
             fwrite(buf, len, 1, logFile);
             if (logFlush) {
@@ -624,7 +631,7 @@ LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
 #endif
             }
         }
-        else if (!inSignalContext && needBuffer) {
+        else if (needBuffer) {
             if (len > bufferUnused) {
                 bufferSize += 1024;
                 bufferUnused += 1024;
@@ -647,7 +654,7 @@ LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
 void
 LogVWrite(int verb, const char *f, va_list args)
 {
-    return LogVMessageVerb(X_NONE, verb, f, args);
+    LogVMessageVerb(X_NONE, verb, f, args);
 }
 
 void
@@ -710,11 +717,6 @@ LogVMessageVerb(MessageType type, int verb, const char *format, va_list args)
     Bool newline;
     size_t len = 0;
 
-    if (inSignalContext) {
-        LogVMessageVerbSigSafe(type, verb, format, args);
-        return;
-    }
-
     type_str = LogMessageTypeVerbString(type, verb);
     if (!type_str)
         return;
@@ -812,13 +814,8 @@ LogVHdrMessageVerb(MessageType type, int verb, const char *msg_format,
     if (!type_str)
         return;
 
-    if (inSignalContext) {
-        vprintf_func = vpnprintf;
-        printf_func = pnprintf;
-    } else {
-        vprintf_func = Xvscnprintf;
-        printf_func = Xscnprintf;
-    }
+    vprintf_func = Xvscnprintf;
+    printf_func = Xscnprintf;
 
     /* if type_str is not "", prepend it and ' ', to message */
     if (type_str[0] != '\0')
@@ -971,7 +968,7 @@ VAuditF(const char *f, va_list args)
         if (auditTimer != NULL)
             TimerForce(auditTimer);
         ErrorF("%s%s", prefix != NULL ? prefix : "", buf);
-        strlcpy(oldbuf, buf, sizeof(oldbuf));
+        strncpy(oldbuf, buf, sizeof(oldbuf));
         oldlen = len;
         nrepeat = 0;
         auditTimer = TimerSet(auditTimer, 0, AUDIT_TIMEOUT, AuditFlush, NULL);
@@ -979,6 +976,8 @@ VAuditF(const char *f, va_list args)
     free(prefix);
 }
 
+extern char g_FatalErrorMessage[1024];
+
 void
 FatalError(const char *f, ...)
 {
@@ -993,8 +992,10 @@ FatalError(const char *f, ...)
 
     va_start(args, f);
 
+#ifndef _MSC_VER
     /* Make a copy for OsVendorFatalError */
     va_copy(args2, args);
+#endif
 
 #ifdef __APPLE__
     {
@@ -1005,10 +1006,16 @@ FatalError(const char *f, ...)
                         sizeof(__crashreporter_info_buff__), f, apple_args);
         va_end(apple_args);
     }
+#endif
+#ifdef WIN32
+    vsnprintf(g_FatalErrorMessage, 1024, f, args);
 #endif
     VErrorFSigSafe(f, args);
     va_end(args);
     ErrorFSigSafe("\n");
+#ifdef _MSC_VER
+    va_start(args2, f);
+#endif
     if (!beenhere)
         OsVendorFatalError(f, args2);
     va_end(args2);
diff --git a/xserver/os/ospoll.c b/vcxsrv-code/xorg-server/os/ospoll.c
index c68aabc..93a1a76 100644
--- a/xserver/os/ospoll.c
+++ b/vcxsrv-code/xorg-server/os/ospoll.c
@@ -739,3 +739,8 @@ ospoll_data(struct ospoll *ospoll, int fd)
     return ospoll->osfds[pos].data;
 #endif
 }
+
+void CheckServerConnections(struct ospoll *server_poll)
+{
+  CheckConnections(server_poll->fds, server_poll->num);
+}
diff --git a/xserver/os/utils.c b/vcxsrv-code/xorg-server/os/utils.c
index c9a8e73..f82b262 100644
--- a/xserver/os/utils.c
+++ b/vcxsrv-code/xorg-server/os/utils.c
@@ -72,6 +72,9 @@ __stdcall unsigned long GetTickCount(void);
 #include <sys/time.h>
 #include <sys/resource.h>
 #endif
+#ifdef _MSC_VER
+# define SMART_SCHEDULE_POSSIBLE
+#endif
 #include "misc.h"
 #include <X11/X.h>
 #define XSERV_t
@@ -187,7 +190,7 @@ Bool noGEExtension = FALSE;
 
 Bool CoreDump;
 
-Bool enableIndirectGLX = FALSE;
+Bool enableIndirectGLX = TRUE;
 
 #ifdef PANORAMIX
 Bool PanoramiXExtensionDisabledHack = FALSE;
@@ -197,7 +200,11 @@ int auditTrailLevel = 1;
 
 char *SeatId = NULL;
 
-sig_atomic_t inSignalContext = FALSE;
+#ifdef _MSC_VER
+static HANDLE s_hSmartScheduleTimer = NULL;
+static HANDLE s_hSmartScheduleTimerQueue = NULL;
+static CRITICAL_SECTION timerCriticalSection;
+#endif
 
 #if defined(SVR4) || defined(__linux__) || defined(CSRG_BASED)
 #define HAS_SAVED_IDS_AND_SETEUID
@@ -237,6 +244,10 @@ OsSignal(int sig, OsSigHandlerPtr handler)
 #define LOCK_PREFIX "/.X"
 #define LOCK_SUFFIX "-lock"
 
+#ifdef _MSC_VER
+#define LockFile szLockFile
+#endif
+
 #if !defined(WIN32) || defined(__CYGWIN__)
 #define LOCK_SERVER
 #endif
@@ -263,6 +274,14 @@ static Bool nolock = FALSE;
 void
 LockServer(void)
 {
+#if defined(WIN32) && !defined(__CYGWIN__)
+  char MutexName[100];
+  sprintf(MutexName, "Global\\VcXsrv_Mutex_%d\n", atoi(display));
+  if (!CreateMutex(NULL,TRUE,MutexName) || GetLastError()== ERROR_ALREADY_EXISTS)
+  {
+    FatalError("Server is already active for display %d\n", atoi(display));
+  }
+#else
     char tmp[PATH_MAX], pid_str[12];
     int lfd, i, haslock, l_pid, t;
     const char *tmppath = LOCK_DIR;
@@ -387,6 +406,7 @@ LockServer(void)
     if (!haslock)
         FatalError("Could not create server lock file: %s\n", LockFile);
     StillLocking = FALSE;
+#endif
 }
 
 /*
@@ -515,7 +535,11 @@ GetTimeInMicros(void)
 void
 UseMsg(void)
 {
-    ErrorF("use: X [:<display>] [option]\n");
+    ErrorF("Usage...\nVcxsrv [:<display>] [option]\n\n");
+    ErrorF(":display-number\n\tVcxsrv runs as the given display-number, which defaults to 0.\n");
+    ErrorF("\tTo run multiple instances, use unique display-numbers.\n\n");
+
+    ErrorF("-silent-dup-error      Do not show fatal exit error mesage box\n");
     ErrorF("-a #                   default pointer acceleration (factor)\n");
     ErrorF("-ac                    disable access control restrictions\n");
     ErrorF("-audit int             set audit trail level\n");
@@ -523,13 +547,15 @@ UseMsg(void)
     ErrorF("-br                    create root window with black background\n");
     ErrorF("+bs                    enable any backing store support\n");
     ErrorF("-bs                    disable any backing store support\n");
-    ErrorF("-c                     turns off key-click\n");
-    ErrorF("c #                    key-click volume (0-100)\n");
     ErrorF("-cc int                default color visual class\n");
     ErrorF("-nocursor              disable the cursor\n");
     ErrorF("-core                  generate core dump on fatal error\n");
     ErrorF("-displayfd fd          file descriptor to write display number to when ready to connect\n");
+#ifdef _MSC_VER
+    ErrorF("-dpi [auto|int]        screen resolution set to native or this dpi\n");
+#else
     ErrorF("-dpi int               screen resolution in dots per inch\n");
+#endif
 #ifdef DPMSExtension
     ErrorF("-dpms                  disables VESA DPMS monitor control\n");
 #endif
@@ -539,8 +565,8 @@ UseMsg(void)
     ErrorF("-fakescreenfps #       fake screen default fps (1-600)\n");
     ErrorF("-fp string             default font path\n");
     ErrorF("-help                  prints message with these options\n");
-    ErrorF("+iglx                  Allow creating indirect GLX contexts\n");
-    ErrorF("-iglx                  Prohibit creating indirect GLX contexts (default)\n");
+    ErrorF("+iglx                  Allow creating indirect GLX contexts (default)\n");
+    ErrorF("-iglx                  Prohibit creating indirect GLX contexts\n");
     ErrorF("-I                     ignore all remaining arguments\n");
 #ifdef RLIMIT_DATA
     ErrorF("-ld int                limit data space to N Kb\n");
@@ -560,23 +586,17 @@ UseMsg(void)
     ErrorF("-noreset               don't reset after last client exists\n");
     ErrorF("-background [none]     create root window with no background\n");
     ErrorF("-reset                 reset after last client exists\n");
-    ErrorF("-p #                   screen-saver pattern duration (minutes)\n");
     ErrorF("-pn                    accept failure to listen on all ports\n");
     ErrorF("-nopn                  reject failure to listen on all ports\n");
     ErrorF("-r                     turns off auto-repeat\n");
     ErrorF("r                      turns on auto-repeat \n");
     ErrorF("-render [default|mono|gray|color] set render color alloc policy\n");
-    ErrorF("-retro                 start with classic stipple and cursor\n");
-    ErrorF("-s #                   screen-saver timeout (minutes)\n");
+    ErrorF("-retro                 start with classic stipple\n");
     ErrorF("-seat string           seat to run on\n");
     ErrorF("-t #                   default pointer threshold (pixels/t)\n");
     ErrorF("-terminate [delay]     terminate at server reset (optional delay in sec)\n");
     ErrorF("-tst                   disable testing extensions\n");
-    ErrorF("ttyxx                  server started from init on /dev/ttyxx\n");
-    ErrorF("v                      video blanking for screen-saver\n");
-    ErrorF("-v                     screen-saver without video blanking\n");
     ErrorF("-wr                    create root window with white background\n");
-    ErrorF("-maxbigreqsize         set maximal bigrequest size \n");
 #ifdef PANORAMIX
     ErrorF("+xinerama              Enable XINERAMA extension\n");
     ErrorF("-xinerama              Disable XINERAMA extension\n");
@@ -584,10 +604,13 @@ UseMsg(void)
     ErrorF
         ("-dumbSched             Disable smart scheduling and threaded input, enable old behavior\n");
     ErrorF("-schedInterval int     Set scheduler interval in msec\n");
-    ErrorF("-sigstop               Enable SIGSTOP based startup\n");
     ErrorF("+extension name        Enable extension\n");
     ErrorF("-extension name        Disable extension\n");
     ListStaticExtensions();
+#ifdef HYPERV
+    ErrorF("-vmid GUID             Hyper-V VM GUID to accept VSock connections from\n");
+    ErrorF("-vsockport port        integer port number to listen for VSock connections.  Default 106000.\n");
+#endif
 #ifdef XDMCP
     XdmcpUseMsg();
 #endif
@@ -649,10 +672,10 @@ static const char *defaultNoListenList[] = {
 #ifndef LISTEN_TCP
     "tcp",
 #endif
-#ifndef LISTEN_UNIX
+#if !defined(LISTEN_UNIX) && defined(UNIXCONN)
     "unix",
 #endif
-#ifndef LISTEN_LOCAL
+#if !defined(LISTEN_LOCAL) && defined(LOCALCONN)
     "local",
 #endif
     NULL
@@ -725,15 +748,6 @@ ProcessCommandLine(int argc, char *argv[])
             enableBackingStore = TRUE;
         else if (strcmp(argv[i], "-bs") == 0)
             disableBackingStore = TRUE;
-        else if (strcmp(argv[i], "c") == 0) {
-            if (++i < argc)
-                defaultKeyboardControl.click = atoi(argv[i]);
-            else
-                UseMsg();
-        }
-        else if (strcmp(argv[i], "-c") == 0) {
-            defaultKeyboardControl.click = 0;
-        }
         else if (strcmp(argv[i], "-cc") == 0) {
             if (++i < argc)
                 defaultColorVisualClass = atoi(argv[i]);
@@ -755,7 +769,24 @@ ProcessCommandLine(int argc, char *argv[])
         }
         else if (strcmp(argv[i], "-dpi") == 0) {
             if (++i < argc)
+#ifdef _MSC_VER
+            {
+                if (strcmp(argv[i], "auto") == 0)
+                {
+                    HDC hdc = GetDC(NULL);
+                    if (hdc)
+                    {
+                        int dpiY = GetDeviceCaps(hdc, LOGPIXELSY);
+                        monitorResolution = dpiY;
+                        ReleaseDC(NULL, hdc);
+                    }
+                }
+                else if (isdigit(*argv[i])) /* Naively prevent a crash if not numeric */
+              monitorResolution = atoi(argv[i]);
+            }
+#else
                 monitorResolution = atoi(argv[i]);
+#endif
             else
                 UseMsg();
         }
@@ -856,21 +887,21 @@ ProcessCommandLine(int argc, char *argv[])
                 nolock = TRUE;
         }
 #endif
-	else if ( strcmp( argv[i], "-maxclients") == 0)
-	{
-	    if (++i < argc) {
-		LimitClients = atoi(argv[i]);
-		if (LimitClients != 64 &&
-		    LimitClients != 128 &&
-		    LimitClients != 256 &&
-		    LimitClients != 512 &&
+        else if ( strcmp( argv[i], "-maxclients") == 0)
+        {
+            if (++i < argc) {
+                LimitClients = atoi(argv[i]);
+                if (LimitClients != 64 &&
+                    LimitClients != 128 &&
+                    LimitClients != 256 &&
+                    LimitClients != 512 &&
                     LimitClients != 1024 &&
                     LimitClients != 2048) {
-		    FatalError("maxclients must be one of 64, 128, 256, 512, 1024 or 2048\n");
-		}
-	    } else
-		UseMsg();
-	}
+                    FatalError("maxclients must be one of 64, 128, 256, 512, 1024 or 2048\n");
+                }
+            } else
+                UseMsg();
+        }
         else if (strcmp(argv[i], "-nolisten") == 0) {
             if (++i < argc) {
                 if (_XSERVTransNoListen(argv[i]))
@@ -944,10 +975,6 @@ ProcessCommandLine(int argc, char *argv[])
         else if (strcmp(argv[i], "-tst") == 0) {
             noTestExtensions = TRUE;
         }
-        else if (strcmp(argv[i], "v") == 0)
-            defaultScreenSaverBlanking = PreferBlanking;
-        else if (strcmp(argv[i], "-v") == 0)
-            defaultScreenSaverBlanking = DontPreferBlanking;
         else if (strcmp(argv[i], "-wr") == 0)
             whiteRoot = TRUE;
         else if (strcmp(argv[i], "-background") == 0) {
@@ -1030,9 +1057,6 @@ ProcessCommandLine(int argc, char *argv[])
             else
                 UseMsg();
         }
-        else if (strcmp(argv[i], "-sigstop") == 0) {
-            RunFromSigStopParent = TRUE;
-        }
         else if (strcmp(argv[i], "+extension") == 0) {
             if (++i < argc) {
                 if (!EnableDisableExtension(argv[i], TRUE))
@@ -1049,6 +1073,23 @@ ProcessCommandLine(int argc, char *argv[])
             else
                 UseMsg();
         }
+#ifdef HYPERV
+        else if(strcmp(argv[i], "-vmid") == 0)
+        {
+            if(++i < argc)
+            {
+                _XSERVTransSetHyperVVmId(argv[i]);
+            } else
+                UseMsg();
+        }
+        else if(strcmp(argv[i], "-vsockport") == 0) {
+
+            if(++i < argc) {
+                _XSERVTransSetHyperVPortNo(argv[i]);
+            } else
+                UseMsg();
+        }
+#endif
         else {
             ErrorF("Unrecognized option: %s\n", argv[i]);
             UseMsg();
@@ -1202,6 +1243,17 @@ void
 SmartScheduleStopTimer(void)
 {
 #ifdef HAVE_SETITIMER
+#ifdef _MSC_VER
+    if (!SmartScheduleSignalEnable)
+        return;
+    EnterCriticalSection(&timerCriticalSection);
+    if (s_hSmartScheduleTimer)
+    {
+      DeleteTimerQueueTimer(s_hSmartScheduleTimerQueue, s_hSmartScheduleTimer, NULL);
+      s_hSmartScheduleTimer=NULL;
+    }
+    LeaveCriticalSection(&timerCriticalSection);
+#else
     struct itimerval timer;
 
     if (!SmartScheduleSignalEnable)
@@ -1212,12 +1264,41 @@ SmartScheduleStopTimer(void)
     timer.it_value.tv_usec = 0;
     (void) setitimer(ITIMER_REAL, &timer, 0);
 #endif
+#endif
 }
 
+#ifdef _MSC_VER
+static VOID CALLBACK SmartScheduleTimer( PVOID lpParameter, BOOLEAN TimerOrWaitFired);
+#endif
+
 void
 SmartScheduleStartTimer(void)
 {
 #ifdef HAVE_SETITIMER
+#ifdef _MSC_VER
+    if (!SmartScheduleSignalEnable)
+        return;
+
+    EnterCriticalSection(&timerCriticalSection);
+    if (s_hSmartScheduleTimer)
+    {
+        LeaveCriticalSection(&timerCriticalSection);
+        return;
+    }
+
+    if (!CreateTimerQueueTimer( &s_hSmartScheduleTimer, s_hSmartScheduleTimerQueue, SmartScheduleTimer, NULL
+                              , SmartScheduleInterval, SmartScheduleInterval, 0))
+    {
+        DWORD Error=GetLastError();
+        ErrorF("Error starting timer, smart scheduling disabled: 0x%x (%d)\n",Error,Error);
+        CloseHandle(s_hSmartScheduleTimer);
+        s_hSmartScheduleTimer=NULL;
+        SmartScheduleSignalEnable = FALSE;
+        LeaveCriticalSection(&timerCriticalSection);
+        return;
+    }
+    LeaveCriticalSection(&timerCriticalSection);
+#else
     struct itimerval timer;
 
     if (!SmartScheduleSignalEnable)
@@ -1228,11 +1309,15 @@ SmartScheduleStartTimer(void)
     timer.it_value.tv_usec = SmartScheduleInterval * 1000;
     setitimer(ITIMER_REAL, &timer, 0);
 #endif
+#endif
 }
-
 #ifdef HAVE_SETITIMER
+#ifdef _MSC_VER
+static VOID CALLBACK SmartScheduleTimer( PVOID lpParameter, BOOLEAN TimerOrWaitFired)
+#else
 static void
 SmartScheduleTimer(int sig)
+#endif
 {
     SmartScheduleTime += SmartScheduleInterval;
 }
@@ -1241,6 +1326,21 @@ static int
 SmartScheduleEnable(void)
 {
     int ret = 0;
+#ifdef _MSC_VER
+    if (!SmartScheduleSignalEnable)
+        return ret;
+    s_hSmartScheduleTimerQueue = CreateTimerQueue();
+    if (!s_hSmartScheduleTimerQueue)
+    {
+        DWORD Error=GetLastError();
+        ErrorF("Error creating timer, smart scheduling disabled: 0x%x (%d)\n",Error,Error);
+        SmartScheduleSignalEnable = FALSE;
+    }
+    else
+    {
+        InitializeCriticalSection(&timerCriticalSection);
+    }
+#else
     struct sigaction act;
 
     if (!SmartScheduleSignalEnable)
@@ -1254,13 +1354,19 @@ SmartScheduleEnable(void)
     sigemptyset(&act.sa_mask);
     sigaddset(&act.sa_mask, SIGALRM);
     ret = sigaction(SIGALRM, &act, 0);
+#endif
     return ret;
 }
 
+#if !defined(WIN32)
 static int
 SmartSchedulePause(void)
 {
     int ret = 0;
+#ifdef _MSC_VER
+    if (!SmartScheduleSignalEnable)
+        return ret;
+#else
     struct sigaction act;
 
     if (!SmartScheduleSignalEnable)
@@ -1271,9 +1377,11 @@ SmartSchedulePause(void)
     act.sa_handler = SIG_IGN;
     sigemptyset(&act.sa_mask);
     ret = sigaction(SIGALRM, &act, 0);
+#endif
     return ret;
 }
 #endif
+#endif
 
 void
 SmartScheduleInit(void)
@@ -1830,7 +1938,7 @@ PrivsElevated(void)
 #endif
 
 #define MAX_ARG_LENGTH          128
-#define MAX_ENV_LENGTH          256
+#define MAX_ENV_LENGTH          2048
 #define MAX_ENV_PATH_LENGTH     2048    /* Limit for *PATH and TERMCAP */
 
 #if USE_ISPRINT
diff --git a/xserver/os/xdmcp.c b/vcxsrv-code/xorg-server/os/xdmcp.c
index 093e300..3688ffb 100644
--- a/xserver/os/xdmcp.c
+++ b/vcxsrv-code/xorg-server/os/xdmcp.c
@@ -490,9 +490,10 @@ XdmcpRegisterConnection(int type, const char *address, int addrlen)
             }
         }
 #endif
-        if (!fromAddr || memcmp(regAddr, fromAddr, regAddrlen) != 0) {
+        if (!fromAddr) {
             return;
         }
+        address = fromAddr; // Register the from address, otherwise some xdmcp managers decline the connection
     }
     if (ConnectionAddresses.length + 1 == 256)
         return;
@@ -607,6 +608,32 @@ XdmcpInit(void)
                                   strlen(defaultDisplayClass));
         AccessUsingXdmcp();
         DisplayNumber = (CARD16) atoi(display);
+        if (ConnectionTypes.length>1 && xdm_from==NULL)
+        {
+          unsigned i=0;
+          char ErrorMessage[1024];
+          sprintf(ErrorMessage,"Multiple ip-addresses detected:\n");
+          for (i=0; i<ConnectionTypes.length; i++)
+          {
+             int AddrLen=ConnectionAddresses.data[i].length;
+             if (AddrLen==4)
+               sprintf(ErrorMessage+strlen(ErrorMessage),"  %d.%d.%d.%d\n",
+                                                         ConnectionAddresses.data[i].data[0],
+                                                         ConnectionAddresses.data[i].data[1],
+                                                         ConnectionAddresses.data[i].data[2],
+                                                         ConnectionAddresses.data[i].data[3]);
+             else
+             {
+               int j;
+               sprintf(ErrorMessage+strlen(ErrorMessage),"  ");
+               for (j=0; j<AddrLen; j++)
+                 sprintf(ErrorMessage+strlen(ErrorMessage),"%02x",ConnectionAddresses.data[i].data[j]);
+               sprintf(ErrorMessage+strlen(ErrorMessage),"\n");
+             }
+          }
+          sprintf(ErrorMessage+strlen(ErrorMessage),"When problems connecting, please specify the ip-address you want to use with -from\n");
+          ErrorF(ErrorMessage);
+        }
         xdmcp_start();
     }
 }
@@ -691,12 +718,94 @@ XdmcpSelectHost(const struct sockaddr *host_sockaddr,
  * selects the first host to respond with willing message.
  */
 
+#ifdef _MSC_VER
+void DisplayXdmcpHostsDialog(void);
+int XdmcpHostAddName(const char *HostName, int HostIndex);
+
+struct hostinfo
+{
+  struct sockaddr *from;
+  int              fromlen;
+  ARRAY8           AuthenticationName;
+};
+static int g_NrHosts;
+static struct hostinfo *g_Hosts;
+
+void XdmcpHostSelected(int HostIdx)
+{
+  int i;
+
+    /* Connect to the selected host */
+  XdmcpSelectHost(g_Hosts[HostIdx].from, g_Hosts[HostIdx].fromlen, &g_Hosts[HostIdx].AuthenticationName);
+
+  for (i=0; i<g_NrHosts; i++)
+  {
+    free(g_Hosts[i].from);
+    free(g_Hosts[i].AuthenticationName.data);
+  }
+  free(g_Hosts);
+  g_Hosts=NULL;
+  g_NrHosts=0;
+}
+#endif
+
  /*ARGSUSED*/ static void
 XdmcpAddHost(const struct sockaddr *from,
              int fromlen,
              ARRAY8Ptr auth_name, ARRAY8Ptr hostname, ARRAY8Ptr status)
 {
+#ifdef _MSC_VER
+  char szHostName[200];
+  int HostIdx;
+
+  if (hostname->length!=0)
+  {
+    memcpy(szHostName,hostname->data,hostname->length);
+    szHostName[hostname->length]=0;
+  }
+  else
+    strcpy(szHostName,"????");
+  strcat(szHostName," - ");
+  switch(from->sa_family)
+  {
+    case AF_INET:
+    {
+      struct sockaddr_in *addr_in = (struct sockaddr_in *)from;
+      inet_ntop(AF_INET, &(addr_in->sin_addr), szHostName+strlen(szHostName), INET_ADDRSTRLEN);
+      break;
+    }
+    case AF_INET6:
+    {
+      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)free;
+      inet_ntop(AF_INET6, &(addr_in6->sin6_addr), szHostName+strlen(szHostName), INET6_ADDRSTRLEN);
+      break;
+    }
+    default:
+      break;
+  }
+
+  DisplayXdmcpHostsDialog();  /* Display the dialog if not already displayed */
+  
+  HostIdx=XdmcpHostAddName(szHostName, g_NrHosts);
+  if (HostIdx==-1)
+  {
+    HostIdx=g_NrHosts;
+    g_NrHosts++;
+    g_Hosts=realloc(g_Hosts,g_NrHosts*sizeof(*g_Hosts));
+    g_Hosts[HostIdx].AuthenticationName.data=NULL;
+    g_Hosts[HostIdx].from=NULL;
+  }
+
+  g_Hosts[HostIdx].fromlen=fromlen;
+  g_Hosts[HostIdx].from=realloc(g_Hosts[HostIdx].from,g_Hosts[HostIdx].fromlen);
+  memcpy(g_Hosts[HostIdx].from,from,fromlen);
+
+  g_Hosts[HostIdx].AuthenticationName.length=auth_name->length;
+  g_Hosts[HostIdx].AuthenticationName.data=realloc(g_Hosts[HostIdx].AuthenticationName.data,auth_name->length);
+  memcpy(g_Hosts[HostIdx].AuthenticationName.data,auth_name->data,auth_name->length);
+#else
     XdmcpSelectHost(from, fromlen, auth_name);
+#endif
 }
 
 /*
@@ -1000,18 +1109,18 @@ send_query_msg(void)
         for (mcl = mcastlist; mcl != NULL; mcl = mcl->next) {
             for (ai = mcl->ai; ai != NULL; ai = ai->ai_next) {
                 if (ai->ai_family == AF_INET) {
-                    unsigned char hopflag = (unsigned char) mcl->hops;
+                    int hopflag = mcl->hops;
 
                     socketfd = xdmcpSocket;
                     setsockopt(socketfd, IPPROTO_IP, IP_MULTICAST_TTL,
-                               &hopflag, sizeof(hopflag));
+                               (char*)&hopflag, sizeof(hopflag));
                 }
                 else if (ai->ai_family == AF_INET6) {
                     int hopflag6 = mcl->hops;
 
                     socketfd = xdmcpSocket6;
                     setsockopt(socketfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
-                               &hopflag6, sizeof(hopflag6));
+                               (char*)&hopflag6, sizeof(hopflag6));
                 }
                 else {
                     continue;
@@ -1318,7 +1427,7 @@ recv_alive_msg(unsigned length)
         return;
     if (XdmcpReadCARD8(&buffer, &SessionRunning) &&
         XdmcpReadCARD32(&buffer, &AliveSessionID)) {
-        if (SessionRunning && AliveSessionID == SessionID) {
+        if (/*SessionRunning && */ AliveSessionID == SessionID) { // For one reason or another, we always receive 0 for SessionRunning????, even if the session is still running
             state = XDM_RUN_SESSION;
             TimerSet(xdmcp_timer, 0, XDM_DEF_DORMANCY * 1000, XdmcpTimerNotify, NULL);
         }
@@ -1359,6 +1468,10 @@ get_addr_by_name(const char *argtype,
     char *pport = portstr;
     int gaierr;
 
+#if defined(WIN32) && defined(TCPCONN)
+    _XSERVTransWSAStartup();
+#endif
+
     memset(&hints, 0, sizeof(hints));
     hints.ai_socktype = socktype;
 
diff --git a/xserver/os/xprintf.c b/vcxsrv-code/xorg-server/os/xprintf.c
index 80caa57..58aad89 100644
--- a/xserver/os/xprintf.c
+++ b/vcxsrv-code/xorg-server/os/xprintf.c
@@ -78,9 +78,11 @@
 #ifdef __va_copy
 #define va_copy __va_copy
 #else
+#ifndef _MSC_VER
 #error "no working va_copy was found"
 #endif
 #endif
+#endif
 
 /**
  * Varargs sprintf that allocates a string buffer the right size for
@@ -99,11 +101,16 @@ Xvasprintf(char **ret, const char *_X_RESTRICT_KYWD format, va_list va)
     return vasprintf(ret, format, va);
 #else
     int size;
+
+#ifdef _MSC_VER
+    size = vsnprintf(NULL, 0, format, va);
+#else
     va_list va2;
 
     va_copy(va2, va);
     size = vsnprintf(NULL, 0, format, va2);
     va_end(va2);
+#endif
 
     *ret = malloc(size + 1);
     if (*ret == NULL)
diff --git a/xserver/os/xstrans.c b/vcxsrv-code/xorg-server/os/xstrans.c
index 2bc79e7..30de32b 100644
--- a/xserver/os/xstrans.c
+++ b/vcxsrv-code/xorg-server/os/xstrans.c
@@ -5,13 +5,21 @@
 #include <X11/Xfuncproto.h>
 
 /* ErrorF is used by xtrans */
-#ifndef HAVE_DIX_CONFIG_H
+/*#ifndef HAVE_DIX_CONFIG_H
 extern _X_EXPORT void
 ErrorF(const char *f, ...)
 _X_ATTRIBUTE_PRINTF(1, 2);
-#endif
+#endif*/
 
 #define TRANS_REOPEN
 #define TRANS_SERVER
 #define XSERV_t
+#ifndef TCPCONN
+#define TCPCONN
+#endif
+#ifdef WIN32
+#undef SO_REUSEADDR
+#define SO_BINDRETRYCOUNT 0  // do not try to bind again when it fails, this will speed up searching for a free listening port
+#endif
+
 #include <X11/Xtrans/transport.c>
diff --git a/xserver/present/present.c b/vcxsrv-code/xorg-server/present/present.c
index 271fe32..e7da9fe 100644
--- a/xserver/present/present.c
+++ b/vcxsrv-code/xorg-server/present/present.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 #include <gcstruct.h>
 
diff --git a/xserver/present/present_event.c b/vcxsrv-code/xorg-server/present/present_event.c
index 435b26b..1b6961d 100644
--- a/xserver/present/present_event.c
+++ b/vcxsrv-code/xorg-server/present/present_event.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 
 static RESTYPE present_event_type;
diff --git a/xserver/present/present_execute.c b/vcxsrv-code/xorg-server/present/present_execute.c
index 68a5878..e10c8b3 100644
--- a/xserver/present/present_execute.c
+++ b/vcxsrv-code/xorg-server/present/present_execute.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 
 /*
diff --git a/xserver/present/present_fake.c b/vcxsrv-code/xorg-server/present/present_fake.c
index f4a3bd8..19f43e6 100644
--- a/xserver/present/present_fake.c
+++ b/vcxsrv-code/xorg-server/present/present_fake.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 #include "list.h"
 
diff --git a/xserver/present/present_fence.c b/vcxsrv-code/xorg-server/present/present_fence.c
index aca04a5..ee09b4e 100644
--- a/xserver/present/present_fence.c
+++ b/vcxsrv-code/xorg-server/present/present_fence.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 #include <gcstruct.h>
 #include <misync.h>
diff --git a/xserver/present/present_notify.c b/vcxsrv-code/xorg-server/present/present_notify.c
index 4459549..fe8a571 100644
--- a/xserver/present/present_notify.c
+++ b/vcxsrv-code/xorg-server/present/present_notify.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 
 /*
diff --git a/xserver/present/present_request.c b/vcxsrv-code/xorg-server/present/present_request.c
index f3e5679..3697391 100644
--- a/xserver/present/present_request.c
+++ b/vcxsrv-code/xorg-server/present/present_request.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 #include "randrstr.h"
 #include <protocol-versions.h>
diff --git a/xserver/present/present_scmd.c b/vcxsrv-code/xorg-server/present/present_scmd.c
index da836ea..92f7b50 100644
--- a/xserver/present/present_scmd.c
+++ b/vcxsrv-code/xorg-server/present/present_scmd.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 #include <misync.h>
 #include <misyncstr.h>
diff --git a/xserver/present/present_screen.c b/vcxsrv-code/xorg-server/present/present_screen.c
index 15684ed..beee6b3 100644
--- a/xserver/present/present_screen.c
+++ b/vcxsrv-code/xorg-server/present/present_screen.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 
 int present_request;
diff --git a/xserver/present/present_vblank.c b/vcxsrv-code/xorg-server/present/present_vblank.c
index a9f17d4..2e84170 100644
--- a/xserver/present/present_vblank.c
+++ b/vcxsrv-code/xorg-server/present/present_vblank.c
@@ -20,6 +20,10 @@
  * OF THIS SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include "present_priv.h"
 
 void
diff --git a/xserver/randr/rrlease.c b/vcxsrv-code/xorg-server/randr/rrlease.c
index cb366e7..ad98622 100644
--- a/xserver/randr/rrlease.c
+++ b/vcxsrv-code/xorg-server/randr/rrlease.c
@@ -321,11 +321,13 @@ leaseReturned:
         return BadAlloc;
     }
 
+#ifdef XTRANS_SEND_FDS
     if (WriteFdToClient(client, fd, TRUE) < 0) {
         RRTerminateLease(lease);
         close(fd);
         return BadAlloc;
     }
+#endif
 
     RRLeaseChangeState(lease, RRLeaseCreating, RRLeaseRunning);
 
diff --git a/xserver/record/record.c b/vcxsrv-code/xorg-server/record/record.c
index e123867..9140285 100644
--- a/xserver/record/record.c
+++ b/vcxsrv-code/xorg-server/record/record.c
@@ -1817,15 +1817,14 @@ static int
 ProcRecordQueryVersion(ClientPtr client)
 {
     /* REQUEST(xRecordQueryVersionReq); */
-    xRecordQueryVersionReply rep = {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .majorVersion = SERVER_RECORD_MAJOR_VERSION,
-        .minorVersion = SERVER_RECORD_MINOR_VERSION
-    };
+    xRecordQueryVersionReply rep;
 
     REQUEST_SIZE_MATCH(xRecordQueryVersionReq);
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.majorVersion = SERVER_RECORD_MAJOR_VERSION;
+    rep.minorVersion = SERVER_RECORD_MINOR_VERSION;
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swaps(&rep.majorVersion);
@@ -2230,14 +2229,14 @@ ProcRecordGetContext(ClientPtr client)
 
     /* write the reply header */
 
-    rep = (xRecordGetContextReply) {
-        .type = X_Reply,
-        .enabled = pContext->pRecordingClient != NULL,
-        .sequenceNumber = client->sequence,
-        .length = length,
-        .elementHeader = pContext->elemHeaders,
-        .nClients = nClients
-    };
+
+    rep.type = X_Reply;
+    rep.enabled = pContext->pRecordingClient != NULL;
+    rep.sequenceNumber = client->sequence;
+    rep.length = length;
+    rep.elementHeader = pContext->elemHeaders;
+    rep.nClients = nClients;
+
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.length);
@@ -2733,7 +2732,7 @@ RecordAClientStateChange(CallbackListPtr *pcbl, void *nulldata,
             break;
         ppAllContextsCopy = xallocarray(numContextsCopy,
                                         sizeof(RecordContextPtr));
-        assert(ppAllContextsCopy);
+        assert(ppAllContextsCopy!=NULL);
         memcpy(ppAllContextsCopy, ppAllContexts,
                numContextsCopy * sizeof(RecordContextPtr));
 
diff --git a/xserver/record/set.c b/vcxsrv-code/xorg-server/record/set.c
index e0db385..1809188 100644
--- a/xserver/record/set.c
+++ b/vcxsrv-code/xorg-server/record/set.c
@@ -152,7 +152,7 @@ static RecordSetIteratePtr
 BitVectorIterateSet(RecordSetPtr pSet, RecordSetIteratePtr pIter,
                     RecordSetInterval * pInterval)
 {
-    int iterbit = (int) (long) pIter;
+    int iterbit = (int) (intptr_t) pIter;
     int b;
 
     b = BitVectorFindBit(pSet, iterbit, TRUE);
@@ -162,7 +162,7 @@ BitVectorIterateSet(RecordSetPtr pSet, RecordSetIteratePtr pIter,
 
     b = BitVectorFindBit(pSet, b, FALSE);
     pInterval->last = (b < 0) ? ((BitVectorSetPtr) pSet)->maxMember : b - 1;
-    return (RecordSetIteratePtr) (long) (pInterval->last + 1);
+    return (RecordSetIteratePtr) (uintptr_t) (pInterval->last + 1);
 }
 
 static RecordSetOperations BitVectorSetOperations = {
@@ -416,7 +416,7 @@ RecordCreateSet(RecordSetInterval * pIntervals, int nIntervals, void *pMem,
     size = _RecordSetMemoryRequirements(pIntervals, nIntervals, &alignment,
                                         &pCreateSet);
     if (pMem) {
-        if (((long) pMem & (alignment - 1)) || memsize < size)
+        if (((long)(uintptr_t) pMem & (alignment - 1)) || memsize < size)
             return NULL;
     }
     return (*pCreateSet) (pIntervals, nIntervals, pMem, size);
diff --git a/xserver/render/mipict.c b/vcxsrv-code/xorg-server/render/mipict.c
index 7fb0343..0b9f7bd 100644
--- a/xserver/render/mipict.c
+++ b/vcxsrv-code/xorg-server/render/mipict.c
@@ -226,7 +226,7 @@ miChangePictureFilter(PicturePtr pPicture,
 
 #define BOUND(v)	(INT16) ((v) < MINSHORT ? MINSHORT : (v) > MAXSHORT ? MAXSHORT : (v))
 
-static inline pixman_bool_t
+static __inline pixman_bool_t
 miClipPictureReg(pixman_region16_t * pRegion,
                  pixman_region16_t * pClip, int dx, int dy)
 {
diff --git a/xserver/render/render.c b/vcxsrv-code/xorg-server/render/render.c
index 456f156..8a6f43e 100644
--- a/xserver/render/render.c
+++ b/vcxsrv-code/xorg-server/render/render.c
@@ -255,11 +255,7 @@ static int
 ProcRenderQueryVersion(ClientPtr client)
 {
     RenderClientPtr pRenderClient = GetRenderClient(client);
-    xRenderQueryVersionReply rep = {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    xRenderQueryVersionReply rep;
 
     REQUEST(xRenderQueryVersionReq);
 
@@ -268,6 +264,10 @@ ProcRenderQueryVersion(ClientPtr client)
     pRenderClient->major_version = stuff->majorVersion;
     pRenderClient->minor_version = stuff->minorVersion;
 
+    memset(&rep, 0, sizeof(xRenderQueryVersionReply));
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
     if ((stuff->majorVersion * 1000 + stuff->minorVersion) <
         (SERVER_RENDER_MAJOR_VERSION * 1000 + SERVER_RENDER_MINOR_VERSION)) {
         rep.majorVersion = stuff->majorVersion;
diff --git a/xserver/xfixes/cursor.c b/vcxsrv-code/xorg-server/xfixes/cursor.c
index c5d4554..89a4460 100644
--- a/xserver/xfixes/cursor.c
+++ b/vcxsrv-code/xorg-server/xfixes/cursor.c
@@ -44,6 +44,8 @@
 
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
+#else
+#define XFIXES
 #endif
 
 #include "xfixesint.h"
@@ -174,14 +176,13 @@ CursorDisplayCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
         UpdateCurrentTimeIf();
         for (e = cursorEvents; e; e = e->next) {
             if ((e->eventMask & XFixesDisplayCursorNotifyMask)) {
-                xXFixesCursorNotifyEvent ev = {
-                    .type = XFixesEventBase + XFixesCursorNotify,
-                    .subtype = XFixesDisplayCursorNotify,
-                    .window = e->pWindow->drawable.id,
-                    .cursorSerial = pCursor ? pCursor->serialNumber : 0,
-                    .timestamp = currentTime.milliseconds,
-                    .name = pCursor ? pCursor->name : None
-                };
+                xXFixesCursorNotifyEvent ev;
+                ev.type = XFixesEventBase + XFixesCursorNotify;
+                ev.subtype = XFixesDisplayCursorNotify;
+                ev.window = e->pWindow->drawable.id;
+                ev.cursorSerial = pCursor ? pCursor->serialNumber : 0;
+                ev.timestamp = currentTime.milliseconds;
+                ev.name = pCursor ? pCursor->name : None;
                 WriteEventsToClient(e->pClient, 1, (xEvent *) &ev);
             }
         }
@@ -473,13 +474,13 @@ ProcXFixesGetCursorName(ClientPtr client)
         str = "";
     len = strlen(str);
 
-    reply = (xXFixesGetCursorNameReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(len),
-        .atom = pCursor->name,
-        .nbytes = len
-    };
+
+    reply.type = X_Reply;
+    reply.sequenceNumber = client->sequence;
+    reply.length = bytes_to_int32(len);
+    reply.atom = pCursor->name;
+    reply.nbytes = len;
+
     if (client->swapped) {
         swaps(&reply.sequenceNumber);
         swapl(&reply.length);
diff --git a/xserver/xfixes/select.c b/vcxsrv-code/xorg-server/xfixes/select.c
index 19b2c73..6c4c373 100644
--- a/xserver/xfixes/select.c
+++ b/vcxsrv-code/xorg-server/xfixes/select.c
@@ -78,16 +78,15 @@ XFixesSelectionCallback(CallbackListPtr *callbacks, void *data, void *args)
     UpdateCurrentTimeIf();
     for (e = selectionEvents; e; e = e->next) {
         if (e->selection == selection->selection && (e->eventMask & eventMask)) {
-            xXFixesSelectionNotifyEvent ev = {
-                .type = XFixesEventBase + XFixesSelectionNotify,
-                .subtype = subtype,
-                .window = e->pWindow->drawable.id,
-                .owner = (subtype == XFixesSetSelectionOwnerNotify) ?
-                            selection->window : 0,
-                .selection = e->selection,
-                .timestamp = currentTime.milliseconds,
-                .selectionTimestamp = selection->lastTimeChanged.milliseconds
-            };
+            xXFixesSelectionNotifyEvent ev;
+            ev.type = XFixesEventBase + XFixesSelectionNotify;
+            ev.subtype = subtype;
+            ev.window = e->pWindow->drawable.id;
+            ev.owner = (subtype == XFixesSetSelectionOwnerNotify) ?
+                            selection->window : 0;
+            ev.selection = e->selection;
+            ev.timestamp = currentTime.milliseconds;
+            ev.selectionTimestamp = selection->lastTimeChanged.milliseconds;
             WriteEventsToClient(e->pClient, 1, (xEvent *) &ev);
         }
     }
diff --git a/xserver/xfixes/xfixes.c b/vcxsrv-code/xorg-server/xfixes/xfixes.c
index ecb6f29..9f45017 100644
--- a/xserver/xfixes/xfixes.c
+++ b/vcxsrv-code/xorg-server/xfixes/xfixes.c
@@ -63,15 +63,15 @@ ProcXFixesQueryVersion(ClientPtr client)
 {
     int major, minor;
     XFixesClientPtr pXFixesClient = GetXFixesClient(client);
-    xXFixesQueryVersionReply rep = {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+    xXFixesQueryVersionReply rep;
 
     REQUEST(xXFixesQueryVersionReq);
 
     REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);
+    memset(&rep, 0, sizeof(xXFixesQueryVersionReply));
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
 
     if (version_compare(stuff->majorVersion, stuff->minorVersion,
                         SERVER_XFIXES_MAJOR_VERSION,
diff --git a/xserver/xkb/XKBMisc.c b/vcxsrv-code/xorg-server/xkb/XKBMisc.c
index 2bad695..ddab96c 100644
--- a/xserver/xkb/XKBMisc.c
+++ b/vcxsrv-code/xorg-server/xkb/XKBMisc.c
@@ -328,7 +328,7 @@ _XkbFindMatchingInterp(XkbDescPtr xkb,
 static void
 _XkbAddKeyChange(KeyCode *pFirst, unsigned char *pNum, KeyCode newKey)
 {
-    KeyCode last;
+    int last;
 
     last = (*pFirst) + (*pNum);
     if (newKey < *pFirst) {
diff --git a/xserver/xkb/ddxPrivate.c b/vcxsrv-code/xorg-server/xkb/ddxPrivate.c
index fcde3a1..c4d21cb 100644
--- a/xserver/xkb/ddxPrivate.c
+++ b/vcxsrv-code/xorg-server/xkb/ddxPrivate.c
@@ -3,12 +3,44 @@
 #include <dix-config.h>
 #endif
 
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdio.h>
 #include <X11/X.h>
 #include "windowstr.h"
+#define XKBSRV_NEED_FILE_FUNCS
 #include <xkbsrv.h>
 
+#include "dixgrabs.h"
+#include "os.h"
+#include "xf86.h"
+
 int
 XkbDDXPrivate(DeviceIntPtr dev, KeyCode key, XkbAction *act)
 {
+    XkbAnyAction *xf86act = &(act->any);
+    char msgbuf[XkbAnyActionDataSize+1];
+
+    if (xf86act->type == XkbSA_XFree86Private) {
+        memcpy(msgbuf, xf86act->data, XkbAnyActionDataSize);
+        msgbuf[XkbAnyActionDataSize]= '\0';
+        if (strcasecmp(msgbuf, "prgrbs")==0) {
+            DeviceIntPtr tmp;
+            ErrorF("Printing all currently active device grabs:\n");
+            for (tmp = inputInfo.devices; tmp; tmp = tmp->next)
+                if (tmp->deviceGrab.grab)
+                    PrintDeviceGrabInfo(tmp);
+            ErrorF("End list of active device grabs\n");
+        }
+        else if (strcasecmp(msgbuf, "ungrab")==0)
+            UngrabAllDevices(FALSE);
+        else if (strcasecmp(msgbuf, "clsgrb")==0)
+            UngrabAllDevices(TRUE);
+        else if (strcasecmp(msgbuf, "prwins")==0)
+            PrintWindowTree();
+    }
+
     return 0;
 }
diff --git a/xserver/xkb/xkb.c b/vcxsrv-code/xorg-server/xkb/xkb.c
index bfc21de..18e2827 100644
--- a/xserver/xkb/xkb.c
+++ b/vcxsrv-code/xorg-server/xkb/xkb.c
@@ -195,14 +195,13 @@ ProcXkbUseExtension(ClientPtr client)
              stuff->wantedMinor, SERVER_XKB_MAJOR_VERSION,
              SERVER_XKB_MINOR_VERSION);
     }
-    rep = (xkbUseExtensionReply) {
-        .type = X_Reply,
-        .supported = supported,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .serverMajor = SERVER_XKB_MAJOR_VERSION,
-        .serverMinor = SERVER_XKB_MINOR_VERSION
-    };
+    memset(&rep, 0, sizeof(xkbUseExtensionReply));
+    rep.type = X_Reply;
+    rep.supported = supported;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.serverMajor = SERVER_XKB_MAJOR_VERSION;
+    rep.serverMinor = SERVER_XKB_MINOR_VERSION;
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swaps(&rep.serverMajor);
@@ -592,22 +591,21 @@ ProcXkbGetState(ClientPtr client)
     CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
 
     xkb = &dev->key->xkbInfo->state;
-    rep = (xkbGetStateReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .mods = XkbStateFieldFromRec(xkb) & 0xff,
-        .baseMods = xkb->base_mods,
-        .latchedMods = xkb->latched_mods,
-        .lockedMods = xkb->locked_mods,
-        .group = xkb->group,
-        .lockedGroup = xkb->locked_group,
-        .baseGroup = xkb->base_group,
-        .latchedGroup = xkb->latched_group,
-        .compatState = xkb->compat_state,
-        .ptrBtnState = xkb->ptr_buttons
-    };
+    memset(&rep, 0, sizeof(xkbGetStateReply));
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.mods = XkbStateFieldFromRec(xkb) & 0xff;
+    rep.baseMods = xkb->base_mods;
+    rep.latchedMods = xkb->latched_mods;
+    rep.lockedMods = xkb->locked_mods;
+    rep.group = xkb->group;
+    rep.lockedGroup = xkb->locked_group;
+    rep.baseGroup = xkb->base_group;
+    rep.latchedGroup = xkb->latched_group;
+    rep.compatState = xkb->compat_state;
+    rep.ptrBtnState = xkb->ptr_buttons;
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swaps(&rep.ptrBtnState);
@@ -704,38 +702,38 @@ ProcXkbGetControls(ClientPtr client)
     CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);
 
     xkb = dev->key->xkbInfo->desc->ctrls;
-    rep = (xkbGetControlsReply) {
-        .type = X_Reply,
-        .deviceID = ((DeviceIntPtr) dev)->id,
-        .sequenceNumber = client->sequence,
-        .length = bytes_to_int32(SIZEOF(xkbGetControlsReply) -
-                                 SIZEOF(xGenericReply)),
-        .mkDfltBtn = xkb->mk_dflt_btn,
-        .numGroups = xkb->num_groups,
-        .groupsWrap = xkb->groups_wrap,
-        .internalMods = xkb->internal.mask,
-        .ignoreLockMods = xkb->ignore_lock.mask,
-        .internalRealMods = xkb->internal.real_mods,
-        .ignoreLockRealMods = xkb->ignore_lock.real_mods,
-        .internalVMods = xkb->internal.vmods,
-        .ignoreLockVMods = xkb->ignore_lock.vmods,
-        .repeatDelay = xkb->repeat_delay,
-        .repeatInterval = xkb->repeat_interval,
-        .slowKeysDelay = xkb->slow_keys_delay,
-        .debounceDelay = xkb->debounce_delay,
-        .mkDelay = xkb->mk_delay,
-        .mkInterval = xkb->mk_interval,
-        .mkTimeToMax = xkb->mk_time_to_max,
-        .mkMaxSpeed = xkb->mk_max_speed,
-        .mkCurve = xkb->mk_curve,
-        .axOptions = xkb->ax_options,
-        .axTimeout = xkb->ax_timeout,
-        .axtOptsMask = xkb->axt_opts_mask,
-        .axtOptsValues = xkb->axt_opts_values,
-        .axtCtrlsMask = xkb->axt_ctrls_mask,
-        .axtCtrlsValues = xkb->axt_ctrls_values,
-        .enabledCtrls = xkb->enabled_ctrls,
-    };
+    
+    rep.type = X_Reply;
+    rep.deviceID = ((DeviceIntPtr) dev)->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = bytes_to_int32(SIZEOF(xkbGetControlsReply) -
+                                SIZEOF(xGenericReply));
+    rep.mkDfltBtn = xkb->mk_dflt_btn;
+    rep.numGroups = xkb->num_groups;
+    rep.groupsWrap = xkb->groups_wrap;
+    rep.internalMods = xkb->internal.mask;
+    rep.ignoreLockMods = xkb->ignore_lock.mask;
+    rep.internalRealMods = xkb->internal.real_mods;
+    rep.ignoreLockRealMods = xkb->ignore_lock.real_mods;
+    rep.internalVMods = xkb->internal.vmods;
+    rep.ignoreLockVMods = xkb->ignore_lock.vmods;
+    rep.repeatDelay = xkb->repeat_delay;
+    rep.repeatInterval = xkb->repeat_interval;
+    rep.slowKeysDelay = xkb->slow_keys_delay;
+    rep.debounceDelay = xkb->debounce_delay;
+    rep.mkDelay = xkb->mk_delay;
+    rep.mkInterval = xkb->mk_interval;
+    rep.mkTimeToMax = xkb->mk_time_to_max;
+    rep.mkMaxSpeed = xkb->mk_max_speed;
+    rep.mkCurve = xkb->mk_curve;
+    rep.axOptions = xkb->ax_options;
+    rep.axTimeout = xkb->ax_timeout;
+    rep.axtOptsMask = xkb->axt_opts_mask;
+    rep.axtOptsValues = xkb->axt_opts_values;
+    rep.axtCtrlsMask = xkb->axt_ctrls_mask;
+    rep.axtCtrlsValues = xkb->axt_ctrls_values;
+    rep.enabledCtrls = xkb->enabled_ctrls;
+    
     memcpy(rep.perKeyRepeat, xkb->per_key_repeat, XkbPerKeyBitArraySize);
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
@@ -1477,16 +1475,14 @@ ProcXkbGetMap(ClientPtr client)
     CHK_MASK_LEGAL(0x03, stuff->partial, XkbAllMapComponentsMask);
 
     xkb = dev->key->xkbInfo->desc;
-    rep = (xkbGetMapReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2,
-        .present = stuff->partial | stuff->full,
-        .minKeyCode = xkb->min_key_code,
-        .maxKeyCode = xkb->max_key_code
-    };
-
+    memset(&rep, 0, sizeof(xkbGetMapReply));
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = (SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2;
+    rep.present = stuff->partial | stuff->full;
+    rep.minKeyCode = xkb->min_key_code;
+    rep.maxKeyCode = xkb->max_key_code;
     if (stuff->full & XkbKeyTypesMask) {
         rep.firstType = 0;
         rep.nTypes = xkb->map->num_types;
@@ -2917,14 +2913,14 @@ ProcXkbGetCompatMap(ClientPtr client)
     xkb = dev->key->xkbInfo->desc;
     compat = xkb->compat;
 
-    rep = (xkbGetCompatMapReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .deviceID = dev->id,
-        .firstSI = stuff->firstSI,
-        .nSI = stuff->nSI
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.deviceID = dev->id;
+    rep.firstSI = stuff->firstSI;
+    rep.nSI = stuff->nSI;
+
     if (stuff->getAllSI) {
         rep.firstSI = 0;
         rep.nSI = compat->num_si;
@@ -3181,13 +3177,12 @@ ProcXkbGetIndicatorState(ClientPtr client)
     if (!sli)
         return BadAlloc;
 
-    rep = (xkbGetIndicatorStateReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .state = sli->effectiveState
-    };
+
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.state = sli->effectiveState;
 
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
@@ -3296,13 +3291,13 @@ ProcXkbGetIndicatorMap(ClientPtr client)
     xkb = dev->key->xkbInfo->desc;
     leds = xkb->indicators;
 
-    rep = (xkbGetIndicatorMapReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .which = stuff->which
-    };
+
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.which = stuff->which;
+    
     XkbComputeGetIndicatorMapReplySize(leds, &rep);
     return XkbSendIndicatorMap(client, leds, &rep);
 }
@@ -3453,13 +3448,13 @@ ProcXkbGetNamedIndicator(ClientPtr client)
         }
     }
 
-    rep = (xkbGetNamedIndicatorReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .deviceID = dev->id,
-        .indicator = stuff->indicator
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.deviceID = dev->id;
+    rep.indicator = stuff->indicator;
+    
     if (map != NULL) {
         rep.found = TRUE;
         rep.on = ((sli->effectiveState & (1 << i)) != 0);
@@ -4035,18 +4030,18 @@ ProcXkbGetNames(ClientPtr client)
     CHK_MASK_LEGAL(0x01, stuff->which, XkbAllNamesMask);
 
     xkb = dev->key->xkbInfo->desc;
-    rep = (xkbGetNamesReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .which = stuff->which,
-        .nTypes = xkb->map->num_types,
-        .firstKey = xkb->min_key_code,
-        .nKeys = XkbNumKeys(xkb),
-        .nKeyAliases = xkb->names ? xkb->names->num_key_aliases : 0,
-        .nRadioGroups = xkb->names ? xkb->names->num_rg : 0
-    };
+    memset(&rep, 0, sizeof(xkbGetNamesReply));
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.which = stuff->which;
+    rep.nTypes = xkb->map->num_types;
+    rep.firstKey = xkb->min_key_code;
+    rep.nKeys = XkbNumKeys(xkb);
+    rep.nKeyAliases = xkb->names ? xkb->names->num_key_aliases : 0;
+    rep.nRadioGroups = xkb->names ? xkb->names->num_rg : 0;
+    
     XkbComputeGetNamesReplySize(xkb, &rep);
     return XkbSendNames(client, xkb, &rep);
 }
@@ -5116,12 +5111,12 @@ ProcXkbGetGeometry(ClientPtr client)
     CHK_ATOM_OR_NONE(stuff->name);
 
     geom = XkbLookupNamedGeometry(dev, stuff->name, &shouldFree);
-    rep = (xkbGetGeometryReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0
-    };
+
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+
     status = XkbComputeGetGeometryReplySize(geom, &rep, stuff->name);
     if (status != Success)
         return status;
@@ -5722,15 +5717,15 @@ ProcXkbPerClientFlags(ClientPtr client)
         }
     }
 
-    rep = (xkbPerClientFlagsReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .supported = XkbPCF_AllFlagsMask,
-        .value = client->xkbClientFlags & XkbPCF_AllFlagsMask,
-        .autoCtrls = interest ? interest->autoCtrls : 0,
-        .autoCtrlValues =  interest ? interest->autoCtrlValues : 0,
-    };
+    memset(&rep, 0, sizeof(xkbPerClientFlagsReply));
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.supported = XkbPCF_AllFlagsMask;
+    rep.value = client->xkbClientFlags & XkbPCF_AllFlagsMask;
+    rep.autoCtrls = interest ? interest->autoCtrls : 0;
+    rep.autoCtrlValues =  interest ? interest->autoCtrlValues : 0;
+
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.supported);
@@ -5837,19 +5832,19 @@ ProcXkbListComponents(ClientPtr client)
     }
     if ((XkbPaddedSize(len) / 4) != stuff->length)
         return BadLength;
-    rep = (xkbListComponentsReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .nKeymaps = 0,
-        .nKeycodes = 0,
-        .nTypes = 0,
-        .nCompatMaps = 0,
-        .nSymbols = 0,
-        .nGeometries = 0,
-        .extra = 0
-    };
+    memset(&rep, 0, sizeof(xkbListComponentsReply));
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.nKeymaps = 0;
+    rep.nKeycodes = 0;
+    rep.nTypes = 0;
+    rep.nCompatMaps = 0;
+    rep.nSymbols = 0;
+    rep.nGeometries = 0;
+    rep.extra = 0;
+
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.length);
@@ -5897,6 +5892,8 @@ ProcXkbGetKbdByName(ClientPtr client)
     if (!(client->xkbClientFlags & _XkbClientInitialized))
         return BadAccess;
 
+    memset(&mrep,0,sizeof(mrep));  //MH
+    
     CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);
     master = GetMaster(dev, MASTER_KEYBOARD);
 
@@ -6434,25 +6431,24 @@ ProcXkbGetDeviceInfo(ClientPtr client)
         wanted &= ~XkbXI_IndicatorsMask;
 
     nameLen = XkbSizeCountedString(dev->name);
-    rep = (xkbGetDeviceInfoReply) {
-        .type = X_Reply,
-        .deviceID = dev->id,
-        .sequenceNumber = client->sequence,
-        .length = nameLen / 4,
-        .present = wanted,
-        .supported = XkbXI_AllDeviceFeaturesMask,
-        .unsupported = 0,
-        .nDeviceLedFBs = 0,
-        .firstBtnWanted = 0,
-        .nBtnsWanted = 0,
-        .firstBtnRtrn = 0,
-        .nBtnsRtrn = 0,
-        .totalBtns = dev->button ? dev->button->numButtons : 0,
-        .hasOwnState = (dev->key && dev->key->xkbInfo),
-        .dfltKbdFB = dev->kbdfeed ? dev->kbdfeed->ctrl.id : XkbXINone,
-        .dfltLedFB = dev->leds ? dev->leds->ctrl.id : XkbXINone,
-        .devType = dev->xinput_type
-    };
+    memset((char *) &rep, 0, SIZEOF(xkbGetDeviceInfoReply));
+    rep.type = X_Reply;
+    rep.deviceID = dev->id;
+    rep.sequenceNumber = client->sequence;
+    rep.length = nameLen / 4;
+    rep.present = wanted;
+    rep.supported = XkbXI_AllDeviceFeaturesMask;
+    rep.unsupported = 0;
+    rep.nDeviceLedFBs = 0;
+    rep.firstBtnWanted = 0;
+    rep.nBtnsWanted = 0;
+    rep.firstBtnRtrn = 0;
+    rep.nBtnsRtrn = 0;
+    rep.totalBtns = dev->button ? dev->button->numButtons : 0;
+    rep.hasOwnState = (dev->key && dev->key->xkbInfo);
+    rep.dfltKbdFB = dev->kbdfeed ? dev->kbdfeed->ctrl.id : XkbXINone;
+    rep.dfltLedFB = dev->leds ? dev->leds->ctrl.id : XkbXINone;
+    rep.devType = dev->xinput_type;
 
     ledClass = stuff->ledClass;
     ledID = stuff->ledID;
@@ -6938,15 +6934,15 @@ ProcXkbSetDebuggingFlags(ClientPtr client)
     xkbDebugFlags = newFlags;
     xkbDebugCtrls = newCtrls;
 
-    rep = (xkbSetDebuggingFlagsReply) {
-        .type = X_Reply,
-        .sequenceNumber = client->sequence,
-        .length = 0,
-        .currentFlags = newFlags,
-        .currentCtrls = newCtrls,
-        .supportedFlags = ~0,
-        .supportedCtrls = ~0
-    };
+
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.currentFlags = newFlags;
+    rep.currentCtrls = newCtrls;
+    rep.supportedFlags = ~0;
+    rep.supportedCtrls = ~0;
+
     if (client->swapped) {
         swaps(&rep.sequenceNumber);
         swapl(&rep.currentFlags);
diff --git a/xserver/xkb/xkbActions.c b/vcxsrv-code/xorg-server/xkb/xkbActions.c
index db29091..55c78fb 100644
--- a/xserver/xkb/xkbActions.c
+++ b/vcxsrv-code/xorg-server/xkb/xkbActions.c
@@ -1588,6 +1588,7 @@ XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags, int x, int y)
 {
     ValuatorMask mask;
     int gpe_flags = 0;
+    int                 Point[]={x, y};
 
     /* ignore attached SDs */
     if (!IsMaster(dev) && !IsFloating(dev))
@@ -1598,8 +1599,8 @@ XkbFakePointerMotion(DeviceIntPtr dev, unsigned flags, int x, int y)
     else
         gpe_flags = POINTER_RELATIVE;
 
-    valuator_mask_set_range(&mask, 0, 2, (int[]) {
-                            x, y});
+    valuator_mask_set_range(&mask, 0, 2,
+                            Point);
 
     InjectPointerKeyEvents(dev, MotionNotify, 0, gpe_flags, &mask);
 }
diff --git a/xserver/xkb/xkbEvents.c b/vcxsrv-code/xorg-server/xkb/xkbEvents.c
index 0bbd661..5175400 100644
--- a/xserver/xkb/xkbEvents.c
+++ b/vcxsrv-code/xorg-server/xkb/xkbEvents.c
@@ -99,7 +99,8 @@ XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
             continue;
 
         if (keymap_changed) {
-            xEvent core_mn = { .u.u.type = MappingNotify };
+            xEvent core_mn;
+            core_mn.u.u.type = MappingNotify;
             core_mn.u.mappingNotify.request = MappingKeyboard;
 
             /* Clip the keycode range to what the client knows about, so it
@@ -117,11 +118,10 @@ XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
             WriteEventsToClient(clients[i], 1, &core_mn);
         }
         if (modmap_changed) {
-            xEvent core_mn = {
-                .u.mappingNotify.request = MappingModifier,
-                .u.mappingNotify.firstKeyCode = 0,
-                .u.mappingNotify.count = 0
-            };
+            xEvent core_mn;
+            core_mn.u.mappingNotify.request = MappingModifier;
+            core_mn.u.mappingNotify.firstKeyCode = 0;
+            core_mn.u.mappingNotify.count = 0;
             core_mn.u.u.type = MappingNotify;
             WriteEventsToClient(clients[i], 1, &core_mn);
         }
@@ -131,26 +131,24 @@ XkbSendLegacyMapNotify(DeviceIntPtr kbd, CARD16 xkb_event, CARD16 changed,
      * here? Clients might be upset, but that seems better than the
      * alternative of stale keymaps. -ds */
     if (keymap_changed) {
-        deviceMappingNotify xi_mn = {
-            .type = DeviceMappingNotify,
-            .deviceid = kbd->id,
-            .request = MappingKeyboard,
-            .firstKeyCode = first_key,
-            .count = num_keys,
-            .time = time
-        };
+        deviceMappingNotify xi_mn;
+        xi_mn.type = DeviceMappingNotify;
+        xi_mn.deviceid = kbd->id;
+        xi_mn.request = MappingKeyboard;
+        xi_mn.firstKeyCode = first_key;
+        xi_mn.count = num_keys;
+        xi_mn.time = time;
         SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                               1);
     }
     if (modmap_changed) {
-        deviceMappingNotify xi_mn = {
-            .type = DeviceMappingNotify,
-            .deviceid = kbd->id,
-            .request = MappingModifier,
-            .firstKeyCode = 0,
-            .count = 0,
-            .time = time
-        };
+        deviceMappingNotify xi_mn;
+        xi_mn.type = DeviceMappingNotify;
+        xi_mn.deviceid = kbd->id;
+        xi_mn.request = MappingModifier;
+        xi_mn.firstKeyCode = 0;
+        xi_mn.count = 0;
+        xi_mn.time = time;
         SendEventToAllWindows(kbd, DeviceMappingNotifyMask, (xEvent *) &xi_mn,
                               1);
     }
diff --git a/xserver/xkb/xkbInit.c b/vcxsrv-code/xorg-server/xkb/xkbInit.c
index 4108e1b..4c1470e 100644
--- a/xserver/xkb/xkbInit.c
+++ b/vcxsrv-code/xorg-server/xkb/xkbInit.c
@@ -806,6 +806,7 @@ XkbProcessArguments(int argc, char *argv[], int i)
         }
         return j;
     }
+#ifndef _MSC_VER
     if ((strcmp(argv[i], "-ardelay") == 0) || (strcmp(argv[i], "-ar1") == 0)) { /* -ardelay int */
         if (++i >= argc)
             UseMsg();
@@ -820,6 +821,7 @@ XkbProcessArguments(int argc, char *argv[], int i)
             XkbDfltRepeatInterval = (long) atoi(argv[i]);
         return 2;
     }
+#endif
     return 0;
 }
 
@@ -829,6 +831,8 @@ XkbUseMsg(void)
     ErrorF
         ("[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask] ] ] ]\n");
     ErrorF("                       enable/disable accessx key sequences\n");
+#ifndef _MSC_VER
     ErrorF("-ardelay               set XKB autorepeat delay\n");
     ErrorF("-arinterval            set XKB autorepeat interval\n");
+#endif
 }
