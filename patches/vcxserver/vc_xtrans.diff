diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtrans.c b/vcxsrv-code/X11/xtrans/Xtrans.c
index e1e9013..84a28ec 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtrans.c
+++ b/vcxsrv-code/X11/xtrans/Xtrans.c
@@ -48,12 +48,17 @@ from The Open Group.
  */
 
 #include <ctype.h>
+#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #ifdef HAVE_SYSTEMD_DAEMON
 #include <systemd/sd-daemon.h>
 #endif
 
+#ifdef _MSC_VER
+#include <X11\Xwinsock.h>
+#endif
+
 /*
  * The transport table contains a definition for every transport (protocol)
  * family. All operations that can be made on the transport go through this
@@ -75,18 +80,19 @@ from The Open Group.
 #define TRANS_SOCKET_TCP_INDEX		7
 #define TRANS_DNET_INDEX		8
 #define TRANS_LOCAL_LOCAL_INDEX		9
-#define TRANS_LOCAL_PTS_INDEX		10
+/* 10 used to be PTS, but that's gone. */
 #define TRANS_LOCAL_NAMED_INDEX		11
 /* 12 used to be ISC, but that's gone. */
-#define TRANS_LOCAL_SCO_INDEX		13
+/* 13 used to be SCO, but that's gone. */
 #define TRANS_SOCKET_INET6_INDEX	14
 #define TRANS_LOCAL_PIPE_INDEX		15
+#define TRANS_HYPERV_INDEX		16
 
 
 static
 Xtransport_table Xtransports[] = {
 #if defined(TCPCONN)
-    { &TRANS(SocketTCPFuncs),	TRANS_SOCKET_TCP_INDEX },
+    { &TRANS(SocketTCPFuncs), TRANS_SOCKET_TCP_INDEX },
 #if defined(IPv6) && defined(AF_INET6)
     { &TRANS(SocketINET6Funcs),	TRANS_SOCKET_INET6_INDEX },
 #endif /* IPv6 */
@@ -100,25 +106,23 @@ Xtransport_table Xtransports[] = {
 #endif /* UNIXCONN */
 #if defined(LOCALCONN)
     { &TRANS(LocalFuncs),	TRANS_LOCAL_LOCAL_INDEX },
-#ifndef __sun
-    { &TRANS(PTSFuncs),		TRANS_LOCAL_PTS_INDEX },
-#endif /* __sun */
 #if defined(SVR4) || defined(__SVR4)
     { &TRANS(NAMEDFuncs),	TRANS_LOCAL_NAMED_INDEX },
 #endif
 #ifdef __sun
     { &TRANS(PIPEFuncs),	TRANS_LOCAL_PIPE_INDEX },
 #endif /* __sun */
-#if defined(__SCO__) || defined(__UNIXWARE__)
-    { &TRANS(SCOFuncs),		TRANS_LOCAL_SCO_INDEX },
-#endif /* __SCO__ || __UNIXWARE__ */
 #endif /* LOCALCONN */
+#if defined(HYPERV)
+        { &TRANS(SocketHyperVFuncs), TRANS_HYPERV_INDEX },
+#endif
+    { NULL, 0}
 };
 
-#define NUMTRANS	(sizeof(Xtransports)/sizeof(Xtransport_table))
+#define NUMTRANS	(sizeof(Xtransports)/sizeof(Xtransport_table)-1)
 
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 #define ioctl ioctlsocket
 #endif
 
@@ -189,10 +193,7 @@ TRANS(SelectTransport) (const char *protocol)
     return NULL;
 }
 
-#ifndef TEST_t
-static
-#endif /* TEST_t */
-int
+static int
 TRANS(ParseAddress) (const char *address,
                      char **protocol, char **host, char **port)
 
@@ -409,7 +410,7 @@ TRANS(Open) (int type, const char *address)
 
     prmsg (2,"Open(%d,%s)\n", type, address);
 
-#if (defined(WIN32) || defined(_WIN32)) && defined(TCPCONN)
+#if defined(WIN32) && (defined(TCPCONN) || defined(HYPERV))
     if (TRANS(WSAStartup)())
     {
 	prmsg (1,"Open: WSAStartup failed\n");
@@ -646,7 +647,7 @@ TRANS(SetOption) (XtransConnInfo ciptr, int option, int arg)
 	    break;
 	case 1: /* Set to non-blocking mode */
 
-#if defined(O_NONBLOCK) && !defined(SCO325)
+#if defined(O_NONBLOCK)
 	    ret = fcntl (fd, F_GETFL, 0);
 	    if (ret != -1)
 		ret = fcntl (fd, F_SETFL, ret | O_NONBLOCK);
@@ -658,10 +659,10 @@ TRANS(SetOption) (XtransConnInfo ciptr, int option, int arg)
 	    ret = ioctl (fd, FIOSNBIO, &arg);
 	}
 #else
-#if defined(WIN32) || defined(_WIN32)
+#if defined(WIN32)
 	{
-#if defined(WIN32) || defined(_WIN32)
-	    u_long arg;
+#ifdef WIN32
+	    unsigned long arg;
 #else
 	    int arg;
 #endif
@@ -788,6 +789,20 @@ TRANS(Listen) (const char * protocol)
    return ret;
 }
 
+#ifdef HYPERV
+
+int TRANS(SetHyperVVmId)(char * svmId)
+{
+    return TRANS(SocketSetHyperVVmId)(svmId);
+}
+
+int TRANS(SetHyperVPortNo)(char * sport)
+{
+    return TRANS(SocketSetHyperVPortNo)(sport);
+}
+
+#endif //HYPERV
+
 int
 TRANS(IsListening) (const char * protocol)
 {
@@ -914,7 +929,6 @@ TRANS(Writev) (XtransConnInfo ciptr, struct iovec *buf, int size)
     return ciptr->transptr->Writev (ciptr, buf, size);
 }
 
-#if XTRANS_SEND_FDS
 int
 TRANS(SendFd) (XtransConnInfo ciptr, int fd, int do_close)
 {
@@ -926,7 +940,6 @@ TRANS(RecvFd) (XtransConnInfo ciptr)
 {
     return ciptr->transptr->RecvFd(ciptr);
 }
-#endif
 
 int
 TRANS(Disconnect) (XtransConnInfo ciptr)
@@ -969,7 +982,11 @@ int
 TRANS(IsLocal) (XtransConnInfo ciptr)
 
 {
-    return (ciptr->family == AF_UNIX);
+    return (ciptr->family == AF_UNIX
+#ifdef HYPERV
+        || ciptr->family == AF_HYPERV
+#endif
+    );
 }
 
 int
@@ -1256,7 +1273,7 @@ TRANS(MakeAllCOTSServerListeners) (const char *port, int *partial,
  */
 
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 
 /*
  * emulate readv
@@ -1318,7 +1335,7 @@ static int TRANS(WriteV) (XtransConnInfo ciptr, struct iovec *iov, int iovcnt)
 #endif /* WIN32 */
 
 
-#if defined(_POSIX_SOURCE) || defined(USG) || defined(SVR4) || defined(__SVR4) || defined(__SCO__)
+#if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__SVR4)
 #ifndef NEED_UTSNAME
 #define NEED_UTSNAME
 #endif
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtrans.h b/vcxsrv-code/X11/xtrans/Xtrans.h
index abd13de..fbf385e 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtrans.h
+++ b/vcxsrv-code/X11/xtrans/Xtrans.h
@@ -54,7 +54,7 @@ from The Open Group.
 #include <X11/Xos.h>
 #include <X11/Xmd.h>
 
-#if !(defined(WIN32) || defined(_WIN32))
+#ifndef WIN32
 #include <sys/socket.h>
 #endif
 
@@ -148,7 +148,7 @@ typedef long BytesReadable_t;
 #endif
 
 
-#if defined(WIN32) || defined(_WIN32) || defined(USG)
+#if defined(WIN32)
 
 /*
  *      TRANS(Readv) and TRANS(Writev) use struct iovec, normally found
@@ -292,6 +292,18 @@ XtransConnInfo TRANS(Accept)(
     int *		/* status */
 );
 
+#ifdef HYPERV
+
+int TRANS(SetHyperVVmId)(
+    char *svmId
+);
+
+int TRANS(SetHyperVPortNo)(
+    char *sport
+);
+
+#endif //HYPERV
+
 #endif /* TRANS_SERVER */
 
 #ifdef TRANS_CLIENT
@@ -409,7 +421,7 @@ TRANS(GetHostname) (
     int 	/* maxlen */
 );
 
-#if (defined(WIN32) || defined(_WIN32)) && defined(TCPCONN)
+#if defined(WIN32) && defined(TCPCONN)
 int TRANS(WSAStartup)();
 #endif
 
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtransint.h b/vcxsrv-code/X11/xtrans/Xtransint.h
index 735b543..789b81b 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtransint.h
+++ b/vcxsrv-code/X11/xtrans/Xtransint.h
@@ -72,7 +72,7 @@ from The Open Group.
 #  define XTRANSDEBUG 1
 #endif
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 # define _WILLWINSOCK_
 #endif
 
@@ -88,7 +88,7 @@ from The Open Group.
 
 #include <errno.h>
 
-#if !(defined(WIN32) || defined(_WIN32))
+#ifndef WIN32
 #  include <sys/socket.h>
 # include <netinet/in.h>
 # include <arpa/inet.h>
@@ -98,7 +98,7 @@ from The Open Group.
  * to avoid a race condition. JKJ (6/5/97)
  */
 
-# if defined(_POSIX_SOURCE) || defined(USG) || defined(SVR4) || defined(__SVR4) || defined(__SCO__)
+# if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__SVR4)
 #  ifndef NEED_UTSNAME
 #   define NEED_UTSNAME
 #  endif
@@ -255,7 +255,6 @@ typedef struct _Xtransport {
 	int			/* size */
     );
 
-#if XTRANS_SEND_FDS
     int (*SendFd)(
 	XtransConnInfo,		/* connection */
         int,                    /* fd */
@@ -265,7 +264,6 @@ typedef struct _Xtransport {
     int (*RecvFd)(
 	XtransConnInfo		/* connection */
     );
-#endif
 
     int	(*Disconnect)(
 	XtransConnInfo		/* connection */
@@ -318,7 +316,7 @@ typedef struct _Xtransport_table {
  * systems, so they may be emulated.
  */
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 
 #define READV(ciptr, iov, iovcnt)	TRANS(ReadV)(ciptr, iov, iovcnt)
 
@@ -335,7 +333,7 @@ static	int TRANS(ReadV)(
 #endif /* WIN32 */
 
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 
 #define WRITEV(ciptr, iov, iovcnt)	TRANS(WriteV)(ciptr, iov, iovcnt)
 
@@ -381,6 +379,11 @@ static int trans_mkdir (
 # if defined(XSERV_t) && defined(TRANS_SERVER)
 #  include "os.h"
 # else
+
+#ifdef _MSC_VER
+#define inline __inline
+#endif
+
 static inline void _X_ATTRIBUTE_PRINTF(1, 0)
 VErrorF(const char *f, va_list args)
 {
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtranslcl.c b/vcxsrv-code/X11/xtrans/Xtranslcl.c
index 26b7f63..2fbf5b0 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtranslcl.c
+++ b/vcxsrv-code/X11/xtrans/Xtranslcl.c
@@ -72,16 +72,18 @@ from The Open Group.
 
 #include <errno.h>
 #include <ctype.h>
+#ifdef _MSC_VER
+#include <signal.h>
+#else
 #include <sys/signal.h>
 #include <sys/ioctl.h>
+#endif
 #include <sys/stat.h>
 #if defined(SVR4) || defined(__SVR4)
 #include <sys/filio.h>
 #endif
-#ifdef __sun
+#ifndef _MSC_VER
 # include <stropts.h>
-#else
-# include <sys/stropts.h>
 #endif
 #include <sys/wait.h>
 #include <sys/types.h>
@@ -102,17 +104,10 @@ from The Open Group.
 /* Types of local connections supported:
  *  - PTS
  *  - named pipes
- *  - SCO
  */
-#if !defined(__sun)
-# define LOCAL_TRANS_PTS
-#endif
 #if defined(SVR4) || defined(__SVR4)
 # define LOCAL_TRANS_NAMED
 #endif
-#if defined(__SCO__) || defined(__UNIXWARE__)
-# define LOCAL_TRANS_SCO
-#endif
 
 static int TRANS(LocalClose)(XtransConnInfo ciptr);
 
@@ -220,448 +215,31 @@ TRANS(FillAddrInfo)(XtransConnInfo ciptr,
 
 
 
-#ifdef LOCAL_TRANS_PTS
-/* PTS */
-
-#if defined(SYSV) && !defined(__SCO__)
-#define SIGNAL_T int
-#else
-#define SIGNAL_T void
-#endif /* SYSV */
-
-typedef SIGNAL_T (*PFV)();
-
-extern PFV signal();
-
-extern char *ptsname(
-    int
-);
-
-static void _dummy(int sig _X_UNUSED)
-
-{
-}
-#endif /* LOCAL_TRANS_PTS */
 
-#ifndef __sun
-#define X_STREAMS_DIR	"/dev/X"
-#define DEV_SPX		"/dev/spx"
-#else
 #ifndef X11_t
 #define X_STREAMS_DIR	"/dev/X"
 #else
 #define X_STREAMS_DIR	"/tmp/.X11-pipe"
 #endif
-#endif
 
 #define DEV_PTMX	"/dev/ptmx"
 
 #if defined(X11_t)
 
-#define PTSNODENAME "/dev/X/server."
-#ifdef __sun
 #define NAMEDNODENAME "/tmp/.X11-pipe/X"
-#else
-#define NAMEDNODENAME "/dev/X/Nserver."
-
-#define SCORNODENAME	"/dev/X%1sR"
-#define SCOSNODENAME	"/dev/X%1sS"
-#endif /* !__sun */
 #endif
 #if defined(XIM_t)
-#ifdef __sun
 #define NAMEDNODENAME "/tmp/.XIM-pipe/XIM"
-#else
-#define PTSNODENAME	"/dev/X/XIM."
-#define NAMEDNODENAME	"/dev/X/NXIM."
-#define SCORNODENAME	"/dev/XIM.%sR"
-#define SCOSNODENAME	"/dev/XIM.%sS"
-#endif
 #endif
 #if defined(FS_t) || defined (FONT_t)
-#ifdef __sun
 #define NAMEDNODENAME	"/tmp/.font-pipe/fs"
-#else
-/*
- * USL has already defined something here. We need to check with them
- * and see if their choice is usable here.
- */
-#define PTSNODENAME	"/dev/X/fontserver."
-#define NAMEDNODENAME	"/dev/X/Nfontserver."
-#define SCORNODENAME	"/dev/fontserver.%sR"
-#define SCOSNODENAME	"/dev/fontserver.%sS"
-#endif
 #endif
 #if defined(ICE_t)
-#ifdef __sun
 #define NAMEDNODENAME	"/tmp/.ICE-pipe/"
-#else
-#define PTSNODENAME	"/dev/X/ICE."
-#define NAMEDNODENAME	"/dev/X/NICE."
-#define SCORNODENAME	"/dev/ICE.%sR"
-#define SCOSNODENAME	"/dev/ICE.%sS"
-#endif
-#endif
-#if defined(TEST_t)
-#ifdef __sun
-#define NAMEDNODENAME	"/tmp/.Test-unix/test"
-#endif
-#define PTSNODENAME	"/dev/X/transtest."
-#define NAMEDNODENAME	"/dev/X/Ntranstest."
-#define SCORNODENAME	"/dev/transtest.%sR"
-#define SCOSNODENAME	"/dev/transtest.%sS"
 #endif
 
 
 
-#ifdef LOCAL_TRANS_PTS
-#ifdef TRANS_CLIENT
-
-static int
-TRANS(PTSOpenClient)(XtransConnInfo ciptr, const char *port)
-
-{
-#ifdef PTSNODENAME
-    int			fd,server,exitval,alarm_time,ret;
-    char		server_path[64];
-    char		*slave, namelen;
-    char		buf[20]; /* MAX_PATH_LEN?? */
-    PFV			savef;
-    pid_t		saved_pid;
-#endif
-
-    prmsg(2,"PTSOpenClient(%s)\n", port);
-
-#if !defined(PTSNODENAME)
-    prmsg(1,"PTSOpenClient: Protocol is not supported by a pts connection\n");
-    return -1;
-#else
-    if (port && *port ) {
-	if( *port == '/' ) { /* A full pathname */
-	    snprintf(server_path, sizeof(server_path), "%s", port);
-	} else {
-	    snprintf(server_path, sizeof(server_path), "%s%s",
-		     PTSNODENAME, port);
-	}
-    } else {
-	snprintf(server_path, sizeof(server_path), "%s%d",
-		 PTSNODENAME, getpid());
-    }
-
-
-    /*
-     * Open the node the on which the server is listening.
-     */
-
-    if ((server = open (server_path, O_RDWR)) < 0) {
-	prmsg(1,"PTSOpenClient: failed to open %s\n", server_path);
-	return -1;
-    }
-
-
-    /*
-     * Open the streams based pipe that will be this connection.
-     */
-
-    if ((fd = open(DEV_PTMX, O_RDWR)) < 0) {
-	prmsg(1,"PTSOpenClient: failed to open %s\n", DEV_PTMX);
-	close(server);
-	return(-1);
-    }
-
-    (void) grantpt(fd);
-    (void) unlockpt(fd);
-
-    slave = ptsname(fd); /* get name */
-
-    if( slave == NULL ) {
-	prmsg(1,"PTSOpenClient: failed to get ptsname()\n");
-	close(fd);
-	close(server);
-	return -1;
-    }
-
-    /*
-     * This is neccesary for the case where a program is setuid to non-root.
-     * grantpt() calls /usr/lib/pt_chmod which is set-uid root. This program will
-     * set the owner of the pt device incorrectly if the uid is not restored
-     * before it is called. The problem is that once it gets restored, it
-     * cannot be changed back to its original condition, hence the fork().
-     */
-
-    if(!(saved_pid=fork())) {
-	uid_t       saved_euid;
-
-	saved_euid = geteuid();
-	/** sets the euid to the actual/real uid **/
-	if (setuid( getuid() ) == -1) {
-		exit(1);
-	}
-	if( chown( slave, saved_euid, -1 ) < 0 ) {
-		exit( 1 );
-		}
-
-	exit( 0 );
-    }
-
-    waitpid(saved_pid, &exitval, 0);
-    if (WIFEXITED(exitval) && WEXITSTATUS(exitval) != 0) {
-	close(fd);
-	close(server);
-	prmsg(1, "PTSOpenClient: cannot set the owner of %s\n",
-	      slave);
-	return(-1);
-    }
-    if (chmod(slave, 0666) < 0) {
-	close(fd);
-	close(server);
-	prmsg(1,"PTSOpenClient: Cannot chmod %s\n", slave);
-	return(-1);
-    }
-
-    /*
-     * write slave name to server
-     */
-
-    namelen = strlen(slave);
-    buf[0] = namelen;
-    (void) sprintf(&buf[1], slave);
-    (void) write(server, buf, namelen+1);
-    (void) close(server);
-
-    /*
-     * wait for server to respond
-     */
-
-    savef = signal(SIGALRM, _dummy);
-    alarm_time = alarm (30); /* CONNECT_TIMEOUT */
-
-    ret = read(fd, buf, 1);
-
-    (void) alarm(alarm_time);
-    (void) signal(SIGALRM, savef);
-
-    if (ret != 1) {
-	prmsg(1,
-	"PTSOpenClient: failed to get acknoledgement from server\n");
-	(void) close(fd);
-	fd = -1;
-    }
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-
-    if (TRANS(FillAddrInfo) (ciptr, slave, server_path) == 0)
-    {
-	prmsg(1,"PTSOpenClient: failed to fill in addr info\n");
-	close(fd);
-	return -1;
-    }
-
-    return(fd);
-
-#endif /* !PTSNODENAME */
-}
-
-#endif /* TRANS_CLIENT */
-
-
-#ifdef TRANS_SERVER
-
-static int
-TRANS(PTSOpenServer)(XtransConnInfo ciptr, const char *port)
-
-{
-#ifdef PTSNODENAME
-    int fd, server;
-    char server_path[64], *slave;
-    int mode;
-#endif
-
-    prmsg(2,"PTSOpenServer(%s)\n", port);
-
-#if !defined(PTSNODENAME)
-    prmsg(1,"PTSOpenServer: Protocol is not supported by a pts connection\n");
-    return -1;
-#else
-    if (port && *port ) {
-	if( *port == '/' ) { /* A full pathname */
-		(void) sprintf(server_path, "%s", port);
-	    } else {
-		(void) sprintf(server_path, "%s%s", PTSNODENAME, port);
-	    }
-    } else {
-	(void) sprintf(server_path, "%s%d", PTSNODENAME, getpid());
-    }
-
-#ifdef HAS_STICKY_DIR_BIT
-    mode = 01777;
-#else
-    mode = 0777;
-#endif
-    if (trans_mkdir(X_STREAMS_DIR, mode) == -1) {
-	prmsg (1, "PTSOpenServer: mkdir(%s) failed, errno = %d\n",
-	       X_STREAMS_DIR, errno);
-	return(-1);
-    }
-
-#if 0
-    if( (fd=open(server_path, O_RDWR)) >= 0 ) {
-	/*
-	 * This doesn't prevent the server from starting up, and doesn't
-	 * prevent clients from trying to connect to the in-use PTS (which
-	 * is often in use by something other than another server).
-	 */
-	prmsg(1, "PTSOpenServer: A server is already running on port %s\n", port);
-	prmsg(1, "PTSOpenServer: Remove %s if this is incorrect.\n", server_path);
-	close(fd);
-	return(-1);
-    }
-#else
-    /* Just remove the old path (which is what happens with UNIXCONN) */
-#endif
-
-    unlink(server_path);
-
-    if( (fd=open(DEV_PTMX, O_RDWR)) < 0) {
-	prmsg(1, "PTSOpenServer: Unable to open %s\n", DEV_PTMX);
-	return(-1);
-    }
-
-    grantpt(fd);
-    unlockpt(fd);
-
-    if( (slave=ptsname(fd)) == NULL) {
-	prmsg(1, "PTSOpenServer: Unable to get slave device name\n");
-	close(fd);
-	return(-1);
-    }
-
-    if( link(slave,server_path) < 0 ) {
-	prmsg(1, "PTSOpenServer: Unable to link %s to %s\n", slave, server_path);
-	close(fd);
-	return(-1);
-    }
-
-    if( chmod(server_path, 0666) < 0 ) {
-	prmsg(1, "PTSOpenServer: Unable to chmod %s to 0666\n", server_path);
-	close(fd);
-	return(-1);
-    }
-
-    if( (server=open(server_path, O_RDWR)) < 0 ) {
-	prmsg(1, "PTSOpenServer: Unable to open server device %s\n", server_path);
-	close(fd);
-	return(-1);
-    }
-
-    close(server);
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-
-    if (TRANS(FillAddrInfo) (ciptr, server_path, server_path) == 0)
-    {
-	prmsg(1,"PTSOpenServer: failed to fill in addr info\n");
-	close(fd);
-	return -1;
-    }
-
-    return fd;
-
-#endif /* !PTSNODENAME */
-}
-
-static int
-TRANS(PTSAccept)(XtransConnInfo ciptr, XtransConnInfo newciptr, int *status)
-
-{
-    int			newfd;
-    int			in;
-    unsigned char	length;
-    char		buf[256];
-    struct sockaddr_un	*sunaddr;
-
-    prmsg(2,"PTSAccept(%x->%d)\n",ciptr,ciptr->fd);
-
-    if( (in=read(ciptr->fd,&length,1)) <= 0 ){
-	if( !in ) {
-		prmsg(2,
-		"PTSAccept: Incoming connection closed\n");
-		}
-	else {
-		prmsg(1,
-	"PTSAccept: Error reading incoming connection. errno=%d \n",
-								errno);
-		}
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return -1;
-    }
-
-    if( (in=read(ciptr->fd,buf,length)) <= 0 ){
-	if( !in ) {
-		prmsg(2,
-		"PTSAccept: Incoming connection closed\n");
-		}
-	else {
-		prmsg(1,
-"PTSAccept: Error reading device name for new connection. errno=%d \n",
-								errno);
-		}
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return -1;
-    }
-
-    buf[length] = '\0';
-
-    if( (newfd=open(buf,O_RDWR)) < 0 ) {
-	prmsg(1, "PTSAccept: Failed to open %s\n",buf);
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return -1;
-    }
-
-    write(newfd,"1",1);
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-
-    newciptr->addrlen=ciptr->addrlen;
-    if( (newciptr->addr = malloc(newciptr->addrlen)) == NULL ) {
-	prmsg(1,"PTSAccept: failed to allocate memory for peer addr\n");
-	close(newfd);
-	*status = TRANS_ACCEPT_BAD_MALLOC;
-	return -1;
-    }
-
-    memcpy(newciptr->addr,ciptr->addr,newciptr->addrlen);
-
-    newciptr->peeraddrlen=sizeof(struct sockaddr_un);
-    if( (sunaddr = malloc(newciptr->peeraddrlen)) == NULL ) {
-	prmsg(1,"PTSAccept: failed to allocate memory for peer addr\n");
-	free(newciptr->addr);
-	close(newfd);
-	*status = TRANS_ACCEPT_BAD_MALLOC;
-	return -1;
-    }
-
-    sunaddr->sun_family=AF_UNIX;
-    strcpy(sunaddr->sun_path,buf);
-#if defined(BSD44SOCKETS)
-    sunaddr->sun_len=strlen(sunaddr->sun_path);
-#endif
-
-    newciptr->peeraddr=(char *)sunaddr;
-
-    *status = 0;
-
-    return newfd;
-}
-
-#endif /* TRANS_SERVER */
-#endif /* LOCAL_TRANS_PTS */
 
 
 #ifdef LOCAL_TRANS_NAMED
@@ -678,9 +256,6 @@ TRANS(NAMEDOpenClient)(XtransConnInfo ciptr, const char *port)
     int			fd;
     char		server_path[64];
     struct stat		filestat;
-# ifndef __sun
-    extern int		isastream(int);
-# endif
 #endif
 
     prmsg(2,"NAMEDOpenClient(%s)\n", port);
@@ -824,368 +399,18 @@ TRANS(NAMEDOpenServer)(XtransConnInfo ciptr, const char *port)
 #else
     if ( port && *port ) {
 	if( *port == '/' ) { /* A full pathname */
-	    (void) snprintf(server_path, sizeof(server_path), "%s", port);
-	} else {
-	    (void) snprintf(server_path, sizeof(server_path), "%s%s",
-			    NAMEDNODENAME, port);
-	}
-    } else {
-	(void) snprintf(server_path, sizeof(server_path), "%s%ld",
-		       NAMEDNODENAME, (long)getpid());
-    }
-
-    fd = TRANS(NAMEDOpenPipe)(server_path);
-    if (fd < 0) {
-	return -1;
-    }
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-
-    if (TRANS(FillAddrInfo) (ciptr, server_path, server_path) == 0)
-    {
-	prmsg(1,"NAMEDOpenServer: failed to fill in addr info\n");
-	TRANS(LocalClose)(ciptr);
-	return -1;
-    }
-
-    return fd;
-
-#endif /* !NAMEDNODENAME */
-}
-
-static int
-TRANS(NAMEDResetListener) (XtransConnInfo ciptr)
-
-{
-  struct sockaddr_un      *sockname=(struct sockaddr_un *) ciptr->addr;
-  struct stat     statb;
-
-  prmsg(2,"NAMEDResetListener(%p, %d)\n", ciptr, ciptr->fd);
-
-  if (ciptr->fd != -1) {
-    /*
-     * see if the pipe has disappeared
-     */
-
-    if (stat (sockname->sun_path, &statb) == -1 ||
-	(statb.st_mode & S_IFMT) != S_IFIFO) {
-      prmsg(3, "Pipe %s trashed, recreating\n", sockname->sun_path);
-      TRANS(LocalClose)(ciptr);
-      ciptr->fd = TRANS(NAMEDOpenPipe)(sockname->sun_path);
-      if (ciptr->fd >= 0)
-	  return TRANS_RESET_NEW_FD;
-      else
-	  return TRANS_CREATE_LISTENER_FAILED;
-    }
-  }
-  return TRANS_RESET_NOOP;
-}
-
-static int
-TRANS(NAMEDAccept)(XtransConnInfo ciptr, XtransConnInfo newciptr, int *status)
-
-{
-    struct strrecvfd str;
-
-    prmsg(2,"NAMEDAccept(%p->%d)\n", ciptr, ciptr->fd);
-
-    if( ioctl(ciptr->fd, I_RECVFD, &str ) < 0 ) {
-	prmsg(1, "NAMEDAccept: ioctl(I_RECVFD) failed, errno=%d\n", errno);
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return(-1);
-    }
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-    newciptr->family=ciptr->family;
-    newciptr->addrlen=ciptr->addrlen;
-    if( (newciptr->addr = malloc(newciptr->addrlen)) == NULL ) {
-	prmsg(1,
-	      "NAMEDAccept: failed to allocate memory for pipe addr\n");
-	close(str.fd);
-	*status = TRANS_ACCEPT_BAD_MALLOC;
-	return -1;
-    }
-
-    memcpy(newciptr->addr,ciptr->addr,newciptr->addrlen);
-
-    newciptr->peeraddrlen=newciptr->addrlen;
-    if( (newciptr->peeraddr = malloc(newciptr->peeraddrlen)) == NULL ) {
-	prmsg(1,
-	"NAMEDAccept: failed to allocate memory for peer addr\n");
-	free(newciptr->addr);
-	close(str.fd);
-	*status = TRANS_ACCEPT_BAD_MALLOC;
-	return -1;
-    }
-
-    memcpy(newciptr->peeraddr,newciptr->addr,newciptr->peeraddrlen);
-
-    *status = 0;
-
-    return str.fd;
-}
-
-#endif /* TRANS_SERVER */
-
-#endif /* LOCAL_TRANS_NAMED */
-
-
-
-#if defined(LOCAL_TRANS_SCO)
-
-/*
- * connect_spipe is used by the SCO connection type.
- */
-static int
-connect_spipe(int fd1, int fd2)
-{
-    long temp;
-    struct strfdinsert sbuf;
-
-    sbuf.databuf.maxlen = -1;
-    sbuf.databuf.len = -1;
-    sbuf.databuf.buf = NULL;
-    sbuf.ctlbuf.maxlen = sizeof(long);
-    sbuf.ctlbuf.len = sizeof(long);
-    sbuf.ctlbuf.buf = (caddr_t)&temp;
-    sbuf.offset = 0;
-    sbuf.fildes = fd2;
-    sbuf.flags = 0;
-
-    if( ioctl(fd1, I_FDINSERT, &sbuf) < 0 )
-	return(-1);
-
-    return(0);
-}
-
-/*
- * named_spipe is used by the SCO connection type.
- */
-
-static int
-named_spipe(int fd, char *path)
-
-{
-    int oldUmask, ret;
-    struct stat sbuf;
-
-    oldUmask = umask(0);
-
-    (void) fstat(fd, &sbuf);
-    ret = mknod(path, 0020666, sbuf.st_rdev);
-
-    umask(oldUmask);
-
-    if (ret < 0) {
-	ret = -1;
-    } else {
-	ret = fd;
-    }
-
-    return(ret);
-}
-
-#endif /* defined(LOCAL_TRANS_SCO) */
-
-
-
-
-#ifdef LOCAL_TRANS_SCO
-/* SCO */
-
-/*
- * 2002-11-09 (jkj@sco.com)
- *
- * This code has been modified to match what is in the actual SCO X server.
- * This greatly helps inter-operability between X11R6 and X11R5 (the native
- * SCO server). Mainly, it relies on streams nodes existing in /dev, not
- * creating them or unlinking them, which breaks the native X server.
- *
- * However, this is only for the X protocol. For all other protocols, we
- * do in fact create the nodes, as only X11R6 will use them, and this makes
- * it possible to have both types of clients running, otherwise we get all
- * kinds of nasty errors on startup for anything that doesnt use the X
- * protocol (like SM, when KDE starts up).
- */
-
-#ifdef TRANS_CLIENT
-
-static int
-TRANS(SCOOpenClient)(XtransConnInfo ciptr, const char *port)
-{
-#ifdef SCORNODENAME
-    int			fd, server, fl, ret;
-    char		server_path[64];
-    struct strbuf	ctlbuf;
-    unsigned long	alarm_time;
-    void		(*savef)();
-    long		temp;
-    extern int	getmsg(), putmsg();
-#endif
-
-    prmsg(2,"SCOOpenClient(%s)\n", port);
-    if (!port || !port[0])
-	port = "0";
-
-#if !defined(SCORNODENAME)
-    prmsg(2,"SCOOpenClient: Protocol is not supported by a SCO connection\n");
-    return -1;
-#else
-    (void) sprintf(server_path, SCORNODENAME, port);
-
-    if ((server = open(server_path, O_RDWR)) < 0) {
-	prmsg(1,"SCOOpenClient: failed to open %s\n", server_path);
-	return -1;
-    }
-
-    if ((fd = open(DEV_SPX, O_RDWR)) < 0) {
-	prmsg(1,"SCOOpenClient: failed to open %s\n", DEV_SPX);
-	close(server);
-	return -1;
-    }
-
-    (void) write(server, &server, 1);
-    ctlbuf.len = 0;
-    ctlbuf.maxlen = sizeof(long);
-    ctlbuf.buf = (caddr_t)&temp;
-    fl = 0;
-
-    savef = signal(SIGALRM, _dummy);
-    alarm_time = alarm(10);
-
-    ret = getmsg(server, &ctlbuf, 0, &fl);
-
-    (void) alarm(alarm_time);
-    (void) signal(SIGALRM, savef);
-
-    if (ret < 0) {
-	prmsg(1,"SCOOpenClient: error from getmsg\n");
-	close(fd);
-	close(server);
-	return -1;
-    }
-
-    /* The msg we got via getmsg is the result of an
-     * I_FDINSERT, so if we do a putmsg with whatever
-     * we recieved, we're doing another I_FDINSERT ...
-     */
-    (void) putmsg(fd, &ctlbuf, 0, 0);
-    (void) fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0)|O_NDELAY);
-
-    (void) close(server);
-
-    /*
-     * Everything looks good: fill in the XtransConnInfo structure.
-     */
-
-#if defined(X11_t) && defined(__SCO__)
-    ciptr->flags |= TRANS_NOUNLINK;
-#endif
-    if (TRANS(FillAddrInfo) (ciptr, server_path, server_path) == 0)
-    {
-	prmsg(1,"SCOOpenClient: failed to fill addr info\n");
-	close(fd);
-	return -1;
-    }
-
-    return(fd);
-
-#endif  /* !SCORNODENAME */
-}
-
-#endif /* TRANS_CLIENT */
-
-
-#ifdef TRANS_SERVER
-
-static int
-TRANS(SCOOpenServer)(XtransConnInfo ciptr, const char *port)
-{
-#ifdef SCORNODENAME
-    char		serverR_path[64];
-    char		serverS_path[64];
-    struct flock	mylock;
-    int			fdr = -1;
-    int			fds = -1;
-#endif
-
-    prmsg(2,"SCOOpenServer(%s)\n", port);
-    if (!port || !port[0])
-	port = "0";
-
-#if !defined(SCORNODENAME)
-    prmsg(1,"SCOOpenServer: Protocol is not supported by a SCO connection\n");
-    return -1;
-#else
-    (void) sprintf(serverR_path, SCORNODENAME, port);
-    (void) sprintf(serverS_path, SCOSNODENAME, port);
-
-#if !defined(X11_t) || !defined(__SCO__)
-    unlink(serverR_path);
-    unlink(serverS_path);
-
-    if ((fds = open(DEV_SPX, O_RDWR)) < 0 ||
-	(fdr = open(DEV_SPX, O_RDWR)) < 0 ) {
-	prmsg(1,"SCOOpenServer: failed to open %s\n", DEV_SPX);
-	if (fds >= 0)
-		close(fds);
-	if (fdr >= 0)
-		close(fdr);
-	return -1;
-    }
-
-    if (named_spipe (fds, serverS_path) == -1) {
-	prmsg(1,"SCOOpenServer: failed to create %s\n", serverS_path);
-	close (fdr);
-	close (fds);
-	return -1;
-    }
-
-    if (named_spipe (fdr, serverR_path) == -1) {
-	prmsg(1,"SCOOpenServer: failed to create %s\n", serverR_path);
-	close (fdr);
-	close (fds);
-	return -1;
-    }
-#else /* X11_t */
-
-    fds = open (serverS_path, O_RDWR | O_NDELAY);
-    if (fds < 0) {
-	prmsg(1,"SCOOpenServer: failed to open %s\n", serverS_path);
-	return -1;
-    }
-
-    /*
-     * Lock the connection device for the duration of the server.
-     * This resolves multiple server starts especially on SMP machines.
-     */
-    mylock.l_type	= F_WRLCK;
-    mylock.l_whence	= 0;
-    mylock.l_start	= 0;
-    mylock.l_len	= 0;
-    if (fcntl (fds, F_SETLK, &mylock) < 0) {
-	prmsg(1,"SCOOpenServer: failed to lock %s\n", serverS_path);
-	close (fds);
-	return -1;
-    }
-
-    fdr = open (serverR_path, O_RDWR | O_NDELAY);
-    if (fdr < 0) {
-	prmsg(1,"SCOOpenServer: failed to open %s\n", serverR_path);
-	close (fds);
-	return -1;
+	    (void) snprintf(server_path, sizeof(server_path), "%s", port);
+	} else {
+	    (void) snprintf(server_path, sizeof(server_path), "%s%s",
+			    NAMEDNODENAME, port);
+	}
+    } else {
+	(void) snprintf(server_path, sizeof(server_path), "%s%ld",
+		       NAMEDNODENAME, (long)getpid());
     }
-#endif /* X11_t */
 
-    if (connect_spipe(fds, fdr)) {
-	prmsg(1,"SCOOpenServer: ioctl(I_FDINSERT) failed on %s\n",
-	      serverS_path);
-	close (fdr);
-	close (fds);
+    fd = TRANS(NAMEDOpenPipe)(server_path);
+    if (fd < 0) {
 	return -1;
     }
 
@@ -1193,72 +418,81 @@ TRANS(SCOOpenServer)(XtransConnInfo ciptr, const char *port)
      * Everything looks good: fill in the XtransConnInfo structure.
      */
 
-#if defined(X11_t) && defined(__SCO__)
-    ciptr->flags |= TRANS_NOUNLINK;
-#endif
-    if (TRANS(FillAddrInfo) (ciptr, serverS_path, serverR_path) == 0) {
-	prmsg(1,"SCOOpenServer: failed to fill in addr info\n");
-	close(fds);
-	close(fdr);
+    if (TRANS(FillAddrInfo) (ciptr, server_path, server_path) == 0)
+    {
+	prmsg(1,"NAMEDOpenServer: failed to fill in addr info\n");
+	TRANS(LocalClose)(ciptr);
 	return -1;
     }
 
-    return(fds);
+    return fd;
 
-#endif /* !SCORNODENAME */
+#endif /* !NAMEDNODENAME */
 }
 
 static int
-TRANS(SCOAccept)(XtransConnInfo ciptr, XtransConnInfo newciptr, int *status)
+TRANS(NAMEDResetListener) (XtransConnInfo ciptr)
+
 {
-    char		c;
-    int			fd;
+  struct sockaddr_un      *sockname=(struct sockaddr_un *) ciptr->addr;
+  struct stat     statb;
 
-    prmsg(2,"SCOAccept(%d)\n", ciptr->fd);
+  prmsg(2,"NAMEDResetListener(%p, %d)\n", ciptr, ciptr->fd);
 
-    if (read(ciptr->fd, &c, 1) < 0) {
-	prmsg(1,"SCOAccept: can't read from client\n");
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return(-1);
-    }
+  if (ciptr->fd != -1) {
+    /*
+     * see if the pipe has disappeared
+     */
 
-    if( (fd = open(DEV_SPX, O_RDWR)) < 0 ) {
-	prmsg(1,"SCOAccept: can't open \"%s\"\n",DEV_SPX);
-	*status = TRANS_ACCEPT_MISC_ERROR;
-	return(-1);
+    if (stat (sockname->sun_path, &statb) == -1 ||
+	(statb.st_mode & S_IFMT) != S_IFIFO) {
+      prmsg(3, "Pipe %s trashed, recreating\n", sockname->sun_path);
+      TRANS(LocalClose)(ciptr);
+      ciptr->fd = TRANS(NAMEDOpenPipe)(sockname->sun_path);
+      if (ciptr->fd >= 0)
+	  return TRANS_RESET_NEW_FD;
+      else
+	  return TRANS_CREATE_LISTENER_FAILED;
     }
+  }
+  return TRANS_RESET_NOOP;
+}
+
+static int
+TRANS(NAMEDAccept)(XtransConnInfo ciptr, XtransConnInfo newciptr, int *status)
 
-    if (connect_spipe (ciptr->fd, fd) < 0) {
-	prmsg(1,"SCOAccept: ioctl(I_FDINSERT) failed\n");
-	close (fd);
+{
+    struct strrecvfd str;
+
+    prmsg(2,"NAMEDAccept(%p->%d)\n", ciptr, ciptr->fd);
+
+    if( ioctl(ciptr->fd, I_RECVFD, &str ) < 0 ) {
+	prmsg(1, "NAMEDAccept: ioctl(I_RECVFD) failed, errno=%d\n", errno);
 	*status = TRANS_ACCEPT_MISC_ERROR;
-	return -1;
+	return(-1);
     }
 
     /*
      * Everything looks good: fill in the XtransConnInfo structure.
      */
-
+    newciptr->family=ciptr->family;
     newciptr->addrlen=ciptr->addrlen;
     if( (newciptr->addr = malloc(newciptr->addrlen)) == NULL ) {
 	prmsg(1,
-	      "SCOAccept: failed to allocate memory for peer addr\n");
-	close(fd);
+	      "NAMEDAccept: failed to allocate memory for pipe addr\n");
+	close(str.fd);
 	*status = TRANS_ACCEPT_BAD_MALLOC;
 	return -1;
     }
 
     memcpy(newciptr->addr,ciptr->addr,newciptr->addrlen);
-#if defined(__SCO__)
-    newciptr->flags |= TRANS_NOUNLINK;
-#endif
 
     newciptr->peeraddrlen=newciptr->addrlen;
     if( (newciptr->peeraddr = malloc(newciptr->peeraddrlen)) == NULL ) {
 	prmsg(1,
-	      "SCOAccept: failed to allocate memory for peer addr\n");
+	"NAMEDAccept: failed to allocate memory for peer addr\n");
 	free(newciptr->addr);
-	close(fd);
+	close(str.fd);
 	*status = TRANS_ACCEPT_BAD_MALLOC;
 	return -1;
     }
@@ -1267,55 +501,23 @@ TRANS(SCOAccept)(XtransConnInfo ciptr, XtransConnInfo newciptr, int *status)
 
     *status = 0;
 
-    return(fd);
+    return str.fd;
 }
 
 #endif /* TRANS_SERVER */
-#endif /* LOCAL_TRANS_SCO */
-
-
-
-#ifdef TRANS_REOPEN
-#ifdef LOCAL_TRANS_PTS
 
-static int
-TRANS(PTSReopenServer)(XtransConnInfo ciptr, int fd, const char *port)
+#endif /* LOCAL_TRANS_NAMED */
 
-{
-#ifdef PTSNODENAME
-    char server_path[64];
-#endif
 
-    prmsg(2,"PTSReopenServer(%d,%s)\n", fd, port);
+
 
-#if !defined(PTSNODENAME)
-    prmsg(1,"PTSReopenServer: Protocol is not supported by a pts connection\n");
-    return 0;
-#else
-    if (port && *port ) {
-	if( *port == '/' ) { /* A full pathname */
-	    snprintf(server_path, sizeof(server_path), "%s", port);
-	} else {
-	    snprintf(server_path, sizeof(server_path), "%s%s",
-		     PTSNODENAME, port);
-	}
-    } else {
-	snprintf(server_path, sizeof(server_path), "%s%ld",
-		PTSNODENAME, (long)getpid());
-    }
 
-    if (TRANS(FillAddrInfo) (ciptr, server_path, server_path) == 0)
-    {
-	prmsg(1,"PTSReopenServer: failed to fill in addr info\n");
-	return 0;
-    }
 
-    return 1;
+
 
-#endif /* !PTSNODENAME */
-}
 
-#endif /* LOCAL_TRANS_PTS */
+
+#ifdef TRANS_REOPEN
 
 #ifdef LOCAL_TRANS_NAMED
 
@@ -1359,41 +561,6 @@ TRANS(NAMEDReopenServer)(XtransConnInfo ciptr, int fd _X_UNUSED, const char *por
 #endif /* LOCAL_TRANS_NAMED */
 
 
-#ifdef LOCAL_TRANS_SCO
-static int
-TRANS(SCOReopenServer)(XtransConnInfo ciptr, int fd, const char *port)
-
-{
-#ifdef SCORNODENAME
-    char serverR_path[64], serverS_path[64];
-#endif
-
-    prmsg(2,"SCOReopenServer(%s)\n", port);
-    if (!port || !port[0])
-      port = "0";
-
-#if !defined(SCORNODENAME)
-    prmsg(2,"SCOReopenServer: Protocol is not supported by a SCO connection\n");
-    return 0;
-#else
-    (void) sprintf(serverR_path, SCORNODENAME, port);
-    (void) sprintf(serverS_path, SCOSNODENAME, port);
-
-#if defined(X11_t) && defined(__SCO__)
-    ciptr->flags |= TRANS_NOUNLINK;
-#endif
-    if (TRANS(FillAddrInfo) (ciptr, serverS_path, serverR_path) == 0)
-    {
-	prmsg(1, "SCOReopenServer: failed to fill in addr info\n");
-	return 0;
-    }
-
-    return 1;
-
-#endif /* SCORNODENAME */
-}
-
-#endif /* LOCAL_TRANS_SCO */
 
 #endif /* TRANS_REOPEN */
 
@@ -1470,76 +637,6 @@ typedef struct _LOCALtrans2dev {
 } LOCALtrans2dev;
 
 static LOCALtrans2dev LOCALtrans2devtab[] = {
-#ifdef LOCAL_TRANS_PTS
-{"",
-#ifdef TRANS_CLIENT
-     TRANS(PTSOpenClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(PTSOpenServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-     TRANS(OpenFail),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(OpenFail),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-     TRANS(PTSReopenServer),
-     TRANS(ReopenFail),
-#endif
-#ifdef TRANS_SERVER
-     NULL,		/* ResetListener */
-     TRANS(PTSAccept)
-#endif /* TRANS_SERVER */
-},
-
-{"local",
-#ifdef TRANS_CLIENT
-     TRANS(PTSOpenClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(PTSOpenServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-     TRANS(OpenFail),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(OpenFail),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-     TRANS(PTSReopenServer),
-     TRANS(ReopenFail),
-#endif
-#ifdef TRANS_SERVER
-     NULL,		/* ResetListener */
-     TRANS(PTSAccept)
-#endif /* TRANS_SERVER */
-},
-
-{"pts",
-#ifdef TRANS_CLIENT
-     TRANS(PTSOpenClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(PTSOpenServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-     TRANS(OpenFail),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(OpenFail),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-     TRANS(PTSReopenServer),
-     TRANS(ReopenFail),
-#endif
-#ifdef TRANS_SERVER
-     NULL,		/* ResetListener */
-     TRANS(PTSAccept)
-#endif /* TRANS_SERVER */
-},
-#else /* !LOCAL_TRANS_PTS */
 {"",
 #ifdef TRANS_CLIENT
      TRANS(NAMEDOpenClient),
@@ -1585,7 +682,6 @@ static LOCALtrans2dev LOCALtrans2devtab[] = {
      TRANS(NAMEDAccept)
 #endif /* TRANS_SERVER */
 },
-#endif /* !LOCAL_TRANS_PTS */
 
 #ifdef LOCAL_TRANS_NAMED
 {"named",
@@ -1611,7 +707,6 @@ static LOCALtrans2dev LOCALtrans2devtab[] = {
 #endif /* TRANS_SERVER */
 },
 
-#ifdef __sun /* Alias "pipe" to named, since that's what Solaris called it */
 {"pipe",
 #ifdef TRANS_CLIENT
      TRANS(NAMEDOpenClient),
@@ -1634,34 +729,9 @@ static LOCALtrans2dev LOCALtrans2devtab[] = {
      TRANS(NAMEDAccept)
 #endif /* TRANS_SERVER */
 },
-#endif /* __sun */
 #endif /* LOCAL_TRANS_NAMED */
 
 
-#ifdef LOCAL_TRANS_SCO
-{"sco",
-#ifdef TRANS_CLIENT
-     TRANS(SCOOpenClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(SCOOpenServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-     TRANS(OpenFail),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-     TRANS(OpenFail),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-     TRANS(SCOReopenServer),
-     TRANS(ReopenFail),
-#endif
-#ifdef TRANS_SERVER
-     NULL,		/* ResetListener */
-     TRANS(SCOAccept)
-#endif /* TRANS_SERVER */
-},
-#endif /* LOCAL_TRANS_SCO */
 };
 
 #define NUMTRANSPORTS	(sizeof(LOCALtrans2devtab)/sizeof(LOCALtrans2dev))
@@ -1670,15 +740,7 @@ static const char	*XLOCAL=NULL;
 static	char	*workingXLOCAL=NULL;
 static	char	*freeXLOCAL=NULL;
 
-#if defined(__SCO__)
-#define DEF_XLOCAL "SCO:UNIX:PTS"
-#elif defined(__UNIXWARE__)
-#define DEF_XLOCAL "UNIX:PTS:NAMED:SCO"
-#elif defined(__sun)
 #define DEF_XLOCAL "UNIX:NAMED"
-#else
-#define DEF_XLOCAL "UNIX:PTS:NAMED:SCO"
-#endif
 
 static void
 TRANS(LocalInitTransports)(const char *protocol)
@@ -2185,11 +1247,7 @@ TRANS(LocalBytesReadable)(XtransConnInfo ciptr, BytesReadable_t *pend )
 {
     prmsg(2,"LocalBytesReadable(%p->%d,%p)\n", ciptr, ciptr->fd, pend);
 
-#if defined(SCO325)
-    return ioctl(ciptr->fd, I_NREAD, (char *)pend);
-#else
     return ioctl(ciptr->fd, FIONREAD, (char *)pend);
-#endif
 }
 
 static int
@@ -2288,16 +1346,8 @@ TRANS(LocalCloseForCloning)(XtransConnInfo ciptr)
 
 #ifdef TRANS_SERVER
 static const char * local_aliases[] = {
-# ifdef LOCAL_TRANS_PTS
-                                  "pts",
-# endif
 				  "named",
-# ifdef __sun
 				  "pipe", /* compatibility with Solaris Xlib */
-# endif
-# ifdef LOCAL_TRANS_SCO
-				  "sco",
-# endif
 				  NULL };
 #endif
 
@@ -2338,46 +1388,6 @@ Xtransport	TRANS(LocalFuncs) = {
 	TRANS(LocalCloseForCloning),
 };
 
-#ifdef LOCAL_TRANS_PTS
-
-Xtransport	TRANS(PTSFuncs) = {
-	/* Local Interface */
-	"pts",
-	TRANS_LOCAL,
-#ifdef TRANS_CLIENT
-	TRANS(LocalOpenCOTSClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-	NULL,
-	TRANS(LocalOpenCOTSServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-	TRANS(LocalReopenCOTSServer),
-#endif
-	TRANS(LocalSetOption),
-#ifdef TRANS_SERVER
-	TRANS(LocalCreateListener),
-	TRANS(LocalResetListener),
-	TRANS(LocalAccept),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-	TRANS(LocalConnect),
-#endif /* TRANS_CLIENT */
-	TRANS(LocalBytesReadable),
-	TRANS(LocalRead),
-	TRANS(LocalWrite),
-	TRANS(LocalReadv),
-	TRANS(LocalWritev),
-#if XTRANS_SEND_FDS
-	TRANS(LocalSendFdInvalid),
-	TRANS(LocalRecvFdInvalid),
-#endif
-	TRANS(LocalDisconnect),
-	TRANS(LocalClose),
-	TRANS(LocalCloseForCloning),
-};
-
-#endif /* LOCAL_TRANS_PTS */
 
 #ifdef LOCAL_TRANS_NAMED
 
@@ -2418,7 +1428,6 @@ Xtransport	TRANS(NAMEDFuncs) = {
 	TRANS(LocalCloseForCloning),
 };
 
-#ifdef __sun
 Xtransport	TRANS(PIPEFuncs) = {
 	/* Local Interface */
 	"pipe",
@@ -2455,45 +1464,6 @@ Xtransport	TRANS(PIPEFuncs) = {
 	TRANS(LocalClose),
 	TRANS(LocalCloseForCloning),
 };
-#endif /* __sun */
 #endif /* LOCAL_TRANS_NAMED */
 
 
-#ifdef LOCAL_TRANS_SCO
-Xtransport	TRANS(SCOFuncs) = {
-	/* Local Interface */
-	"sco",
-	TRANS_LOCAL,
-#ifdef TRANS_CLIENT
-	TRANS(LocalOpenCOTSClient),
-#endif /* TRANS_CLIENT */
-#ifdef TRANS_SERVER
-	NULL,
-	TRANS(LocalOpenCOTSServer),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_REOPEN
-	TRANS(LocalReopenCOTSServer),
-#endif
-	TRANS(LocalSetOption),
-#ifdef TRANS_SERVER
-	TRANS(LocalCreateListener),
-	TRANS(LocalResetListener),
-	TRANS(LocalAccept),
-#endif /* TRANS_SERVER */
-#ifdef TRANS_CLIENT
-	TRANS(LocalConnect),
-#endif /* TRANS_CLIENT */
-	TRANS(LocalBytesReadable),
-	TRANS(LocalRead),
-	TRANS(LocalWrite),
-	TRANS(LocalReadv),
-	TRANS(LocalWritev),
-#if XTRANS_SEND_FDS
-	TRANS(LocalSendFdInvalid),
-	TRANS(LocalRecvFdInvalid),
-#endif
-	TRANS(LocalDisconnect),
-	TRANS(LocalClose),
-	TRANS(LocalCloseForCloning),
-};
-#endif /* LOCAL_TRANS_SCO */
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtranssock.c b/vcxsrv-code/X11/xtrans/Xtranssock.c
index 719d276..c29390e 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtranssock.c
+++ b/vcxsrv-code/X11/xtrans/Xtranssock.c
@@ -74,7 +74,7 @@ from the copyright holders.
 #include <X11/Xthreads.h>
 #endif
 
-#if !(defined(WIN32) || defined(_WIN32))
+#ifndef WIN32
 
 #if defined(TCPCONN) || defined(UNIXCONN)
 #include <sys/socket.h>
@@ -95,7 +95,6 @@ from the copyright holders.
 #include <sys/stat.h>
 #endif
 
-
 #ifndef NO_TCP_H
 #if defined(linux) || defined(__GLIBC__)
 #include <sys/param.h>
@@ -119,20 +118,45 @@ from the copyright holders.
 #include <X11/Xwinsock.h>
 #include <X11/Xwindows.h>
 #include <X11/Xw32defs.h>
-#include <ws2tcpip.h>
 #undef close
 #define close closesocket
+#undef ECONNREFUSED
 #define ECONNREFUSED WSAECONNREFUSED
+#undef EADDRINUSE
 #define EADDRINUSE WSAEADDRINUSE
+#undef EPROTOTYPE
 #define EPROTOTYPE WSAEPROTOTYPE
 #undef EWOULDBLOCK
 #define EWOULDBLOCK WSAEWOULDBLOCK
+#undef EINPROGRESS
 #define EINPROGRESS WSAEINPROGRESS
 #undef EINTR
 #define EINTR WSAEINTR
 #define X_INCLUDE_NETDB_H
 #define XOS_USE_MTSAFE_NETDBAPI
 #include <X11/Xos_r.h>
+
+#if defined(HYPERV)
+#define AF_HYPERV 34
+#define HV_PROTOCOL_RAW 1
+#include <initguid.h>
+DEFINE_GUID(HV_GUID_VSOCK_TEMPLATE, 0x00000000, 0xfacb, 0x11e6, 0xbd, 0x58, 0x64, 0x00, 0x6a, 0x79, 0x86, 0xd3);
+DEFINE_GUID(HV_GUID_WILDCARD, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
+
+typedef struct _SOCKADDR_HV
+{
+     ADDRESS_FAMILY Family;
+     USHORT Reserved;
+     GUID VmId;
+     GUID ServiceId;
+	 ULONG Flags;
+} SOCKADDR_HV, *PSOCKADDR_HV;
+
+static GUID vmId;
+static unsigned int vsockPort = 106000;
+
+#endif //HYPERV
+
 #endif /* WIN32 */
 
 #if defined(SO_DONTLINGER) && defined(SO_LINGER)
@@ -189,6 +213,9 @@ static Sockettrans2dev Sockettrans2devtab[] = {
     {"local",AF_UNIX,SOCK_STREAM,SOCK_DGRAM,0},
 #endif /* !LOCALCONN */
 #endif /* UNIXCONN */
+#ifdef HYPERV
+	{"hyperv",AF_HYPERV,SOCK_STREAM,SOCK_DGRAM,HV_PROTOCOL_RAW},
+#endif
 };
 
 #define NUMSOCKETFAMILIES (sizeof(Sockettrans2devtab)/sizeof(Sockettrans2dev))
@@ -227,13 +254,20 @@ static int TRANS(SocketINETClose) (XtransConnInfo ciptr);
 #endif
 
 #if defined HAVE_SOCKLEN_T || (defined(IPv6) && defined(AF_INET6))
+#ifdef _MSC_VER
+# define SOCKLEN_T int
+#else
 # define SOCKLEN_T socklen_t
-#elif defined(SVR4) || defined(__SVR4) || defined(__SCO__)
+#endif
+#elif defined(SVR4) || defined(__SVR4)
 # define SOCKLEN_T size_t
 #else
 # define SOCKLEN_T int
 #endif
 
+static int TRANS(SocketRecvFdInvalid)(XtransConnInfo ciptr);
+static int TRANS(SocketSendFdInvalid)(XtransConnInfo ciptr, int fd, int do_close);
+
 /*
  * These are some utility function used by the real interface function below.
  */
@@ -288,7 +322,7 @@ TRANS(SocketINETGetAddr) (XtransConnInfo ciptr)
     if (getsockname (ciptr->fd,(struct sockaddr *) socknamePtr,
 		     (void *)&namelen) < 0)
     {
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	errno = WSAGetLastError();
 #endif
 	prmsg (1,"SocketINETGetAddr: getsockname() failed: %d\n",
@@ -319,6 +353,399 @@ TRANS(SocketINETGetAddr) (XtransConnInfo ciptr)
 }
 
 
+#ifdef HYPERV
+static int StringToGUID(const char* szGUID, GUID* g) {
+    // Check if string is a valid GUID
+    if (strlen(szGUID) != 38) return 0;
+    for (int i=0; i<strlen(szGUID); ++i) {
+            char g = szGUID[i];
+
+            if (i == 0) {
+                    if (g != '{') return 0;
+            } else if (i == 37) {
+                    if (g != '}') return 0;
+            } else if ((i == 9) || (i == 14) || (i == 19) || (i == 24)) {
+                    if (g != '-') return 0;
+            } else {
+                    if (!((g >= '0') && (g <= '9')) && !((g >= 'A') && (g <= 'F')) && !((g >= 'a') && (g <= 'f'))) {
+                            return 0;
+                    }
+            }
+    }
+
+    char* pEnd;
+    g->Data1 = strtoul(szGUID+1,&pEnd,16);
+    g->Data2 = strtoul(szGUID+10,&pEnd,16);
+    g->Data3 = strtoul(szGUID+15,&pEnd,16);
+        char b[3]; b[2] = 0;
+        memcpy(&b[0], szGUID+20, 2*sizeof(b[0])); g->Data4[0] = strtoul(&b[0], &pEnd, 16);
+        memcpy(&b[0], szGUID+22, 2*sizeof(b[0])); g->Data4[1] = strtoul(&b[0], &pEnd, 16);
+        for (int i=0; i<6; ++i) {
+                memcpy(&b[0], szGUID+25+i*2, 2*sizeof(b[0])); g->Data4[2+i] = strtoul(&b[0], &pEnd, 16);
+        }
+        return 1;
+}
+
+static char * guid_to_str(const GUID * id, char * out) {
+    int i;
+    char * ret = out;
+    out += sprintf(out, "%.8lX-%.4hX-%.4hX-", id->Data1, id->Data2, id->Data3);
+    for (i = 0; i < sizeof(id->Data4); ++i) {
+        out += sprintf(out, "%.2hhX", id->Data4[i]);
+        if (i == 1) *(out++) = '-';
+    }
+    return ret;
+}
+int TRANS(SocketSetHyperVVmId)(char *svmId)
+{
+	if(!StringToGUID(svmId, &vmId))
+	{
+		FatalError("vmid must be a GUID formatted as {00000000-0000-0000-0000-000000000000}\n");
+	}
+
+	char vmIds[40];
+	guid_to_str(&vmId, vmIds);
+    prmsg (2, "SocketSetHyperVVmId: vmId (%s)\n", vmIds);
+
+    return 0;
+}
+
+int TRANS(SocketSetHyperVPortNo)(char * sport)
+{
+    vsockPort = (unsigned int) strtoul(sport, (char**)NULL, 10);
+
+    prmsg (2,"SocketSetHyperVPortNo: vsockPort (%d)\n", vsockPort);
+
+	return 0;
+}
+
+/*
+ * This function gets the local address of the socket and stores it in the
+ * XtransConnInfo structure for the connection.
+ */
+
+static int
+TRANS(SocketHyperVGetAddr) (XtransConnInfo ciptr)
+
+{
+	SOCKADDR_HV sockaddr_hv;
+
+    void *socknamePtr;
+    SOCKLEN_T namelen;
+
+    prmsg (3,"SocketHyperVGetAddr(%p)\n", ciptr);
+
+	namelen = sizeof(sockaddr_hv);
+	socknamePtr = &sockaddr_hv;
+
+    bzero(socknamePtr, namelen);
+
+    if (getsockname (ciptr->fd,(struct sockaddr *) socknamePtr,
+		     (void *)&namelen) < 0)
+    {
+		errno = WSAGetLastError();
+		prmsg (1,"SocketHyperVGetAddr: getsockname() failed: %d\n",
+	    EGET());
+	return -1;
+    }
+
+    /*
+     * Everything looks good: fill in the XtransConnInfo structure.
+     */
+
+    if ((ciptr->addr = malloc (namelen)) == NULL)
+    {
+        prmsg (1,
+	    "SocketHyperVGetAddr: Can't allocate space for the addr\n");
+        return -1;
+    }
+
+	ciptr->family = sockaddr_hv.Family;
+    ciptr->addrlen = namelen;
+    memcpy (ciptr->addr, socknamePtr, ciptr->addrlen);
+
+    return 0;
+}
+
+/*
+ * This function gets the remote address of the socket and stores it in the
+ * XtransConnInfo structure for the connection.
+ */
+
+static int
+TRANS(SocketHyperVGetPeerAddr) (XtransConnInfo ciptr)
+
+{
+	SOCKADDR_HV sockname_hv;
+    void *socknamePtr;
+    SOCKLEN_T namelen;
+
+	namelen = sizeof(sockname_hv);
+	socknamePtr = &sockname_hv;
+    bzero(socknamePtr, namelen);
+
+    prmsg (3,"SocketHyperVGetPeerAddr(%p)\n", ciptr);
+
+    if (getpeername (ciptr->fd, (struct sockaddr *) socknamePtr,
+		     (void *)&namelen) < 0)
+    {
+		errno = WSAGetLastError();
+		prmsg (1,"SocketHyperVGetPeerAddr: getpeername() failed: %d\n",
+	    EGET());
+		return -1;
+    }
+
+    /*
+     * Everything looks good: fill in the XtransConnInfo structure.
+     */
+
+    if ((ciptr->peeraddr = malloc (namelen)) == NULL)
+    {
+        prmsg (1,
+	   "SocketHyperVGetPeerAddr: Can't allocate space for the addr\n");
+        return -1;
+    }
+
+    ciptr->peeraddrlen = namelen;
+    memcpy (ciptr->peeraddr, socknamePtr, ciptr->peeraddrlen);
+
+    return 0;
+}
+
+static int
+TRANS(SocketHyperVCreateListener) (XtransConnInfo ciptr, const char *port,
+                                 unsigned int flags)
+
+{
+	SOCKADDR_HV sockname;
+    SOCKLEN_T	namelen = sizeof(sockname);
+    int		status;
+#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
+    _Xgetservbynameparams sparams;
+#endif
+    struct servent *servp;
+
+#ifdef X11_t
+    char	portbuf[PORTBUFSIZE];
+#endif
+
+    bzero(&sockname, sizeof(sockname));
+	sockname.Family = AF_HYPERV;
+	sockname.Reserved = 0;
+	sockname.ServiceId = HV_GUID_VSOCK_TEMPLATE;
+	sockname.ServiceId.Data1 = vsockPort;
+	sockname.VmId = vmId;
+	sockname.Flags = 0;
+
+	char vmIds[40];
+	char svcIds[40];
+	guid_to_str(&vmId, vmIds);
+	guid_to_str(&sockname.ServiceId, svcIds);
+    prmsg (2, "SocketHyperVCreateListener(%s:%s:%d)\n", vmIds, svcIds, vsockPort);
+
+    if ((status = TRANS(SocketCreateListener) (ciptr,
+	(struct sockaddr *) &sockname, namelen, flags)) < 0)
+    {
+		prmsg (1,
+		"SocketHyperVCreateListener: ...SocketCreateListener() failed (%d)\n", status);
+		return status;
+    }
+
+    if (TRANS(SocketHyperVGetAddr) (ciptr) < 0)
+    {
+		prmsg (1,
+		"SocketHyperVCreateListener: ...SocketHyperVGetAddr() failed\n");
+		return TRANS_CREATE_LISTENER_FAILED;
+    }
+
+    return 0;
+}
+
+static XtransConnInfo
+TRANS(SocketHyperVAccept) (XtransConnInfo ciptr, int *status)
+
+{
+    XtransConnInfo	newciptr;
+	SOCKADDR_HV sockname;
+    SOCKLEN_T		namelen = sizeof(sockname);
+
+    prmsg (2, "SocketHyperVAccept(%p,%d)\n", ciptr, ciptr->fd);
+
+    if ((newciptr = calloc (1, sizeof(struct _XtransConnInfo))) == NULL)
+    {
+	prmsg (1, "SocketHyperVAccept: malloc failed\n");
+	*status = TRANS_ACCEPT_BAD_MALLOC;
+	return NULL;
+    }
+
+    if ((newciptr->fd = accept (ciptr->fd,
+	(struct sockaddr *) &sockname, (void *)&namelen)) < 0)
+    {
+	errno = WSAGetLastError();
+	prmsg (1, "SocketHyperVAccept: accept() failed\n");
+	free (newciptr);
+	*status = TRANS_ACCEPT_FAILED;
+	return NULL;
+    }
+
+    /*
+     * Get this address again because the transport may give a more
+     * specific address now that a connection is established.
+     */
+
+    if (TRANS(SocketHyperVGetAddr) (newciptr) < 0)
+    {
+	prmsg (1,
+	    "SocketHyperVAccept: ...SocketHyperVGetAddr() failed:\n");
+	close (newciptr->fd);
+	free (newciptr);
+	*status = TRANS_ACCEPT_MISC_ERROR;
+        return NULL;
+    }
+
+    if (TRANS(SocketHyperVGetPeerAddr) (newciptr) < 0)
+    {
+	prmsg (1,
+	  "SocketHyperVAccept: ...SocketHyperVGetPeerAddr() failed:\n");
+	close (newciptr->fd);
+	if (newciptr->addr) free (newciptr->addr);
+	free (newciptr);
+	*status = TRANS_ACCEPT_MISC_ERROR;
+        return NULL;
+    }
+
+    *status = 0;
+
+    return newciptr;
+}
+
+static int
+TRANS(SocketHyperVConnect) (XtransConnInfo ciptr,
+                          const char *host, const char *port)
+
+{
+    struct sockaddr *	socketaddr = NULL;
+    int			socketaddrlen = 0;
+    int			res;
+    SOCKADDR_HV	sockname;
+    struct hostent	*hostp;
+    struct servent	*servp;
+    unsigned long 	tmpport;
+
+prmsg (1,"SocketHyperVConnect: Not Implemented\n");
+		ESET(EINVAL);
+		return TRANS_CONNECT_FAILED;
+
+#ifdef X11_t
+    char	portbuf[PORTBUFSIZE];
+#endif
+
+    char 		hostnamebuf[256];		/* tmp space */
+
+    prmsg (2,"SocketHyperVConnect(%d,%s,%s)\n", ciptr->fd, host, port);
+
+    if (!host)
+    {
+		hostnamebuf[0] = '\0';
+		(void) TRANS(GetHostname) (hostnamebuf, sizeof hostnamebuf);
+		host = hostnamebuf;
+    }
+
+#ifdef X11_t
+    /*
+     * X has a well known port, that is transport dependent. It is easier
+     * to handle it here, than try and come up with a transport independent
+     * representation that can be passed in and resolved the usual way.
+     *
+     * The port that is passed here is really a string containing the idisplay
+     * from ConnectDisplay().
+     */
+
+    if (is_numeric (port))
+    {
+	tmpport = X_TCP_PORT + strtol (port, (char**)NULL, 10) + 100000;
+	snprintf (portbuf, sizeof(portbuf), "%lu", tmpport);
+	port = portbuf;
+    }
+#endif
+
+	prmsg (4,"SocketHyperVConnect() inet_addr(%s) = %lx\n", host, tmpport);
+
+	if (tmpport == 0) {
+		prmsg (1,"SocketHyperVConnect: Can't determine 'port'\n");
+		ESET(EINVAL);
+		return TRANS_CONNECT_FAILED;
+	}
+
+	//sockname.?????
+
+	socketaddr = (struct sockaddr *) &sockname;
+	socketaddrlen = sizeof(sockname);
+
+    /*
+     * Do the connect()
+     */
+
+    if (connect (ciptr->fd, socketaddr, socketaddrlen ) < 0)
+    {
+		int olderrno = WSAGetLastError();
+
+		/*
+		* If the error was ECONNREFUSED, the server may be overloaded
+		* and we should try again.
+		*
+		* If the error was EWOULDBLOCK or EINPROGRESS then the socket
+		* was non-blocking and we should poll using select
+		*
+		* If the error was EINTR, the connect was interrupted and we
+		* should try again.
+		*
+		* If multiple addresses are found for a host then we should
+		* try to connect again with a different address for a larger
+		* number of errors that made us quit before, since those
+		* could be caused by trying to use an IPv6 address to contact
+		* a machine with an IPv4-only server or other reasons that
+		* only affect one of a set of addresses.
+		*/
+
+		if (olderrno == ECONNREFUSED || olderrno == EINTR)
+			res = TRANS_TRY_CONNECT_AGAIN;
+		else if (olderrno == EWOULDBLOCK || olderrno == EINPROGRESS)
+			res = TRANS_IN_PROGRESS;
+		else
+		{
+			prmsg (2,"SocketHyperVConnect: Can't connect: errno = %d\n",
+			olderrno);
+
+			res = TRANS_CONNECT_FAILED;
+		}
+    } else {
+		res = 0;
+
+		/*
+		* Sync up the address fields of ciptr.
+		*/
+
+		if (TRANS(SocketHyperVGetAddr) (ciptr) < 0)
+		{
+			prmsg (1,
+			"SocketHyperVConnect: ...SocketHyperVGetAddr() failed:\n");
+			res = TRANS_CONNECT_FAILED;
+		}
+
+		else if (TRANS(SocketHyperVGetPeerAddr) (ciptr) < 0)
+		{
+			prmsg (1,
+			"SocketHyperVConnect: ...SocketHyperVGetPeerAddr() failed:\n");
+			res = TRANS_CONNECT_FAILED;
+		}
+    }
+
+    return res;
+}
+
+#endif //HYPERV
+
 /*
  * This function gets the remote address of the socket and stores it in the
  * XtransConnInfo structure for the connection.
@@ -355,7 +782,7 @@ TRANS(SocketINETGetPeerAddr) (XtransConnInfo ciptr)
     if (getpeername (ciptr->fd, (struct sockaddr *) socknamePtr,
 		     (void *)&namelen) < 0)
     {
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	errno = WSAGetLastError();
 #endif
 	prmsg (1,"SocketINETGetPeerAddr: getpeername() failed: %d\n",
@@ -397,13 +824,13 @@ TRANS(SocketOpen) (int i, int type)
 
     if ((ciptr->fd = socket(Sockettrans2devtab[i].family, type,
 	Sockettrans2devtab[i].protocol)) < 0
-#if !(defined(WIN32) || defined(_WIN32))
+#ifndef WIN32
 #if (defined(X11_t) && !defined(USE_POLL)) || defined(FS_t) || defined(FONT_t)
        || ciptr->fd >= sysconf(_SC_OPEN_MAX)
 #endif
 #endif
       ) {
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	errno = WSAGetLastError();
 #endif
 	prmsg (2, "SocketOpen: socket() failed for %s\n",
@@ -436,7 +863,11 @@ TRANS(SocketOpen) (int i, int type)
      * proceed at glacial speed.
      */
 #ifdef SO_SNDBUF
-    if (Sockettrans2devtab[i].family == AF_UNIX)
+    if (Sockettrans2devtab[i].family == AF_UNIX
+#ifdef HYPERV
+		|| Sockettrans2devtab[i].family == AF_HYPERV
+#endif
+	)
     {
 	SOCKLEN_T len = sizeof (int);
 	int val;
@@ -448,6 +879,13 @@ TRANS(SocketOpen) (int i, int type)
 	    setsockopt (ciptr->fd, SOL_SOCKET, SO_SNDBUF,
 	        (char *) &val, sizeof (int));
 	}
+	if (getsockopt (ciptr->fd, SOL_SOCKET, SO_RCVBUF,
+	    (char *) &val, &len) == 0 && val < 64 * 1024)
+	{
+	    val = 64 * 1024;
+	    setsockopt (ciptr->fd, SOL_SOCKET, SO_RCVBUF,
+	        (char *) &val, sizeof (int));
+	}
     }
 #endif
 
@@ -646,11 +1084,10 @@ TRANS(SocketOpenCOTSServer) (Xtransport *thistrans, const char *protocol,
     if (Sockettrans2devtab[i].family == AF_INET6)
     {
 	int one = 1;
-	setsockopt(ciptr->fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(int));
+	setsockopt(ciptr->fd, IPPROTO_IPV6, IPV6_V6ONLY, (const char *)&one, sizeof(int));
     }
 #endif
     /* Save the index for later use */
-
     ciptr->index = i;
 
     return ciptr;
@@ -737,6 +1174,10 @@ set_sun_path(const char *port, const char *upath, char *path, int abstract)
 
 #ifdef TRANS_SERVER
 
+#ifndef SO_BINDRETRYCOUNT
+#define SO_BINDRETRYCOUNT 20
+#endif
+
 static int
 TRANS(SocketCreateListener) (XtransConnInfo ciptr,
 			     struct sockaddr *sockname,
@@ -752,9 +1193,11 @@ TRANS(SocketCreateListener) (XtransConnInfo ciptr,
     if (Sockettrans2devtab[ciptr->index].family == AF_INET
 #if defined(IPv6) && defined(AF_INET6)
       || Sockettrans2devtab[ciptr->index].family == AF_INET6
+#elif defined(HYPERV)
+	  || Sockettrans2devtab[ciptr->index].family == AF_HYPERV
 #endif
 	)
-	retry = 20;
+	retry = SO_BINDRETRYCOUNT;
     else
 	retry = 0;
 
@@ -784,10 +1227,10 @@ TRANS(SocketCreateListener) (XtransConnInfo ciptr,
       || Sockettrans2devtab[ciptr->index].family == AF_INET6
 #endif
 	) {
-#ifdef SO_DONTLINGER
+#if defined(SO_DONTLINGER) && !defined(HYPERV)
 	setsockopt (fd, SOL_SOCKET, SO_DONTLINGER, (char *) NULL, 0);
 #else
-#ifdef SO_LINGER
+#if defined(SO_LINGER) && !defined(HYPERV)
     {
 	static int linger[2] = { 0, 0 };
 	setsockopt (fd, SOL_SOCKET, SO_LINGER,
@@ -797,11 +1240,15 @@ TRANS(SocketCreateListener) (XtransConnInfo ciptr,
 #endif
 }
 
-    if (listen (fd, BACKLOG) < 0)
+	int err;
+    if ((err = listen (fd, BACKLOG)) < 0)
     {
-	prmsg (1, "SocketCreateListener: listen() failed\n");
-	close (fd);
-	return TRANS_CREATE_LISTENER_FAILED;
+#ifdef WIN32
+		err = WSAGetLastError();
+#endif
+		prmsg (1, "SocketCreateListener: listen() failed (%d)\n", err);
+		close (fd);
+		return TRANS_CREATE_LISTENER_FAILED;
     }
 
     /* Set a flag to indicate that this connection is a listener */
@@ -991,7 +1438,7 @@ TRANS(SocketUNIXCreateListener) (XtransConnInfo ciptr, const char *port,
 	return TRANS_CREATE_LISTENER_FAILED;
     }
 
-#if (defined(BSD44SOCKETS) || defined(__UNIXWARE__))
+#if defined(BSD44SOCKETS)
     sockname.sun_len = strlen(sockname.sun_path);
 #endif
 
@@ -1069,7 +1516,7 @@ TRANS(SocketUNIXResetListener) (XtransConnInfo ciptr)
     if (!abstract && (
 	stat (unsock->sun_path, &statb) == -1 ||
         ((statb.st_mode & S_IFMT) !=
-#if defined(NCR) || defined(SCO325) || !defined(S_IFSOCK)
+#if !defined(S_IFSOCK)
 	  		S_IFIFO
 #else
 			S_IFSOCK
@@ -1135,7 +1582,11 @@ TRANS(SocketINETAccept) (XtransConnInfo ciptr, int *status)
 
 {
     XtransConnInfo	newciptr;
+#if defined(IPv6) && defined(AF_INET6)
+    struct sockaddr_storage	sockname;
+#else
     struct sockaddr_in	sockname;
+#endif
     SOCKLEN_T		namelen = sizeof(sockname);
 
     prmsg (2, "SocketINETAccept(%p,%d)\n", ciptr, ciptr->fd);
@@ -1150,7 +1601,7 @@ TRANS(SocketINETAccept) (XtransConnInfo ciptr, int *status)
     if ((newciptr->fd = accept (ciptr->fd,
 	(struct sockaddr *) &sockname, (void *)&namelen)) < 0)
     {
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	errno = WSAGetLastError();
 #endif
 	prmsg (1, "SocketINETAccept: accept() failed\n");
@@ -1204,7 +1655,6 @@ TRANS(SocketINETAccept) (XtransConnInfo ciptr, int *status)
 
 #endif /* TCPCONN */
 
-
 #ifdef UNIXCONN
 static XtransConnInfo
 TRANS(SocketUNIXAccept) (XtransConnInfo ciptr, int *status)
@@ -1592,7 +2042,7 @@ TRANS(SocketINETConnect) (XtransConnInfo ciptr,
 
     if (connect (ciptr->fd, socketaddr, socketaddrlen ) < 0)
     {
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	int olderrno = WSAGetLastError();
 #else
 	int olderrno = errno;
@@ -1865,7 +2315,7 @@ TRANS(SocketUNIXConnect) (XtransConnInfo ciptr,
 	return TRANS_CONNECT_FAILED;
     }
 
-#if (defined(BSD44SOCKETS) || defined(__UNIXWARE__))
+#if defined(BSD44SOCKETS)
     sockname.sun_len = strlen (sockname.sun_path);
 #endif
 
@@ -1972,7 +2422,7 @@ TRANS(SocketBytesReadable) (XtransConnInfo ciptr, BytesReadable_t *pend)
 {
     prmsg (2,"SocketBytesReadable(%p,%d,%p)\n",
 	ciptr, ciptr->fd, pend);
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
     {
 	int ret = ioctlsocket ((SOCKET) ciptr->fd, FIONREAD, (u_long *) pend);
 	if (ret == SOCKET_ERROR) errno = WSAGetLastError();
@@ -2067,6 +2517,15 @@ TRANS(SocketSendFd) (XtransConnInfo ciptr, int fd, int do_close)
     return 0;
 }
 
+#define MAX_FDS		128
+
+union fd_pass {
+	struct cmsghdr	cmsghdr;
+	char		buf[CMSG_SPACE(MAX_FDS * sizeof(int))];
+};
+
+#endif /* XTRANS_SEND_FDS */
+
 static int
 TRANS(SocketRecvFdInvalid)(XtransConnInfo ciptr)
 {
@@ -2081,25 +2540,16 @@ TRANS(SocketSendFdInvalid)(XtransConnInfo ciptr, int fd, int do_close)
     return -1;
 }
 
-#define MAX_FDS		128
-
-union fd_pass {
-	struct cmsghdr	cmsghdr;
-	char		buf[CMSG_SPACE(MAX_FDS * sizeof(int))];
-};
-
-#endif /* XTRANS_SEND_FDS */
-
 static int
 TRANS(SocketRead) (XtransConnInfo ciptr, char *buf, int size)
 
 {
     prmsg (2,"SocketRead(%d,%p,%d)\n", ciptr->fd, buf, size);
 
-#if defined(WIN32) || defined(_WIN32)
+#if defined(WIN32)
     {
 	int ret = recv ((SOCKET)ciptr->fd, buf, size, 0);
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	if (ret == SOCKET_ERROR) errno = WSAGetLastError();
 #endif
 	return ret;
@@ -2236,10 +2686,10 @@ TRANS(SocketWrite) (XtransConnInfo ciptr, char *buf, int size)
 {
     prmsg (2,"SocketWrite(%d,%p,%d)\n", ciptr->fd, buf, size);
 
-#if defined(WIN32) || defined(_WIN32)
+#if defined(WIN32)
     {
 	int ret = send ((SOCKET)ciptr->fd, buf, size, 0);
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 	if (ret == SOCKET_ERROR) errno = WSAGetLastError();
 #endif
 	return ret;
@@ -2265,11 +2715,11 @@ TRANS(SocketDisconnect) (XtransConnInfo ciptr)
 {
     prmsg (2,"SocketDisconnect(%p,%d)\n", ciptr, ciptr->fd);
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
     {
-	int ret = shutdown (ciptr->fd, 2);
-	if (ret == SOCKET_ERROR) errno = WSAGetLastError();
-	return ret;
+		int ret = shutdown (ciptr->fd, 2);
+		if (ret == SOCKET_ERROR) errno = WSAGetLastError();
+		return ret;
     }
 #else
     return shutdown (ciptr->fd, 2); /* disallow further sends and receives */
@@ -2284,7 +2734,7 @@ TRANS(SocketINETClose) (XtransConnInfo ciptr)
 {
     prmsg (2,"SocketINETClose(%p,%d)\n", ciptr, ciptr->fd);
 
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
     {
 	int ret = close (ciptr->fd);
 	if (ret == SOCKET_ERROR) errno = WSAGetLastError();
@@ -2297,7 +2747,6 @@ TRANS(SocketINETClose) (XtransConnInfo ciptr)
 
 #endif /* TCPCONN */
 
-
 #ifdef UNIXCONN
 static int
 TRANS(SocketUNIXClose) (XtransConnInfo ciptr)
@@ -2393,10 +2842,8 @@ Xtransport	TRANS(SocketTCPFuncs) = {
 	TRANS(SocketWrite),
 	TRANS(SocketReadv),
 	TRANS(SocketWritev),
-#if XTRANS_SEND_FDS
-        TRANS(SocketSendFdInvalid),
-        TRANS(SocketRecvFdInvalid),
-#endif
+	TRANS(SocketSendFdInvalid),
+	TRANS(SocketRecvFdInvalid),
 	TRANS(SocketDisconnect),
 	TRANS(SocketINETClose),
 	TRANS(SocketINETClose),
@@ -2430,10 +2877,8 @@ Xtransport	TRANS(SocketINETFuncs) = {
 	TRANS(SocketWrite),
 	TRANS(SocketReadv),
 	TRANS(SocketWritev),
-#if XTRANS_SEND_FDS
-        TRANS(SocketSendFdInvalid),
-        TRANS(SocketRecvFdInvalid),
-#endif
+	TRANS(SocketSendFdInvalid),
+	TRANS(SocketRecvFdInvalid),
 	TRANS(SocketDisconnect),
 	TRANS(SocketINETClose),
 	TRANS(SocketINETClose),
@@ -2468,10 +2913,8 @@ Xtransport     TRANS(SocketINET6Funcs) = {
 	TRANS(SocketWrite),
 	TRANS(SocketReadv),
 	TRANS(SocketWritev),
-#if XTRANS_SEND_FDS
-        TRANS(SocketSendFdInvalid),
-        TRANS(SocketRecvFdInvalid),
-#endif
+	TRANS(SocketSendFdInvalid),
+	TRANS(SocketRecvFdInvalid),
 	TRANS(SocketDisconnect),
 	TRANS(SocketINETClose),
 	TRANS(SocketINETClose),
@@ -2479,6 +2922,43 @@ Xtransport     TRANS(SocketINET6Funcs) = {
 #endif /* IPv6 */
 #endif /* TCPCONN */
 
+#if defined(HYPERV)
+Xtransport	TRANS(SocketHyperVFuncs) = {
+	/* HyperV Interface */
+	"hyperv",
+	0,
+#ifdef TRANS_CLIENT
+	TRANS(SocketOpenCOTSClient),
+#endif /* TRANS_CLIENT */
+#ifdef TRANS_SERVER
+	NULL,
+	TRANS(SocketOpenCOTSServer),
+#endif /* TRANS_SERVER */
+#ifdef TRANS_REOPEN
+	TRANS(SocketReopenCOTSServer),
+#endif
+	TRANS(SocketSetOption),
+#ifdef TRANS_SERVER
+	TRANS(SocketHyperVCreateListener),
+	NULL,		       			/* ResetListener */
+	TRANS(SocketHyperVAccept),
+#endif /* TRANS_SERVER */
+#ifdef TRANS_CLIENT
+	TRANS(SocketHyperVConnect),
+#endif /* TRANS_CLIENT */
+	TRANS(SocketBytesReadable),
+	TRANS(SocketRead),
+	TRANS(SocketWrite),
+	TRANS(SocketReadv),
+	TRANS(SocketWritev),
+	TRANS(SocketSendFdInvalid),
+	TRANS(SocketRecvFdInvalid),
+	TRANS(SocketDisconnect),
+	TRANS(SocketINETClose),
+	TRANS(SocketINETClose),
+	};
+#endif /* HYPERV */
+
 #ifdef UNIXCONN
 #if !defined(LOCALCONN)
 Xtransport	TRANS(SocketLocalFuncs) = {
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtransutil.c b/vcxsrv-code/X11/xtrans/Xtransutil.c
index 2f8af0e..f15be24 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/Xtransutil.c
+++ b/vcxsrv-code/X11/xtrans/Xtransutil.c
@@ -57,13 +57,9 @@ from The Open Group.
 #ifdef XTHREADS
 #include <X11/Xthreads.h>
 #endif
-#if defined(WIN32) || defined(_WIN32)
+#ifdef WIN32
 #include <X11/Xlibint.h>
 #include <X11/Xwinsock.h>
-#ifdef _MSC_VER
-#include <direct.h>
-#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
-#endif
 #endif
 
 #ifdef X11_t
@@ -173,13 +169,6 @@ TRANS(ConvertAddress)(int *familyp, int *addrlenp, Xtransaddr **addrp)
     }
 #endif /* defined(UNIXCONN) || defined(LOCALCONN) */
 
-#if (defined(__SCO__) || defined(__UNIXWARE__)) && defined(LOCALCONN)
-    case 0:
-    {
-	*familyp=FamilyLocal;
-	break;
-    }
-#endif
 
     default:
 	prmsg(1,"ConvertAddress: Unknown family type %d\n",
@@ -422,7 +411,7 @@ TRANS(GetPeerNetworkId) (XtransConnInfo ciptr)
 #endif /* ICE_t */
 
 
-#if (defined(WIN32) || defined(_WIN32)) && defined(TCPCONN)
+#if defined(WIN32) && defined(TCPCONN)
 int
 TRANS(WSAStartup) (void)
 {
@@ -482,7 +471,7 @@ trans_mkdir(const char *path, int mode)
 	}
 	/* Dir doesn't exist. Try to create it */
 
-#if !(defined(WIN32) || defined(_WIN32)) && !defined(__CYGWIN__)
+#if !defined(WIN32) && !defined(__CYGWIN__)
 	/*
 	 * 'sticky' bit requested: assume application makes
 	 * certain security implications. If effective user ID
@@ -503,7 +492,7 @@ trans_mkdir(const char *path, int mode)
 	}
 #endif
 
-#if !(defined(WIN32) || defined(_WIN32))
+#ifndef WIN32
 	if (mkdir(path, mode) == 0) {
 	    if (chmod(path, mode)) {
 		prmsg(1, "mkdir: ERROR: Mode of %s should be set to %04o\n",
diff --git a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/xtrans.m4 b/vcxsrv-code/X11/xtrans/xtrans.m4
index 8215e87..70f88c0 100644
--- a/xserver-vcpkg/build/ninja/release/_deps/vcpkg-src/buildtrees/xtrans/src/6ab38e006f-59a55c7d23.clean/xtrans.m4
+++ b/vcxsrv-code/X11/xtrans/xtrans.m4
@@ -43,6 +43,15 @@ AC_DEFUN([XTRANS_TCP_FLAGS],[
  fi
  AC_MSG_RESULT($IPV6CONN)
 
+AC_ARG_ENABLE(hyperv,
+	AS_HELP_STRING([--enable-hyperv],[Enable HyperV VSock support]),
+	[HYPERV=$enableval],[HYPERV=yes])
+ AC_MSG_CHECKING([if HyperV VSock support should be built])
+ AC_MSG_RESULT($HYPERV)
+ if test "$HYPERV" = "yes"; then
+	AC_DEFINE(HYPERV,1,[Support HyperV for VSock connections])
+ fi
+
  # 4.3BSD-Reno added a new member to struct sockaddr_in
  AC_CHECK_MEMBER([struct sockaddr_in.sin_len],
 	AC_DEFINE([BSD44SOCKETS],1,
@@ -122,7 +131,7 @@ AC_DEFUN([XTRANS_CONNECTION_FLAGS],[
 	XTRANS_TCP_FLAGS
  fi
  [case $host_os in
-	solaris*|sco*|sysv4*)	localdef="yes" ;;
+	solaris*)		localdef="yes" ;;
 	*)			localdef="no"  ;;
  esac]
  AC_ARG_ENABLE(local-transport,
