--- ./os/save_connection.c	2019-11-01 14:42:57.297097972 +0000
+++ ./os/connection.c	2019-11-01 15:11:38.699371344 +0000
@@ -66,6 +66,8 @@
 
 #ifdef WIN32
 #include <X11/Xwinsock.h>
+#include <ws2tcpip.h>
+extern const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);
 #endif
 #include <X11/X.h>
 #include <X11/Xproto.h>
@@ -139,12 +141,14 @@
 Bool AnyWritesPending;          /* true if some client blocked on write or NotifyFd with write */
 Bool NoListenAll;               /* Don't establish any listening sockets */
 
+#if !defined(__MINGW32__)
 static Bool RunFromSmartParent; /* send SIGUSR1 to parent process */
+static Pid_t ParentProcess;
+#endif
 Bool RunFromSigStopParent;      /* send SIGSTOP to our own process; Upstart (or
                                    equivalent) will send SIGCONT back. */
 static char dynamic_display[7]; /* display name */
 Bool PartialNetwork;            /* continue even if unable to bind all addrs */
-static Pid_t ParentProcess;
 
 static Bool debug_conns = FALSE;
 
@@ -178,7 +182,7 @@
 
 struct _ct_node *ct_head[256];
 
-void
+static void
 InitConnectionTranslation(void)
 {
     memset(ct_head, 0, sizeof(ct_head));
@@ -438,14 +442,21 @@
     if (ListenTransFds == NULL)
         FatalError ("Failed to create listening socket array");
 
-    for (i = 0; i < ListenTransCount; i++) {
-        int fd = _XSERVTransGetConnectionNumber(ListenTransConns[i]);
+    for (i = ListenTransCount; i > 0; i--) {
+        int fd = _XSERVTransGetConnectionNumber(ListenTransConns[i - 1]);
 
-        ListenTransFds[i] = fd;
+        ListenTransFds[i - 1] = fd;
         FD_SET(fd, &WellKnownConnections);
 
-        if (!_XSERVTransIsLocal(ListenTransConns[i]))
-            DefineSelf (fd);
+        if (!_XSERVTransIsLocal(ListenTransConns[i - 1])) {
+            int protocol = 0;
+
+            if (!strcmp("inet", ListenTransConns[i - 1]->transptr->TransName))
+                protocol = 4;
+            else if (!strcmp("inet6", ListenTransConns[i - 1]->transptr->TransName))
+                protocol = 6;
+            DefineSelf(fd, protocol);
+        }
     }
 
     if (!XFD_ANYSET(&WellKnownConnections) && !NoListenAll)
@@ -995,15 +1006,17 @@
 {
 #ifndef WIN32
     fd_mask mask;
+    int curoff;
 #endif
     fd_set tmask;
-    int curclient, curoff;
+    int curclient;
     int i;
     struct timeval notime;
     int r;
 
 #ifdef WIN32
     fd_set savedAllClients;
+    unsigned j;
 #endif
 
     notime.tv_sec = 0;
@@ -1027,17 +1040,23 @@
         }
     }
 #else
-    XFD_COPYSET(&AllClients, &savedAllClients);
-    for (i = 0; i < XFD_SETCOUNT(&savedAllClients); i++) {
-        curclient = XFD_FD(&savedAllClients, i);
-        FD_ZERO(&tmask);
-        FD_SET(curclient, &tmask);
-        do {
-            r = Select(curclient + 1, &tmask, NULL, NULL, &notime);
-        } while (r < 0 && (errno == EINTR || errno == EAGAIN));
-        if (r < 0)
-            if (GetConnectionTranslation(curclient) > 0)
-                CloseDownClient(clients[GetConnectionTranslation(curclient)]);
+    /* First test AllSockets and then AllClients are valid sockets */
+    XFD_COPYSET(&AllSockets, &savedAllClients);
+    for (j = 0; j < 2; j++) {
+        for (i = 0; i < XFD_SETCOUNT(&savedAllClients); i++) {
+            curclient = XFD_FD(&savedAllClients, i);
+            FD_ZERO(&tmask);
+            FD_SET(curclient, &tmask);
+            do {
+                r = Select(curclient + 1, &tmask, NULL, NULL, &notime);
+            } while (r == SOCKET_ERROR &&
+                     (WSAGetLastError() == WSAEINTR ||
+                      WSAGetLastError() == WSAEWOULDBLOCK));
+            if (r < 0)
+                if (GetConnectionTranslation(curclient) > 0)
+                    CloseDownClient(clients[GetConnectionTranslation(curclient)]);
+        }
+        XFD_COPYSET(&AllClients, &savedAllClients);
     }
 #endif
 }
