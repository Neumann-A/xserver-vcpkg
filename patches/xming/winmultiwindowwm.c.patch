--- ./hw/xwin/save_winmultiwindowwm.c	2020-07-05 22:49:30.000000000 +0100
+++ ./hw/xwin/winmultiwindowwm.c	2022-01-03 23:22:39.841443153 +0000
@@ -49,6 +49,7 @@
 #include <xcb/xcb_icccm.h>
 #include <xcb/xcb_ewmh.h>
 #include <xcb/xcb_aux.h>
+#include <xcb/composite.h>
 
 #include <X11/Xwindows.h>
 
@@ -90,6 +91,9 @@
 #define WIN_MSG_QUEUE_FNAME	"/dev/windows"
 #endif
 
+#define HINT_MAX	(1L<<0)
+#define HINT_MIN	(1L<<1)
+
 /*
  * Local structures
  */
@@ -118,7 +122,9 @@
     xcb_atom_t atmCurrentDesktop;
     xcb_atom_t atmNumberDesktops;
     xcb_atom_t atmDesktopNames;
+    xcb_atom_t atmWmState;
     xcb_ewmh_connection_t ewmh;
+    Bool fCompositeWM;
 } WMInfoRec, *WMInfoPtr;
 
 typedef struct _WMProcArgRec {
@@ -161,6 +167,9 @@
 static void *winMultiWindowXMsgProc(void *pArg);
 
 static void
+winMultiWindowThreadExit(void *arg);
+
+static void
  winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg);
 
 #if 0
@@ -172,7 +181,7 @@
 CheckAnotherWindowManager(xcb_connection_t *conn, DWORD dwScreen);
 
 static void
- winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle);
+ winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle, unsigned long *maxmin);
 
 void
  winUpdateWindowPosition(HWND hWnd, HWND * zstyle);
@@ -543,8 +552,10 @@
     }
 
     /* Some sanity checks */
-    if (!hWnd)
+    if (!hWnd) {
+        winDebug("getHwnd: no HWND\n");
         return NULL;
+    }
     if (!IsWindow(hWnd))
         return NULL;
 
@@ -555,7 +566,7 @@
  * Helper function to check for override-redirect
  */
 static Bool
-IsOverrideRedirect(xcb_connection_t *conn, xcb_window_t iWin)
+IsOverrideRedirect(xcb_connection_t *conn, xcb_window_t iWin, int notsilent)
 {
     Bool result = FALSE;
     xcb_get_window_attributes_reply_t *reply;
@@ -568,7 +579,7 @@
         free(reply);
     }
     else {
-        ErrorF("IsOverrideRedirect: Failed to get window attributes\n");
+        if (notsilent) ErrorF("IsOverrideRedirect -%d- Failed to get window attributes\n", notsilent);
     }
 
     return result;
@@ -622,7 +633,7 @@
         return;
 
     /* If window isn't override-redirect */
-    if (!IsOverrideRedirect(pWMInfo->conn, iWindow)) {
+    if (!IsOverrideRedirect(pWMInfo->conn, iWindow, 1)) {
         char *pszWindowName;
 
         /* Get the X windows window name */
@@ -661,7 +672,7 @@
         return;
 
     /* If window isn't override-redirect */
-    if (!IsOverrideRedirect(pWMInfo->conn, iWindow)) {
+    if (!IsOverrideRedirect(pWMInfo->conn, iWindow, 2)) {
         char *window_name = 0;
         char *res_name = 0;
         char *res_class = 0;
@@ -682,18 +693,22 @@
  */
 
 static void
-UpdateStyle(WMInfoPtr pWMInfo, xcb_window_t iWindow)
+UpdateStyle(WMInfoPtr pWMInfo, xcb_window_t iWindow, unsigned long *maxmin)
 {
     HWND hWnd;
     HWND zstyle = HWND_NOTOPMOST;
     UINT flags;
 
+    /* If window isn't override-redirect */
+    if (IsOverrideRedirect(pWMInfo->conn, iWindow, 3-3))
+        return;
+
     hWnd = getHwnd(pWMInfo, iWindow);
     if (!hWnd)
         return;
 
     /* Determine the Window style, which determines borders and clipping region... */
-    winApplyHints(pWMInfo, iWindow, hWnd, &zstyle);
+    winApplyHints(pWMInfo, iWindow, hWnd, &zstyle, maxmin);
     winUpdateWindowPosition(hWnd, &zstyle);
 
     /* Apply the updated window style, without changing its show or activation state */
@@ -718,21 +733,148 @@
 
 /*
  * Updates the state of a HWND
- * (only minimization supported at the moment)
  */
 
 static void
-UpdateState(WMInfoPtr pWMInfo, xcb_window_t iWindow)
+UpdateState(WMInfoPtr pWMInfo, xcb_window_t iWindow, int state)
 {
     HWND hWnd;
+    int current_state = -1;
 
-    winDebug("UpdateState: iWindow 0x%08x\n", (int)iWindow);
+    winDebug("UpdateState: iWindow 0x%08x %d\n", (int)iWindow, state);
 
     hWnd = getHwnd(pWMInfo, iWindow);
-    if (!hWnd)
-        return;
+    if (hWnd)
+        {
+            // Keep track of the Window state, do nothing if it's not changing
+            current_state = (intptr_t)GetProp(hWnd, WIN_STATE_PROP);
+
+            if (current_state == state)
+                return;
+
+            SetProp(hWnd, WIN_STATE_PROP, (HANDLE)(intptr_t)state);
+
+            switch (state)
+                {
+                case XCB_ICCCM_WM_STATE_ICONIC:
+                    ShowWindow(hWnd, SW_SHOWMINNOACTIVE);
+                    break;
+
+#define XCB_ICCCM_WM_STATE_ZOOM 2
+                case XCB_ICCCM_WM_STATE_ZOOM:
+                    // There doesn't seem to be a SW_SHOWMAXNOACTIVE.  Hopefully
+                    // always activating a maximized window isn't so bad...
+                    ShowWindow(hWnd, SW_SHOWMAXIMIZED);
+                    break;
+
+                case XCB_ICCCM_WM_STATE_NORMAL:
+                    ShowWindow(hWnd, SW_SHOWNOACTIVATE);
+                    break;
+
+                case XCB_ICCCM_WM_STATE_WITHDRAWN:
+                    ShowWindow(hWnd, SW_HIDE);
+                    break;
+                }
+        }
+
+    // Update WM_STATE property
+    {
+        // ZoomState is obsolete in ICCCM, so map it to NormalState
+        int icccm_state = state;
+        int icccm_current_state = current_state;
+
+        if (icccm_state == XCB_ICCCM_WM_STATE_ZOOM)
+            icccm_state = XCB_ICCCM_WM_STATE_NORMAL;
+
+        if (icccm_current_state == XCB_ICCCM_WM_STATE_ZOOM)
+            icccm_current_state = XCB_ICCCM_WM_STATE_NORMAL;
+
+        // Don't change property unnecessarily
+        //
+        // (Note that we do not take notice of WM_STATE PropertyNotify, only
+        // WM_CHANGE_STATE ClientMessage, so this should not cause the state to
+        // change itself)
+        if (icccm_current_state != icccm_state)
+            {
+                struct
+                {
+                    CARD32 state;
+                    XID     icon;
+                } wmstate;
+
+                wmstate.state = icccm_state;
+                wmstate.icon = None;
+
+                xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
+                                    iWindow, pWMInfo->atmWmState,
+                                    pWMInfo->atmWmState, 32,
+                                    sizeof(wmstate)/sizeof(int),
+                                    (unsigned char *) &wmstate);
+            }
+    }
 
-    ShowWindow(hWnd, SW_MINIMIZE);
+    // Update _NET_WM_STATE property
+    if (state == XCB_ICCCM_WM_STATE_WITHDRAWN) {
+        xcb_delete_property(pWMInfo->conn, iWindow, pWMInfo->ewmh._NET_WM_STATE);
+    }
+    else {
+        xcb_get_property_cookie_t cookie;
+        xcb_get_property_reply_t *reply;
+
+        cookie = xcb_get_property(pWMInfo->conn, FALSE, iWindow,
+                                  pWMInfo->ewmh._NET_WM_STATE,
+                                  XCB_ATOM_ATOM,
+                                  0, INT_MAX);
+        reply = xcb_get_property_reply(pWMInfo->conn, cookie, NULL);
+        if (reply) {
+            int nitems = xcb_get_property_value_length(reply)/sizeof(xcb_atom_t);
+            xcb_atom_t *pAtom = xcb_get_property_value(reply);
+            unsigned long i, o = 0;
+            xcb_atom_t netwmstate[nitems + 2];
+            Bool changed = FALSE;
+
+            // Make a copy with _NET_WM_HIDDEN, _NET_WM_MAXIMIZED_{VERT,HORZ}
+            // removed
+            for (i = 0; i < nitems; i++) {
+                if ((pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_HIDDEN) &&
+                    (pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                    (pAtom[i] != pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                    netwmstate[o++] = pAtom[i];
+            }
+            free(reply);
+
+            // if iconized, add _NET_WM_HIDDEN
+            if (state == XCB_ICCCM_WM_STATE_ICONIC) {
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_HIDDEN;
+            }
+
+            // if maximized, add  _NET_WM_MAXIMIZED_{VERT,HORZ}
+            if (state == XCB_ICCCM_WM_STATE_ZOOM) {
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT;
+                netwmstate[o++] = pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ;
+            }
+
+            // Don't change property unnecessarily
+            if (nitems != o)
+                changed = TRUE;
+            else
+                for (i = 0; i < nitems; i++)
+                    {
+                        if (pAtom[i] != netwmstate[i])
+                            {
+                                changed = TRUE;
+                                break;
+                            }
+                    }
+
+            if (changed)
+                xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
+                                    iWindow,
+                                    pWMInfo->ewmh._NET_WM_STATE,
+                                    XCB_ATOM_ATOM, 32,
+                                    o, (unsigned char *) &netwmstate);
+        }
+    }
 }
 
 #if 0
@@ -786,6 +928,8 @@
     WMProcArgPtr pProcArg = (WMProcArgPtr) pArg;
     WMInfoPtr pWMInfo = pProcArg->pWMInfo;
 
+    pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
+
     /* Initialize the Window Manager */
     winInitMultiWindowWM(pWMInfo, pProcArg);
 
@@ -807,8 +951,8 @@
         }
 
 #if CYGMULTIWINDOW_DEBUG
-        ErrorF("winMultiWindowWMProc - MSG: %s (%d) ID: %d\n",
-               MessageName(&(pNode->msg)), (int)pNode->msg.msg, (int)pNode->msg.dwID);
+        ErrorF("winMultiWindowWMProc - MSG: %s (%d) Window: %08x ID: %d\n",
+               MessageName(&(pNode->msg)), (int)pNode->msg.msg, pNode->msg.iWindow, (int)pNode->msg.dwID);
 #endif
 
         /* Branch on the message type */
@@ -849,10 +993,12 @@
                                 pNode->msg.iWindow, pWMInfo->atmPrivMap,
                                 XCB_ATOM_INTEGER, 32,
                                 sizeof(HWND)/4, &(pNode->msg.hwndWindow));
-
             break;
 
         case WM_WM_MAP_MANAGED:
+          {
+            unsigned long maxmin = 0;
+
             /* Put a note as to the HWND associated with this Window */
             xcb_change_property(pWMInfo->conn, XCB_PROP_MODE_REPLACE,
                                 pNode->msg.iWindow, pWMInfo->atmPrivMap,
@@ -860,9 +1006,8 @@
                                 sizeof(HWND)/4, &(pNode->msg.hwndWindow));
 
             UpdateName(pWMInfo, pNode->msg.iWindow);
+            UpdateStyle(pWMInfo, pNode->msg.iWindow, &maxmin);
             UpdateIcon(pWMInfo, pNode->msg.iWindow);
-            UpdateStyle(pWMInfo, pNode->msg.iWindow);
-
 
             /* Reshape */
             {
@@ -874,7 +1019,20 @@
                 }
             }
 
-            break;
+            /* Establish initial state */
+            UpdateState(pWMInfo, pNode->msg.iWindow, XCB_ICCCM_WM_STATE_NORMAL);
+
+            /*
+              It only makes sense to apply minimize/maximize override as the
+              initial state, otherwise that state can't be changed.
+            */
+            if (maxmin & HINT_MAX)
+                SendMessage(pNode->msg.hwndWindow, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
+            else if (maxmin & HINT_MIN)
+                SendMessage(pNode->msg.hwndWindow, WM_SYSCOMMAND, SC_MINIMIZE, 0);
+          }
+
+          break;
 
         case WM_WM_UNMAP:
 
@@ -907,6 +1065,7 @@
                -- independently, the WM_TAKE_FOCUS protocol determines whether
                the WM should send a WM_TAKE_FOCUS ClientMessage.
             */
+            if (pNode->msg.iWindow)
             {
               Bool neverFocus = FALSE;
               xcb_get_property_cookie_t cookie;
@@ -920,7 +1079,7 @@
               }
 
               if (!neverFocus)
-                xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_POINTER_ROOT,
+                xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_PARENT,
                                     pNode->msg.iWindow, XCB_CURRENT_TIME);
 
               if (IsWmProtocolAvailable(pWMInfo,
@@ -931,6 +1090,13 @@
                              pWMInfo->atmWmProtos, pWMInfo->atmWmTakeFocus);
 
             }
+            else
+            /* Set the input focus to none */
+            {
+              xcb_set_input_focus(pWMInfo->conn, XCB_INPUT_FOCUS_NONE,
+                                  XCB_NONE, XCB_CURRENT_TIME);
+
+            }
             break;
 
         case WM_WM_NAME_EVENT:
@@ -943,16 +1109,14 @@
 
         case WM_WM_HINTS_EVENT:
             {
-            /* Don't do anything if this is an override-redirect window */
-            if (IsOverrideRedirect(pWMInfo->conn, pNode->msg.iWindow))
-              break;
+            unsigned long maxmin = 0;
 
-            UpdateStyle(pWMInfo, pNode->msg.iWindow);
+            UpdateStyle(pWMInfo, pNode->msg.iWindow, &maxmin);
             }
             break;
 
         case WM_WM_CHANGE_STATE:
-            UpdateState(pWMInfo, pNode->msg.iWindow);
+            UpdateState(pWMInfo, pNode->msg.iWindow, pNode->msg.dwID);
             break;
 
         default:
@@ -973,10 +1137,10 @@
             if (event) {
                 if ((event->response_type & ~0x80) == 0) {
                     xcb_generic_error_t *err = (xcb_generic_error_t *)event;
-                    ErrorF("winMultiWindowWMProc - Error code: %i, ID: 0x%08x, "
-                           "Major opcode: %i, Minor opcode: %i\n",
-                           err->error_code, err->resource_id,
-                           err->major_code, err->minor_code);
+                    winDebug("winMultiWindowWMProc - Error code: %i, ID: 0x%08x, "
+                             "Major opcode: %i, Minor opcode: %i\n",
+                             err->error_code, err->resource_id,
+                             err->major_code, err->minor_code);
                 }
             }
         }
@@ -986,6 +1150,7 @@
             int e = xcb_connection_has_error(pWMInfo->conn);
             if (e) {
                 ErrorF("winMultiWindowWMProc - Fatal error %d on xcb connection\n", e);
+                pthread_exit(NULL);
                 break;
             }
         }
@@ -1003,6 +1168,9 @@
 #if CYGMULTIWINDOW_DEBUG
     ErrorF("-winMultiWindowWMProc ()\n");
 #endif
+
+    pthread_cleanup_pop(0);
+
     return NULL;
 }
 
@@ -1041,6 +1209,10 @@
     xcb_atom_t atmWindowState, atmMotifWmHints, atmWindowType, atmNormalHints;
     int iReturn;
     xcb_auth_info_t *auth_info;
+    xcb_screen_t *root_screen;
+    xcb_window_t root_window_id;
+
+    pthread_cleanup_push(&winMultiWindowThreadExit, NULL);
 
     winDebug("winMultiWindowXMsgProc - Hello\n");
 
@@ -1113,11 +1285,11 @@
         pthread_exit(NULL);
     }
 
-    {
-        /* Get root window id */
-        xcb_screen_t *root_screen = xcb_aux_get_screen(pProcArg->conn, pProcArg->dwScreen);
-        xcb_window_t root_window_id = root_screen->root;
+    /* Get root window id */
+    root_screen = xcb_aux_get_screen(pProcArg->conn, pProcArg->dwScreen);
+    root_window_id = root_screen->root;
 
+    {
         /* Set WM_ICON_SIZE property indicating desired icon sizes */
         typedef struct {
             uint32_t min_width, min_height;
@@ -1146,14 +1318,39 @@
     atmNormalHints = intern_atom(pProcArg->conn, "WM_NORMAL_HINTS");
 
     /*
-       iiimxcf had a bug until 2009-04-27, assuming that the
-       WM_STATE atom exists, causing clients to fail with
-       a BadAtom X error if it doesn't.
-
-       Since this is on in the default Solaris 10 install,
-       workaround this by making sure it does exist...
+      Enable Composite extension and redirect subwindows of the root window
      */
-    intern_atom(pProcArg->conn, "WM_STATE");
+    if (pProcArg->pWMInfo->fCompositeWM) {
+        const char *extension_name = "Composite";
+        xcb_query_extension_cookie_t cookie;
+        xcb_query_extension_reply_t *reply;
+
+        cookie = xcb_query_extension(pProcArg->conn, strlen(extension_name), extension_name);
+        reply = xcb_query_extension_reply(pProcArg->conn, cookie, NULL);
+
+        if (reply && (reply->present)) {
+            xcb_composite_redirect_subwindows(pProcArg->conn,
+                                              root_window_id,
+                                              XCB_COMPOSITE_REDIRECT_AUTOMATIC);
+
+            /*
+              We use automatic updating of the root window for two
+              reasons:
+
+              1) redirected window contents are mirrored to the root
+              window so that the root window draws correctly when shown.
+
+              2) updating the root window causes damage against the
+              shadow framebuffer, which ultimately causes WM_PAINT to be
+              sent to the affected window(s) to cause the damage regions
+              to be redrawn.
+            */
+
+            ErrorF("Using Composite redirection\n");
+
+            free(reply);
+        }
+    }
 
     /* Loop until we explicitly break out */
     while (1) {
@@ -1168,7 +1365,8 @@
         event = xcb_wait_for_event(pProcArg->conn);
         if (!event) { // returns NULL on I/O error
             int e = xcb_connection_has_error(pProcArg->conn);
-            ErrorF("winMultiWindowXMsgProc - Fatal error %d on xcb connection\n", e);
+            if (!g_shutdown) ErrorF("winMultiWindowXMsgProc - Fatal error %d on xcb connection\n", e);
+            pthread_exit(NULL);
             break;
         }
 
@@ -1180,10 +1378,10 @@
         /* Branch on event type */
         if (type == 0) {
             xcb_generic_error_t *err = (xcb_generic_error_t *)event;
-            ErrorF("winMultiWindowXMsgProc - Error code: %i, ID: 0x%08x, "
-                   "Major opcode: %i, Minor opcode: %i\n",
-                   err->error_code, err->resource_id,
-                   err->major_code, err->minor_code);
+            winDebug("winMultiWindowXMsgProc - Error code: %i, ID: 0x%08x, "
+                     "Major opcode: %i, Minor opcode: %i\n",
+                     err->error_code, err->resource_id,
+                     err->major_code, err->minor_code);
             }
         else if (type == XCB_CREATE_NOTIFY) {
             xcb_create_notify_event_t *notify = (xcb_create_notify_event_t *)event;
@@ -1194,7 +1392,7 @@
                                           XCB_CW_EVENT_MASK, mask_value);
 
             /* If it's not override-redirect, set the border-width to 0 */
-            if (!IsOverrideRedirect(pProcArg->conn, notify->window)) {
+            if (!IsOverrideRedirect(pProcArg->conn, notify->window, 4-4)) {
                 const static uint32_t width_value[] = { 0 };
                 xcb_configure_window(pProcArg->conn, notify->window,
                                      XCB_CONFIG_WINDOW_BORDER_WIDTH, width_value);
@@ -1252,6 +1450,16 @@
                 }
             }
         }
+        else if (type == XCB_UNMAP_NOTIFY) {
+            xcb_unmap_notify_event_t *notify = (xcb_unmap_notify_event_t *)event;
+
+            memset(&msg, 0, sizeof(msg));
+            msg.msg = WM_WM_CHANGE_STATE;
+            msg.iWindow = notify->window;
+            msg.dwID = XCB_ICCCM_WM_STATE_WITHDRAWN;
+
+            winSendMessageToWM(pProcArg->pWMInfo, &msg);
+        }
         else if (type == XCB_CONFIGURE_NOTIFY) {
             if (!send_event) {
                 /*
@@ -1278,6 +1486,15 @@
         else if (type ==  XCB_PROPERTY_NOTIFY) {
             xcb_property_notify_event_t *notify = (xcb_property_notify_event_t *)event;
 
+            xcb_get_atom_name_cookie_t cookie = xcb_get_atom_name(pProcArg->conn, notify->atom);
+            xcb_get_atom_name_reply_t *reply = xcb_get_atom_name_reply(pProcArg->conn, cookie, NULL);
+            if (reply) {
+                winDebug("winMultiWindowXMsgProc: PropertyNotify %.*s\n",
+                         xcb_get_atom_name_name_length(reply),
+                         xcb_get_atom_name_name(reply));
+                free(reply);
+            }
+
             if ((notify->atom == atmWmName) ||
                 (notify->atom == atmNetWmName)) {
                 memset(&msg, 0, sizeof(msg));
@@ -1320,18 +1537,60 @@
         }
         else if (type == XCB_CLIENT_MESSAGE) {
             xcb_client_message_event_t *client_msg = (xcb_client_message_event_t *)event;
+            winDebug("winMultiWindowXMsgProc: ClientMessage: type %d window 0x%08x data[0] %d\n", client_msg->type, client_msg->window, client_msg->data.data32[0]);
 
             if (client_msg->type == atmWmChange
                  && client_msg->data.data32[0] == XCB_ICCCM_WM_STATE_ICONIC) {
                 ErrorF("winMultiWindowXMsgProc - WM_CHANGE_STATE - IconicState\n");
 
                 memset(&msg, 0, sizeof(msg));
-
                 msg.msg = WM_WM_CHANGE_STATE;
                 msg.iWindow = client_msg->window;
+                msg.dwID = client_msg->data.data32[0];
 
                 winSendMessageToWM(pProcArg->pWMInfo, &msg);
             }
+            else if (client_msg->type == pProcArg->pWMInfo->ewmh._NET_WM_STATE) {
+                int action = client_msg->data.data32[0];
+                int state = -1;
+
+                if (action == XCB_EWMH_WM_STATE_ADD) {
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                        state = XCB_ICCCM_WM_STATE_ZOOM;
+
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT))
+                        state = XCB_ICCCM_WM_STATE_ZOOM;
+
+                    if (client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_HIDDEN)
+                        state = XCB_ICCCM_WM_STATE_ICONIC;
+                }
+                else if (action == XCB_EWMH_WM_STATE_REMOVE) {
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ))
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+
+                    if ((client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ) &&
+                        (client_msg->data.data32[2] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT))
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+
+                    if (client_msg->data.data32[1] == pProcArg->pWMInfo->ewmh._NET_WM_STATE_HIDDEN)
+                        state = XCB_ICCCM_WM_STATE_NORMAL;
+                }
+                else {
+                    ErrorF("winMultiWindowXMsgProc: ClientMEssage _NET_WM_STATE unsupported action %d\n", action);
+                }
+
+                if (state != -1) {
+                    memset(&msg, 0, sizeof(msg));
+                    msg.msg = WM_WM_CHANGE_STATE;
+                    msg.iWindow = client_msg->window;
+                    msg.dwID = state;
+
+                    winSendMessageToWM(pProcArg->pWMInfo, &msg);
+                }
+            }
         }
 
         /* Free the event */
@@ -1339,7 +1598,7 @@
     }
 
     xcb_disconnect(pProcArg->conn);
-    pthread_exit(NULL);
+    pthread_cleanup_pop(0);
     return NULL;
 }
 
@@ -1354,7 +1613,7 @@
           pthread_t * ptWMProc,
           pthread_t * ptXMsgProc,
           pthread_mutex_t * ppmServerStarted,
-          int dwScreen, HWND hwndScreen)
+          int dwScreen, HWND hwndScreen, Bool compositeWM)
 {
     WMProcArgPtr pArg = malloc(sizeof(WMProcArgRec));
     WMInfoPtr pWMInfo = malloc(sizeof(WMInfoRec));
@@ -1376,6 +1635,7 @@
 
     /* Set a return pointer to the Window Manager info structure */
     *ppWMInfo = pWMInfo;
+    pWMInfo->fCompositeWM = compositeWM;
 
     /* Setup the argument structure for the thread function */
     pArg->dwScreen = dwScreen;
@@ -1498,6 +1758,7 @@
     pWMInfo->atmCurrentDesktop = intern_atom(pWMInfo->conn, "_NET_CURRENT_DESKTOP");
     pWMInfo->atmNumberDesktops = intern_atom(pWMInfo->conn, "_NET_NUMBER_OF_DESKTOPS");
     pWMInfo->atmDesktopNames = intern_atom(pWMInfo->conn, "__NET_DESKTOP_NAMES");
+    pWMInfo->atmWmState = intern_atom(pWMInfo->conn, "WM_STATE");
 
     /* Initialization for the xcb_ewmh and EWMH atoms */
     {
@@ -1522,6 +1783,8 @@
                     pWMInfo->ewmh._NET_WM_STATE_ABOVE,
                     pWMInfo->ewmh._NET_WM_STATE_BELOW,
                     pWMInfo->ewmh._NET_WM_STATE_SKIP_TASKBAR,
+                    pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT,
+                    pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ,
                 };
 
             xcb_ewmh_set_supported(&pWMInfo->ewmh, pProcArg->dwScreen,
@@ -1597,7 +1860,7 @@
     WMMsgNodePtr pNode;
 
 #if CYGMULTIWINDOW_DEBUG
-    ErrorF("winSendMessageToWM %s\n", MessageName(pMsg));
+    ErrorF("winSendMessageToWM %s %08x %d\n", MessageName(pMsg), pMsg->iWindow, pMsg->dwID);
 #endif
 
     pNode = malloc(sizeof(WMMsgNodeRec));
@@ -1608,6 +1871,17 @@
 }
 
 /*
+ * winMultiWindowThreadExit - Thread exit handler
+ */
+
+static void
+winMultiWindowThreadExit(void *arg)
+{
+    /* multiwindow client thread has exited, stop server as well */
+    raise(SIGTERM);
+}
+
+/*
  * Check if another window manager is running
  */
 
@@ -1662,6 +1936,7 @@
 void
 winDeinitMultiWindowWM(void)
 {
+    if (g_shutdown == TRUE) return;
     ErrorF("winDeinitMultiWindowWM - Noting shutdown in progress\n");
     g_shutdown = TRUE;
 }
@@ -1675,14 +1950,10 @@
 #define HINT_NOMINIMIZE (1L<<5)
 #define HINT_NOSYSMENU  (1L<<6)
 #define HINT_SKIPTASKBAR (1L<<7)
-/* These two are used on their own */
-#define HINT_MAX	(1L<<0)
-#define HINT_MIN	(1L<<1)
 
 static void
-winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle)
+winApplyHints(WMInfoPtr pWMInfo, xcb_window_t iWindow, HWND hWnd, HWND * zstyle, unsigned long *maxmin)
 {
-
     xcb_connection_t *conn = pWMInfo->conn;
     static xcb_atom_t windowState, motif_wm_hints;
     static xcb_atom_t hiddenState, fullscreenState, belowState, aboveState,
@@ -1690,9 +1961,12 @@
     static xcb_atom_t splashType;
     static int generation;
 
-    unsigned long hint = 0, maxmin = 0;
+    unsigned long hint = HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION;
+    unsigned long taskbar = 0;
     unsigned long style, exStyle;
 
+    *maxmin = 0;
+
     if (!hWnd)
         return;
     if (!IsWindow(hWnd))
@@ -1717,20 +1991,29 @@
         int i;
         int nitems = xcb_get_property_value_length(reply)/sizeof(xcb_atom_t);
         xcb_atom_t *pAtom = xcb_get_property_value(reply);
+        Bool verMax = FALSE;
+        Bool horMax = FALSE;
 
             for (i = 0; i < nitems; i++) {
                 if (pAtom[i] == skiptaskbarState)
                     hint |= HINT_SKIPTASKBAR;
                 if (pAtom[i] == hiddenState)
-                    maxmin |= HINT_MIN;
+                    *maxmin |= HINT_MIN;
                 else if (pAtom[i] == fullscreenState)
-                    maxmin |= HINT_MAX;
+                    *maxmin |= HINT_MAX;
                 if (pAtom[i] == belowState)
                     *zstyle = HWND_BOTTOM;
                 else if (pAtom[i] == aboveState)
                     *zstyle = HWND_TOPMOST;
+                if (pAtom[i] == pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_VERT)
+                  verMax = TRUE;
+                if (pAtom[i] == pWMInfo->ewmh._NET_WM_STATE_MAXIMIZED_HORZ)
+                  horMax = TRUE;
             }
 
+            if (verMax && horMax)
+              *maxmin |= HINT_MAX;
+
             free(reply);
       }
     }
@@ -1743,15 +2026,17 @@
         MwmHints *mwm_hint = xcb_get_property_value(reply);
         if (mwm_hint && (nitems >= PropMwmHintsElements) &&
             (mwm_hint->flags & MwmHintsDecorations)) {
-            if (!mwm_hint->decorations)
+            if (!mwm_hint->decorations) {
+                hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION);
                 hint |= (HINT_NOFRAME | HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE);
+            }
             else if (!(mwm_hint->decorations & MwmDecorAll)) {
-                if (mwm_hint->decorations & MwmDecorBorder)
-                    hint |= HINT_BORDER;
-                if (mwm_hint->decorations & MwmDecorHandle)
-                    hint |= HINT_SIZEBOX;
-                if (mwm_hint->decorations & MwmDecorTitle)
-                    hint |= HINT_CAPTION;
+                if (!(mwm_hint->decorations & MwmDecorBorder))
+                    hint &= ~HINT_BORDER;
+                if (!(mwm_hint->decorations & MwmDecorHandle))
+                    hint &= ~HINT_SIZEBOX;
+                if (!(mwm_hint->decorations & MwmDecorTitle))
+                    hint &= ~HINT_CAPTION;
                 if (!(mwm_hint->decorations & MwmDecorMenu))
                     hint |= HINT_NOSYSMENU;
                 if (!(mwm_hint->decorations & MwmDecorMinimize))
@@ -1777,11 +2062,13 @@
       if (xcb_ewmh_get_wm_window_type_reply(&pWMInfo->ewmh, cookie, &type, NULL)) {
         for (i = 0; i < type.atoms_len; i++) {
             if (type.atoms[i] ==  pWMInfo->ewmh._NET_WM_WINDOW_TYPE_DOCK) {
-                hint = (hint & ~HINT_NOFRAME) | HINT_SKIPTASKBAR | HINT_SIZEBOX;
+                hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION | HINT_NOFRAME);
+                hint |= (HINT_SKIPTASKBAR | HINT_SIZEBOX);
                 *zstyle = HWND_TOPMOST;
             }
             else if ((type.atoms[i] == pWMInfo->ewmh._NET_WM_WINDOW_TYPE_SPLASH)
                      || (type.atoms[i] == splashType)) {
+                hint &= ~(HINT_BORDER | HINT_SIZEBOX | HINT_CAPTION);
                 hint |= (HINT_SKIPTASKBAR | HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE);
                 *zstyle = HWND_TOPMOST;
             }
@@ -1795,8 +2082,14 @@
 
         cookie = xcb_icccm_get_wm_normal_hints(conn, iWindow);
         if (xcb_icccm_get_wm_normal_hints_reply(conn, cookie, &size_hints, NULL)) {
-            if (size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE) {
+            /* Notwithstanding MwmDecorHandle, if we have a border, and
+               WM_NORMAL_HINTS indicates the window should be resizeable, let
+               the window have a resizing border.  This is necessary for windows
+               with gtk3+ 3.14 csd. */
+            if (hint & HINT_BORDER)
+                hint |= HINT_SIZEBOX;
 
+            if (size_hints.flags & XCB_ICCCM_SIZE_HINT_P_MAX_SIZE) {
                 /* Not maximizable if a maximum size is specified, and that size
                    is smaller (in either dimension) than the screen size */
                 if ((size_hints.max_width < GetSystemMetrics(SM_CXVIRTUALSCREEN))
@@ -1809,8 +2102,10 @@
                        don't bother with a resizing frame
                      */
                     if ((size_hints.min_width == size_hints.max_width)
-                        && (size_hints.min_height == size_hints.max_height))
+                        && (size_hints.min_height == size_hints.max_height)) {
+                        hint |= HINT_NOMAXIMIZE;
                         hint = (hint & ~HINT_SIZEBOX);
+                    }
                 }
             }
         }
@@ -1825,44 +2120,49 @@
         char *window_name = 0;
         char *res_name = 0;
         char *res_class = 0;
+        char *rand_id = 0;
 
         GetClassNames(pWMInfo, iWindow, &res_name, &res_class, &window_name);
 
         style = STYLE_NONE;
         style = winOverrideStyle(res_name, res_class, window_name);
+        taskbar = winOverrideTaskbar(res_name, res_class, window_name);
 
-#define APPLICATION_ID_FORMAT	"%s.xwin.%s"
-#define APPLICATION_ID_UNKNOWN "unknown"
-        if (res_class) {
-            asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
-                     res_class);
-        }
-        else {
-            asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
-                     APPLICATION_ID_UNKNOWN);
-        }
+        if (taskbar & TASKBAR_NEWTAB) {
+            int irand_id;
+            srand((unsigned)time(NULL));
+            irand_id = rand();
+            asprintf(&rand_id, "%d", irand_id);
+        }
+        /* AppUserModelID in the following form CompanyName.ProductName.SubProduct.VersionInformation
+           VersionInformation is set random with NEWTAB and to display-number normally. No spaces allowed. */
+        asprintf(&application_id,
+                 "%s.%s.%s.%s",
+                 XVENDORNAME,
+                 PROJECT_NAME,
+                 (res_class) ? res_class :
+                 (res_name) ? res_name :
+                 (window_name) ? window_name : "SubProductUnknown",
+                 (taskbar & TASKBAR_NEWTAB) ? rand_id :
+                 (getenv("DISNO")) ? getenv("DISNO") : 0);
         winSetAppUserModelID(hWnd, application_id);
 
         free(application_id);
         free(res_name);
         free(res_class);
         free(window_name);
+        free(rand_id);
     }
 
     if (style & STYLE_TOPMOST)
         *zstyle = HWND_TOPMOST;
     else if (style & STYLE_MAXIMIZE)
-        maxmin = (hint & ~HINT_MIN) | HINT_MAX;
+        *maxmin = (hint & ~HINT_MIN) | HINT_MAX;
     else if (style & STYLE_MINIMIZE)
-        maxmin = (hint & ~HINT_MAX) | HINT_MIN;
+        *maxmin = (hint & ~HINT_MAX) | HINT_MIN;
     else if (style & STYLE_BOTTOM)
         *zstyle = HWND_BOTTOM;
 
-    if (maxmin & HINT_MAX)
-        SendMessage(hWnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
-    else if (maxmin & HINT_MIN)
-        SendMessage(hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
-
     if (style & STYLE_NOTITLE)
         hint =
             (hint & ~HINT_NOFRAME & ~HINT_BORDER & ~HINT_CAPTION) |
@@ -1876,6 +2176,9 @@
             (hint & ~HINT_BORDER & ~HINT_CAPTION & ~HINT_SIZEBOX) |
             HINT_NOFRAME;
 
+    if (taskbar & TASKBAR_NOTAB)
+        hint |= HINT_SKIPTASKBAR;
+
     /* Now apply styles to window */
     style = GetWindowLongPtr(hWnd, GWL_STYLE);
     if (!style)
